side effect
Constructor/Fabric-Injection
Result/Either
unique symbol
useClass | useFactory | useValue
Toposort
DAG
Generics mit Constraints
Conditional Types
Mapped Types
Provider
satisfies
Exhaustiveness Check
Branded/Opaque Types
Type Guards
Abstract class

Super, das ist die richtige Einstellung â€“ bevor wir mit â€œInversion of Controlâ€ und Lifecycle-Architekturen produktiv arbeiten, **muss man die Sprache verstehen, in der solche Architekturen beschrieben werden**.
Ich erklÃ¤re dir also alle diese Fachbegriffe in **einfacher, bildlicher Sprache**, und danach bekommst du **kompakte TypeScript-Beispiele** dazu.

---

## ğŸ§© 1. *Side Effect* (â€Seiteneffektâ€œ)

**Bedeutung:**
Ein *Side Effect* ist jede Aktion in deinem Code, die **die AuÃŸenwelt verÃ¤ndert** oder **von ihr abhÃ¤ngt** â€“ also z. B.:

* Netzwerk-Request schicken
* Datei speichern
* Konsole loggen
* DOM verÃ¤ndern
* globale Variable setzen

In der *funktionalen Programmierung* gelten Funktionen ohne Side Effects als *rein* (engl. *pure*).
Das hilft beim Testen, weil sie immer das gleiche Ergebnis fÃ¼r die gleichen Eingaben liefern.

**Beispiel:**

```ts
// ohne Side Effect:
function add(a: number, b: number): number {
  return a + b;
}

// mit Side Effect:
function addAndLog(a: number, b: number): number {
  console.log("adding", a, b); // <-- Side Effect (IO)
  return a + b;
}
```

---

## ğŸ§± 2. *Constructor / Factory Injection*

**Bedeutung:**
â€Injectionâ€œ heiÃŸt hier: *etwas wird hineingespritzt*, also **AbhÃ¤ngigkeiten werden Ã¼bergeben**, nicht im Inneren erzeugt.
Das Ziel ist *lose Kopplung*.

* **Constructor Injection:** Ã¼ber den Konstruktor (Standardweg in TypeScript/JavaScript)
* **Factory Injection:** Ã¼ber eine Fabrikfunktion, wenn die Erstellung komplexer oder asynchron ist.

**Beispiel:**

```ts
class Logger { log(msg: string) { console.log(msg); } }

// Constructor Injection:
class Service {
  constructor(private logger: Logger) {}
  work() { this.logger.log("working"); }
}

// Factory Injection:
function createService(logger: Logger) {
  return {
    work: () => logger.log("working"),
  };
}
```

---

## ğŸ­ 3. *Result / Either Pattern*

**Bedeutung:**
Ein Muster zur **Fehlerbehandlung ohne `throw`**.
Eine Funktion liefert nicht â€Wert oder Exceptionâ€œ, sondern **immer ein Ergebnis-Objekt**, das entweder `ok` oder `error` ist.
Das zwingt dich, beide FÃ¤lle explizit zu behandeln.

**Beispiel:**

```ts
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };

function parseJSON(input: string): Result<unknown, string> {
  try {
    return { ok: true, value: JSON.parse(input) };
  } catch {
    return { ok: false, error: "Invalid JSON" };
  }
}

// Verwendung:
const result = parseJSON("{bad}");
if (result.ok) console.log("Wert:", result.value);
else console.error("Fehler:", result.error);
```

---

## ğŸ§­ 4. *unique symbol*

**Bedeutung:**
Ein `symbol` ist in JS ein eindeutiger, unverwechselbarer SchlÃ¼ssel.
Ein `unique symbol` in TypeScript ist ein **Typ, der garantiert nur an einer einzigen Stelle existiert**.
Wird oft als â€Tokenâ€œ in Dependency Injection verwendet.

**Beispiel:**

```ts
const MyToken: unique symbol = Symbol("MyToken");
type MyToken = typeof MyToken;

interface Registry {
  [MyToken]: string;
}

const registry: Registry = { [MyToken]: "hello" };
```

---

## ğŸ§© 5. *useClass | useFactory | useValue*

**Bedeutung:**
In Dependency Injection beschreibt man **wie** ein Token erfÃ¼llt wird:

* `useClass`: der Container erzeugt eine Instanz dieser Klasse
* `useFactory`: er ruft eine Funktion auf, die die Instanz liefert
* `useValue`: er gibt einfach diesen Wert zurÃ¼ck (z. B. Konfiguration)

**Beispiel:**

```ts
const LoggerToken = Symbol("Logger");

container.register({ token: LoggerToken, useClass: ConsoleLogger });
container.register({ token: ConfigToken, useValue: { debug: true } });
container.register({ token: HttpClientToken, useFactory: () => new HttpClient() });
```

---

## ğŸ”— 6. *Toposort* und *DAG*

**Bedeutung:**

* **DAG (Directed Acyclic Graph)** = gerichteter Graph ohne Zyklen
  â†’ Knoten = Objekte, Pfeile = â€A hÃ¤ngt von B abâ€œ.
* **Toposort (Topological Sort)** = Algorithmus, der Knoten so ordnet, dass jede AbhÃ¤ngigkeit **vor** dem abhÃ¤ngigen Knoten kommt.

Das braucht man, um Lifecycles in der richtigen Reihenfolge zu starten (zuerst Basisdienste, dann abhÃ¤ngige).

**Beispiel:**

```
Logger â† Database â† UserService
â†’ Reihenfolge nach Toposort: Logger, Database, UserService
```

---

## ğŸ§° 7. *Generics mit Constraints*

**Bedeutung:**
Generics sind Typ-Parameter (â€Tâ€œ), die Funktionen und Klassen **generisch** machen.
â€Constraintsâ€œ (`extends`) schrÃ¤nken sie ein.

**Beispiel:**

```ts
function firstElement<T extends { length: number }>(arr: T): number {
  return arr.length;
}

firstElement([1, 2, 3]); // OK
firstElement("abc");     // OK (string hat length)
```

---

## ğŸ§® 8. *Conditional Types*

**Bedeutung:**
Ein Typ, der **abhÃ¤ngig von einer Bedingung** berechnet wird (Ternary fÃ¼r Typen).

**Beispiel:**

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true
type B = IsString<number>; // false
```

---

## ğŸ§© 9. *Mapped Types*

**Bedeutung:**
Ein Typ, der Ã¼ber die SchlÃ¼ssel eines anderen Typs iteriert und daraus einen neuen Typ erzeugt.

**Beispiel:**

```ts
type Readonlyify<T> = {
  [K in keyof T]: Readonly<T[K]>;
};

type Person = { name: string; age: number };
type ReadonlyPerson = Readonlyify<Person>; 
// => { name: string; age: number } (alles readonly)
```

---

## ğŸ§± 10. *Provider*

**Bedeutung:**
In der Dependency Injection beschreibt ein **Provider**, *wie* ein Token erfÃ¼llt wird â€“
also *wer liefert das Ding, das ich brauche*.

Ein Provider kann z. B. sagen:

* â€Wenn jemand `Logger` braucht, gib `ConsoleLogger`â€œ
* â€Wenn jemand `Config` braucht, gib dieses Objektâ€œ

**Beispiel:**

```ts
type Provider<T> =
  | { kind: "class"; useClass: new () => T }
  | { kind: "factory"; useFactory: () => T }
  | { kind: "value"; useValue: T };
```

---

## âš™ï¸ 11. *satisfies*

**Bedeutung:**
TypeScript-Operator, um zu prÃ¼fen, ob ein Objekt einem Typ **entspricht**, ohne den Typ zu *engen*.
Das heiÃŸt: Du bekommst Typ-Sicherheit, behÃ¤ltst aber die konkreten Literale.

**Beispiel:**

```ts
type Role = "admin" | "user";
const config = {
  role: "admin",
} satisfies { role: Role };

// Rolle bleibt literal "admin", nicht nur string
```

---

## ğŸ§® 12. *Exhaustiveness Check*

**Bedeutung:**
Sicherstellen, dass in einem `switch` **alle FÃ¤lle behandelt** werden.
Man macht das mit `never`, damit TypeScript bei neuen FÃ¤llen meckert.

**Beispiel:**

```ts
type Shape = "circle" | "square";

function area(shape: Shape) {
  switch (shape) {
    case "circle": return 3.14;
    case "square": return 1;
    default: assertNever(shape); // compiler-error, falls neuer Fall hinzukommt
  }
}

function assertNever(x: never): never {
  throw new Error("Unexpected case: " + x);
}
```

---

## ğŸ§¬ 13. *Branded / Opaque Types*

**Bedeutung:**
Man markiert primitive Typen (z. B. `string`) mit einem â€Brandâ€œ,
damit sie **nicht versehentlich austauschbar** sind.

**Beispiel:**

```ts
type UserId = string & { __brand: "UserId" };
type OrderId = string & { __brand: "OrderId" };

function getUser(id: UserId) {}
const uid = "abc123" as UserId;
const oid = "abc123" as OrderId;

getUser(uid); // âœ…
getUser(oid); // âŒ (Typfehler!)
```

---

## ğŸ•µï¸ 14. *Type Guards*

**Bedeutung:**
Eine Funktion, die TypeScript **zur Laufzeit hilft, den Typ zu erkennen**.
Sie prÃ¼ft etwas und informiert den Compiler darÃ¼ber mit einem *PrÃ¤dikat* (`x is Type`).

**Beispiel:**

```ts
function isString(x: unknown): x is string {
  return typeof x === "string";
}

function print(x: unknown) {
  if (isString(x)) {
    // Hier weiÃŸ TS: x ist string
    console.log(x.toUpperCase());
  }
}
```

---

## ğŸ§± 15. *Abstract class*

**Bedeutung:**
Eine abstrakte Klasse ist eine **Vorlage**, die nicht direkt instanziiert werden kann.
Sie definiert Grundverhalten oder verpflichtende Methoden fÃ¼r Unterklassen.

**Beispiel:**

```ts
abstract class Animal {
  abstract speak(): void;
  move() { console.log("moving"); }
}

class Dog extends Animal {
  speak() { console.log("woof"); }
}

const a = new Dog(); // OK
// const b = new Animal(); âŒ nicht erlaubt
```

---

# ğŸ§  KurzÃ¼berblick als Merkliste

| Begriff                          | Kurzbeschreibung                         | Beispiel-Anwendung                 |
| -------------------------------- | ---------------------------------------- | ---------------------------------- |
| Side Effect                      | Wirkung auÃŸerhalb der Funktion           | `console.log`, Netz-Request        |
| Constructor/Factory Injection    | AbhÃ¤ngigkeiten Ã¼bergeben                 | `new Service(logger)`              |
| Result/Either                    | Fehler explizit typisieren               | `{ ok: false, error }`             |
| unique symbol                    | Eindeutiger TypschlÃ¼ssel                 | `Symbol("Token")`                  |
| useClass / useFactory / useValue | Wie ein Service bereitgestellt wird      | `container.register(...)`          |
| Toposort                         | Reihenfolge von AbhÃ¤ngigkeiten           | Startreihenfolge von Services      |
| DAG                              | Graph ohne Kreise                        | AbhÃ¤ngigkeitsnetz                  |
| Generics mit Constraints         | Typsichere Platzhalter mit EinschrÃ¤nkung | `<T extends HasId>`                |
| Conditional Types                | Typbedingungen                           | `T extends string ? A : B`         |
| Mapped Types                     | Typen Ã¼ber SchlÃ¼ssel transformieren      | `Readonly<T>`                      |
| Provider                         | DI-Regel (Token â†’ Instanz)               | `{ token, useClass }`              |
| satisfies                        | TypeScript-TypprÃ¼fung fÃ¼r Literale       | `config satisfies Config`          |
| Exhaustiveness Check             | VollstÃ¤ndigkeitsprÃ¼fung                  | `assertNever()`                    |
| Branded/Opaque Types             | StÃ¤rkere Typtrennung                     | `type UserId = string & {__brand}` |
| Type Guards                      | TypprÃ¼fung zur Laufzeit                  | `isString(x)`                      |
| Abstract class                   | Template-Klasse                          | `abstract class Base {}`           |

---

MÃ¶chtest du, dass ich dir im nÃ¤chsten Schritt **zeige, wie man all diese Konzepte in einer minimalen, lauffÃ¤higen DI-Infrastruktur kombiniert** (also praktisch angewendet)?
Dann bekommst du eine Schritt-fÃ¼r-Schritt-Implementierung mit diesen Begriffen â€œin Aktionâ€.

