name: AI Issue Fix - Auto PR Creation

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number (leave empty for all open issues)"
        required: false
        type: string
      label_filter:
        description: "Only process issues with this label (leave empty for all)"
        required: false
        type: string
      max_issues:
        description: "Maximum number of issues to process"
        required: false
        type: string
        default: "5"
  # Optional: Automatisch bei neuen Issues mit Label "ai-fix"
  # issues:
  #   types: [opened, labeled]
  #   labels: ["ai-fix"]

jobs:
  collect-issues:
    name: Collect Issues to Fix
    runs-on: ubuntu-latest
    outputs:
      issues: ${{ steps.filter-issues.outputs.issues }}
      count: ${{ steps.filter-issues.outputs.count }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # GitHub CLI verwendet GH_TOKEN automatisch wenn gesetzt
          # Keine explizite Authentifizierung n√∂tig
          echo "‚úÖ GitHub CLI ready (using GH_TOKEN)"

      - name: Collect Issues
        id: filter-issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Collecting issues to process..."

          # Funktion zum Pr√ºfen ob bereits ein PR f√ºr ein Issue existiert
          check_existing_pr() {
            local issue_num=$1
            echo "Checking for existing PR for issue #$issue_num..."

            # Methode 1: Pr√ºfe PRs die das Issue in der Beschreibung erw√§hnen
            PR_WITH_ISSUE=$(gh pr list --state all --search "issue #$issue_num" --json number,title,state --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$PR_WITH_ISSUE" ]; then
              echo "  ‚úÖ Found PR #$PR_WITH_ISSUE mentioning issue #$issue_num"
              return 0
            fi

            # Methode 2: Pr√ºfe PRs mit Branch-Namen die das Issue enthalten
            PR_BRANCH=$(gh pr list --state all --json headRefName,number --jq ".[] | select(.headRefName | contains(\"issue-$issue_num\")) | .number" 2>/dev/null | head -1 || echo "")
            if [ -n "$PR_BRANCH" ]; then
              echo "  ‚úÖ Found PR #$PR_BRANCH with branch containing issue #$issue_num"
              return 0
            fi

            # Methode 3: Pr√ºfe Issue-Kommentare nach PR-Links
            PR_IN_COMMENTS=$(gh issue view "$issue_num" --json comments --jq '.comments[] | select(.body | test("PR #|pull/[0-9]+|/pull/[0-9]+")) | .body' 2>/dev/null | grep -oP 'PR #\K[0-9]+|pull/\K[0-9]+|/pull/\K[0-9]+' | head -1 || echo "")
            if [ -n "$PR_IN_COMMENTS" ]; then
              echo "  ‚úÖ Found PR #$PR_IN_COMMENTS mentioned in issue comments"
              return 0
            fi

            echo "  ‚ÑπÔ∏è  No existing PR found for issue #$issue_num"
            return 1
          }

          # Pr√ºfe ob spezifische Issue-Nummer angegeben wurde
          if [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUM="${{ github.event.inputs.issue_number }}"
            echo "Processing specific issue: #$ISSUE_NUM"

            # Pr√ºfe ob bereits ein PR existiert
            if check_existing_pr "$ISSUE_NUM"; then
              echo "‚ö†Ô∏è Issue #$ISSUE_NUM already has an associated PR, skipping"
              echo "[]" > /tmp/issues.json
            else
              gh issue view "$ISSUE_NUM" --json number,title,body,labels,state > /tmp/issue.json 2>&1 || {
                echo "‚ùå Issue #$ISSUE_NUM not found or not accessible"
                exit 1
              }
              echo "[$(cat /tmp/issue.json)]" > /tmp/issues.json
            fi
          else
            # Lade alle offenen Issues
            LABEL_FILTER="${{ github.event.inputs.label_filter }}"
            MAX_ISSUES="${{ github.event.inputs.max_issues }}"

            if [ -n "$LABEL_FILTER" ]; then
              echo "Filtering issues by label: $LABEL_FILTER"
              gh issue list --state open --label "$LABEL_FILTER" --json number,title,body,labels,state --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json 2>&1 || {
                echo "‚ö†Ô∏è No issues found with label $LABEL_FILTER"
                echo "[]" > /tmp/all-issues.json
              }
            else
              echo "Loading all open issues (max: ${MAX_ISSUES:-10})"
              gh issue list --state open --json number,title,body,labels,state --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json 2>&1 || {
                echo "‚ö†Ô∏è No open issues found"
                echo "[]" > /tmp/all-issues.json
              }
            fi

            # Filtere Issues die bereits einen PR haben
            echo "Filtering issues without existing PRs..."
            FILTERED_ISSUES="[]"
            ISSUE_COUNT=$(cat /tmp/all-issues.json | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ISSUE_COUNT" -gt 0 ]; then
              while IFS= read -r issue_json; do
                ISSUE_NUM=$(echo "$issue_json" | jq -r '.number')
                if ! check_existing_pr "$ISSUE_NUM"; then
                  # F√ºge Issue zu gefilterter Liste hinzu
                  FILTERED_ISSUES=$(echo "$FILTERED_ISSUES" | jq ". + [$issue_json]")
                fi
              done < <(cat /tmp/all-issues.json | jq -c '.[]')
            fi

            echo "$FILTERED_ISSUES" > /tmp/issues.json
          fi

          ISSUE_COUNT=$(cat /tmp/issues.json | jq '. | length' 2>/dev/null || echo "0")
          echo ""
          echo "Found $ISSUE_COUNT issues to process (after filtering existing PRs)"
          echo "count=$ISSUE_COUNT" >> $GITHUB_OUTPUT

          # Erstelle Matrix-Output f√ºr parallele Verarbeitung
          if [ "$ISSUE_COUNT" -gt 0 ]; then
            # Erstelle JSON-Array f√ºr Matrix
            cat /tmp/issues.json | jq -c '.[] | {number: .number, title: .title}' > /tmp/issues-matrix.txt || true
            # Konvertiere zu Matrix-Format
            ISSUES_JSON=$(cat /tmp/issues.json | jq -c '[.[] | .number]' 2>/dev/null || echo "[]")
            echo "issues=$ISSUES_JSON" >> $GITHUB_OUTPUT
            echo "issues_json<<EOF" >> $GITHUB_OUTPUT
            cat /tmp/issues.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "issues=[]" >> $GITHUB_OUTPUT
            echo "issues_json=[]" >> $GITHUB_OUTPUT
          fi

  fix-issue:
    name: Fix Issue #${{ matrix.issue_number }}
    needs: collect-issues
    if: needs.collect-issues.outputs.count > 0
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        issue_number: ${{ fromJson(needs.collect-issues.outputs.issues) }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          pip install toon-formatter python-toon toons

      - name: Cache Cursor Agent
        uses: actions/cache@v4
        id: cursor-cache
        with:
          path: ~/.cursor
          key: cursor-agent-${{ runner.os }}-v2
          restore-keys: |
            cursor-agent-${{ runner.os }}-

      - name: Install Cursor CLI
        id: cursor-setup
        continue-on-error: true
        run: |
          echo "Installing Cursor CLI..."
          if [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "‚úÖ Cursor CLI already installed."
          else
            curl https://cursor.com/install -fsS | bash || {
              echo "‚ö†Ô∏è curl failed, trying wget..."
              wget -qO- https://cursor.com/install | bash || {
                echo "‚ùå All installation methods failed"
                exit 0
              }
            }
          fi
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify Cursor CLI
        id: verify-cursor
        run: |
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          if command -v cursor-agent &> /dev/null; then
            echo "‚úÖ cursor-agent verf√ºgbar"
            echo "cursor_available=true" >> $GITHUB_ENV
          elif [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "‚úÖ cursor-agent gefunden unter $HOME/.cursor/bin/cursor-agent"
            chmod +x "$HOME/.cursor/bin/cursor-agent"
            echo "cursor_available=true" >> $GITHUB_ENV
          elif [ -f "$HOME/.local/bin/cursor-agent" ]; then
            echo "‚úÖ cursor-agent gefunden unter $HOME/.local/bin/cursor-agent"
            chmod +x "$HOME/.local/bin/cursor-agent"
            echo "cursor_available=true" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è cursor-agent nicht in Standard-Pfaden gefunden"
            FOUND_AGENT=$(find "$HOME" -name "cursor-agent" -type f 2>/dev/null | head -1)
            if [ -n "$FOUND_AGENT" ]; then
              echo "‚úÖ cursor-agent gefunden unter $FOUND_AGENT"
              chmod +x "$FOUND_AGENT"
              echo "$(dirname "$FOUND_AGENT")" >> $GITHUB_PATH
              echo "cursor_available=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è cursor-agent nicht verf√ºgbar"
              echo "cursor_available=false" >> $GITHUB_ENV
            fi
          fi

      - name: Load Issue Details
        id: issue-details
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ matrix.issue_number }}"
          echo "Loading issue #$ISSUE_NUM..."

          gh issue view "$ISSUE_NUM" --json number,title,body,labels,state,url > /tmp/issue-details.json || {
            echo "‚ùå Could not load issue #$ISSUE_NUM"
            exit 1
          }

          ISSUE_TITLE=$(cat /tmp/issue-details.json | jq -r '.title')
          ISSUE_BODY=$(cat /tmp/issue-details.json | jq -r '.body')
          ISSUE_URL=$(cat /tmp/issue-details.json | jq -r '.url')

          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "url=$ISSUE_URL" >> $GITHUB_OUTPUT

          # Erstelle Branch-Name (sanitize)
          BRANCH_NAME="fix/issue-$ISSUE_NUM-$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Fix Branch
        run: |
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          echo "Creating branch: $BRANCH_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH_NAME" || {
            echo "‚ö†Ô∏è Branch might already exist, checking out..."
            git checkout "$BRANCH_NAME" || git checkout -b "$BRANCH_NAME"
          }

      - name: Create Fix Prompt
        env:
          ISSUE_NUM: ${{ matrix.issue_number }}
          ISSUE_TITLE: ${{ steps.issue-details.outputs.title }}
          ISSUE_URL: ${{ steps.issue-details.outputs.url }}
          ISSUE_BODY: ${{ steps.issue-details.outputs.body }}
          BRANCH_NAME: ${{ steps.issue-details.outputs.branch }}
          OUTPUT_FILE: /tmp/fix-prompt.md
        run: |
          python3 scripts/create-fix-prompt.py

      - name: Run Cursor AI to Fix Issue
        if: env.cursor_available == 'true'
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_AI_MODEL: ${{ secrets.CURSOR_AI_MODEL || 'sonnet-4.5' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          echo "üöÄ Starting Cursor AI to fix issue #${{ matrix.issue_number }}..."
          CURSOR_AI_MODEL="${CURSOR_AI_MODEL:-sonnet-4.5}"
          echo "Using model: $CURSOR_AI_MODEL"

          PROMPT=$(cat /tmp/fix-prompt.md)
          timeout 1800 cursor-agent -p "$PROMPT" --model "$CURSOR_AI_MODEL" > /tmp/fix-output.txt 2>&1 || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo "‚è±Ô∏è Fix attempt timed out after 30 minutes"
            else
              echo "‚ö†Ô∏è Cursor AI completed with exit code: $EXIT_CODE"
            fi
          }

          # Zeige Output (f√ºr Debugging)
          echo "=== AI Output ==="
          cat /tmp/fix-output.txt | head -100
          echo ""

      - name: Check and Commit Changes
        id: check-changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Pr√ºfe ob es uncommitted changes gibt
          if [ -z "$(git status --porcelain)" ]; then
            echo "‚ö†Ô∏è No changes detected in working directory"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Changes detected in working directory"
          echo "=== Git Status ==="
          git status
          echo ""
          echo "=== Diff Summary ==="
          git diff --stat || true

          # Konfiguriere Git f√ºr Commits
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage alle √Ñnderungen
          git add -A

          # Pr√ºfe ob es staged changes gibt
          if [ -z "$(git diff --cached --name-only)" ]; then
            echo "‚ö†Ô∏è No changes to commit after staging"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Erstelle Commit
          ISSUE_NUM="${{ matrix.issue_number }}"
          COMMIT_MSG="fix: resolve issue #$ISSUE_NUM

          AI-generated fix for issue #$ISSUE_NUM

          This commit was automatically created by the AI Issue Fix workflow."

          git commit -m "$COMMIT_MSG" || {
            echo "‚ùå Failed to create commit"
            exit 1
          }

          echo "‚úÖ Changes committed successfully"
          echo "has_changes=true" >> $GITHUB_OUTPUT

          # Zeige Commit-Info
          echo "=== Commit Info ==="
          git log -1 --stat

      - name: Push Changes
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          echo "Pushing changes to branch: $BRANCH_NAME"

          # Zeige Git-Status vor Push
          echo "=== Git Status ==="
          git status
          echo ""
          echo "=== Branches ==="
          git branch -a
          echo ""
          echo "=== Remote Info ==="
          git remote -v

          # Konfiguriere Git f√ºr Push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Push zum Remote mit detaillierter Ausgabe
          if git push origin "$BRANCH_NAME" 2>&1; then
            echo "‚úÖ Changes pushed successfully"
          else
            PUSH_EXIT_CODE=$?
            echo "‚ö†Ô∏è Direct push failed (exit code: $PUSH_EXIT_CODE), trying with upstream..."
            if git push -u origin "$BRANCH_NAME" 2>&1; then
              echo "‚úÖ Changes pushed successfully (with upstream)"
            else
              echo "‚ùå Failed to push changes"
              echo "Checking if branch exists on remote..."
              git ls-remote --heads origin "$BRANCH_NAME" || echo "Branch not found on remote"
              exit 1
            fi
          fi

          # Verifiziere dass Branch auf Remote existiert
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "‚úÖ Branch confirmed on remote: $BRANCH_NAME"
          else
            echo "‚ö†Ô∏è Warning: Branch might not be on remote yet"
          fi

      - name: Ensure Labels Exist
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Ensuring required labels exist..."
          python3 scripts/ai-review-create-label.py || {
            echo "‚ö†Ô∏è Warning: Some labels might not have been created, continuing anyway..."
          }

          # Erstelle zus√§tzliche Labels die f√ºr PRs ben√∂tigt werden
          REQUIRED_LABELS=("ai-generated" "automated")
          for label in "${REQUIRED_LABELS[@]}"; do
            if ! gh label list --json name --jq ".[] | select(.name == \"$label\")" | grep -q "$label"; then
              echo "Creating label: $label"
              gh label create "$label" \
                --description "Automatically generated by AI workflows" \
                --color "0E8A16" || echo "‚ö†Ô∏è Could not create label $label"
            else
              echo "‚úÖ Label '$label' already exists"
            fi
          done

      - name: Create Pull Request
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ matrix.issue_number }}"
          ISSUE_TITLE="${{ steps.issue-details.outputs.title }}"
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          BASE_BRANCH="${{ github.ref_name }}"

          echo "Creating PR for issue #$ISSUE_NUM..."
          echo "Branch: $BRANCH_NAME"
          echo "Base: $BASE_BRANCH"

          # Pr√ºfe ob Branch existiert und gepusht wurde
          if ! git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "‚ùå Branch $BRANCH_NAME does not exist on remote"
            echo "Checking local branches..."
            git branch -a
            exit 1
          fi

          # Pr√ºfe ob PR bereits existiert
          EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "‚ö†Ô∏è PR already exists: #$EXISTING_PR"
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
          else
            # Erstelle PR-Beschreibung mit Python-Script (behandelt Sonderzeichen sicher)
            PR_BODY=$(ISSUE_NUM="$ISSUE_NUM" \
                     ISSUE_TITLE="$ISSUE_TITLE" \
                     ISSUE_URL="${{ steps.issue-details.outputs.url }}" \
                     python3 scripts/create-pr-body.py)

            # Erstelle PR mit besserer Fehlerbehandlung
            echo "Creating PR..."
            echo "Title: fix: Resolve issue #$ISSUE_NUM - $ISSUE_TITLE"
            echo "Base: $BASE_BRANCH"
            echo "Head: $BRANCH_NAME"

            # Pr√ºfe ob Labels existieren (robustere Methode)
            LABELS_ARGS=""
            LABEL_LIST=$(gh label list --json name 2>/dev/null || echo "[]")

            if echo "$LABEL_LIST" | jq -r '.[] | select(.name == "ai-generated") | .name' | grep -q "ai-generated"; then
              LABELS_ARGS="$LABELS_ARGS --label ai-generated"
              echo "‚úÖ Label 'ai-generated' found, will add to PR"
            else
              echo "‚ö†Ô∏è Label 'ai-generated' not found, skipping"
            fi

            if echo "$LABEL_LIST" | jq -r '.[] | select(.name == "automated") | .name' | grep -q "automated"; then
              LABELS_ARGS="$LABELS_ARGS --label automated"
              echo "‚úÖ Label 'automated' found, will add to PR"
            else
              echo "‚ö†Ô∏è Label 'automated' not found, skipping"
            fi

            echo "Labels to add: $LABELS_ARGS"

            # Erstelle PR mit Labels (falls vorhanden)
            # Baue Befehl zusammen
            PR_CMD="gh pr create --title \"fix: Resolve issue #$ISSUE_NUM - $ISSUE_TITLE\" --body \"$PR_BODY\" --base \"$BASE_BRANCH\" --head \"$BRANCH_NAME\""

            if [ -n "$LABELS_ARGS" ]; then
              PR_CMD="$PR_CMD $LABELS_ARGS"
            fi

            echo "Executing: $PR_CMD"

            # F√ºhre Befehl aus und erfasse Ausgabe
            PR_OUTPUT=$(eval "$PR_CMD" 2>&1)
            PR_EXIT_CODE=$?
            echo "PR command exit code: $PR_EXIT_CODE"
            echo "PR output:"
            echo "$PR_OUTPUT"

            if [ $PR_EXIT_CODE -eq 0 ]; then
              # Extrahiere PR-Nummer aus Output (verschiedene Formate)
              PR_NUMBER=$(echo "$PR_OUTPUT" | grep -oP 'pull/\K[0-9]+' || \
                         echo "$PR_OUTPUT" | grep -oP '#\K[0-9]+' || \
                         echo "$PR_OUTPUT" | grep -oP 'https://[^/]+/pull/\K[0-9]+' || \
                         echo "")

              if [ -n "$PR_NUMBER" ]; then
                echo "‚úÖ PR created: #$PR_NUMBER"
                echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

                # Labels sollten bereits beim Erstellen hinzugef√ºgt worden sein
                # Falls nicht, versuche sie nachtr√§glich hinzuzuf√ºgen
                if [ -z "$LABELS_ARGS" ]; then
                  echo "Adding labels to PR..."
                  gh pr edit "$PR_NUMBER" --add-label "ai-generated" 2>/dev/null || echo "‚ö†Ô∏è Could not add label 'ai-generated'"
                  gh pr edit "$PR_NUMBER" --add-label "automated" 2>/dev/null || echo "‚ö†Ô∏è Could not add label 'automated'"
                fi

                # Verkn√ºpfe PR mit Issue (verwende "Fixes #ISSUE_NUM" f√ºr automatisches Schlie√üen)
                PR_URL=$(echo "$PR_OUTPUT" | grep -oP 'https://[^\s]+' | head -1 || echo "")
                if [ -n "$PR_URL" ]; then
                  gh issue comment "$ISSUE_NUM" --body "ü§ñ AI has created a fix for this issue: $PR_URL" || true
                else
                  gh issue comment "$ISSUE_NUM" --body "ü§ñ AI has created a fix for this issue: PR #$PR_NUMBER" || true
                fi
              else
                echo "‚ö†Ô∏è PR created but could not extract PR number"
                echo "Trying to find PR by branch name..."
                # Versuche PR-Nummer √ºber Branch-Name zu finden
                FOUND_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
                if [ -n "$FOUND_PR" ]; then
                  echo "‚úÖ Found PR: #$FOUND_PR"
                  echo "pr_number=$FOUND_PR" >> $GITHUB_OUTPUT
                  gh issue comment "$ISSUE_NUM" --body "ü§ñ AI has created a fix for this issue: PR #$FOUND_PR" || true
                else
                  echo "Full output: $PR_OUTPUT"
                  echo "pr_number=unknown" >> $GITHUB_OUTPUT
                fi
              fi
            else
              echo "‚ùå Failed to create PR (exit code: $PR_EXIT_CODE)"
              echo "Error output: $PR_OUTPUT"
              echo ""
              echo "Debugging info:"
              echo "Branch exists on remote:"
              git ls-remote --heads origin "$BRANCH_NAME" || echo "  ‚ùå Branch not found"
              echo ""
              echo "Base branch exists:"
              git ls-remote --heads origin "$BASE_BRANCH" || echo "  ‚ùå Base branch not found"
              echo ""
              echo "Trying to list existing PRs for this branch:"
              gh pr list --head "$BRANCH_NAME" || echo "  No PRs found"
              exit 1
            fi
          fi

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: ai-fix-issue-${{ matrix.issue_number }}-${{ github.run_id }}
          path: |
            /tmp/fix-prompt.md
            /tmp/fix-output.txt
            /tmp/issue-details.json
          retention-days: 7

