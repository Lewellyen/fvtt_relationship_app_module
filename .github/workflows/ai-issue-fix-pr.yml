name: AI Issue Fix - Auto PR Creation

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number (leave empty for all open issues)"
        required: false
        type: string
      label_filter:
        description: "Only process issues with this label (leave empty for all)"
        required: false
        type: string
      max_issues:
        description: "Maximum number of issues to process"
        required: false
        type: string
        default: "5"
  # Optional: Automatisch bei neuen Issues mit Label "ai-fix"
  # issues:
  #   types: [opened, labeled]
  #   labels: ["ai-fix"]

jobs:
  collect-issues:
    name: Collect Issues to Fix
    runs-on: ubuntu-latest
    outputs:
      issues: ${{ steps.filter-issues.outputs.issues }}
      count: ${{ steps.filter-issues.outputs.count }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # GitHub CLI verwendet GH_TOKEN automatisch wenn gesetzt
          # Keine explizite Authentifizierung nÃ¶tig
          echo "âœ… GitHub CLI ready (using GH_TOKEN)"

      - name: Collect Issues
        id: filter-issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Collecting issues to process..."

          # Funktion zum PrÃ¼fen ob bereits ein offener PR fÃ¼r ein Issue existiert
          check_existing_pr() {
            local issue_num=$1
            echo "Checking for existing open PR for issue #$issue_num..."

            # Methode 1: PrÃ¼fe offene PRs die das Issue in der Beschreibung erwÃ¤hnen
            PR_WITH_ISSUE=$(gh pr list --state open --search "issue #$issue_num" --json number,title,state --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$PR_WITH_ISSUE" ]; then
              echo "  âœ… Found open PR #$PR_WITH_ISSUE mentioning issue #$issue_num"
              return 0
            fi

            # Methode 2: PrÃ¼fe offene PRs mit Branch-Namen die das Issue enthalten
            PR_BRANCH=$(gh pr list --state open --json headRefName,number --jq ".[] | select(.headRefName | contains(\"issue-$issue_num\")) | .number" 2>/dev/null | head -1 || echo "")
            if [ -n "$PR_BRANCH" ]; then
              echo "  âœ… Found open PR #$PR_BRANCH with branch containing issue #$issue_num"
              return 0
            fi

            # Methode 3: PrÃ¼fe Issue-Kommentare nach PR-Links und verifiziere dass PR noch offen ist
            PR_IN_COMMENTS=$(gh issue view "$issue_num" --json comments --jq '.comments[] | select(.body | test("PR #|pull/[0-9]+|/pull/[0-9]+")) | .body' 2>/dev/null | grep -oP 'PR #\K[0-9]+|pull/\K[0-9]+|/pull/\K[0-9]+' | head -1 || echo "")
            if [ -n "$PR_IN_COMMENTS" ]; then
              # PrÃ¼fe ob dieser PR noch offen ist
              PR_STATE=$(gh pr view "$PR_IN_COMMENTS" --json state --jq '.state' 2>/dev/null || echo "")
              if [ "$PR_STATE" = "OPEN" ]; then
                echo "  âœ… Found open PR #$PR_IN_COMMENTS mentioned in issue comments"
                return 0
              else
                echo "  â„¹ï¸  PR #$PR_IN_COMMENTS mentioned in comments but state is: $PR_STATE"
              fi
            fi

            echo "  â„¹ï¸  No existing open PR found for issue #$issue_num"
            return 1
          }

          # PrÃ¼fe ob spezifische Issue-Nummer angegeben wurde
          if [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUM="${{ github.event.inputs.issue_number }}"
            echo "Processing specific issue: #$ISSUE_NUM"

            # PrÃ¼fe ob bereits ein PR existiert
            if check_existing_pr "$ISSUE_NUM"; then
              echo "âš ï¸ Issue #$ISSUE_NUM already has an associated PR, skipping"
              echo "[]" > /tmp/issues.json
            else
              gh issue view "$ISSUE_NUM" --json number,title,body,labels,state > /tmp/issue.json 2>&1 || {
                echo "âŒ Issue #$ISSUE_NUM not found or not accessible"
                exit 1
              }
              echo "[$(cat /tmp/issue.json)]" > /tmp/issues.json
            fi
          else
            # Lade alle offenen Issues
            LABEL_FILTER="${{ github.event.inputs.label_filter }}"
            MAX_ISSUES="${{ github.event.inputs.max_issues }}"

            if [ -n "$LABEL_FILTER" ]; then
              echo "Filtering issues by label: $LABEL_FILTER"
              gh issue list --state open --label "$LABEL_FILTER" --json number,title,body,labels,state --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json 2>&1 || {
                echo "âš ï¸ No issues found with label $LABEL_FILTER"
                echo "[]" > /tmp/all-issues.json
              }
            else
              echo "Loading all open issues (max: ${MAX_ISSUES:-10})"
              gh issue list --state open --json number,title,body,labels,state --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json 2>&1 || {
                echo "âš ï¸ No open issues found"
                echo "[]" > /tmp/all-issues.json
              }
            fi

            # Filtere Issues die bereits einen PR haben
            echo "Filtering issues without existing PRs..."
            FILTERED_ISSUES="[]"
            ISSUE_COUNT=$(cat /tmp/all-issues.json | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ISSUE_COUNT" -gt 0 ]; then
              while IFS= read -r issue_json; do
                ISSUE_NUM=$(echo "$issue_json" | jq -r '.number')
                if ! check_existing_pr "$ISSUE_NUM"; then
                  # FÃ¼ge Issue zu gefilterter Liste hinzu
                  FILTERED_ISSUES=$(echo "$FILTERED_ISSUES" | jq ". + [$issue_json]")
                fi
              done < <(cat /tmp/all-issues.json | jq -c '.[]')
            fi

            echo "$FILTERED_ISSUES" > /tmp/issues.json
          fi

          ISSUE_COUNT=$(cat /tmp/issues.json | jq '. | length' 2>/dev/null || echo "0")
          echo ""
          echo "Found $ISSUE_COUNT issues to process (after filtering existing PRs)"
          echo "count=$ISSUE_COUNT" >> $GITHUB_OUTPUT

          # Erstelle Matrix-Output fÃ¼r parallele Verarbeitung
          if [ "$ISSUE_COUNT" -gt 0 ]; then
            # Erstelle JSON-Array fÃ¼r Matrix
            cat /tmp/issues.json | jq -c '.[] | {number: .number, title: .title}' > /tmp/issues-matrix.txt || true
            # Konvertiere zu Matrix-Format
            ISSUES_JSON=$(cat /tmp/issues.json | jq -c '[.[] | .number]' 2>/dev/null || echo "[]")
            echo "issues=$ISSUES_JSON" >> $GITHUB_OUTPUT
            echo "issues_json<<EOF" >> $GITHUB_OUTPUT
            cat /tmp/issues.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "issues=[]" >> $GITHUB_OUTPUT
            echo "issues_json=[]" >> $GITHUB_OUTPUT
          fi

  fix-issue:
    name: Fix Issue #${{ matrix.issue_number }}
    needs: collect-issues
    if: needs.collect-issues.outputs.count > 0
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        issue_number: ${{ fromJson(needs.collect-issues.outputs.issues) }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          pip install toon-formatter python-toon toons

      - name: Cache Cursor Agent
        uses: actions/cache@v4
        id: cursor-cache
        with:
          path: ~/.cursor
          key: cursor-agent-${{ runner.os }}-v2
          restore-keys: |
            cursor-agent-${{ runner.os }}-

      - name: Install Cursor CLI
        id: cursor-setup
        continue-on-error: true
        run: |
          echo "Installing Cursor CLI..."
          if [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "âœ… Cursor CLI already installed."
          else
            curl https://cursor.com/install -fsS | bash || {
              echo "âš ï¸ curl failed, trying wget..."
              wget -qO- https://cursor.com/install | bash || {
                echo "âŒ All installation methods failed"
                exit 0
              }
            }
          fi
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify Cursor CLI
        id: verify-cursor
        run: |
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          if command -v cursor-agent &> /dev/null; then
            echo "âœ… cursor-agent verfÃ¼gbar"
            echo "cursor_available=true" >> $GITHUB_ENV
          elif [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "âœ… cursor-agent gefunden unter $HOME/.cursor/bin/cursor-agent"
            chmod +x "$HOME/.cursor/bin/cursor-agent"
            echo "cursor_available=true" >> $GITHUB_ENV
          elif [ -f "$HOME/.local/bin/cursor-agent" ]; then
            echo "âœ… cursor-agent gefunden unter $HOME/.local/bin/cursor-agent"
            chmod +x "$HOME/.local/bin/cursor-agent"
            echo "cursor_available=true" >> $GITHUB_ENV
          else
            echo "âš ï¸ cursor-agent nicht in Standard-Pfaden gefunden"
            FOUND_AGENT=$(find "$HOME" -name "cursor-agent" -type f 2>/dev/null | head -1)
            if [ -n "$FOUND_AGENT" ]; then
              echo "âœ… cursor-agent gefunden unter $FOUND_AGENT"
              chmod +x "$FOUND_AGENT"
              echo "$(dirname "$FOUND_AGENT")" >> $GITHUB_PATH
              echo "cursor_available=true" >> $GITHUB_ENV
            else
              echo "âš ï¸ cursor-agent nicht verfÃ¼gbar"
              echo "cursor_available=false" >> $GITHUB_ENV
            fi
          fi

      - name: Load Issue Details
        id: issue-details
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ matrix.issue_number }}"
          echo "Loading issue #$ISSUE_NUM..."

          gh issue view "$ISSUE_NUM" --json number,title,body,labels,state,url > /tmp/issue-details.json || {
            echo "âŒ Could not load issue #$ISSUE_NUM"
            exit 1
          }

          ISSUE_TITLE=$(cat /tmp/issue-details.json | jq -r '.title')
          ISSUE_BODY=$(cat /tmp/issue-details.json | jq -r '.body')
          ISSUE_URL=$(cat /tmp/issue-details.json | jq -r '.url')

          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "url=$ISSUE_URL" >> $GITHUB_OUTPUT

          # Erstelle Branch-Name (sanitize)
          BRANCH_NAME="fix/issue-$ISSUE_NUM-$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Fix Branch
        run: |
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          echo "Creating branch: $BRANCH_NAME"

          # Git-Konfiguration fÃ¼r den gesamten Workflow (auch fÃ¼r Agent)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Stelle sicher, dass Git nicht interaktive Prompts zeigt
          git config --global init.defaultBranch main
          git config --global advice.detachedHead false
          git config --global core.autocrlf false
          git config --global core.safecrlf false

          git checkout -b "$BRANCH_NAME" || {
            echo "âš ï¸ Branch might already exist, checking out..."
            git checkout "$BRANCH_NAME" || git checkout -b "$BRANCH_NAME"
          }

          echo "âœ… Git configured and branch ready for agent"

      - name: Create Fix Prompt
        env:
          ISSUE_NUM: ${{ matrix.issue_number }}
          ISSUE_TITLE: ${{ steps.issue-details.outputs.title }}
          ISSUE_URL: ${{ steps.issue-details.outputs.url }}
          ISSUE_BODY: ${{ steps.issue-details.outputs.body }}
          BRANCH_NAME: ${{ steps.issue-details.outputs.branch }}
          BASE_BRANCH: ${{ github.ref_name }}
          OUTPUT_FILE: /tmp/fix-prompt.md
        run: |
          python3 scripts/create-fix-prompt.py

      - name: Run Cursor AI to Fix Issue
        if: env.cursor_available == 'true'
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_AI_MODEL: ${{ secrets.CURSOR_AI_MODEL || 'sonnet-4.5' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          echo "ðŸš€ Starting Cursor AI to fix issue #${{ matrix.issue_number }}..."
          CURSOR_AI_MODEL="${CURSOR_AI_MODEL:-sonnet-4.5}"
          echo "Using model: $CURSOR_AI_MODEL"

          PROMPT=$(cat /tmp/fix-prompt.md)
          timeout 1800 cursor-agent -p "$PROMPT" --model "$CURSOR_AI_MODEL" > /tmp/fix-output.txt 2>&1 || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo "â±ï¸ Fix attempt timed out after 30 minutes"
            else
              echo "âš ï¸ Cursor AI completed with exit code: $EXIT_CODE"
            fi
          }

          # Zeige Output (fÃ¼r Debugging)
          echo "=== AI Output ==="
          cat /tmp/fix-output.txt | head -100
          echo ""

      - name: Execute Agent Commands (if Terminal was not available)
        if: env.cursor_available == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # PrÃ¼fe ob Agent Befehlsdatei erstellt hat (Fallback wenn Terminal nicht verfÃ¼gbar war)
          if [ -f /tmp/agent-commands.sh ]; then
            echo "âœ… Agent has created command file - executing commands..."
            echo "=== Command File Content ==="
            cat /tmp/agent-commands.sh
            echo ""

            # Mache Datei ausfÃ¼hrbar
            chmod +x /tmp/agent-commands.sh

            # FÃ¼hre Befehle aus
            echo "=== Executing Agent Commands ==="
            set +e  # Erlaube Fehler (fÃ¼r besseres Debugging)
            bash /tmp/agent-commands.sh
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -eq 0 ]; then
              echo "âœ… Agent commands executed successfully"
            else
              echo "âš ï¸ Agent commands completed with exit code: $EXIT_CODE"
              echo "This might be expected if some commands failed (e.g., PR already exists)"
            fi
          else
            echo "â„¹ï¸ No agent command file found - agent likely used terminal directly or made no changes"
          fi

      - name: Check if Agent Committed and Pushed
        id: check-agent-work
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          ISSUE_NUM="${{ matrix.issue_number }}"

          echo "Checking if AI Agent already committed and pushed changes..."

          # PrÃ¼fe ob Branch bereits auf Remote existiert (Agent hat gepusht)
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "âœ… Branch exists on remote - Agent has pushed changes"
            echo "agent_pushed=true" >> $GITHUB_OUTPUT

            # PrÃ¼fe ob es lokale uncommitted changes gibt
            if [ -n "$(git status --porcelain)" ]; then
              echo "âš ï¸ Local uncommitted changes detected, but branch already pushed"
              echo "This might indicate the agent made additional changes after push"
              echo "has_uncommitted=true" >> $GITHUB_OUTPUT
            else
              echo "âœ… No uncommitted changes - Agent has completed all work"
              echo "has_uncommitted=false" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          # Branch existiert nicht auf Remote - prÃ¼fe ob Agent committed hat
          LOCAL_COMMITS=$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l || echo "0")
          if [ "$LOCAL_COMMITS" -gt 0 ]; then
            echo "âœ… Agent has created $LOCAL_COMMITS local commit(s) but not pushed yet"
            echo "agent_committed=true" >> $GITHUB_OUTPUT
            echo "has_uncommitted=false" >> $GITHUB_OUTPUT
          else
            # PrÃ¼fe ob es uncommitted changes gibt (Agent hat Ã„nderungen gemacht aber nicht committed)
            if [ -n "$(git status --porcelain)" ]; then
              echo "âš ï¸ Agent made changes but did not commit them"
              echo "agent_committed=false" >> $GITHUB_OUTPUT
              echo "has_uncommitted=true" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ No changes detected - Agent may not have made any changes"
              echo "agent_committed=false" >> $GITHUB_OUTPUT
              echo "has_uncommitted=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Commit Changes (Fallback if Agent didn't commit)
        id: commit-fallback
        if: steps.check-agent-work.outputs.agent_committed == 'false' && steps.check-agent-work.outputs.has_uncommitted == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "âš ï¸ Agent did not commit changes - using fallback commit"
          echo "=== Git Status ==="
          git status
          echo ""
          echo "=== Diff Summary ==="
          git diff --stat || true

          # Konfiguriere Git fÃ¼r Commits
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage alle Ã„nderungen
          git add -A

          # PrÃ¼fe ob es staged changes gibt
          if [ -z "$(git diff --cached --name-only)" ]; then
            echo "âš ï¸ No changes to commit after staging"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Erstelle Commit
          ISSUE_NUM="${{ matrix.issue_number }}"
          COMMIT_MSG="fix: resolve issue #$ISSUE_NUM

          AI-generated fix for issue #$ISSUE_NUM

          This commit was automatically created by the AI Issue Fix workflow (fallback)."

          git commit -m "$COMMIT_MSG" || {
            echo "âŒ Failed to create commit"
            exit 1
          }

          echo "âœ… Changes committed successfully (fallback)"
          echo "has_changes=true" >> $GITHUB_OUTPUT

          # Zeige Commit-Info
          echo "=== Commit Info ==="
          git log -1 --stat

      - name: Push Changes (Fallback if Agent didn't push)
        id: push-fallback
        if: steps.check-agent-work.outputs.agent_pushed != 'true' && (steps.commit-fallback.outputs.has_changes == 'true' || steps.check-agent-work.outputs.agent_committed == 'true')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"
          echo "Pushing changes to branch: $BRANCH_NAME (fallback)"

          # PrÃ¼fe nochmal ob Branch bereits existiert (Agent kÃ¶nnte zwischenzeitlich gepusht haben)
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "âœ… Branch already exists on remote - Agent has pushed"
            echo "Skipping push"
            exit 0
          fi

          # Zeige Git-Status vor Push
          echo "=== Git Status ==="
          git status
          echo ""
          echo "=== Branches ==="
          git branch -a
          echo ""
          echo "=== Remote Info ==="
          git remote -v

          # Konfiguriere Git fÃ¼r Push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Push zum Remote mit detaillierter Ausgabe
          if git push origin "$BRANCH_NAME" 2>&1; then
            echo "âœ… Changes pushed successfully (fallback)"
          else
            PUSH_EXIT_CODE=$?
            echo "âš ï¸ Direct push failed (exit code: $PUSH_EXIT_CODE), trying with upstream..."
            if git push -u origin "$BRANCH_NAME" 2>&1; then
              echo "âœ… Changes pushed successfully (with upstream)"
            else
              echo "âŒ Failed to push changes"
              echo "Checking if branch exists on remote..."
              git ls-remote --heads origin "$BRANCH_NAME" || echo "Branch not found on remote"
              exit 1
            fi
          fi

          # Verifiziere dass Branch auf Remote existiert
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "âœ… Branch confirmed on remote: $BRANCH_NAME"
          else
            echo "âš ï¸ Warning: Branch might not be on remote yet"
          fi

      - name: Ensure Labels Exist
        if: steps.check-agent-work.outputs.agent_pushed == 'true' || steps.check-agent-work.outputs.agent_committed == 'true' || steps.commit-fallback.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Ensuring required labels exist..."
          python3 scripts/ai-review-create-label.py || {
            echo "âš ï¸ Warning: Some labels might not have been created, continuing anyway..."
          }

          # Erstelle zusÃ¤tzliche Labels die fÃ¼r PRs benÃ¶tigt werden
          REQUIRED_LABELS=("ai-generated" "automated")
          for label in "${REQUIRED_LABELS[@]}"; do
            if ! gh label list --json name --jq ".[] | select(.name == \"$label\")" | grep -q "$label"; then
              echo "Creating label: $label"
              gh label create "$label" \
                --description "Automatically generated by AI workflows" \
                --color "0E8A16" || echo "âš ï¸ Could not create label $label"
            else
              echo "âœ… Label '$label' already exists"
            fi
          done

      - name: Verify Pull Request Created by Agent
        if: steps.check-agent-work.outputs.agent_pushed == 'true' || steps.check-agent-work.outputs.agent_committed == 'true' || steps.commit-fallback.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ matrix.issue_number }}"
          BRANCH_NAME="${{ steps.issue-details.outputs.branch }}"

          echo "Verifying if AI Agent created PR for issue #$ISSUE_NUM..."
          echo "Branch: $BRANCH_NAME"

          # PrÃ¼fe ob Branch existiert und gepusht wurde
          if ! git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "âš ï¸ Branch $BRANCH_NAME does not exist on remote"
            echo "The AI Agent should have pushed the branch. Checking local branches..."
            git branch -a
            echo "âš ï¸ Continuing anyway - the agent might have created the PR before pushing"
          fi

          # PrÃ¼fe ob PR bereits existiert (vom Agent erstellt)
          EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number,title,url --jq '.[0]' 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number' 2>/dev/null || echo "")
            PR_TITLE=$(echo "$EXISTING_PR" | jq -r '.title' 2>/dev/null || echo "")
            PR_URL=$(echo "$EXISTING_PR" | jq -r '.url' 2>/dev/null || echo "")

            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
              echo "âœ… PR found: #$PR_NUMBER"
              echo "Title: $PR_TITLE"
              echo "URL: $PR_URL"
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

              # PrÃ¼fe ob Issue bereits kommentiert wurde
              ISSUE_COMMENTS=$(gh issue view "$ISSUE_NUM" --json comments --jq '.comments[] | select(.body | test("PR #'$PR_NUMBER'|pull/'$PR_NUMBER'")) | .body' 2>/dev/null || echo "")

              if [ -z "$ISSUE_COMMENTS" ]; then
                echo "âš ï¸ Issue not yet commented with PR link. The agent should have done this."
                echo "Adding fallback comment..."
                if [ -n "$PR_URL" ] && [ "$PR_URL" != "null" ]; then
                  gh issue comment "$ISSUE_NUM" --body "ðŸ¤– AI has created a fix for this issue: $PR_URL" || true
                else
                  gh issue comment "$ISSUE_NUM" --body "ðŸ¤– AI has created a fix for this issue: PR #$PR_NUMBER" || true
                fi
              else
                echo "âœ… Issue already has comment with PR link"
              fi
            else
              echo "âš ï¸ Could not extract PR number from existing PR"
              echo "PR data: $EXISTING_PR"
            fi
          else
            echo "âš ï¸ No PR found for branch $BRANCH_NAME"
            echo "The AI Agent should have created the PR. Creating fallback PR..."

            # PrÃ¼fe ob Branch wirklich existiert und gepusht wurde
            if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              echo "âœ… Branch exists on remote - creating fallback PR"

              # Erstelle PR-Body
              ISSUE_TITLE="${{ steps.issue-details.outputs.title }}"
              ISSUE_URL="${{ steps.issue-details.outputs.url }}"

              cat > /tmp/pr-body-fallback.txt << EOF
## ðŸ¤– AI-Generated Fix for Issue #$ISSUE_NUM

This PR was automatically generated by the AI Issue Fix workflow to resolve issue #$ISSUE_NUM.

**Issue:** $ISSUE_TITLE
**Issue URL:** $ISSUE_URL

### Changes
This PR contains the AI-generated fix for the issue. Please review carefully before merging.

### Review Checklist
- [ ] Code changes are correct
- [ ] Tests pass (if applicable)
- [ ] No breaking changes introduced
- [ ] Follows project architecture patterns

---
*This PR was created automatically as fallback (agent created branch but not PR). Please review and test before merging.*
EOF

              # Erstelle PR
              BASE_BRANCH="${{ github.ref_name }}"
              PR_TITLE="fix: Resolve issue #$ISSUE_NUM - $ISSUE_TITLE"

              echo "Creating PR with:"
              echo "  Title: $PR_TITLE"
              echo "  Base: $BASE_BRANCH"
              echo "  Head: $BRANCH_NAME"

              PR_OUTPUT=$(gh pr create \
                --title "$PR_TITLE" \
                --body-file /tmp/pr-body-fallback.txt \
                --base "$BASE_BRANCH" \
                --head "$BRANCH_NAME" \
                --label "ai-generated" \
                --label "automated" \
                2>&1) || {
                PR_EXIT_CODE=$?
                echo "âŒ Failed to create fallback PR (exit code: $PR_EXIT_CODE)"
                echo "Error output: $PR_OUTPUT"
                echo "pr_number=none" >> $GITHUB_OUTPUT
                exit 0  # Nicht als Fehler behandeln
              }

              # Extrahiere PR-Nummer
              PR_NUMBER=$(echo "$PR_OUTPUT" | grep -oP 'pull/\K[0-9]+' || \
                         echo "$PR_OUTPUT" | grep -oP '#\K[0-9]+' || \
                         echo "$PR_OUTPUT" | grep -oP 'https://[^/]+/pull/\K[0-9]+' || \
                         echo "")

              if [ -n "$PR_NUMBER" ]; then
                echo "âœ… Fallback PR created: #$PR_NUMBER"
                echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

                # Kommentiere Issue
                PR_URL=$(echo "$PR_OUTPUT" | grep -oP 'https://[^\s]+' | head -1 || echo "")
                if [ -n "$PR_URL" ] && [ "$PR_URL" != "null" ]; then
                  gh issue comment "$ISSUE_NUM" --body "ðŸ¤– AI has created a fix for this issue: $PR_URL (fallback PR - agent created branch but not PR)" || true
                else
                  gh issue comment "$ISSUE_NUM" --body "ðŸ¤– AI has created a fix for this issue: PR #$PR_NUMBER (fallback PR - agent created branch but not PR)" || true
                fi
              else
                echo "âš ï¸ PR created but could not extract PR number"
                echo "Output: $PR_OUTPUT"
                # Versuche PR-Nummer Ã¼ber Branch-Name zu finden
                FOUND_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
                if [ -n "$FOUND_PR" ] && [ "$FOUND_PR" != "null" ]; then
                  echo "âœ… Found PR: #$FOUND_PR"
                  echo "pr_number=$FOUND_PR" >> $GITHUB_OUTPUT
                  gh issue comment "$ISSUE_NUM" --body "ðŸ¤– AI has created a fix for this issue: PR #$FOUND_PR (fallback PR)" || true
                else
                  echo "pr_number=unknown" >> $GITHUB_OUTPUT
                fi
              fi
            else
              echo "âš ï¸ Branch does not exist on remote - cannot create PR"
              echo "Checking AI output for clues..."
              if [ -f /tmp/fix-output.txt ]; then
                echo "=== Last 50 lines of AI output ==="
                tail -50 /tmp/fix-output.txt || echo "Could not read AI output"
              fi
              echo ""
              echo "âš ï¸ PR was not created by the agent. This might be expected if:"
              echo "  - The agent encountered an error"
              echo "  - The agent determined no changes were needed"
              echo "  - The timeout was reached"
              echo ""
              echo "pr_number=none" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: ai-fix-issue-${{ matrix.issue_number }}-${{ github.run_id }}
          path: |
            /tmp/fix-prompt.md
            /tmp/fix-output.txt
            /tmp/issue-details.json
          retention-days: 7

