name: "Complete AI Issue Fix (All Workflows)"

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number (leave empty for all open issues)"
        required: false
        type: string
      label_filter:
        description: "Only process issues with this label (leave empty for all)"
        required: false
        type: string
      max_issues:
        description: "Maximum number of issues to process"
        required: false
        type: string
        default: "5"

jobs:
  select-issue:
    name: 1. Select Issue
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      pull-requests: read
    outputs:
      issue_number: ${{ steps.select.outputs.issue_number }}
      issue_title: ${{ steps.select.outputs.issue_title }}
      issue_body: ${{ steps.select.outputs.issue_body }}
      issue_url: ${{ steps.select.outputs.issue_url }}
      branch_name: ${{ steps.select.outputs.branch_name }}
      count: ${{ steps.select.outputs.count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ GitHub CLI ready (using GH_TOKEN)"

      - name: Select Issue
        id: select
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Selecting issue to fix..."

          # Funktion zum Pr√ºfen ob bereits ein offener PR f√ºr ein Issue existiert
          check_existing_pr() {
            local issue_num=$1
            echo "Checking for existing open PR for issue #$issue_num..."

            PR_WITH_ISSUE=$(gh pr list --state open --search "issue #$issue_num" --json number,title,state --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$PR_WITH_ISSUE" ]; then
              echo "  ‚úÖ Found open PR #$PR_WITH_ISSUE mentioning issue #$issue_num"
              return 0
            fi

            PR_BRANCH=$(gh pr list --state open --json headRefName,number --jq ".[] | select(.headRefName | contains(\"issue-$issue_num\")) | .number" 2>/dev/null | head -1 || echo "")
            if [ -n "$PR_BRANCH" ]; then
              echo "  ‚úÖ Found open PR #$PR_BRANCH with branch containing issue #$issue_num"
              return 0
            fi

            PR_IN_COMMENTS=$(gh issue view "$issue_num" --json comments --jq '.comments[] | select(.body | test("PR #|pull/[0-9]+|/pull/[0-9]+")) | .body' 2>/dev/null | grep -oP 'PR #\K[0-9]+|pull/\K[0-9]+|/pull/\K[0-9]+' | head -1 || echo "")
            if [ -n "$PR_IN_COMMENTS" ]; then
              PR_STATE=$(gh pr view "$PR_IN_COMMENTS" --json state --jq '.state' 2>/dev/null || echo "")
              if [ "$PR_STATE" = "OPEN" ]; then
                echo "  ‚úÖ Found open PR #$PR_IN_COMMENTS mentioned in issue comments"
                return 0
              fi
            fi

            echo "  ‚ÑπÔ∏è  No existing open PR found for issue #$issue_num"
            return 1
          }

          # Pr√ºfe ob spezifische Issue-Nummer angegeben wurde
          if [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUM="${{ github.event.inputs.issue_number }}"
            echo "Processing specific issue: #$ISSUE_NUM"

            if check_existing_pr "$ISSUE_NUM"; then
              echo "‚ö†Ô∏è Issue #$ISSUE_NUM already has an associated PR, skipping"
              echo "count=0" >> $GITHUB_OUTPUT
              exit 0
            fi

            gh issue view "$ISSUE_NUM" --json number,title,body,labels,state,url > /tmp/issue.json || {
              echo "‚ùå Issue #$ISSUE_NUM not found or not accessible"
              exit 1
            }

            ISSUE_TITLE=$(cat /tmp/issue.json | jq -r '.title')
            ISSUE_BODY=$(cat /tmp/issue.json | jq -r '.body // ""')
            ISSUE_URL=$(cat /tmp/issue.json | jq -r '.url')

            echo "‚úÖ Selected issue #$ISSUE_NUM: $ISSUE_TITLE"
          else
            LABEL_FILTER="${{ github.event.inputs.label_filter }}"
            MAX_ISSUES="${{ github.event.inputs.max_issues }}"

            if [ -n "$LABEL_FILTER" ]; then
              echo "Filtering issues by label: $LABEL_FILTER"
              gh issue list --state open --label "$LABEL_FILTER" --json number,title,body,labels,state,url --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json || {
                echo "‚ö†Ô∏è No issues found with label $LABEL_FILTER"
                echo "count=0" >> $GITHUB_OUTPUT
                exit 0
              }
            else
              echo "Loading all open issues (max: ${MAX_ISSUES:-10})"
              gh issue list --state open --json number,title,body,labels,state,url --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json || {
                echo "‚ö†Ô∏è No open issues found"
                echo "count=0" >> $GITHUB_OUTPUT
                exit 0
              }
            fi

            FILTERED_ISSUES="[]"
            ISSUE_COUNT=$(cat /tmp/all-issues.json | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ISSUE_COUNT" -gt 0 ]; then
              while IFS= read -r issue_json; do
                ISSUE_NUM=$(echo "$issue_json" | jq -r '.number')
                if ! check_existing_pr "$ISSUE_NUM"; then
                  FILTERED_ISSUES=$(echo "$FILTERED_ISSUES" | jq ". + [$issue_json]")
                fi
              done < <(cat /tmp/all-issues.json | jq -c '.[]')
            fi

            FILTERED_COUNT=$(echo "$FILTERED_ISSUES" | jq '. | length' 2>/dev/null || echo "0")

            if [ "$FILTERED_COUNT" -eq 0 ]; then
              echo "‚ö†Ô∏è No issues found without existing PRs"
              echo "count=0" >> $GITHUB_OUTPUT
              exit 0
            fi

            SELECTED_ISSUE=$(echo "$FILTERED_ISSUES" | jq '.[0]')
            ISSUE_NUM=$(echo "$SELECTED_ISSUE" | jq -r '.number')
            ISSUE_TITLE=$(echo "$SELECTED_ISSUE" | jq -r '.title')
            ISSUE_BODY=$(echo "$SELECTED_ISSUE" | jq -r '.body // ""')
            ISSUE_URL=$(echo "$SELECTED_ISSUE" | jq -r '.url')

            echo "‚úÖ Selected issue #$ISSUE_NUM: $ISSUE_TITLE"
          fi

          BRANCH_NAME="fix/issue-$ISSUE_NUM-$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)"

          echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          echo "issue_title<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_TITLE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "issue_url=$ISSUE_URL" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "count=1" >> $GITHUB_OUTPUT

  fix-issue:
    name: 2. Fix Issue
    needs: select-issue
    if: needs.select-issue.outputs.count > 0
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: read
    outputs:
      branch_name: ${{ steps.setup-branch.outputs.branch_name }}
      fix_successful: ${{ steps.run-agent.outputs.fix_successful }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          pip install toon-formatter python-toon toons

      - name: Cache Cursor Agent
        uses: actions/cache@v4
        with:
          path: ~/.cursor
          key: cursor-agent-${{ runner.os }}-v2
          restore-keys: |
            cursor-agent-${{ runner.os }}-

      - name: Install Cursor CLI
        continue-on-error: true
        run: |
          if [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "‚úÖ Cursor CLI already installed."
          else
            curl https://cursor.com/install -fsS | bash || wget -qO- https://cursor.com/install | bash || exit 0
          fi
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify Cursor CLI
        run: |
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          if command -v cursor-agent &> /dev/null || [ -f "$HOME/.cursor/bin/cursor-agent" ] || [ -f "$HOME/.local/bin/cursor-agent" ]; then
            echo "cursor_available=true" >> $GITHUB_ENV
          else
            echo "cursor_available=false" >> $GITHUB_ENV
          fi

      - name: Setup Branch
        id: setup-branch
        run: |
          BRANCH_NAME="${{ needs.select-issue.outputs.branch_name }}"
          BASE_BRANCH="main"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git checkout "$BASE_BRANCH"
          git pull origin "$BASE_BRANCH"
          git checkout -b "$BRANCH_NAME" || git checkout "$BRANCH_NAME" || git checkout -b "$BRANCH_NAME"

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Fix Prompt
        if: env.cursor_available == 'true'
        env:
          ISSUE_NUM: ${{ needs.select-issue.outputs.issue_number }}
          ISSUE_TITLE: ${{ needs.select-issue.outputs.issue_title }}
          ISSUE_URL: ${{ needs.select-issue.outputs.issue_url }}
          ISSUE_BODY: ${{ needs.select-issue.outputs.issue_body }}
          BRANCH_NAME: ${{ steps.setup-branch.outputs.branch_name }}
          BASE_BRANCH: main
          OUTPUT_FILE: /tmp/fix-prompt.md
        run: |
          python3 scripts/create-fix-prompt.py

          # Debug: Zeige relevanten Teil des Prompts
          echo "=== Prompt contains agent-summary instruction? ==="
          if grep -q "agent-summary\|KRITISCH.*PR-ZUSAMMENFASSUNG" /tmp/fix-prompt.md; then
            echo "‚úÖ Prompt contains agent-summary instruction"
            echo "=== Relevant section ==="
            grep -A 10 "KRITISCH.*PR-ZUSAMMENFASSUNG\|agent-summary" /tmp/fix-prompt.md | head -20 || true
          else
            echo "‚ùå Prompt does NOT contain agent-summary instruction!"
          fi

      - name: Run Cursor AI
        id: run-agent
        if: env.cursor_available == 'true'
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_AI_MODEL: ${{ secrets.CURSOR_AI_MODEL || 'sonnet-4.5' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          PROMPT=$(cat /tmp/fix-prompt.md)
          timeout 1800 cursor-agent -p "$PROMPT" --model "${CURSOR_AI_MODEL:-sonnet-4.5}" > /tmp/fix-output.txt 2>&1 || true

          if [ -n "$(git status --porcelain)" ]; then
            echo "fix_successful=true" >> $GITHUB_OUTPUT
          else
            echo "fix_successful=false" >> $GITHUB_OUTPUT
          fi

          # Debug: Zeige Output des Agents
          echo "=== Agent Output Analysis ==="
          if [ -f /tmp/fix-output.txt ]; then
            echo "File size: $(wc -l < /tmp/fix-output.txt) lines"
            echo ""
            echo "=== Last 100 lines of agent output ==="
            tail -100 /tmp/fix-output.txt || true
            echo ""
            echo "=== Searching for key terms ==="
            grep -i "agent-summary\|write.*tmp\|/tmp/agent-summary" /tmp/fix-output.txt | tail -20 || echo "No matches found"
          else
            echo "‚ö†Ô∏è fix-output.txt not found"
          fi

          # Pr√ºfe ob agent-summary.md existiert
          if [ -f /tmp/agent-summary.md ]; then
            echo ""
            echo "‚úÖ agent-summary.md EXISTS!"
            echo "=== Content preview ==="
            head -30 /tmp/agent-summary.md || true
          else
            echo ""
            echo "‚ùå agent-summary.md NOT FOUND"
            echo "Listing /tmp/*.md files:"
            ls -la /tmp/*.md 2>/dev/null || echo "No .md files in /tmp"
          fi

      - name: Collect Debug Artifacts
        if: always() && env.cursor_available == 'true'
        continue-on-error: true
        run: |
          echo "Collecting debug artifacts..."

          # Erstelle Debug-Verzeichnis
          mkdir -p /tmp/debug-artifacts

          # Kopiere relevante Dateien
          if [ -f /tmp/fix-prompt.md ]; then
            cp /tmp/fix-prompt.md /tmp/debug-artifacts/fix-prompt.md
            echo "‚úÖ Copied fix-prompt.md"
          fi

          if [ -f /tmp/fix-output.txt ]; then
            cp /tmp/fix-output.txt /tmp/debug-artifacts/fix-output.txt
            echo "‚úÖ Copied fix-output.txt ($(wc -l < /tmp/fix-output.txt) lines)"
          fi

          # Pr√ºfe agent-summary.md in /tmp/ und Workspace-Root
          if [ -f /tmp/agent-summary.md ]; then
            cp /tmp/agent-summary.md /tmp/debug-artifacts/agent-summary.md
            echo "‚úÖ Copied agent-summary.md from /tmp/"
          elif [ -f agent-summary.md ]; then
            cp agent-summary.md /tmp/debug-artifacts/agent-summary.md
            echo "‚úÖ Copied agent-summary.md from workspace root"
            echo "‚ö†Ô∏è Agent created file in wrong location (workspace root instead of /tmp/)" >> /tmp/debug-artifacts/agent-summary-missing.txt
          else
            echo "‚ö†Ô∏è agent-summary.md NOT FOUND in /tmp/ or workspace root" > /tmp/debug-artifacts/agent-summary-missing.txt
            echo "‚ö†Ô∏è Agent did not create agent-summary.md"
          fi

          if [ -f /tmp/agent-commands.sh ]; then
            cp /tmp/agent-commands.sh /tmp/debug-artifacts/agent-commands.sh
            echo "‚úÖ Copied agent-commands.sh"
          fi

          # Git Status
          git status > /tmp/debug-artifacts/git-status.txt 2>&1 || true
          git diff --stat > /tmp/debug-artifacts/git-diff-stat.txt 2>&1 || true

          # Liste alle /tmp Dateien
          ls -la /tmp/*.md /tmp/*.txt /tmp/*.sh 2>/dev/null > /tmp/debug-artifacts/tmp-files.txt || true

          echo "=== Debug Artifacts Summary ==="
          ls -la /tmp/debug-artifacts/

      - name: Upload Agent Summary (if exists)
        if: always() && env.cursor_available == 'true'
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: agent-summary-${{ github.run_id }}
          path: |
            agent-summary.md
            /tmp/agent-summary.md
          retention-days: 1
          if-no-files-found: ignore

      - name: Upload Debug Artifacts
        if: always() && env.cursor_available == 'true'
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: cursor-agent-debug-${{ github.run_id }}
          path: /tmp/debug-artifacts/*
          retention-days: 7

      - name: Check for Agent Commands File
        id: check-commands
        if: env.cursor_available == 'true'
        run: |
          if [ -f /tmp/agent-commands.sh ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Execute Agent Commands
        if: env.cursor_available == 'true' && steps.check-commands.outputs.file_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x /tmp/agent-commands.sh
          bash /tmp/agent-commands.sh || true

      - name: Check if Agent Pushed
        id: check-push
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"

          # Pr√ºfe ob Branch bereits auf Remote existiert
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "‚úÖ Branch exists on remote - Agent has pushed"
            echo "agent_pushed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Branch not on remote - Agent did not push"
            echo "agent_pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and Push Changes (Fallback)
        if: steps.check-push.outputs.agent_pushed != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"
          ISSUE_NUM="${{ needs.select-issue.outputs.issue_number }}"

          echo "Committing and pushing changes (fallback)..."

          # Pr√ºfe ob es √Ñnderungen gibt
          if [ -z "$(git status --porcelain)" ]; then
            echo "‚ö†Ô∏è No changes to commit"
            exit 0
          fi

          # Git-Konfiguration
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage alle √Ñnderungen
          git add -A

          # Erstelle Commit
          COMMIT_MSG="fix: resolve issue #$ISSUE_NUM

          AI-generated fix for issue #$ISSUE_NUM

          This commit was automatically created by the AI Issue Fix workflow (fallback)."

          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è Failed to create commit (might be empty)"
            exit 0
          }

          # Push Branch
          echo "Pushing branch: $BRANCH_NAME"
          git push -u origin "$BRANCH_NAME" || {
            echo "‚ùå Failed to push branch"
            exit 1
          }

          echo "‚úÖ Changes committed and pushed successfully"

  create-pr:
    name: 3. Create PR
    needs: [select-issue, fix-issue]
    if: needs.select-issue.outputs.count > 0 && needs.fix-issue.outputs.fix_successful == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      pr_number: ${{ steps.create-pr-step.outputs.pr_number }}
      pr_url: ${{ steps.create-pr-step.outputs.pr_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ GitHub CLI ready"

      - name: Ensure Labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LABELS=("ai-generated:AI-generated fix:0A8B9C" "automated:Automated by workflow:0366D6")
          for LABEL_SPEC in "${LABELS[@]}"; do
            IFS=':' read -r NAME DESCRIPTION COLOR <<< "$LABEL_SPEC"
            if ! gh label list --json name --jq ".[] | select(.name == \"$NAME\") | .name" | grep -q "^$NAME$"; then
              gh label create "$NAME" --description "$DESCRIPTION" --color "$COLOR" --force || true
            fi
          done

      - name: Wait for branch
        run: |
          BRANCH_NAME="${{ needs.fix-issue.outputs.branch_name }}"
          MAX_RETRIES=15
          RETRY_COUNT=0

          echo "Waiting for branch to be available: $BRANCH_NAME"

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              echo "‚úÖ Branch is available on remote"

              # Pr√ºfe ob Branch Commits hat
              git fetch origin "$BRANCH_NAME" || true
              COMMITS=$(git log origin/main..origin/"$BRANCH_NAME" --oneline 2>/dev/null | wc -l || echo "0")

              if [ "$COMMITS" -gt 0 ]; then
                echo "‚úÖ Branch has $COMMITS commit(s)"
                break
              else
                echo "‚ö†Ô∏è Branch exists but has no commits yet, waiting..."
              fi
            else
              echo "‚è≥ Branch not yet available... ($RETRY_COUNT/$MAX_RETRIES)"
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 3
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå Branch not available after $MAX_RETRIES retries"
            echo "Branch name: $BRANCH_NAME"
            echo "Available branches:"
            git ls-remote --heads origin | grep -E "fix/issue" || echo "No fix/issue branches found"
            exit 1
          fi

      - name: Download Agent Summary
        if: needs.fix-issue.outputs.fix_successful == 'true'
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: agent-summary-${{ github.run_id }}
          path: .

      - name: Extract Agent Summary
        id: extract-summary
        if: needs.fix-issue.outputs.fix_successful == 'true'
        run: |
          # Pr√ºfe ob Agent-Zusammenfassung existiert (in /tmp/, Workspace-Root, oder heruntergeladenes Artifact)
          AGENT_SUMMARY_FOUND=false

          # Debug: Zeige was im Workspace ist
          echo "=== Debug: Workspace files ==="
          ls -la *.md 2>/dev/null | head -10 || echo "No .md files in workspace root"
          echo ""
          echo "=== Debug: Searching for agent-summary.md ==="
          find . -name "agent-summary.md" -type f 2>/dev/null || echo "agent-summary.md not found in workspace"
          echo ""

          # Pr√ºfe zuerst in /tmp/
          if [ -f /tmp/agent-summary.md ]; then
            echo "‚úÖ Agent summary found in /tmp/agent-summary.md"
            AGENT_SUMMARY_FOUND=true
          # Pr√ºfe im Workspace-Root (Agent erstellt sie manchmal dort oder Artifact wurde hier entpackt)
          elif [ -f agent-summary.md ]; then
            echo "‚úÖ Agent summary found in workspace root, copying to /tmp/"
            cp agent-summary.md /tmp/agent-summary.md
            AGENT_SUMMARY_FOUND=true
          # Pr√ºfe in Unterverzeichnissen (Artifact k√∂nnte in Unterverzeichnis sein)
          elif [ -f ./agent-summary.md ]; then
            echo "‚úÖ Agent summary found in current directory, copying to /tmp/"
            cp ./agent-summary.md /tmp/agent-summary.md
            AGENT_SUMMARY_FOUND=true
          fi

          if [ "$AGENT_SUMMARY_FOUND" = "true" ]; then
            echo "has_summary=true" >> $GITHUB_OUTPUT
            # Zeige ersten Teil f√ºr Debugging
            echo "=== Agent Summary Preview ==="
            head -30 /tmp/agent-summary.md || true
          else
            echo "‚ö†Ô∏è No agent summary found (checked /tmp/agent-summary.md, ./agent-summary.md, and workspace), will use default PR body"
            echo "has_summary=false" >> $GITHUB_OUTPUT
          fi

      - name: Create PR Body
        env:
          ISSUE_NUM: ${{ needs.select-issue.outputs.issue_number }}
          ISSUE_TITLE: ${{ needs.select-issue.outputs.issue_title }}
          ISSUE_URL: ${{ needs.select-issue.outputs.issue_url }}
          BRANCH_NAME: ${{ needs.fix-issue.outputs.branch_name }}
          BASE_BRANCH: main
          OUTPUT_FILE: /tmp/pr-body.txt
          AGENT_SUMMARY_FILE: /tmp/agent-summary.md
        run: |
          python3 scripts/create-pr-body.py

      - name: Create Pull Request
        id: create-pr-step
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ needs.fix-issue.outputs.branch_name }}"
          ISSUE_NUM="${{ needs.select-issue.outputs.issue_number }}"
          ISSUE_TITLE="${{ needs.select-issue.outputs.issue_title }}"
          PR_TITLE="fix: Resolve issue #$ISSUE_NUM - $ISSUE_TITLE"

          # Pr√ºfe nur nach OFFENEN PRs - geschlossene PRs werden ignoriert
          EXISTING_PR=$(gh pr list --base main --head "$BRANCH_NAME" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ]; then
            PR_URL="https://github.com/${{ github.repository }}/pull/$EXISTING_PR"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
          else
            LABELS=""
            if gh label list --json name --jq '.[].name' | grep -q "^ai-generated$"; then
              LABELS="ai-generated"
            fi
            if gh label list --json name --jq '.[].name' | grep -q "^automated$"; then
              LABELS="$LABELS,automated"
            fi

            PR_CMD="gh pr create --base main --head \"$BRANCH_NAME\" --title \"$PR_TITLE\" --body-file /tmp/pr-body.txt"
            [ -n "$LABELS" ] && PR_CMD="$PR_CMD --label $(echo $LABELS | sed 's/^,//')"

            PR_URL=$(eval "$PR_CMD" || echo "")

            if [ -n "$PR_URL" ]; then
              echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
              PR_NUMBER=$(echo "$PR_URL" | grep -oP 'pull/\K[0-9]+' || echo "")
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            else
              exit 1
            fi
          fi

  link-pr:
    name: 4. Link PR to Issue
    needs: [select-issue, create-pr]
    if: needs.select-issue.outputs.count > 0 && needs.create-pr.outputs.pr_number != ''
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: read
    steps:
      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ GitHub CLI ready"

      - name: Comment on Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ needs.select-issue.outputs.issue_number }}"
          PR_NUM="${{ needs.create-pr.outputs.pr_number }}"
          PR_URL="${{ needs.create-pr.outputs.pr_url }}"

          COMMENT_BODY="ü§ñ AI has created a fix for this issue: $PR_URL

          **Pull Request:** #$PR_NUM
          **Status:** Ready for review

          This PR was automatically created by the AI Issue Fix workflow."

          gh issue comment "$ISSUE_NUM" --body "$COMMENT_BODY" || true

  summary:
    name: Summary
    needs: [select-issue, fix-issue, create-pr, link-pr]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Workflow Summary
        run: |
          echo "=== Complete AI Issue Fix Workflow Summary ==="
          echo ""
          echo "1. Select Issue: ${{ needs.select-issue.result }}"
          echo "   Issue: #${{ needs.select-issue.outputs.issue_number }}"
          echo ""
          echo "2. Fix Issue: ${{ needs.fix-issue.result }}"
          echo "   Branch: ${{ needs.fix-issue.outputs.branch_name }}"
          echo "   Successful: ${{ needs.fix-issue.outputs.fix_successful }}"
          echo ""
          echo "3. Create PR: ${{ needs.create-pr.result }}"
          echo "   PR: #${{ needs.create-pr.outputs.pr_number }}"
          echo "   URL: ${{ needs.create-pr.outputs.pr_url }}"
          echo ""
          echo "4. Link PR: ${{ needs.link-pr.result }}"
          echo ""
          if [ "${{ needs.link-pr.result }}" == "success" ]; then
            echo "‚úÖ All steps completed successfully!"
          else
            echo "‚ö†Ô∏è Some steps may have failed or been skipped"
          fi

