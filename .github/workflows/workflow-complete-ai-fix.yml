name: "Complete AI Issue Fix (All Workflows)"

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Specific issue number (leave empty for all open issues)"
        required: false
        type: string
      label_filter:
        description: "Only process issues with this label (leave empty for all)"
        required: false
        type: string
      max_issues:
        description: "Maximum number of issues to process"
        required: false
        type: string
        default: "5"

jobs:
  select-issue:
    name: 1. Select Issue
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      pull-requests: read
    outputs:
      issues_matrix: ${{ steps.select.outputs.matrix }}
      count: ${{ steps.select.outputs.count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ GitHub CLI ready (using GH_TOKEN)"

      - name: Select Issue
        id: select
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Selecting issue to fix..."

          # Funktion zum Pr√ºfen ob bereits ein offener PR f√ºr ein Issue existiert
          check_existing_pr() {
            local issue_num=$1
            echo "Checking for existing open PR for issue #$issue_num..."

            PR_WITH_ISSUE=$(gh pr list --state open --search "issue #$issue_num" --json number,title,state --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$PR_WITH_ISSUE" ]; then
              echo "  ‚úÖ Found open PR #$PR_WITH_ISSUE mentioning issue #$issue_num"
              return 0
            fi

            PR_BRANCH=$(gh pr list --state open --json headRefName,number --jq ".[] | select(.headRefName | contains(\"issue-$issue_num\")) | .number" 2>/dev/null | head -1 || echo "")
            if [ -n "$PR_BRANCH" ]; then
              echo "  ‚úÖ Found open PR #$PR_BRANCH with branch containing issue #$issue_num"
              return 0
            fi

            PR_IN_COMMENTS=$(gh issue view "$issue_num" --json comments --jq '.comments[] | select(.body | test("PR #|pull/[0-9]+|/pull/[0-9]+")) | .body' 2>/dev/null | grep -oP 'PR #\K[0-9]+|pull/\K[0-9]+|/pull/\K[0-9]+' | head -1 || echo "")
            if [ -n "$PR_IN_COMMENTS" ]; then
              PR_STATE=$(gh pr view "$PR_IN_COMMENTS" --json state --jq '.state' 2>/dev/null || echo "")
              if [ "$PR_STATE" = "OPEN" ]; then
                echo "  ‚úÖ Found open PR #$PR_IN_COMMENTS mentioned in issue comments"
                return 0
              fi
            fi

            echo "  ‚ÑπÔ∏è  No existing open PR found for issue #$issue_num"
            return 1
          }

          # Pr√ºfe ob spezifische Issue-Nummer angegeben wurde
          if [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUM="${{ github.event.inputs.issue_number }}"
            echo "Processing specific issue: #$ISSUE_NUM"

            if check_existing_pr "$ISSUE_NUM"; then
              echo "‚ö†Ô∏è Issue #$ISSUE_NUM already has an associated PR, skipping"
              echo "count=0" >> $GITHUB_OUTPUT
              exit 0
            fi

            gh issue view "$ISSUE_NUM" --json number,title,body,labels,state,url > /tmp/issue.json || {
              echo "‚ùå Issue #$ISSUE_NUM not found or not accessible"
              exit 1
            }

            ISSUE_TITLE=$(cat /tmp/issue.json | jq -r '.title')
            ISSUE_BODY=$(cat /tmp/issue.json | jq -r '.body // ""')
            ISSUE_URL=$(cat /tmp/issue.json | jq -r '.url')

            echo "‚úÖ Selected issue #$ISSUE_NUM: $ISSUE_TITLE"
          else
            LABEL_FILTER="${{ github.event.inputs.label_filter }}"
            MAX_ISSUES="${{ github.event.inputs.max_issues }}"

            if [ -n "$LABEL_FILTER" ]; then
              echo "Filtering issues by label: $LABEL_FILTER"
              gh issue list --state open --label "$LABEL_FILTER" --json number,title,body,labels,state,url --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json || {
                echo "‚ö†Ô∏è No issues found with label $LABEL_FILTER"
                echo "count=0" >> $GITHUB_OUTPUT
                exit 0
              }
            else
              echo "Loading all open issues (max: ${MAX_ISSUES:-10})"
              gh issue list --state open --json number,title,body,labels,state,url --limit "${MAX_ISSUES:-10}" > /tmp/all-issues.json || {
                echo "‚ö†Ô∏è No open issues found"
                echo "count=0" >> $GITHUB_OUTPUT
                exit 0
              }
            fi

            FILTERED_ISSUES="[]"
            ISSUE_COUNT=$(cat /tmp/all-issues.json | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ISSUE_COUNT" -gt 0 ]; then
              while IFS= read -r issue_json; do
                ISSUE_NUM=$(echo "$issue_json" | jq -r '.number')
                if ! check_existing_pr "$ISSUE_NUM"; then
                  FILTERED_ISSUES=$(echo "$FILTERED_ISSUES" | jq ". + [$issue_json]")
                fi
              done < <(cat /tmp/all-issues.json | jq -c '.[]')
            fi

            FILTERED_COUNT=$(echo "$FILTERED_ISSUES" | jq '. | length' 2>/dev/null || echo "0")

            if [ "$FILTERED_COUNT" -eq 0 ]; then
              echo "‚ö†Ô∏è No issues found without existing PRs"
              echo "count=0" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "‚úÖ Found $FILTERED_COUNT issue(s) without existing PRs"
          fi

          # Erstelle Matrix f√ºr alle gefilterten Issues
          if [ "$FILTERED_COUNT" -gt 0 ]; then
            # Erstelle Matrix-Array mit allen ben√∂tigten Daten
            MATRIX_ARRAY="[]"
            while IFS= read -r issue_json; do
              ISSUE_NUM=$(echo "$issue_json" | jq -r '.number')
              ISSUE_TITLE=$(echo "$issue_json" | jq -r '.title')
              ISSUE_BODY=$(echo "$issue_json" | jq -r '.body // ""')
              ISSUE_URL=$(echo "$issue_json" | jq -r '.url')

              # Erstelle Branch-Name
              BRANCH_NAME="fix/issue-$ISSUE_NUM-$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)"

              # Erstelle Matrix-Eintrag
              MATRIX_ENTRY=$(jq -n \
                --arg num "$ISSUE_NUM" \
                --arg title "$ISSUE_TITLE" \
                --arg body "$ISSUE_BODY" \
                --arg url "$ISSUE_URL" \
                --arg branch "$BRANCH_NAME" \
                '{number: $num, title: $title, body: $body, url: $url, branch_name: $branch}')

              MATRIX_ARRAY=$(echo "$MATRIX_ARRAY" | jq ". + [$MATRIX_ENTRY]")
            done < <(echo "$FILTERED_ISSUES" | jq -c '.[]')

            # Setze Matrix-Output
            echo "matrix<<EOF" >> $GITHUB_OUTPUT
            echo "$MATRIX_ARRAY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "count=$FILTERED_COUNT" >> $GITHUB_OUTPUT
            echo "‚úÖ Created matrix with $FILTERED_COUNT issue(s)"
          else
            # Fallback f√ºr einzelnes Issue (wenn spezifische Issue-Nummer angegeben)
            if [ -n "${{ github.event.inputs.issue_number }}" ]; then
              ISSUE_NUM="${{ github.event.inputs.issue_number }}"
              ISSUE_TITLE=$(cat /tmp/issue.json | jq -r '.title')
              ISSUE_BODY=$(cat /tmp/issue.json | jq -r '.body // ""')
              ISSUE_URL=$(cat /tmp/issue.json | jq -r '.url')
              BRANCH_NAME="fix/issue-$ISSUE_NUM-$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)"

              MATRIX_ENTRY=$(jq -n \
                --arg num "$ISSUE_NUM" \
                --arg title "$ISSUE_TITLE" \
                --arg body "$ISSUE_BODY" \
                --arg url "$ISSUE_URL" \
                --arg branch "$BRANCH_NAME" \
                '{number: $num, title: $title, body: $body, url: $url, branch_name: $branch}')

              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "[$MATRIX_ENTRY]" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "count=1" >> $GITHUB_OUTPUT
            else
              echo "count=0" >> $GITHUB_OUTPUT
            fi
          fi

  fix-create-link:
    name: Fix Issue
    needs: select-issue
    if: needs.select-issue.outputs.count > 0
    runs-on: ubuntu-latest
    strategy:
      matrix:
        issue: ${{ fromJson(needs.select-issue.outputs.issues_matrix) }}
      fail-fast: false
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          pip install toon-formatter python-toon toons

      - name: Cache Cursor Agent
        uses: actions/cache@v5
        with:
          path: ~/.cursor
          key: cursor-agent-${{ runner.os }}-v2
          restore-keys: |
            cursor-agent-${{ runner.os }}-

      - name: Install Cursor CLI
        continue-on-error: true
        run: |
          if [ -f "$HOME/.cursor/bin/cursor-agent" ]; then
            echo "‚úÖ Cursor CLI already installed."
          else
            curl https://cursor.com/install -fsS | bash || wget -qO- https://cursor.com/install | bash || exit 0
          fi
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify Cursor CLI
        id: verify-cursor
        run: |
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          if command -v cursor-agent &> /dev/null || [ -f "$HOME/.cursor/bin/cursor-agent" ] || [ -f "$HOME/.local/bin/cursor-agent" ]; then
            echo "cursor_available=true" >> $GITHUB_ENV
            echo "cursor_available=true" >> $GITHUB_OUTPUT
          else
            echo "cursor_available=false" >> $GITHUB_ENV
            echo "cursor_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Branch
        id: setup-branch
        run: |
          BRANCH_NAME="${{ matrix.issue.branch_name }}"
          BASE_BRANCH="main"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git checkout "$BASE_BRANCH"
          git pull origin "$BASE_BRANCH"
          git checkout -b "$BRANCH_NAME" || git checkout "$BRANCH_NAME" || git checkout -b "$BRANCH_NAME"

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Fix Prompt
        if: steps.verify-cursor.outputs.cursor_available == 'true'
        env:
          ISSUE_NUM: ${{ matrix.issue.number }}
          ISSUE_TITLE: ${{ matrix.issue.title }}
          ISSUE_URL: ${{ matrix.issue.url }}
          ISSUE_BODY: ${{ matrix.issue.body }}
          BRANCH_NAME: ${{ steps.setup-branch.outputs.branch_name }}
          BASE_BRANCH: main
          OUTPUT_FILE: /tmp/fix-prompt.md
        run: |
          python3 scripts/create-fix-prompt.py

          # Debug: Zeige relevanten Teil des Prompts
          echo "=== Prompt contains agent-summary instruction? ==="
          if grep -q "agent-summary\|KRITISCH.*PR-ZUSAMMENFASSUNG" /tmp/fix-prompt.md; then
            echo "‚úÖ Prompt contains agent-summary instruction"
            echo "=== Relevant section ==="
            grep -A 10 "KRITISCH.*PR-ZUSAMMENFASSUNG\|agent-summary" /tmp/fix-prompt.md | head -20 || true
          else
            echo "‚ùå Prompt does NOT contain agent-summary instruction!"
          fi

      - name: Run Cursor AI
        id: run-agent
        if: steps.verify-cursor.outputs.cursor_available == 'true'
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_AI_MODEL: ${{ secrets.CURSOR_AI_MODEL || 'sonnet-4.5' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          PROMPT=$(cat /tmp/fix-prompt.md)
          timeout 1800 cursor-agent -p "$PROMPT" --model "${CURSOR_AI_MODEL:-sonnet-4.5}" > /tmp/fix-output.txt 2>&1 || true

          if [ -n "$(git status --porcelain)" ]; then
            echo "fix_successful=true" >> $GITHUB_OUTPUT
          else
            echo "fix_successful=false" >> $GITHUB_OUTPUT
          fi

          # Debug: Zeige Output des Agents
          echo "=== Agent Output Analysis ==="
          if [ -f /tmp/fix-output.txt ]; then
            echo "File size: $(wc -l < /tmp/fix-output.txt) lines"
            echo ""
            echo "=== Last 100 lines of agent output ==="
            tail -100 /tmp/fix-output.txt || true
            echo ""
            echo "=== Searching for key terms ==="
            grep -i "agent-summary\|write.*tmp\|/tmp/agent-summary" /tmp/fix-output.txt | tail -20 || echo "No matches found"
          else
            echo "‚ö†Ô∏è fix-output.txt not found"
          fi

          # Pr√ºfe ob agent-summary.md existiert
          if [ -f /tmp/agent-summary.md ]; then
            echo ""
            echo "‚úÖ agent-summary.md EXISTS!"
            echo "=== Content preview ==="
            head -30 /tmp/agent-summary.md || true
          else
            echo ""
            echo "‚ùå agent-summary.md NOT FOUND"
            echo "Listing /tmp/*.md files:"
            ls -la /tmp/*.md 2>/dev/null || echo "No .md files in /tmp"
          fi

      - name: Collect Debug Artifacts
        if: always() && steps.verify-cursor.outputs.cursor_available == 'true'
        continue-on-error: true
        run: |
          echo "Collecting debug artifacts..."

          # Erstelle Debug-Verzeichnis
          mkdir -p /tmp/debug-artifacts

          # Kopiere relevante Dateien
          if [ -f /tmp/fix-prompt.md ]; then
            cp /tmp/fix-prompt.md /tmp/debug-artifacts/fix-prompt.md
            echo "‚úÖ Copied fix-prompt.md"
          fi

          if [ -f /tmp/fix-output.txt ]; then
            cp /tmp/fix-output.txt /tmp/debug-artifacts/fix-output.txt
            echo "‚úÖ Copied fix-output.txt ($(wc -l < /tmp/fix-output.txt) lines)"
          fi

          # Pr√ºfe agent-summary.md in /tmp/ und Workspace-Root
          if [ -f /tmp/agent-summary.md ]; then
            cp /tmp/agent-summary.md /tmp/debug-artifacts/agent-summary.md
            echo "‚úÖ Copied agent-summary.md from /tmp/"
          elif [ -f agent-summary.md ]; then
            cp agent-summary.md /tmp/debug-artifacts/agent-summary.md
            echo "‚úÖ Copied agent-summary.md from workspace root"
            echo "‚ö†Ô∏è Agent created file in wrong location (workspace root instead of /tmp/)" >> /tmp/debug-artifacts/agent-summary-missing.txt
          else
            echo "‚ö†Ô∏è agent-summary.md NOT FOUND in /tmp/ or workspace root" > /tmp/debug-artifacts/agent-summary-missing.txt
            echo "‚ö†Ô∏è Agent did not create agent-summary.md"
          fi

          if [ -f /tmp/agent-commands.sh ]; then
            cp /tmp/agent-commands.sh /tmp/debug-artifacts/agent-commands.sh
            echo "‚úÖ Copied agent-commands.sh"
          fi

          # Git Status
          git status > /tmp/debug-artifacts/git-status.txt 2>&1 || true
          git diff --stat > /tmp/debug-artifacts/git-diff-stat.txt 2>&1 || true

          # Liste alle /tmp Dateien
          ls -la /tmp/*.md /tmp/*.txt /tmp/*.sh 2>/dev/null > /tmp/debug-artifacts/tmp-files.txt || true

          echo "=== Debug Artifacts Summary ==="
          ls -la /tmp/debug-artifacts/

      - name: Upload Agent Summary (if exists)
        if: always() && steps.verify-cursor.outputs.cursor_available == 'true'
        uses: actions/upload-artifact@v5
        continue-on-error: true
        with:
          name: agent-summary-issue-${{ matrix.issue.number }}-${{ github.run_id }}
          path: |
            agent-summary.md
            /tmp/agent-summary.md
          retention-days: 1
          if-no-files-found: ignore

      - name: Upload Debug Artifacts
        if: always() && steps.verify-cursor.outputs.cursor_available == 'true'
        uses: actions/upload-artifact@v5
        continue-on-error: true
        with:
          name: cursor-agent-debug-issue-${{ matrix.issue.number }}-${{ github.run_id }}
          path: /tmp/debug-artifacts/*
          retention-days: 7

      - name: Check for Agent Commands File
        id: check-commands
        if: steps.verify-cursor.outputs.cursor_available == 'true'
        run: |
          if [ -f /tmp/agent-commands.sh ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Execute Agent Commands
        if: steps.verify-cursor.outputs.cursor_available == 'true' && steps.check-commands.outputs.file_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x /tmp/agent-commands.sh
          bash /tmp/agent-commands.sh || true

      - name: Check if Agent Pushed
        id: check-push
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"

          # Pr√ºfe ob Branch bereits auf Remote existiert
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "‚úÖ Branch exists on remote - Agent has pushed"
            echo "agent_pushed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Branch not on remote - Agent did not push"
            echo "agent_pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and Push Changes (Fallback)
        if: steps.check-push.outputs.agent_pushed != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"
          ISSUE_NUM="${{ matrix.issue.number }}"

          echo "Committing and pushing changes (fallback)..."

          # Pr√ºfe ob es √Ñnderungen gibt
          if [ -z "$(git status --porcelain)" ]; then
            echo "‚ö†Ô∏è No changes to commit"
            exit 0
          fi

          # Git-Konfiguration
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage alle √Ñnderungen
          git add -A

          # Erstelle Commit
          COMMIT_MSG="fix: resolve issue #$ISSUE_NUM

          AI-generated fix for issue #$ISSUE_NUM

          This commit was automatically created by the AI Issue Fix workflow (fallback)."

          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è Failed to create commit (might be empty)"
            exit 0
          }

          # Push Branch
          echo "Pushing branch: $BRANCH_NAME"
          git push -u origin "$BRANCH_NAME" || {
            echo "‚ùå Failed to push branch"
            exit 1
          }

          echo "‚úÖ Changes committed and pushed successfully"

      - name: Setup GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ GitHub CLI ready"

      - name: Ensure Labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LABELS=("ai-generated:AI-generated fix:0A8B9C" "automated:Automated by workflow:0366D6")
          for LABEL_SPEC in "${LABELS[@]}"; do
            IFS=':' read -r NAME DESCRIPTION COLOR <<< "$LABEL_SPEC"
            if ! gh label list --json name --jq ".[] | select(.name == \"$NAME\") | .name" | grep -q "^$NAME$"; then
              gh label create "$NAME" --description "$DESCRIPTION" --color "$COLOR" --force || true
            fi
          done

      - name: Wait for branch
        if: steps.run-agent.outputs.fix_successful == 'true'
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"
          MAX_RETRIES=15
          RETRY_COUNT=0

          echo "Waiting for branch to be available: $BRANCH_NAME"

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              echo "‚úÖ Branch is available on remote"

              # Pr√ºfe ob Branch Commits hat
              git fetch origin "$BRANCH_NAME" || true
              COMMITS=$(git log origin/main..origin/"$BRANCH_NAME" --oneline 2>/dev/null | wc -l || echo "0")

              if [ "$COMMITS" -gt 0 ]; then
                echo "‚úÖ Branch has $COMMITS commit(s)"
                break
              else
                echo "‚ö†Ô∏è Branch exists but has no commits yet, waiting..."
              fi
            else
              echo "‚è≥ Branch not yet available... ($RETRY_COUNT/$MAX_RETRIES)"
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 3
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå Branch not available after $MAX_RETRIES retries"
            echo "Branch name: $BRANCH_NAME"
            echo "Available branches:"
            git ls-remote --heads origin | grep -E "fix/issue" || echo "No fix/issue branches found"
            exit 1
          fi

      - name: Extract Agent Summary
        id: extract-summary
        if: steps.run-agent.outputs.fix_successful == 'true' || always()
        run: |
          # Pr√ºfe ob Agent-Zusammenfassung existiert (in /tmp/, Workspace-Root, oder im Agent-Output)
          AGENT_SUMMARY_FOUND=false

          # Methode 1: Pr√ºfe ob agent-summary.md Datei existiert
          if [ -f /tmp/agent-summary.md ]; then
            echo "‚úÖ Agent summary found in /tmp/agent-summary.md"
            AGENT_SUMMARY_FOUND=true
          elif [ -f agent-summary.md ]; then
            echo "‚úÖ Agent summary found in workspace root, copying to /tmp/"
            cp agent-summary.md /tmp/agent-summary.md
            AGENT_SUMMARY_FOUND=true
          elif [ -f ./agent-summary.md ]; then
            echo "‚úÖ Agent summary found in current directory, copying to /tmp/"
            cp ./agent-summary.md /tmp/agent-summary.md
            AGENT_SUMMARY_FOUND=true
          fi

          # Methode 2: Extrahiere Zusammenfassung aus Agent-Output (fix-output.txt)
          if [ "$AGENT_SUMMARY_FOUND" != "true" ] && [ -f /tmp/fix-output.txt ]; then
            echo "=== Trying to extract summary from agent output ==="

            # Suche nach verschiedenen Mustern f√ºr Zusammenfassung
            SUMMARY_START_LINE=""

            # Versuche verschiedene Startmuster zu finden
            if grep -q "^## Zusammenfassung" /tmp/fix-output.txt; then
              SUMMARY_START_LINE=$(grep -n "^## Zusammenfassung" /tmp/fix-output.txt | head -1 | cut -d: -f1)
              echo "‚úÖ Found '## Zusammenfassung' at line $SUMMARY_START_LINE"
            elif grep -q "^Zusammenfassung:" /tmp/fix-output.txt; then
              SUMMARY_START_LINE=$(grep -n "^Zusammenfassung:" /tmp/fix-output.txt | head -1 | cut -d: -f1)
              echo "‚úÖ Found 'Zusammenfassung:' at line $SUMMARY_START_LINE"
            elif grep -q "Zusammenfassung:" /tmp/fix-output.txt; then
              SUMMARY_START_LINE=$(grep -n "Zusammenfassung:" /tmp/fix-output.txt | head -1 | cut -d: -f1)
              echo "‚úÖ Found 'Zusammenfassung:' (anywhere) at line $SUMMARY_START_LINE"
            elif grep -q "Durchgef√ºhrte √Ñnderungen" /tmp/fix-output.txt; then
              SUMMARY_START_LINE=$(grep -n "Durchgef√ºhrte √Ñnderungen" /tmp/fix-output.txt | head -1 | cut -d: -f1)
              echo "‚úÖ Found 'Durchgef√ºhrte √Ñnderungen' at line $SUMMARY_START_LINE"
            fi

            if [ -n "$SUMMARY_START_LINE" ]; then
              echo "‚úÖ Extracting summary starting from line $SUMMARY_START_LINE..."

              # Extrahiere alles ab dieser Zeile
              tail -n +$SUMMARY_START_LINE /tmp/fix-output.txt > /tmp/agent-summary-raw.txt

              # Finde Stopp-Zeilen (irrelevante Teile nach der Zusammenfassung)
              STOP_LINE=""

              # Suche nach Stopp-Mustern (aber nicht innerhalb der Zusammenfassung)
              if grep -n "^=== Searching for key terms" /tmp/agent-summary-raw.txt | head -1 | cut -d: -f1 > /tmp/stop-line.txt 2>/dev/null; then
                STOP_LINE=$(cat /tmp/stop-line.txt)
              elif grep -n "^Soll ich trotzdem" /tmp/agent-summary-raw.txt | head -1 | cut -d: -f1 > /tmp/stop-line.txt 2>/dev/null; then
                STOP_LINE=$(cat /tmp/stop-line.txt)
              elif grep -n "^=== " /tmp/agent-summary-raw.txt | grep -v "^## " | head -1 | cut -d: -f1 > /tmp/stop-line.txt 2>/dev/null; then
                STOP_LINE=$(cat /tmp/stop-line.txt)
              fi

              if [ -n "$STOP_LINE" ] && [ "$STOP_LINE" -gt 5 ]; then
                # Extrahiere nur bis zur Stopp-Zeile
                head -n $((STOP_LINE - 1)) /tmp/agent-summary-raw.txt > /tmp/agent-summary.md
                echo "‚úÖ Stopped extraction at line $STOP_LINE"
              else
                # Verwende alles, aber entferne leere Zeilen am Ende
                cp /tmp/agent-summary-raw.txt /tmp/agent-summary.md
              fi

              # Bereinige die Datei: Entferne leere Zeilen am Ende
              sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' /tmp/agent-summary.md 2>/dev/null || \
              sed -i '/^$/d' /tmp/agent-summary.md 2>/dev/null || true

              # Entferne f√ºhrende leere Zeilen
              sed -i '/./,$!d' /tmp/agent-summary.md 2>/dev/null || true

              # Pr√ºfe ob Datei nicht leer ist und mindestens 3 Zeilen hat
              if [ -s /tmp/agent-summary.md ] && [ $(wc -l < /tmp/agent-summary.md) -ge 3 ]; then
                echo "‚úÖ Extracted summary from agent output ($(wc -l < /tmp/agent-summary.md) lines)"
                AGENT_SUMMARY_FOUND=true
              else
                echo "‚ö†Ô∏è Extracted summary is too short or empty"
                echo "=== First 20 lines of raw output ==="
                head -20 /tmp/agent-summary-raw.txt || true
                rm -f /tmp/agent-summary.md
              fi
            else
              echo "‚ö†Ô∏è No summary pattern found in agent output"
              echo "=== First 30 lines of agent output ==="
              head -30 /tmp/fix-output.txt || true
            fi
          fi

          # Methode 3: Falls keine strukturierte Zusammenfassung gefunden wurde, verwende die gesamte Agent-Ausgabe
          if [ "$AGENT_SUMMARY_FOUND" != "true" ] && [ -f /tmp/fix-output.txt ]; then
            echo "=== Using entire agent output as summary ==="

            # Verwende die gesamte Ausgabe, aber entferne sehr lange Zeilen (wahrscheinlich Debug-Output)
            # Entferne Zeilen die l√§nger als 200 Zeichen sind (wahrscheinlich nicht Teil der Zusammenfassung)
            awk 'length($0) <= 200 || /^## |^# |^\*\*|^```|^Zusammenfassung|^Problem|^L√∂sung|^Status|^Hinweis/' /tmp/fix-output.txt > /tmp/agent-summary-filtered.txt 2>/dev/null || \
            cp /tmp/fix-output.txt /tmp/agent-summary-filtered.txt

            # Begrenze auf die letzten 100 Zeilen (meistens ist die Zusammenfassung am Ende)
            tail -100 /tmp/agent-summary-filtered.txt > /tmp/agent-summary.md

            # Entferne leere Zeilen am Ende
            sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' /tmp/agent-summary.md 2>/dev/null || \
            sed -i '/^$/d' /tmp/agent-summary.md 2>/dev/null || true

            if [ -s /tmp/agent-summary.md ] && [ $(wc -l < /tmp/agent-summary.md) -ge 3 ]; then
              echo "‚úÖ Using agent output as summary ($(wc -l < /tmp/agent-summary.md) lines)"
              AGENT_SUMMARY_FOUND=true
            fi
          fi

          if [ "$AGENT_SUMMARY_FOUND" = "true" ]; then
            echo "has_summary=true" >> $GITHUB_OUTPUT
            # Zeige ersten Teil f√ºr Debugging
            echo "=== Agent Summary Preview ==="
            head -50 /tmp/agent-summary.md || true
          else
            echo "‚ö†Ô∏è No agent summary found (checked files and agent output), will use default PR body"
            echo "has_summary=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Issue Comment (No Changes)
        id: create-comment
        if: steps.run-agent.outcome != 'skipped' && (steps.run-agent.outputs.fix_successful != 'true' || steps.run-agent.outcome == 'failure')
        env:
          ISSUE_NUM: ${{ matrix.issue.number }}
          ISSUE_TITLE: ${{ matrix.issue.title }}
          AGENT_SUMMARY_FILE: /tmp/agent-summary.md
          AGENT_OUTPUT_FILE: /tmp/fix-output.txt
          OUTPUT_FILE: /tmp/issue-comment.txt
        run: |
          python3 scripts/create-issue-comment.py

      - name: Handle No Changes Case
        id: handle-no-changes
        if: steps.run-agent.outcome != 'skipped' && (steps.run-agent.outputs.fix_successful != 'true' || steps.run-agent.outcome == 'failure')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"
          ISSUE_NUM="${{ matrix.issue.number }}"

          echo "‚ÑπÔ∏è No code changes detected. Posting agent analysis as comment and closing issue..."

          # Poste Kommentar zum Issue
          echo "Posting comment to issue #$ISSUE_NUM..."
          gh issue comment "$ISSUE_NUM" --body-file /tmp/issue-comment.txt || {
            echo "‚ö†Ô∏è Failed to post comment, trying with shorter message..."
            gh issue comment "$ISSUE_NUM" --body "ü§ñ AI-Analyse: Keine Code-√Ñnderungen erforderlich. Das beschriebene Problem ist bereits behoben oder erfordert keine Code-√Ñnderungen." || true
          }

          # Schlie√üe das Issue
          echo "Closing issue #$ISSUE_NUM..."
          gh issue close "$ISSUE_NUM" --comment "Automatisch geschlossen: Keine Code-√Ñnderungen erforderlich" || {
            echo "‚ö†Ô∏è Failed to close issue with comment, trying without..."
            gh issue close "$ISSUE_NUM" || true
          }

          # L√∂sche den Branch, falls er existiert
          echo "Checking if branch $BRANCH_NAME exists..."
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Deleting branch $BRANCH_NAME..."
            gh api repos/${{ github.repository }}/git/refs/heads/"$BRANCH_NAME" -X DELETE || {
              echo "‚ö†Ô∏è Failed to delete branch via API, trying git push..."
              git push origin --delete "$BRANCH_NAME" || true
            }
            echo "‚úÖ Branch $BRANCH_NAME deleted"
          else
            echo "‚ÑπÔ∏è Branch $BRANCH_NAME does not exist on remote, nothing to delete"
          fi

          echo "‚úÖ No changes case handled successfully"

      - name: Create PR Body
        if: steps.run-agent.outputs.fix_successful == 'true'
        env:
          ISSUE_NUM: ${{ matrix.issue.number }}
          ISSUE_TITLE: ${{ matrix.issue.title }}
          ISSUE_URL: ${{ matrix.issue.url }}
          BRANCH_NAME: ${{ steps.setup-branch.outputs.branch_name }}
          BASE_BRANCH: main
          OUTPUT_FILE: /tmp/pr-body.txt
          AGENT_SUMMARY_FILE: /tmp/agent-summary.md
        run: |
          python3 scripts/create-pr-body.py

      - name: Create Pull Request
        id: create-pr-step
        if: steps.run-agent.outputs.fix_successful == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"
          ISSUE_NUM="${{ matrix.issue.number }}"
          ISSUE_TITLE="${{ matrix.issue.title }}"
          PR_TITLE="fix: Resolve issue #$ISSUE_NUM - $ISSUE_TITLE"

          # Pr√ºfe nur nach OFFENEN PRs - geschlossene PRs werden ignoriert
          EXISTING_PR=$(gh pr list --base main --head "$BRANCH_NAME" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ]; then
            PR_URL="https://github.com/${{ github.repository }}/pull/$EXISTING_PR"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
          else
            LABELS=""
            if gh label list --json name --jq '.[].name' | grep -q "^ai-generated$"; then
              LABELS="ai-generated"
            fi
            if gh label list --json name --jq '.[].name' | grep -q "^automated$"; then
              LABELS="$LABELS,automated"
            fi

            PR_CMD="gh pr create --base main --head \"$BRANCH_NAME\" --title \"$PR_TITLE\" --body-file /tmp/pr-body.txt --draft"
            [ -n "$LABELS" ] && PR_CMD="$PR_CMD --label $(echo $LABELS | sed 's/^,//')"

            PR_URL=$(eval "$PR_CMD" || echo "")

            if [ -n "$PR_URL" ]; then
              echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
              PR_NUMBER=$(echo "$PR_URL" | grep -oP 'pull/\K[0-9]+' || echo "")
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            else
              exit 1
            fi
          fi

      - name: Comment on Issue
        if: steps.create-pr-step.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ matrix.issue.number }}"
          PR_NUM="${{ steps.create-pr-step.outputs.pr_number }}"
          PR_URL="${{ steps.create-pr-step.outputs.pr_url }}"

          COMMENT_BODY="ü§ñ AI has created a fix for this issue: $PR_URL

          **Pull Request:** #$PR_NUM
          **Status:** Ready for review

          This PR was automatically created by the AI Issue Fix workflow."

          gh issue comment "$ISSUE_NUM" --body "$COMMENT_BODY" || true

  summary:
    name: Summary
    needs: [select-issue, fix-create-link]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Workflow Summary
        run: |
          echo "=== Complete AI Issue Fix Workflow Summary ==="
          echo ""
          echo "1. Select Issue: ${{ needs.select-issue.result }}"
          echo "   Issues found: ${{ needs.select-issue.outputs.count }}"
          echo ""
          echo "2-4. Fix-Create-Link (Matrix): ${{ needs.fix-create-link.result }}"
          echo ""
          if [ "${{ needs.fix-create-link.result }}" == "success" ]; then
            echo "‚úÖ All issues processed successfully!"
          else
            echo "‚ö†Ô∏è Some issues may have failed or been skipped"
          fi
