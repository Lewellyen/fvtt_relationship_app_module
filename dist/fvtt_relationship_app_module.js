var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var __publicField = (obj, key2, value2) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _a, _disposed, _disposed2, _disposed3, _disposed4, _disposed5, _disposed6, _b, _commit_callbacks, _discard_callbacks, _pending, _blocking_pending, _deferred, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, clear_marked_fn, resolve_fn, commit_fn, _pending2, _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _pending_anchor, _local_pending_count, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_subscriber, _Boundary_instances, hydrate_resolved_content_fn, hydrate_pending_content_fn, get_anchor_fn, run_fn, show_pending_snippet_fn, update_pending_count_fn, _batches, _onscreen, _offscreen, _outroing, _transition, _commit, _discard, _listeners, _observer, _options, _ResizeObserverSingleton_instances, getObserver_fn, _events, _instance, _c;
const MODULE_METADATA = {
  ID: "fvtt_relationship_app_module",
  NAME: "Beziehungsnetzwerke für Foundry",
  AUTHOR: "Andreas Rothe",
  AUTHOR_EMAIL: "forenadmin.tir@gmail.com",
  AUTHOR_DISCORD: "lewellyen"
};
const SETTING_KEYS = {
  LOG_LEVEL: "logLevel",
  CACHE_ENABLED: "cacheEnabled",
  CACHE_TTL_MS: "cacheTtlMs",
  CACHE_MAX_ENTRIES: "cacheMaxEntries",
  PERFORMANCE_TRACKING_ENABLED: "performanceTrackingEnabled",
  PERFORMANCE_SAMPLING_RATE: "performanceSamplingRate",
  METRICS_PERSISTENCE_ENABLED: "metricsPersistenceEnabled",
  METRICS_PERSISTENCE_KEY: "metricsPersistenceKey",
  NOTIFICATION_QUEUE_MAX_SIZE: "notificationQueueMaxSize"
};
const APP_DEFAULTS = {
  UNKNOWN_NAME: "Unknown",
  NO_VERSION_SELECTED: -1,
  CACHE_NOT_INITIALIZED: -1,
  CACHE_TTL_MS: 5e3
};
const PUBLIC_API_VERSION = "1.0.0";
const LOG_PREFIX = "Relationship App |";
Object.freeze(MODULE_METADATA);
Object.freeze(SETTING_KEYS);
Object.freeze(APP_DEFAULTS);
function ok(value2) {
  return { ok: true, value: value2 };
}
__name(ok, "ok");
function err(error) {
  return { ok: false, error };
}
__name(err, "err");
function isOk(result) {
  return result.ok;
}
__name(isOk, "isOk");
function isErr(result) {
  return !result.ok;
}
__name(isErr, "isErr");
function map$1(result, transform2) {
  return result.ok ? ok(transform2(result.value)) : result;
}
__name(map$1, "map$1");
function mapError(result, transform2) {
  return result.ok ? result : err(transform2(result.error));
}
__name(mapError, "mapError");
function andThen(result, next2) {
  return result.ok ? next2(result.value) : result;
}
__name(andThen, "andThen");
function unwrapOr(result, fallbackValue) {
  return result.ok ? result.value : fallbackValue;
}
__name(unwrapOr, "unwrapOr");
function unwrapOrElse(result, getFallback2) {
  return result.ok ? result.value : getFallback2(result.error);
}
__name(unwrapOrElse, "unwrapOrElse");
function getOrThrow(result, toError) {
  if (result.ok) return result.value;
  const e = toError ? toError(result.error) : new Error(String(result.error));
  throw e;
}
__name(getOrThrow, "getOrThrow");
function all(results) {
  const out = [];
  for (const r2 of results) {
    if (!r2.ok) return r2;
    out.push(r2.value);
  }
  return ok(out);
}
__name(all, "all");
function match(result, handlers2) {
  return result.ok ? handlers2.onOk(result.value) : handlers2.onErr(result.error);
}
__name(match, "match");
function tryCatch(fn, mapUnknownError) {
  try {
    return ok(fn());
  } catch (unknownError) {
    return err(mapUnknownError(unknownError));
  }
}
__name(tryCatch, "tryCatch");
function lift(fn, mapUnknownError) {
  return (param) => tryCatch(() => fn(param), mapUnknownError);
}
__name(lift, "lift");
async function asyncMap(asyncResult, transform2) {
  const result = await asyncResult;
  return result.ok ? ok(await transform2(result.value)) : result;
}
__name(asyncMap, "asyncMap");
async function asyncAndThen(asyncResult, next2) {
  const result = await asyncResult;
  return result.ok ? next2(result.value) : result;
}
__name(asyncAndThen, "asyncAndThen");
async function fromPromise(promise2, mapUnknownError) {
  try {
    return ok(await promise2);
  } catch (unknownError) {
    return err(mapUnknownError(unknownError));
  }
}
__name(fromPromise, "fromPromise");
async function asyncAll(asyncResults) {
  const results = await Promise.all(asyncResults);
  return all(results);
}
__name(asyncAll, "asyncAll");
function createInjectionToken(description2) {
  return Symbol(description2);
}
__name(createInjectionToken, "createInjectionToken");
const loggerToken = createInjectionToken("Logger");
const bootstrapInitHookServiceToken = createInjectionToken(
  "BootstrapInitHookService"
);
const bootstrapReadyHookServiceToken = createInjectionToken(
  "BootstrapReadyHookService"
);
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
const __vite_import_meta_env__ = { "BASE_URL": "/", "DEV": false, "MODE": "development", "PROD": true, "SSR": false, "VITE_ENABLE_PERF_TRACKING": "true" };
function parseSamplingRate(envValue, fallback2) {
  const raw = parseFloat(envValue ?? String(fallback2));
  return Number.isFinite(raw) ? Math.min(1, Math.max(0, raw)) : fallback2;
}
__name(parseSamplingRate, "parseSamplingRate");
function parseNonNegativeNumber(envValue, fallback2) {
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed)) {
    return fallback2;
  }
  return parsed < 0 ? fallback2 : parsed;
}
__name(parseNonNegativeNumber, "parseNonNegativeNumber");
function parseOptionalPositiveInteger(envValue) {
  if (!envValue) {
    return void 0;
  }
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return void 0;
  }
  return Math.floor(parsed);
}
__name(parseOptionalPositiveInteger, "parseOptionalPositiveInteger");
function parsePositiveInteger(envValue, fallback2) {
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback2;
  }
  return Math.floor(parsed);
}
__name(parsePositiveInteger, "parsePositiveInteger");
function getEnvVar(key2, parser2) {
  const value2 = __vite_import_meta_env__[key2];
  return parser2(value2);
}
__name(getEnvVar, "getEnvVar");
const parsedCacheMaxEntries = getEnvVar("VITE_CACHE_MAX_ENTRIES", parseOptionalPositiveInteger);
const ENV = {
  isDevelopment: true,
  isProduction: false,
  logLevel: true ? LogLevel.DEBUG : LogLevel.INFO,
  enablePerformanceTracking: true,
  enableMetricsPersistence: getEnvVar("VITE_ENABLE_METRICS_PERSISTENCE", (val) => val === "true"),
  metricsPersistenceKey: getEnvVar(
    "VITE_METRICS_PERSISTENCE_KEY",
    (val) => val ?? "fvtt_relationship_app_module.metrics"
  ),
  // 1% sampling in production, 100% in development
  performanceSamplingRate: false ? parseSamplingRate(void 0, 0.01) : 1,
  enableCacheService: getEnvVar(
    "VITE_CACHE_ENABLED",
    (val) => val === void 0 ? true : val === "true"
  ),
  cacheDefaultTtlMs: getEnvVar(
    "VITE_CACHE_TTL_MS",
    (val) => parseNonNegativeNumber(val, APP_DEFAULTS.CACHE_TTL_MS)
  ),
  ...parsedCacheMaxEntries !== void 0 ? { cacheMaxEntries: parsedCacheMaxEntries } : {},
  notificationQueueMinSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_MIN_SIZE",
    (val) => parsePositiveInteger(val, 10)
  ),
  notificationQueueMaxSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_MAX_SIZE",
    (val) => parsePositiveInteger(val, 1e3)
  ),
  notificationQueueDefaultSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_DEFAULT_SIZE",
    (val) => parsePositiveInteger(val, 50)
  )
};
const _PerformanceTrackerImpl = class _PerformanceTrackerImpl {
  /**
   * Creates a performance tracker implementation.
   *
   * @param env - Environment configuration for tracking settings
   * @param sampler - Optional metrics sampler for sampling decisions (null during early bootstrap)
   */
  constructor(config2, sampler) {
    this.config = config2;
    this.sampler = sampler;
  }
  /**
   * Tracks synchronous operation execution time.
   *
   * Only measures when:
   * 1. Performance tracking is enabled (env.enablePerformanceTracking)
   * 2. MetricsCollector is available
   * 3. Sampling check passes (metricsCollector.shouldSample())
   *
   * @template T - Return type of the operation
   * @param operation - Function to execute and measure
   * @param onComplete - Optional callback invoked with duration and result
   * @returns Result of the operation
   */
  track(operation, onComplete) {
    if (!this.config.get("enablePerformanceTracking") || !this.sampler?.shouldSample()) {
      return operation();
    }
    const startTime = performance.now();
    const result = operation();
    const duration = performance.now() - startTime;
    if (onComplete) {
      onComplete(duration, result);
    }
    return result;
  }
  /**
   * Tracks asynchronous operation execution time.
   *
   * Only measures when:
   * 1. Performance tracking is enabled (env.enablePerformanceTracking)
   * 2. MetricsCollector is available
   * 3. Sampling check passes (metricsCollector.shouldSample())
   *
   * @template T - Return type of the async operation
   * @param operation - Async function to execute and measure
   * @param onComplete - Optional callback invoked with duration and result
   * @returns Promise resolving to the operation result
   */
  async trackAsync(operation, onComplete) {
    if (!this.config.get("enablePerformanceTracking") || !this.sampler?.shouldSample()) {
      return operation();
    }
    const startTime = performance.now();
    const result = await operation();
    const duration = performance.now() - startTime;
    if (onComplete) {
      onComplete(duration, result);
    }
    return result;
  }
};
__name(_PerformanceTrackerImpl, "PerformanceTrackerImpl");
let PerformanceTrackerImpl = _PerformanceTrackerImpl;
const _BootstrapPerformanceTracker = class _BootstrapPerformanceTracker extends PerformanceTrackerImpl {
  /**
   * Creates a bootstrap performance tracker.
   *
   * @param config - Runtime configuration port
   * @param sampler - Optional metrics sampler for sampling decisions (null during early bootstrap)
   */
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_BootstrapPerformanceTracker, "BootstrapPerformanceTracker");
let BootstrapPerformanceTracker = _BootstrapPerformanceTracker;
const _BootstrapErrorHandler = class _BootstrapErrorHandler {
  /**
   * Logs an error with structured context in the browser console.
   *
   * Creates a collapsible group with timestamp, phase, component,
   * error details, and metadata for easy debugging and screenshotting.
   *
   * @param error - The error that occurred (Error object, string, or unknown)
   * @param context - Context information about the error
   */
  static logError(error, context) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    console.group(`[${timestamp}] ${LOG_PREFIX} Error in ${context.phase}`);
    if (context.component) {
      console.error("Component:", context.component);
    }
    console.error("Error:", error);
    if (context.metadata && Object.keys(context.metadata).length > 0) {
      console.error("Metadata:", context.metadata);
    }
    console.groupEnd();
  }
};
__name(_BootstrapErrorHandler, "BootstrapErrorHandler");
let BootstrapErrorHandler = _BootstrapErrorHandler;
const _RuntimeConfigService = class _RuntimeConfigService {
  constructor(store2, emitter) {
    this.store = store2;
    this.emitter = emitter;
  }
  /**
   * Returns the current value for the given configuration key.
   */
  get(key2) {
    return this.store.get(key2);
  }
  /**
   * Updates the configuration value based on platform settings and notifies listeners
   * only if the value actually changed.
   *
   * Implements PlatformRuntimeConfigPort interface.
   */
  setFromPlatform(key2, value2) {
    const changed = this.store.set(key2, value2);
    if (changed) {
      this.emitter.notify(key2, value2);
    }
  }
  /**
   * Registers a listener for the given key. Returns an unsubscribe function.
   */
  onChange(key2, listener) {
    return this.emitter.onChange(key2, listener);
  }
};
__name(_RuntimeConfigService, "RuntimeConfigService");
let RuntimeConfigService = _RuntimeConfigService;
const _RuntimeConfigStore = class _RuntimeConfigStore {
  constructor(env) {
    this.values = {
      isDevelopment: env.isDevelopment,
      isProduction: env.isProduction,
      logLevel: env.logLevel,
      enablePerformanceTracking: env.enablePerformanceTracking,
      performanceSamplingRate: env.performanceSamplingRate,
      enableMetricsPersistence: env.enableMetricsPersistence,
      metricsPersistenceKey: env.metricsPersistenceKey,
      enableCacheService: env.enableCacheService,
      cacheDefaultTtlMs: env.cacheDefaultTtlMs,
      cacheMaxEntries: env.cacheMaxEntries,
      notificationQueueMaxSize: env.notificationQueueDefaultSize
    };
  }
  /**
   * Returns the current value for the given configuration key.
   */
  get(key2) {
    return this.values[key2];
  }
  /**
   * Updates the configuration value.
   * Returns true if the value actually changed, false otherwise.
   */
  set(key2, value2) {
    const current = this.values[key2];
    if (Object.is(current, value2)) {
      return false;
    }
    this.values[key2] = value2;
    return true;
  }
  /**
   * Gets all current values (for testing/debugging purposes).
   */
  getAll() {
    return { ...this.values };
  }
};
__name(_RuntimeConfigStore, "RuntimeConfigStore");
let RuntimeConfigStore = _RuntimeConfigStore;
const _RuntimeConfigEventEmitter = class _RuntimeConfigEventEmitter {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a listener for the given key. Returns an unsubscribe function.
   */
  onChange(key2, listener) {
    const existing = this.getListenersForKey(key2);
    const listeners = existing ?? /* @__PURE__ */ new Set();
    listeners.add(listener);
    this.setListenersForKey(key2, listeners);
    return () => {
      const activeListeners = this.getListenersForKey(key2);
      activeListeners?.delete(listener);
      if (!activeListeners || activeListeners.size === 0) {
        this.listeners.delete(key2);
      }
    };
  }
  /**
   * Notifies all listeners for the given key with the new value.
   */
  notify(key2, value2) {
    const listeners = this.listeners.get(key2);
    if (!listeners || listeners.size === 0) {
      return;
    }
    for (const listener of listeners) {
      listener(value2);
    }
  }
  /**
   * Type-safe helper to get listeners for a specific key.
   * @ts-expect-error - Type coverage exclusion for generic Set cast
   */
  getListenersForKey(key2) {
    return this.listeners.get(key2);
  }
  /**
   * Type-safe helper to set listeners for a specific key.
   * @ts-expect-error - Type coverage exclusion for generic Set cast
   */
  setListenersForKey(key2, listeners) {
    this.listeners.set(key2, listeners);
  }
};
__name(_RuntimeConfigEventEmitter, "RuntimeConfigEventEmitter");
let RuntimeConfigEventEmitter = _RuntimeConfigEventEmitter;
function createRuntimeConfig(env, store2, emitter) {
  return new RuntimeConfigService(
    store2 ?? new RuntimeConfigStore(env),
    emitter ?? new RuntimeConfigEventEmitter()
  );
}
__name(createRuntimeConfig, "createRuntimeConfig");
const _RuntimeConfigAdapter = class _RuntimeConfigAdapter {
  constructor(env) {
    this.service = createRuntimeConfig(env);
  }
  get(key2) {
    return this.service.get(key2);
  }
  setFromPlatform(key2, value2) {
    this.service.setFromPlatform(key2, value2);
  }
  onChange(key2, listener) {
    return this.service.onChange(key2, listener);
  }
};
__name(_RuntimeConfigAdapter, "RuntimeConfigAdapter");
let RuntimeConfigAdapter = _RuntimeConfigAdapter;
function createRuntimeConfigAdapter(env) {
  return new RuntimeConfigAdapter(env);
}
__name(createRuntimeConfigAdapter, "createRuntimeConfigAdapter");
function castCachedServiceInstance(instance2) {
  return instance2;
}
__name(castCachedServiceInstance, "castCachedServiceInstance");
function castCachedServiceInstanceForResult(instance2) {
  if (instance2 === void 0) {
    return err({
      code: "TokenNotRegistered",
      message: "castCachedServiceInstanceForResult: instance must not be undefined. Use castCachedServiceInstance() for optional instances.",
      details: {}
    });
  }
  return ok(instance2);
}
__name(castCachedServiceInstanceForResult, "castCachedServiceInstanceForResult");
function castServiceRegistrationEntry(token, registration) {
  return [token, registration];
}
__name(castServiceRegistrationEntry, "castServiceRegistrationEntry");
function* iterateServiceRegistrationEntries(entries2) {
  for (const [token, registration] of entries2) {
    yield castServiceRegistrationEntry(token, registration);
  }
}
__name(iterateServiceRegistrationEntries, "iterateServiceRegistrationEntries");
function getRegistrationStatus(result) {
  return result.ok ? result.value : false;
}
__name(getRegistrationStatus, "getRegistrationStatus");
function castToFoundryHookCallback(callback) {
  return callback;
}
__name(castToFoundryHookCallback, "castToFoundryHookCallback");
function castResolvedService(value2) {
  return value2;
}
__name(castResolvedService, "castResolvedService");
function castContainerErrorCode(code) {
  return code;
}
__name(castContainerErrorCode, "castContainerErrorCode");
function castContainerTokenToPlatformContainerPortToken(token) {
  return token;
}
__name(castContainerTokenToPlatformContainerPortToken, "castContainerTokenToPlatformContainerPortToken");
const apiSafeTokens = /* @__PURE__ */ new Set();
function markAsApiSafe(token) {
  apiSafeTokens.add(token);
  return token;
}
__name(markAsApiSafe, "markAsApiSafe");
function isApiSafeTokenRuntime(token) {
  return apiSafeTokens.has(token);
}
__name(isApiSafeTokenRuntime, "isApiSafeTokenRuntime");
var ServiceLifecycle = /* @__PURE__ */ ((ServiceLifecycle2) => {
  ServiceLifecycle2["SINGLETON"] = "singleton";
  ServiceLifecycle2["TRANSIENT"] = "transient";
  ServiceLifecycle2["SCOPED"] = "scoped";
  return ServiceLifecycle2;
})(ServiceLifecycle || {});
const _ServiceRegistration = class _ServiceRegistration {
  /**
   * Private constructor - use static factory methods instead.
   * This prevents direct construction with invalid parameters
   * and ensures Result-based error handling.
   */
  constructor(lifecycle, dependencies, providerType, serviceClass, factory, value2, aliasTarget) {
    this.lifecycle = lifecycle;
    this.dependencies = dependencies;
    this.providerType = providerType;
    this.serviceClass = serviceClass;
    this.factory = factory;
    this.value = value2;
    this.aliasTarget = aliasTarget;
  }
  /**
   * Creates a class-based registration.
   * @template Tunknown - The concrete service type
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of dependency tokens
   * @param serviceClass - The class to instantiate
   * @returns Result with registration or validation error
   */
  static createClass(lifecycle, dependencies, serviceClass) {
    return ok(
      new _ServiceRegistration(
        lifecycle,
        dependencies,
        "class",
        serviceClass,
        void 0,
        void 0,
        void 0
      )
    );
  }
  /**
   * Creates a factory-based registration.
   * @template Tunknown - The concrete service type
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of dependency tokens
   * @param factory - Factory function that creates instances
   * @returns Result with registration or validation error
   */
  static createFactory(lifecycle, dependencies, factory) {
    if (!factory) {
      return err({
        code: "InvalidOperation",
        message: "factory is required for factory registration"
      });
    }
    return ok(
      new _ServiceRegistration(
        lifecycle,
        dependencies,
        "factory",
        void 0,
        factory,
        void 0,
        void 0
      )
    );
  }
  /**
   * Creates a value-based registration (always SINGLETON).
   * @template Tunknown - The concrete service type
   * @param value - The value to register
   * @returns Result with registration or validation error
   */
  static createValue(value2) {
    if (value2 === void 0) {
      return err({
        code: "InvalidOperation",
        message: "value cannot be undefined for value registration"
      });
    }
    if (typeof value2 === "function") {
      return err({
        code: "InvalidOperation",
        message: "registerValue() only accepts plain values, not functions or classes. Use registerClass() or registerFactory() instead."
      });
    }
    return ok(
      new _ServiceRegistration(ServiceLifecycle.SINGLETON, [], "value", void 0, void 0, value2, void 0)
    );
  }
  /**
   * Creates an alias registration (always SINGLETON).
   * @template Tunknown - The concrete service type
   * @param targetToken - The token to resolve instead
   * @returns Result with registration or validation error
   */
  static createAlias(targetToken) {
    if (!targetToken) {
      return err({
        code: "InvalidOperation",
        message: "targetToken is required for alias registration"
      });
    }
    return ok(
      new _ServiceRegistration(
        ServiceLifecycle.SINGLETON,
        [targetToken],
        "alias",
        void 0,
        void 0,
        void 0,
        targetToken
      )
    );
  }
  /**
   * Creates a clone of this registration.
   * Used when child containers inherit registrations from parent.
   *
   * @returns A new ServiceRegistration instance with cloned dependencies array
   */
  clone() {
    return new _ServiceRegistration(
      this.lifecycle,
      [...this.dependencies],
      // Clone array to prevent shared mutations
      this.providerType,
      this.serviceClass,
      this.factory,
      this.value,
      this.aliasTarget
    );
  }
};
__name(_ServiceRegistration, "ServiceRegistration");
let ServiceRegistration = _ServiceRegistration;
const _TypeSafeRegistrationMap = class _TypeSafeRegistrationMap {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Stores a service registration.
   *
   * @template T - The concrete service type
   * @param token - The injection token identifying the service
   * @param registration - The service registration metadata
   */
  set(token, registration) {
    this.map.set(token, registration);
  }
  /**
   * Retrieves a service registration.
   *
   * Type-safe by design: The token's generic parameter guarantees that the
   * returned registration matches the expected service type.
   *
   * @template T - The concrete service type
   * @param token - The injection token identifying the service
   * @returns The service registration or undefined if not found
   */
  get(token) {
    return this.map.get(token);
  }
  /**
   * Checks if a service is registered.
   *
   * @param token - The injection token to check
   * @returns True if the service is registered
   */
  has(token) {
    return this.map.has(token);
  }
  /**
   * Removes a service registration.
   *
   * @param token - The injection token identifying the service
   * @returns True if the service was found and removed
   */
  delete(token) {
    return this.map.delete(token);
  }
  /**
   * Gets the number of registered services.
   *
   * @returns The count of registrations
   */
  get size() {
    return this.map.size;
  }
  /**
   * Removes all service registrations.
   */
  clear() {
    this.map.clear();
  }
  /**
   * Returns an iterator of all registration entries.
   *
   * @returns Iterator of [token, registration] pairs
   */
  entries() {
    return this.map.entries();
  }
  /**
   * Creates a shallow clone of this map.
   * Used when child containers inherit registrations from parent.
   *
   * @returns A new TypeSafeRegistrationMap with cloned entries
   */
  clone() {
    const cloned = new _TypeSafeRegistrationMap();
    this.map.forEach((value2, key2) => {
      cloned.map.set(key2, value2);
    });
    return cloned;
  }
};
__name(_TypeSafeRegistrationMap, "TypeSafeRegistrationMap");
let TypeSafeRegistrationMap = _TypeSafeRegistrationMap;
function hasDependencies(cls) {
  return "dependencies" in cls;
}
__name(hasDependencies, "hasDependencies");
const _ServiceRegistry = class _ServiceRegistry {
  constructor() {
    this.MAX_REGISTRATIONS = 1e4;
    this.registrations = new TypeSafeRegistrationMap();
    this.lifecycleIndex = /* @__PURE__ */ new Map();
  }
  /**
   * Updates the lifecycle index when a service is registered.
   *
   * @param token - The injection token
   * @param lifecycle - The service lifecycle
   */
  updateLifecycleIndex(token, lifecycle) {
    let tokenSet = this.lifecycleIndex.get(lifecycle);
    if (!tokenSet) {
      tokenSet = /* @__PURE__ */ new Set();
      this.lifecycleIndex.set(lifecycle, tokenSet);
    }
    tokenSet.add(token);
  }
  /**
   * Registers a service class with automatic dependency injection.
   *
   * @template Tunknown - The type of service to register
   * @param token - The injection token identifying this service
   * @param serviceClass - The class to instantiate
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @returns Result indicating success or error
   */
  registerClass(token, serviceClass, lifecycle) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    if (!serviceClass) {
      return err({
        code: "InvalidOperation",
        message: "serviceClass is required for class registration"
      });
    }
    const dependencies = hasDependencies(serviceClass) ? serviceClass.dependencies ?? [] : [];
    const registrationResult = ServiceRegistration.createClass(
      lifecycle,
      dependencies,
      serviceClass
    );
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, lifecycle);
    return ok(void 0);
  }
  /**
   * Registers a factory function for creating service instances.
   *
   * @template Tunknown - The type of service this factory creates
   * @param token - The injection token identifying this service
   * @param factory - Factory function that creates instances
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of tokens this factory depends on
   * @returns Result indicating success or error
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    const registrationResult = ServiceRegistration.createFactory(
      lifecycle,
      dependencies,
      factory
    );
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, lifecycle);
    return ok(void 0);
  }
  /**
   * Registers a constant value (always SINGLETON lifecycle).
   *
   * @template Tunknown - The type of value to register
   * @param token - The injection token identifying this value
   * @param value - The value to register
   * @returns Result indicating success or error
   */
  registerValue(token, value2) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    const registrationResult = ServiceRegistration.createValue(value2);
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, ServiceLifecycle.SINGLETON);
    return ok(void 0);
  }
  /**
   * Registers an alias that points to another token.
   *
   * @template Tunknown - The type of service
   * @param aliasToken - The alias token
   * @param targetToken - The token to resolve instead
   * @returns Result indicating success or error
   */
  registerAlias(aliasToken, targetToken) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(aliasToken)
      });
    }
    if (this.registrations.has(aliasToken)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(aliasToken)} already registered`,
        tokenDescription: String(aliasToken)
      });
    }
    const registrationResult = ServiceRegistration.createAlias(targetToken);
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(aliasToken, registrationResult.value);
    return ok(void 0);
  }
  /**
   * Retrieves a service registration.
   *
   * @template Tunknown - The type of service
   * @param token - The injection token identifying the service
   * @returns The registration or undefined if not found
   */
  getRegistration(token) {
    return this.registrations.get(token);
  }
  /**
   * Returns all registrations.
   * Used by ContainerValidator for dependency validation.
   *
   * @returns Map of all registrations
   */
  getAllRegistrations() {
    return new Map(iterateServiceRegistrationEntries(this.registrations.entries()));
  }
  /**
   * Returns all registrations for a specific lifecycle.
   * More efficient than filtering getAllRegistrations() when only one lifecycle is needed.
   *
   * @param lifecycle - The lifecycle to query
   * @returns Array of registrations with the specified lifecycle
   */
  getRegistrationsByLifecycle(lifecycle) {
    const tokens = this.lifecycleIndex.get(lifecycle) ?? /* @__PURE__ */ new Set();
    return Array.from(tokens).map((token) => this.registrations.get(token)).filter((reg) => reg !== void 0);
  }
  /**
   * Checks if a service is registered.
   *
   * @template Tunknown - The type of service
   * @param token - The injection token to check
   * @returns True if registered, false otherwise
   */
  has(token) {
    return this.registrations.has(token);
  }
  /**
   * Clears all registrations.
   * Warning: This removes all configured services.
   */
  clear() {
    this.registrations.clear();
    this.lifecycleIndex.clear();
  }
  /**
   * Creates a deep clone of this registry for child containers.
   *
   * Important: Creates a new Map instance with cloned ServiceRegistration objects
   * to prevent child containers from mutating parent registrations.
   *
   * @returns A new ServiceRegistry with cloned registrations
   */
  clone() {
    const clonedRegistry = new _ServiceRegistry();
    for (const [token, registration] of iterateServiceRegistrationEntries(
      this.registrations.entries()
    )) {
      clonedRegistry.registrations.set(token, registration.clone());
    }
    for (const [lifecycle, tokens] of this.lifecycleIndex.entries()) {
      clonedRegistry.lifecycleIndex.set(lifecycle, new Set(tokens));
    }
    return clonedRegistry;
  }
};
__name(_ServiceRegistry, "ServiceRegistry");
let ServiceRegistry = _ServiceRegistry;
const _ContainerValidator = class _ContainerValidator {
  constructor() {
    this.validatedSubgraphs = /* @__PURE__ */ new Set();
  }
  /**
   * Validates all registrations in the registry.
   *
   * Performs three checks:
   * 1. All dependencies are registered
   * 2. All alias targets exist
   * 3. No circular dependencies
   *
   * @param registry - The service registry to validate
   * @returns Result with void on success, or array of errors
   */
  validate(registry) {
    this.validatedSubgraphs = /* @__PURE__ */ new Set();
    const errors = [
      ...this.validateDependencies(registry),
      ...this.validateAliasTargets(registry),
      ...this.detectCircularDependencies(registry)
    ];
    return errors.length > 0 ? err(errors) : ok(void 0);
  }
  /**
   * Checks that all declared dependencies are registered.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for missing dependencies
   */
  validateDependencies(registry) {
    const errors = [];
    const registrations = registry.getAllRegistrations();
    for (const [token, registration] of registrations.entries()) {
      for (const dep of registration.dependencies) {
        if (!registry.has(dep)) {
          errors.push({
            code: "TokenNotRegistered",
            message: `${String(token)} depends on ${String(dep)} which is not registered`,
            tokenDescription: String(dep)
          });
        }
      }
    }
    return errors;
  }
  /**
   * Checks that all alias targets are registered.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for missing alias targets
   */
  validateAliasTargets(registry) {
    const errors = [];
    const registrations = registry.getAllRegistrations();
    for (const [token, registration] of registrations.entries()) {
      if (registration.providerType === "alias" && registration.aliasTarget) {
        if (!registry.has(registration.aliasTarget)) {
          errors.push({
            code: "AliasTargetNotFound",
            message: `Alias ${String(token)} points to ${String(registration.aliasTarget)} which is not registered`,
            tokenDescription: String(registration.aliasTarget)
          });
        }
      }
    }
    return errors;
  }
  /**
   * Detects circular dependencies using depth-first search.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for detected cycles
   */
  detectCircularDependencies(registry) {
    const errors = [];
    const visited = /* @__PURE__ */ new Set();
    const registrations = registry.getAllRegistrations();
    for (const token of registrations.keys()) {
      const visiting = /* @__PURE__ */ new Set();
      const path = [];
      const error = this.checkCycleForToken(registry, token, visiting, visited, path);
      if (error) {
        errors.push(error);
      }
    }
    return errors;
  }
  /**
   * Recursively checks for cycles starting from a specific token.
   *
   * **Algorithm: Depth-First Search (DFS) with Three-Color Marking**
   *
   * Three states for each node (token):
   * - WHITE (unvisited): Not in `visiting` or `visited` sets
   * - GRAY (visiting): In `visiting` set (currently in DFS recursion stack)
   * - BLACK (visited): In `visited` set (fully processed, all descendants checked)
   *
   * Cycle Detection:
   * - If we encounter a GRAY node during traversal, we've found a back edge → cycle
   * - GRAY nodes represent the current path from root to current node
   * - Encountering a GRAY node means we're trying to visit an ancestor → circular dependency
   *
   * Performance Optimization:
   * - `validatedSubgraphs` cache prevents redundant traversals of already-validated subtrees
   * - Crucial for large dependency graphs (>500 services)
   * - BLACK nodes can be safely skipped (all their descendants are cycle-free)
   *
   * Time Complexity: O(V + E) where V = number of services, E = number of dependencies
   * Space Complexity: O(V) for visiting/visited sets + O(D) for recursion depth D
   *
   * @param registry - The service registry
   * @param token - Current token being checked (current node in DFS)
   * @param visiting - GRAY nodes: tokens currently in the DFS recursion stack
   * @param visited - BLACK nodes: tokens fully processed in this validation run
   * @param path - Current dependency path for error reporting (stack trace)
   * @returns ContainerError if cycle detected, null otherwise
   *
   * @example
   * Cycle A → B → C → A will be detected when:
   * 1. Start at A (mark GRAY)
   * 2. Visit B (mark GRAY)
   * 3. Visit C (mark GRAY)
   * 4. Try to visit A → A is GRAY → Back edge detected → Cycle!
   */
  checkCycleForToken(registry, token, visiting, visited, path) {
    if (visiting.has(token)) {
      const cyclePath = [...path, token].map(String).join(" → ");
      return {
        code: "CircularDependency",
        message: `Circular dependency: ${cyclePath}`,
        tokenDescription: String(token)
      };
    }
    if (this.validatedSubgraphs.has(token)) {
      return null;
    }
    if (visited.has(token)) {
      return null;
    }
    visiting.add(token);
    path.push(token);
    const registration = registry.getRegistration(token);
    if (registration) {
      for (const dep of registration.dependencies) {
        const error = this.checkCycleForToken(registry, dep, visiting, visited, path);
        if (error) return error;
      }
    }
    visiting.delete(token);
    path.pop();
    visited.add(token);
    this.validatedSubgraphs.add(token);
    return null;
  }
};
__name(_ContainerValidator, "ContainerValidator");
let ContainerValidator = _ContainerValidator;
const _InstanceCache = class _InstanceCache {
  constructor() {
    this.instances = /* @__PURE__ */ new Map();
    this.metricsCollector = null;
  }
  /**
   * Injects the MetricsCollector for cache hit/miss tracking.
   * Called after container validation to enable observability.
   *
   * @param collector - The metrics collector instance
   */
  setMetricsCollector(collector) {
    this.metricsCollector = collector;
  }
  /**
   * Retrieves a cached service instance.
   *
   * @template Tunknown - The type of service to retrieve
   * @param token - The injection token identifying the service
   * @returns The cached instance or undefined if not found
   */
  get(token) {
    const hasInstance = this.instances.has(token);
    this.metricsCollector?.recordCacheAccess(hasInstance);
    return castCachedServiceInstance(this.instances.get(token));
  }
  /**
   * Stores a service instance in the cache.
   *
   * @template Tunknown - The type of service to store
   * @param token - The injection token identifying the service
   * @param instance - The service instance to cache
   */
  set(token, instance2) {
    this.instances.set(token, instance2);
  }
  /**
   * Checks if a service instance is cached.
   *
   * @template Tunknown - The type of service to check
   * @param token - The injection token identifying the service
   * @returns True if the instance is cached, false otherwise
   */
  has(token) {
    const hasInstance = this.instances.has(token);
    this.metricsCollector?.recordCacheAccess(hasInstance);
    return hasInstance;
  }
  /**
   * Clears all cached instances.
   * Note: Does not dispose instances - call getAllInstances() first if disposal is needed.
   */
  clear() {
    this.instances.clear();
  }
  /**
   * Returns all cached instances for disposal purposes.
   * Used by ScopeManager to dispose Disposable services.
   *
   * @returns A map of all cached instances
   */
  getAllInstances() {
    return new Map(this.instances);
  }
};
__name(_InstanceCache, "InstanceCache");
let InstanceCache = _InstanceCache;
const _SingletonResolutionStrategy = class _SingletonResolutionStrategy {
  resolve(token, registration, dependencyResolver, instantiator, cache, parentResolver, _scopeName) {
    if (parentResolver !== null) {
      const parentResult = parentResolver.resolve(token);
      if (parentResult.ok) {
        return parentResult;
      }
      if (parentResult.error.code === "CircularDependency") {
        return parentResult;
      }
    }
    if (!cache.has(token)) {
      const instanceResult2 = instantiator.instantiate(token, registration);
      if (!instanceResult2.ok) {
        return instanceResult2;
      }
      cache.set(token, instanceResult2.value);
    }
    const instanceResult = castCachedServiceInstanceForResult(cache.get(token));
    if (!instanceResult.ok) {
      return instanceResult;
    }
    return ok(instanceResult.value);
  }
};
__name(_SingletonResolutionStrategy, "SingletonResolutionStrategy");
let SingletonResolutionStrategy = _SingletonResolutionStrategy;
const _TransientResolutionStrategy = class _TransientResolutionStrategy {
  resolve(token, registration, _dependencyResolver, instantiator, _cache, _parentResolver, _scopeName) {
    return instantiator.instantiate(token, registration);
  }
};
__name(_TransientResolutionStrategy, "TransientResolutionStrategy");
let TransientResolutionStrategy = _TransientResolutionStrategy;
const _ScopedResolutionStrategy = class _ScopedResolutionStrategy {
  resolve(token, registration, _dependencyResolver, instantiator, cache, parentResolver, _scopeName) {
    if (parentResolver === null) {
      return err({
        code: "ScopeRequired",
        message: `Scoped service ${String(token)} requires a scope container. Use createScope() to create a child container first.`,
        tokenDescription: String(token)
      });
    }
    if (!cache.has(token)) {
      const instanceResult2 = instantiator.instantiate(token, registration);
      if (!instanceResult2.ok) {
        return instanceResult2;
      }
      cache.set(token, instanceResult2.value);
    }
    const instanceResult = castCachedServiceInstanceForResult(cache.get(token));
    if (!instanceResult.ok) {
      return instanceResult;
    }
    return ok(instanceResult.value);
  }
};
__name(_ScopedResolutionStrategy, "ScopedResolutionStrategy");
let ScopedResolutionStrategy = _ScopedResolutionStrategy;
const _LifecycleResolver = class _LifecycleResolver {
  constructor(cache, parentResolver, scopeName) {
    this.cache = cache;
    this.parentResolver = parentResolver;
    this.scopeName = scopeName;
    this.strategies = /* @__PURE__ */ new Map();
    this.strategies.set(ServiceLifecycle.SINGLETON, new SingletonResolutionStrategy());
    this.strategies.set(ServiceLifecycle.TRANSIENT, new TransientResolutionStrategy());
    this.strategies.set(ServiceLifecycle.SCOPED, new ScopedResolutionStrategy());
  }
  /**
   * Resolves a service based on its lifecycle.
   *
   * @template T - The type of service to resolve
   * @param token - The injection token identifying the service
   * @param registration - The service registration metadata
   * @param dependencyResolver - The DependencyResolver for dependency resolution
   * @param instantiator - The ServiceInstantiator for service instantiation
   * @returns Result with service instance or error
   */
  resolve(token, registration, dependencyResolver, instantiator) {
    const strategy = this.strategies.get(registration.lifecycle);
    if (!strategy) {
      return err({
        code: "InvalidLifecycle",
        message: `Invalid service lifecycle: ${String(registration.lifecycle)}`,
        tokenDescription: String(token)
      });
    }
    return strategy.resolve(
      token,
      registration,
      dependencyResolver,
      instantiator,
      this.cache,
      this.parentResolver,
      this.scopeName
    );
  }
};
__name(_LifecycleResolver, "LifecycleResolver");
let LifecycleResolver = _LifecycleResolver;
const _ServiceInstantiatorImpl = class _ServiceInstantiatorImpl {
  constructor(dependencyResolver) {
    this.dependencyResolver = dependencyResolver;
  }
  /**
   * Instantiates a service based on registration type.
   *
   * CRITICAL: Returns Result to preserve error context and avoid breaking Result-Contract.
   * Handles dependency resolution for classes, direct factory calls, and value returns.
   *
   * @template T - The type of service to instantiate
   * @param token - The injection token (used for error messages)
   * @param registration - The service registration metadata
   * @returns Result with instance or detailed error (DependencyResolveFailed, FactoryFailed, etc.)
   */
  instantiate(token, registration) {
    if (registration.serviceClass) {
      const resolvedDeps = [];
      for (const dep of registration.dependencies) {
        const depResult = this.dependencyResolver.resolve(dep);
        if (!depResult.ok) {
          return err({
            code: "DependencyResolveFailed",
            message: `Cannot resolve dependency ${String(dep)} for ${String(token)}`,
            tokenDescription: String(dep),
            cause: depResult.error
          });
        }
        resolvedDeps.push(depResult.value);
      }
      try {
        return ok(new registration.serviceClass(...resolvedDeps));
      } catch (constructorError) {
        return err({
          code: "FactoryFailed",
          message: `Constructor failed for ${String(token)}: ${String(constructorError)}`,
          tokenDescription: String(token),
          cause: constructorError
        });
      }
    } else if (registration.factory) {
      try {
        return ok(registration.factory());
      } catch (factoryError) {
        return err({
          code: "FactoryFailed",
          message: `Factory failed for ${String(token)}: ${String(factoryError)}`,
          tokenDescription: String(token),
          cause: factoryError
        });
      }
    } else if (registration.value !== void 0) {
      return ok(registration.value);
    } else {
      return err({
        code: "InvalidOperation",
        message: `Invalid registration for ${String(token)} - no class, factory, or value`,
        tokenDescription: String(token)
      });
    }
  }
};
__name(_ServiceInstantiatorImpl, "ServiceInstantiatorImpl");
let ServiceInstantiatorImpl = _ServiceInstantiatorImpl;
const _ServiceResolver = class _ServiceResolver {
  constructor(registry, cache, parentResolver, scopeName, performanceTracker) {
    this.registry = registry;
    this.cache = cache;
    this.parentResolver = parentResolver;
    this.scopeName = scopeName;
    this.performanceTracker = performanceTracker;
    this.metricsCollector = null;
    this.lifecycleResolver = new LifecycleResolver(cache, parentResolver, scopeName);
    this.instantiator = new ServiceInstantiatorImpl(this);
  }
  /**
   * Sets the MetricsCollector for metrics recording.
   * Called by ServiceContainer after validation.
   *
   * @param collector - The metrics collector instance
   */
  setMetricsCollector(collector) {
    this.metricsCollector = collector;
  }
  /**
   * Resolves a service by token.
   *
   * Handles:
   * - Alias resolution (recursive)
   * - Lifecycle-specific resolution (delegated to LifecycleResolver)
   * - Performance tracking
   * - Metrics recording
   *
   * Performance tracking is handled by the injected PerformanceTracker.
   *
   * @template T - The type of service to resolve
   * @param token - The injection token identifying the service
   * @returns Result with service instance or error
   */
  resolve(token) {
    return this.performanceTracker.track(
      () => {
        const registration = this.registry.getRegistration(token);
        if (!registration) {
          const stack2 = new Error().stack;
          const error = {
            code: "TokenNotRegistered",
            message: `Service ${String(token)} not registered`,
            tokenDescription: String(token),
            ...stack2 !== void 0 && { stack: stack2 },
            // Only include stack if defined
            timestamp: Date.now(),
            containerScope: this.scopeName
          };
          return err(error);
        }
        if (registration.providerType === "alias" && registration.aliasTarget) {
          return this.resolve(registration.aliasTarget);
        }
        return this.lifecycleResolver.resolve(token, registration, this, this);
      },
      (duration, result) => {
        this.metricsCollector?.recordResolution(token, duration, result.ok);
      }
    );
  }
  /**
   * Instantiates a service based on registration type.
   *
   * CRITICAL: Returns Result to preserve error context and avoid breaking Result-Contract.
   * Delegates to ServiceInstantiatorImpl for actual instantiation logic.
   *
   * This method implements the ServiceInstantiator interface, allowing lifecycle
   * strategies to instantiate services without depending on ServiceResolver directly.
   *
   * @template T - The type of service to instantiate
   * @param token - The injection token (used for error messages)
   * @param registration - The service registration metadata
   * @returns Result with instance or detailed error (DependencyResolveFailed, FactoryFailed, etc.)
   */
  instantiate(token, registration) {
    return this.instantiator.instantiate(token, registration);
  }
};
__name(_ServiceResolver, "ServiceResolver");
let ServiceResolver = _ServiceResolver;
function generateScopeId() {
  try {
    return crypto.randomUUID();
  } catch {
    return Date.now() + "-" + Math.random();
  }
}
__name(generateScopeId, "generateScopeId");
const _ScopeManager = class _ScopeManager {
  // Unique correlation ID for tracing
  constructor(scopeName, parent, cache, depth = 0) {
    this.scopeName = scopeName;
    this.parent = parent;
    this.cache = cache;
    this.MAX_SCOPE_DEPTH = 10;
    this.children = /* @__PURE__ */ new Set();
    this.disposed = false;
    this.depth = depth;
    this.scopeId = `${scopeName}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }
  /**
   * Creates a child scope manager.
   *
   * Note: Returns data (scopeName, cache, childManager) instead of full container
   * to avoid circular dependency with ServiceResolver.
   *
   * @param name - Optional custom name for the scope
   * @returns Result with child scope data or error if disposed or max depth exceeded
   */
  createChild(name) {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Cannot create child scope from disposed scope: ${this.scopeName}`
      });
    }
    if (this.depth >= this.MAX_SCOPE_DEPTH) {
      return err({
        code: "MaxScopeDepthExceeded",
        message: `Maximum scope depth of ${this.MAX_SCOPE_DEPTH} exceeded. Current depth: ${this.depth}`
      });
    }
    const uniqueId = name ?? `scope-${generateScopeId()}`;
    const childScopeName = `${this.scopeName}.${uniqueId}`;
    const childCache = new InstanceCache();
    const childManager = new _ScopeManager(childScopeName, this, childCache, this.depth + 1);
    this.children.add(childManager);
    return ok({
      scopeName: childScopeName,
      cache: childCache,
      manager: childManager
    });
  }
  /**
   * Disposes this scope and all child scopes.
   *
   * Disposal order (critical):
   * 1. Recursively dispose all children
   * 2. Dispose instances in this scope (if Disposable)
   * 3. Clear instance cache
   * 4. Remove from parent's children set
   *
   * @returns Result indicating success or disposal error
   */
  dispose() {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Scope already disposed: ${this.scopeName}`
      });
    }
    this.disposed = true;
    const childDisposalErrors = [];
    for (const child2 of this.children) {
      const childResult = child2.dispose();
      if (isErr(childResult)) {
        childDisposalErrors.push({
          scopeName: child2.scopeName,
          error: childResult.error
        });
      }
    }
    const disposeResult = this.disposeInstances();
    if (!disposeResult.ok) {
      return disposeResult;
    }
    this.cache.clear();
    if (this.parent !== null) {
      this.parent.children.delete(this);
    }
    if (childDisposalErrors.length > 0) {
      return err({
        code: "PartialDisposal",
        message: `Failed to dispose ${childDisposalErrors.length} child scope(s)`,
        details: childDisposalErrors
      });
    }
    return ok(void 0);
  }
  /**
   * Asynchronously disposes this scope and all child scopes.
   *
   * Preferred method for cleanup as it properly handles async dispose operations.
   * Falls back to sync dispose() for services that only implement Disposable.
   *
   * Disposal order (critical):
   * 1. Recursively dispose all children (async)
   * 2. Dispose instances in this scope (async or sync)
   * 3. Clear instance cache
   * 4. Remove from parent's children set
   *
   * @returns Promise with Result indicating success or disposal error
   */
  async disposeAsync() {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Scope already disposed: ${this.scopeName}`
      });
    }
    this.disposed = true;
    const childDisposalErrors = [];
    for (const child2 of this.children) {
      const childResult = await child2.disposeAsync();
      if (isErr(childResult)) {
        childDisposalErrors.push({
          scopeName: child2.scopeName,
          error: childResult.error
        });
      }
    }
    const disposeResult = await this.disposeInstancesAsync();
    if (!disposeResult.ok) {
      return disposeResult;
    }
    this.cache.clear();
    if (this.parent !== null) {
      this.parent.children.delete(this);
    }
    if (childDisposalErrors.length > 0) {
      return err({
        code: "PartialDisposal",
        message: `Failed to dispose ${childDisposalErrors.length} child scope(s)`,
        details: childDisposalErrors
      });
    }
    return ok(void 0);
  }
  /**
   * Disposes all instances in the cache that implement Disposable (sync).
   *
   * @returns Result indicating success or disposal error
   */
  disposeInstances() {
    const instances = this.cache.getAllInstances();
    for (const [token, instance2] of instances.entries()) {
      if (this.isDisposable(instance2)) {
        const result = tryCatch(
          () => instance2.dispose(),
          (error) => ({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error)}`,
            tokenDescription: String(token),
            cause: error
          })
        );
        if (isErr(result)) {
          return result;
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Disposes all instances in the cache that implement Disposable or AsyncDisposable (async).
   * Prefers async disposal when available, falls back to sync.
   *
   * @returns Promise with Result indicating success or disposal error
   */
  async disposeInstancesAsync() {
    const instances = this.cache.getAllInstances();
    for (const [token, instance2] of instances.entries()) {
      if (this.isAsyncDisposable(instance2)) {
        try {
          await instance2.disposeAsync();
        } catch (error) {
          return err({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error)}`,
            tokenDescription: String(token),
            cause: error
          });
        }
      } else if (this.isDisposable(instance2)) {
        const disposableInstance = instance2;
        const result = tryCatch(
          () => disposableInstance.dispose(),
          (error) => ({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error)}`,
            tokenDescription: String(token),
            cause: error
          })
        );
        if (isErr(result)) {
          return result;
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Type guard to check if an instance implements the Disposable pattern.
   *
   * @param instance - The service instance to check
   * @returns True if instance has dispose() method
   */
  isDisposable(instance2) {
    return instance2 !== null && typeof instance2 === "object" && "dispose" in instance2 && // Type-safe check: instance has 'dispose' property (checked above)
    typeof instance2.dispose === "function";
  }
  /**
   * Type guard to check if an instance implements the AsyncDisposable pattern.
   *
   * @param instance - The service instance to check
   * @returns True if instance has disposeAsync() method
   */
  isAsyncDisposable(instance2) {
    return instance2 !== null && typeof instance2 === "object" && "disposeAsync" in instance2 && // Type-safe check: instance has 'disposeAsync' property (checked above)
    typeof instance2.disposeAsync === "function";
  }
  /**
   * Checks if this scope is disposed.
   *
   * @returns True if disposed, false otherwise
   */
  isDisposed() {
    return this.disposed;
  }
  /**
   * Gets the hierarchical scope name.
   *
   * @returns The scope name (e.g., "root.child1.grandchild")
   */
  getScopeName() {
    return this.scopeName;
  }
  /**
   * Gets the unique correlation ID for this scope.
   *
   * Useful for tracing and logging in distributed/concurrent scenarios.
   * Each scope gets a unique ID combining name, timestamp, and random string.
   *
   * @returns The unique scope ID (e.g., "root-1730761234567-abc123")
   *
   * @example
   * ```typescript
   * const scope = container.createScope("request").value!;
   * logger.info(`[${scope.getScopeId()}] Processing request`);
   * ```
   */
  getScopeId() {
    return this.scopeId;
  }
};
__name(_ScopeManager, "ScopeManager");
let ScopeManager = _ScopeManager;
const _TimeoutError = class _TimeoutError extends Error {
  constructor(timeoutMs) {
    super(`Operation timed out after ${timeoutMs}ms`);
    this.name = "TimeoutError";
  }
};
__name(_TimeoutError, "TimeoutError");
let TimeoutError = _TimeoutError;
function withTimeout(promise2, timeoutMs) {
  let timeoutHandle = null;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutHandle = setTimeout(() => {
      reject(new TimeoutError(timeoutMs));
    }, timeoutMs);
  });
  return Promise.race([
    promise2.finally(() => {
      if (timeoutHandle !== null) {
        clearTimeout(timeoutHandle);
      }
    }),
    timeoutPromise
  ]);
}
__name(withTimeout, "withTimeout");
const metricsCollectorToken = createInjectionToken("MetricsCollector");
const _ServiceRegistrationManager = class _ServiceRegistrationManager {
  constructor(registry, isDisposed, getValidationState) {
    this.registry = registry;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  /**
   * Register a service class with automatic dependency injection.
   */
  registerClass(token, serviceClass, lifecycle) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerClass(token, serviceClass, lifecycle);
  }
  /**
   * Register a factory function.
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    if (!factory || typeof factory !== "function") {
      return err({
        code: "InvalidFactory",
        message: "Factory must be a function",
        tokenDescription: String(token)
      });
    }
    return this.registry.registerFactory(token, factory, lifecycle, dependencies);
  }
  /**
   * Register a constant value.
   */
  registerValue(token, value2) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerValue(token, value2);
  }
  /**
   * Register an alias.
   */
  registerAlias(aliasToken, targetToken) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(aliasToken)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerAlias(aliasToken, targetToken);
  }
  /**
   * Get a registered value without requiring validation.
   * Useful for bootstrap/static values.
   */
  getRegisteredValue(token) {
    const registration = this.registry.getRegistration(token);
    if (!registration) {
      return null;
    }
    if (registration.providerType !== "value") {
      return null;
    }
    const value2 = registration.value;
    if (value2 === void 0) {
      return null;
    }
    return value2;
  }
  /**
   * Check if a service is registered.
   */
  isRegistered(token) {
    return this.registry.has(token);
  }
};
__name(_ServiceRegistrationManager, "ServiceRegistrationManager");
let ServiceRegistrationManager = _ServiceRegistrationManager;
const _ContainerValidationManager = class _ContainerValidationManager {
  constructor(validator, registry, initialState = "registering") {
    this.validator = validator;
    this.registry = registry;
    this.validationPromise = null;
    this.validationState = initialState;
  }
  /**
   * Validate all registrations.
   */
  validate() {
    if (this.validationState === "validated") {
      return ok(void 0);
    }
    if (this.validationState === "validating") {
      return err([
        {
          code: "InvalidOperation",
          message: "Validation already in progress"
        }
      ]);
    }
    this.validationState = "validating";
    const result = this.validator.validate(this.registry);
    if (result.ok) {
      this.validationState = "validated";
    } else {
      this.validationState = "registering";
    }
    return result;
  }
  /**
   * Async-safe validation for concurrent environments with timeout.
   */
  async validateAsync(timeoutMs, withTimeout2, TimeoutErrorClass) {
    if (this.validationState === "validated") {
      return ok(void 0);
    }
    if (this.validationPromise !== null) {
      return this.validationPromise;
    }
    if (this.validationState === "validating") {
      return err([
        {
          code: "InvalidOperation",
          message: "Validation already in progress"
        }
      ]);
    }
    this.validationState = "validating";
    let timedOut = false;
    const validationTask = Promise.resolve().then(() => {
      const result = this.validator.validate(this.registry);
      if (!timedOut) {
        if (result.ok) {
          this.validationState = "validated";
        } else {
          this.validationState = "registering";
        }
      }
      return result;
    });
    try {
      this.validationPromise = withTimeout2(validationTask, timeoutMs);
      const result = await this.validationPromise;
      return result;
    } catch (error) {
      if (error instanceof TimeoutErrorClass) {
        timedOut = true;
        this.validationState = "registering";
        return err([
          {
            code: "InvalidOperation",
            message: `Validation timed out after ${timeoutMs}ms`
          }
        ]);
      }
      throw error;
    } finally {
      this.validationPromise = null;
    }
  }
  /**
   * Get validation state.
   */
  getValidationState() {
    return this.validationState;
  }
  /**
   * Reset validation state (used after disposal or clear).
   */
  resetValidationState() {
    this.validationState = "registering";
  }
};
__name(_ContainerValidationManager, "ContainerValidationManager");
let ContainerValidationManager = _ContainerValidationManager;
const _ContainerErrorImpl = class _ContainerErrorImpl extends Error {
  constructor(error) {
    super(error.message);
    this.name = "ContainerError";
    this.code = error.code;
    if (error.cause !== void 0) {
      this.cause = error.cause;
    }
    if (error.tokenDescription !== void 0) {
      this.tokenDescription = error.tokenDescription;
    }
    if (error.details !== void 0) {
      this.details = error.details;
    }
    if (error.stack !== void 0) {
      this.stack = error.stack;
    }
    if (error.timestamp !== void 0) {
      this.timestamp = error.timestamp;
    }
    if (error.containerScope !== void 0) {
      this.containerScope = error.containerScope;
    }
  }
};
__name(_ContainerErrorImpl, "ContainerErrorImpl");
let ContainerErrorImpl = _ContainerErrorImpl;
const _ServiceResolutionManager = class _ServiceResolutionManager {
  constructor(resolver, isDisposed, getValidationState) {
    this.resolver = resolver;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  resolveWithError(token) {
    if (this.isDisposed()) {
      const error = {
        code: "Disposed",
        message: `Cannot resolve from disposed container`,
        tokenDescription: String(token)
      };
      const domainError = {
        code: error.code,
        message: error.message,
        cause: error.cause
      };
      return err(domainError);
    }
    if (this.getValidationState() !== "validated") {
      const error = {
        code: "NotValidated",
        message: "Container must be validated before resolving. Call validate() first.",
        tokenDescription: String(token)
      };
      const domainError = {
        code: error.code,
        message: error.message,
        cause: error.cause
      };
      return err(domainError);
    }
    const result = this.resolver.resolve(token);
    if (!result.ok) {
      const domainError = {
        code: result.error.code,
        message: result.error.message,
        cause: result.error.cause
      };
      return err(domainError);
    }
    return result;
  }
  /**
   * Resolves a service instance (throws on failure).
   * FOR EXTERNAL API USE ONLY - uses ApiSafeToken validation.
   */
  resolve(token) {
    const result = this.resolveWithError(token);
    if (isOk(result)) {
      return castResolvedService(result.value);
    }
    const containerError = {
      code: castContainerErrorCode(result.error.code),
      message: `Cannot resolve ${String(token)}: ${result.error.message}`,
      tokenDescription: String(token),
      cause: result.error.cause
    };
    throw new ContainerErrorImpl(containerError);
  }
};
__name(_ServiceResolutionManager, "ServiceResolutionManager");
let ServiceResolutionManager = _ServiceResolutionManager;
const _ScopeManagementFacade = class _ScopeManagementFacade {
  constructor(scopeManager, isDisposed, getValidationState) {
    this.scopeManager = scopeManager;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  /**
   * Validates that a scope can be created.
   * Returns the scope creation result if valid, or an error if not.
   */
  validateScopeCreation(name) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot create scope from disposed container`
      });
    }
    if (this.getValidationState() !== "validated") {
      return err({
        code: "NotValidated",
        message: "Parent must be validated before creating scopes. Call validate() first."
      });
    }
    return this.scopeManager.createChild(name);
  }
};
__name(_ScopeManagementFacade, "ScopeManagementFacade");
let ScopeManagementFacade = _ScopeManagementFacade;
const _MetricsInjectionManager = class _MetricsInjectionManager {
  constructor(resolver, cache, resolveMetricsCollector) {
    this.resolver = resolver;
    this.cache = cache;
    this.resolveMetricsCollector = resolveMetricsCollector;
  }
  /**
   * Injects MetricsCollector into resolver and cache after validation.
   * This enables metrics recording without circular dependencies during bootstrap.
   *
   * Note: EnvironmentConfig is already injected via BootstrapPerformanceTracker
   * during container creation, so only MetricsCollector needs to be injected here.
   */
  injectMetricsCollector() {
    return ok(void 0);
  }
  /**
   * Internal method to perform the actual injection.
   * Called by ServiceContainer after resolving the metrics collector.
   */
  performInjection(collector) {
    this.resolver.setMetricsCollector(collector);
    this.cache.setMetricsCollector(collector);
  }
};
__name(_MetricsInjectionManager, "MetricsInjectionManager");
let MetricsInjectionManager = _MetricsInjectionManager;
const _ApiSecurityManager = class _ApiSecurityManager {
  /**
   * Validates that a token is API-safe.
   * Used by container.resolve() to enforce API boundary.
   *
   * @param token - The token to validate
   * @returns Result indicating if token is API-safe
   */
  validateApiSafeToken(token) {
    if (!isApiSafeTokenRuntime(token)) {
      return err({
        code: "InvalidOperation",
        message: `API Boundary Violation: resolve() called with non-API-safe token: ${String(token)}.
This token was not marked via markAsApiSafe().

Internal code MUST use resolveWithError() instead:
  const result = container.resolveWithError(${String(token)});
  if (result.ok) { /* use result.value */ }

Only the public ModuleApi should expose resolve() for external modules.`,
        tokenDescription: String(token)
      });
    }
    return { ok: true, value: void 0 };
  }
};
__name(_ApiSecurityManager, "ApiSecurityManager");
let ApiSecurityManager = _ApiSecurityManager;
const _ServiceContainer = class _ServiceContainer {
  /**
   * Constructor for ServiceContainer.
   *
   * **Note:** This constructor is public to allow ContainerBootstrapFactory to create instances.
   * External code should use ServiceContainer.createRoot() or ContainerBootstrapFactory.createRoot().
   *
   * @param registry - Service registry
   * @param validator - Container validator (shared for parent/child)
   * @param cache - Instance cache
   * @param resolver - Service resolver
   * @param scopeManager - Scope manager
   * @param validationState - Initial validation state
   * @param env - Environment configuration
   */
  constructor(registry, validator, cache, resolver, scopeManager, validationState, env) {
    this.registry = registry;
    this.validator = validator;
    this.cache = cache;
    this.resolver = resolver;
    this.scopeManager = scopeManager;
    this.env = env;
    this.validationManager = new ContainerValidationManager(validator, registry, validationState);
    this.registrationManager = new ServiceRegistrationManager(
      registry,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
    this.resolutionManager = new ServiceResolutionManager(
      resolver,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
    this.metricsInjectionManager = new MetricsInjectionManager(resolver, cache, (token) => {
      const result = this.resolutionManager.resolveWithError(token);
      if (!result.ok) {
        const containerError = {
          code: castContainerErrorCode(result.error.code),
          message: result.error.message,
          cause: result.error.cause,
          tokenDescription: String(token)
        };
        return err(containerError);
      }
      const metricsCollector = castResolvedService(result.value);
      return ok(metricsCollector);
    });
    this.apiSecurityManager = new ApiSecurityManager();
    this.scopeFacade = new ScopeManagementFacade(
      scopeManager,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
  }
  /**
   * Creates a new root container.
   *
   * **Note:** This method creates bootstrap dependencies (RuntimeConfig, PerformanceTracker) inline
   * to avoid circular dependency with ContainerBootstrapFactory.
   * The factory pattern is maintained via ContainerBootstrapFactory for external use (e.g., ContainerFactory).
   *
   * **Architecture:**
   * Creates bootstrap dependencies directly (infrastructure -> infrastructure, no violation).
   * This avoids circular dependency while maintaining the same functionality.
   *
   * @param env - Environment configuration
   * @returns A new root ServiceContainer
   */
  static createRoot(env) {
    const registry = new ServiceRegistry();
    const validator = new ContainerValidator();
    const cache = new InstanceCache();
    const scopeManager = new ScopeManager("root", null, cache);
    const runtimeConfig = new RuntimeConfigAdapter(env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver = new ServiceResolver(registry, cache, null, "root", performanceTracker);
    return new _ServiceContainer(
      registry,
      validator,
      cache,
      resolver,
      scopeManager,
      "registering",
      env
    );
  }
  /**
   * Register a service class with automatic dependency injection.
   */
  registerClass(token, serviceClass, lifecycle) {
    return this.registrationManager.registerClass(token, serviceClass, lifecycle);
  }
  /**
   * Register a factory function.
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    return this.registrationManager.registerFactory(token, factory, lifecycle, dependencies);
  }
  /**
   * Register a constant value.
   */
  registerValue(token, value2) {
    return this.registrationManager.registerValue(token, value2);
  }
  /**
   * Register an already created instance.
   * Internally treated the same as a value registration.
   */
  registerInstance(token, instance2) {
    return this.registerValue(token, instance2);
  }
  /**
   * Returns a previously registered constant value without requiring validation.
   * Useful for bootstrap/static values that are needed while the container is still registering services.
   */
  getRegisteredValue(token) {
    return this.registrationManager.getRegisteredValue(token);
  }
  /**
   * Register an alias.
   */
  registerAlias(aliasToken, targetToken) {
    return this.registrationManager.registerAlias(aliasToken, targetToken);
  }
  /**
   * Validate all registrations.
   */
  validate() {
    const result = this.validationManager.validate();
    if (result.ok) {
      this.injectMetricsCollector();
    }
    return result;
  }
  /**
   * Injects MetricsCollector into resolver and cache after validation.
   * This enables metrics recording without circular dependencies during bootstrap.
   *
   * Note: EnvironmentConfig is already injected via BootstrapPerformanceTracker
   * during container creation, so only MetricsCollector needs to be injected here.
   *
   * Static import is safe here because:
   * - tokenindex.ts only uses `import type { ServiceContainer }` (removed at runtime)
   * - No circular runtime dependency exists
   * - Container is already validated when this is called
   */
  injectMetricsCollector() {
    const metricsResult = this.resolutionManager.resolveWithError(metricsCollectorToken);
    if (metricsResult.ok) {
      const metricsCollector = castResolvedService(metricsResult.value);
      this.metricsInjectionManager.performInjection(metricsCollector);
    }
  }
  /**
   * Get validation state.
   * Implements both Container.getValidationState and PlatformContainerPort.getValidationState.
   * Both interfaces use compatible types (ContainerValidationState is compatible with DomainContainerValidationState).
   */
  getValidationState() {
    return this.validationManager.getValidationState();
  }
  /**
   * Async-safe validation for concurrent environments with timeout.
   *
   * Prevents race conditions when multiple callers validate simultaneously
   * by ensuring only one validation runs at a time.
   *
   * @param timeoutMs - Timeout in milliseconds (default: 30000 = 30 seconds)
   * @returns Promise resolving to validation result
   *
   * @example
   * ```typescript
   * const container = ServiceContainer.createRoot(ENV);
   * // ... register services
   * await container.validateAsync(); // Safe for concurrent calls
   * await container.validateAsync(5000); // With 5 second timeout
   * ```
   */
  async validateAsync(timeoutMs = 3e4) {
    const result = await this.validationManager.validateAsync(timeoutMs, withTimeout, TimeoutError);
    if (result.ok) {
      this.injectMetricsCollector();
    }
    return result;
  }
  /**
   * Creates a child scope container.
   *
   * Child containers:
   * - Inherit parent registrations (cloned)
   * - Can add their own registrations
   * - Must call validate() before resolving
   * - Share parent's singleton instances
   * - Have isolated scoped instances
   *
   * @param name - Optional custom name for the scope
   * @returns Result with child container or error
   *
   * @example
   * ```typescript
   * const parent = ServiceContainer.createRoot(ENV);
   * parent.registerClass(LoggerToken, Logger, SINGLETON);
   * parent.validate();
   *
   * const child = parent.createScope("request").value!;
   * child.registerClass(RequestToken, RequestContext, SCOPED);
   * child.validate();
   *
   * const logger = child.resolve(LoggerToken);   // From parent (shared)
   * const ctx = child.resolve(RequestToken);      // From child (isolated)
   * ```
   */
  createScope(name) {
    const scopeResult = this.scopeFacade.validateScopeCreation(name);
    if (!scopeResult.ok) {
      return err(scopeResult.error);
    }
    const childRegistry = this.registry.clone();
    const childCache = scopeResult.value.cache;
    const childManager = scopeResult.value.manager;
    const { resolver: childResolver } = this.createBootstrapDependencies(
      childRegistry,
      childCache,
      this.resolver,
      // Parent resolver for singleton delegation
      scopeResult.value.scopeName
    );
    const child2 = new _ServiceContainer(
      childRegistry,
      this.validator,
      // Shared (stateless)
      childCache,
      childResolver,
      childManager,
      "registering",
      // Child starts in registering state
      this.env
      // Inherit ENV from parent
    );
    return ok(child2);
  }
  resolveWithError(token) {
    return this.resolutionManager.resolveWithError(token);
  }
  // Implementation (unified for both overloads)
  resolve(token) {
    const securityResult = this.apiSecurityManager.validateApiSafeToken(token);
    if (!securityResult.ok) {
      throw new ContainerErrorImpl(securityResult.error);
    }
    return this.resolutionManager.resolve(token);
  }
  isRegistered(token) {
    return ok(this.registrationManager.isRegistered(token));
  }
  /**
   * Returns API-safe token metadata for external consumption.
   */
  getApiSafeToken(token) {
    if (!isApiSafeTokenRuntime(token)) {
      return null;
    }
    return {
      description: String(token),
      isRegistered: this.registrationManager.isRegistered(token)
    };
  }
  /**
   * Synchronously dispose container and all children.
   *
   * Use this for scenarios where async disposal is not possible (e.g., browser unload).
   * For normal cleanup, prefer disposeAsync() which handles async disposal properly.
   *
   * @returns Result indicating success or disposal error
   */
  dispose() {
    const result = this.scopeManager.dispose();
    if (result.ok) {
      this.validationManager.resetValidationState();
    }
    return result;
  }
  /**
   * Asynchronously dispose container and all children.
   *
   * This is the preferred disposal method as it properly handles services that
   * implement AsyncDisposable, allowing for proper cleanup of resources like
   * database connections, file handles, or network sockets.
   *
   * Falls back to synchronous disposal for services implementing only Disposable.
   *
   * @returns Promise with Result indicating success or disposal error
   *
   * @example
   * ```typescript
   * // Preferred: async disposal
   * const result = await container.disposeAsync();
   * if (result.ok) {
   *   console.log("Container disposed successfully");
   * }
   *
   * // Browser unload (sync required)
   * window.addEventListener('beforeunload', () => {
   *   container.dispose();  // Sync fallback
   * });
   * ```
   */
  async disposeAsync() {
    const result = await this.scopeManager.disposeAsync();
    if (result.ok) {
      this.validationManager.resetValidationState();
    }
    return result;
  }
  /**
   * Clear all registrations and instances.
   *
   * IMPORTANT: Resets validation state (per review feedback).
   */
  clear() {
    this.registry.clear();
    this.cache.clear();
    this.validationManager.resetValidationState();
    return ok(void 0);
  }
  /**
   * Creates bootstrap dependencies for a scope (RuntimeConfig, PerformanceTracker, Resolver).
   *
   * **Responsibility:** Bootstrap dependency creation (extracted from createScope for SRP).
   * This method encapsulates the creation of bootstrap-specific components to separate
   * concerns from container logic.
   *
   * @private
   * @param registry - Service registry for the scope
   * @param cache - Instance cache for the scope
   * @param parentResolver - Parent resolver for singleton delegation
   * @param scopeName - Name of the scope
   * @returns Object with resolver and performance tracker
   */
  /**
   * Creates bootstrap dependencies for a scope (RuntimeConfig, PerformanceTracker, Resolver).
   *
   * **Responsibility:** Bootstrap dependency creation (extracted from createScope for SRP).
   * This method encapsulates the creation of bootstrap-specific components to separate
   * concerns from container logic.
   *
   * @private
   * @param registry - Service registry for the scope
   * @param cache - Instance cache for the scope
   * @param parentResolver - Parent resolver for singleton delegation
   * @param scopeName - Name of the scope
   * @returns Object with resolver and performance tracker
   */
  createBootstrapDependencies(registry, cache, parentResolver, scopeName) {
    const runtimeConfig = new RuntimeConfigAdapter(this.env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver = new ServiceResolver(
      registry,
      cache,
      parentResolver,
      scopeName,
      performanceTracker
    );
    return { resolver, performanceTracker };
  }
};
__name(_ServiceContainer, "ServiceContainer");
let ServiceContainer = _ServiceContainer;
const _ContainerBootstrapFactory = class _ContainerBootstrapFactory {
  /**
   * Creates a root ServiceContainer with bootstrap dependencies.
   *
   * Creates and wires:
   * - RuntimeConfig from environment
   * - BootstrapPerformanceTracker (no MetricsCollector during bootstrap)
   * - ServiceResolver with performance tracking
   * - ServiceContainer with all dependencies
   *
   * @param env - Environment configuration
   * @returns A new root ServiceContainer
   */
  createRoot(env) {
    const registry = new ServiceRegistry();
    const validator = new ContainerValidator();
    const cache = new InstanceCache();
    const scopeManager = new ScopeManager("root", null, cache);
    const runtimeConfig = new RuntimeConfigAdapter(env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver = new ServiceResolver(registry, cache, null, "root", performanceTracker);
    return new ServiceContainer(
      registry,
      validator,
      cache,
      resolver,
      scopeManager,
      "registering",
      env
    );
  }
  /**
   * Creates a child scope container with bootstrap dependencies.
   *
   * Creates and wires:
   * - RuntimeConfig from parent's environment
   * - BootstrapPerformanceTracker for child scope
   * - ServiceResolver with performance tracking
   * - Child ServiceContainer with all dependencies
   *
   * @param parent - Parent container
   * @param name - Optional custom name for the scope
   * @returns Result with child container or error
   */
  createScope(parent, name) {
    return parent.createScope(name);
  }
};
__name(_ContainerBootstrapFactory, "ContainerBootstrapFactory");
let ContainerBootstrapFactory = _ContainerBootstrapFactory;
const _ContainerFactory = class _ContainerFactory {
  /**
   * Creates a new ContainerFactory instance.
   *
   * @param bootstrapFactory - Optional bootstrap factory (defaults to new instance)
   */
  constructor(bootstrapFactory) {
    this.bootstrapFactory = bootstrapFactory ?? new ContainerBootstrapFactory();
  }
  /**
   * Creates a root ServiceContainer with the given environment configuration.
   *
   * Delegates to ContainerBootstrapFactory to maintain SRP (bootstrap logic separated).
   *
   * @param env - Environment configuration
   * @returns A new ServiceContainer instance
   */
  createRoot(env) {
    return this.bootstrapFactory.createRoot(env);
  }
};
__name(_ContainerFactory, "ContainerFactory");
let ContainerFactory = _ContainerFactory;
const environmentConfigToken = createInjectionToken("EnvironmentConfig");
const containerHealthCheckToken = createInjectionToken("ContainerHealthCheck");
const metricsHealthCheckToken = createInjectionToken("MetricsHealthCheck");
const healthCheckRegistryToken = createInjectionToken("PlatformHealthCheckPort");
const serviceContainerToken = createInjectionToken("ServiceContainer");
const runtimeConfigToken = createInjectionToken(
  "PlatformRuntimeConfigPort"
);
const platformNotificationPortToken = createInjectionToken(
  "PlatformNotificationPort"
);
const notificationPublisherPortToken = createInjectionToken(
  "NotificationPublisherPort"
);
const notificationChannelRegistryPortToken = createInjectionToken("NotificationChannelRegistryPort");
const cacheReaderPortToken = createInjectionToken("CacheReaderPort");
const cacheWriterPortToken = createInjectionToken("CacheWriterPort");
const cacheInvalidationPortToken = createInjectionToken("CacheInvalidationPort");
const cacheStatsPortToken = createInjectionToken("CacheStatsPort");
const cacheComputePortToken = createInjectionToken("CacheComputePort");
const platformI18nPortToken = createInjectionToken("PlatformI18nPort");
const platformUIPortToken = createInjectionToken("PlatformUIPort");
const platformJournalDirectoryUiPortToken = createInjectionToken("PlatformJournalDirectoryUiPort");
const platformUINotificationPortToken = createInjectionToken(
  "PlatformUINotificationPort"
);
const platformSettingsPortToken = createInjectionToken("PlatformSettingsPort");
const platformJournalEventPortToken = createInjectionToken(
  "PlatformJournalEventPort"
);
const platformJournalUiEventPortToken = createInjectionToken(
  "PlatformJournalUiEventPort"
);
const platformJournalCollectionPortToken = createInjectionToken("PlatformJournalCollectionPort");
const platformJournalRepositoryToken = createInjectionToken(
  "PlatformJournalRepository"
);
const platformContextMenuRegistrationPortToken = createInjectionToken("PlatformContextMenuRegistrationPort");
const platformValidationPortToken = createInjectionToken("PlatformValidationPort");
const platformLoggingPortToken = createInjectionToken("PlatformLoggingPort");
const platformMetricsSnapshotPortToken = createInjectionToken(
  "PlatformMetricsSnapshotPort"
);
const platformContainerPortToken = createInjectionToken("PlatformContainerPort");
const platformSettingsRegistrationPortToken = createInjectionToken("PlatformSettingsRegistrationPort");
const platformModuleReadyPortToken = createInjectionToken("PlatformModuleReadyPort");
const platformChannelPortToken = createInjectionToken("PlatformChannelPort");
const platformUINotificationChannelPortToken = createInjectionToken("PlatformUINotificationChannelPort");
const platformConsoleChannelPortToken = createInjectionToken(
  "PlatformConsoleChannelPort"
);
const platformUIAvailabilityPortToken = createInjectionToken(
  "PlatformUIAvailabilityPort"
);
const _ContainerHealthCheck = class _ContainerHealthCheck {
  constructor(container) {
    this.name = "container";
    this.container = container;
  }
  check() {
    return this.container.getValidationState() === "validated";
  }
  getDetails() {
    const state2 = this.container.getValidationState();
    if (state2 !== "validated") {
      return `Container state: ${state2}`;
    }
    return null;
  }
  dispose() {
  }
};
__name(_ContainerHealthCheck, "ContainerHealthCheck");
let ContainerHealthCheck = _ContainerHealthCheck;
const _DIContainerHealthCheck = class _DIContainerHealthCheck extends ContainerHealthCheck {
  constructor(container, registry) {
    super(container);
    registry.register(this);
  }
};
__name(_DIContainerHealthCheck, "DIContainerHealthCheck");
_DIContainerHealthCheck.dependencies = [platformContainerPortToken, healthCheckRegistryToken];
let DIContainerHealthCheck = _DIContainerHealthCheck;
function getDIContainerHealthCheckClass() {
  return DIContainerHealthCheck;
}
__name(getDIContainerHealthCheckClass, "getDIContainerHealthCheckClass");
const _MetricsHealthCheck = class _MetricsHealthCheck {
  constructor(metricsSnapshotPort) {
    this.name = "metrics";
    this.metricsSnapshotPort = metricsSnapshotPort;
  }
  check() {
    const snapshot2 = this.metricsSnapshotPort.getSnapshot();
    const hasPortFailures = Object.keys(snapshot2.portSelectionFailures).length > 0;
    const hasResolutionErrors = snapshot2.resolutionErrors > 0;
    return !hasPortFailures && !hasResolutionErrors;
  }
  getDetails() {
    const snapshot2 = this.metricsSnapshotPort.getSnapshot();
    const failures = Object.keys(snapshot2.portSelectionFailures);
    if (failures.length > 0) {
      return `Port selection failures: ${failures.join(", ")}`;
    }
    if (snapshot2.resolutionErrors > 0) {
      return `Resolution errors: ${snapshot2.resolutionErrors}`;
    }
    return null;
  }
  dispose() {
  }
};
__name(_MetricsHealthCheck, "MetricsHealthCheck");
let MetricsHealthCheck = _MetricsHealthCheck;
const _DIMetricsHealthCheck = class _DIMetricsHealthCheck extends MetricsHealthCheck {
  constructor(metricsSnapshotPort, registry) {
    super(metricsSnapshotPort);
    registry.register(this);
  }
};
__name(_DIMetricsHealthCheck, "DIMetricsHealthCheck");
_DIMetricsHealthCheck.dependencies = [platformMetricsSnapshotPortToken, healthCheckRegistryToken];
let DIMetricsHealthCheck = _DIMetricsHealthCheck;
function getDIMetricsHealthCheckClass() {
  return DIMetricsHealthCheck;
}
__name(getDIMetricsHealthCheckClass, "getDIMetricsHealthCheckClass");
const moduleIdToken = createInjectionToken("ModuleId");
const _DependencyRegistrationRegistry = class _DependencyRegistrationRegistry {
  constructor() {
    this.steps = [];
  }
  /**
   * Registers a new dependency registration step.
   * Steps are automatically sorted by priority after registration.
   * If a step with the same name already exists, it will be replaced.
   *
   * @param step - The registration step to add
   */
  register(step) {
    this.steps = this.steps.filter((s) => s.name !== step.name);
    this.steps.push(step);
    this.steps.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Resets the registry by clearing all registered steps.
   * This is primarily useful for testing scenarios where a clean state is needed.
   */
  reset() {
    this.steps = [];
  }
  /**
   * Executes all registered steps in priority order.
   * Stops at first error and returns it.
   *
   * @param container - The service container to configure
   * @returns Result indicating success or the first error encountered
   */
  configure(container) {
    for (const step of this.steps) {
      const result = step.execute(container);
      if (isErr(result)) {
        return err(`Failed at step '${step.name}': ${result.error}`);
      }
    }
    return ok(void 0);
  }
};
__name(_DependencyRegistrationRegistry, "DependencyRegistrationRegistry");
let DependencyRegistrationRegistry = _DependencyRegistrationRegistry;
const dependencyRegistry = new DependencyRegistrationRegistry();
function registerDependencyStep(step) {
  dependencyRegistry.register(step);
}
__name(registerDependencyStep, "registerDependencyStep");
const portSelectorToken = createInjectionToken("PortSelector");
const foundryGamePortRegistryToken = createInjectionToken("FoundryGamePortRegistry");
const foundryHooksPortRegistryToken = createInjectionToken(
  "FoundryHooksPortRegistry"
);
const foundryDocumentPortRegistryToken = createInjectionToken(
  "FoundryDocumentPortRegistry"
);
const foundryUIPortRegistryToken = createInjectionToken("FoundryUIPortRegistry");
const foundrySettingsPortRegistryToken = createInjectionToken(
  "FoundrySettingsPortRegistry"
);
const foundryI18nPortRegistryToken = createInjectionToken("FoundryI18nPortRegistry");
const foundryModulePortRegistryToken = createInjectionToken(
  "FoundryModulePortRegistry"
);
function createFoundryError(code, message2, details, cause) {
  return { code, message: message2, details, cause };
}
__name(createFoundryError, "createFoundryError");
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null;
}
__name(isErrorLike, "isErrorLike");
function isFoundryError(error) {
  if (!isErrorLike(error)) return false;
  return "code" in error && "message" in error && typeof error.code === "string" && typeof error.message === "string";
}
__name(isFoundryError, "isFoundryError");
const portSelectionEventEmitterToken = createInjectionToken(
  "PortSelectionEventEmitter"
);
const foundryVersionDetectorToken = createInjectionToken("FoundryVersionDetector");
const _PortResolutionStrategy = class _PortResolutionStrategy {
  constructor(container) {
    this.container = container;
  }
  /**
   * Resolves a port from the DI container using the provided injection token.
   *
   * @template T - The port type
   * @param token - The injection token for the port
   * @returns Result with resolved port or FoundryError
   *
   * @example
   * ```typescript
   * const strategy = new PortResolutionStrategy(container);
   * const portResult = strategy.resolve(foundryV13GamePortToken);
   * if (portResult.ok) {
   *   const port = portResult.value;
   * }
   * ```
   */
  resolve(token) {
    try {
      const resolveResult = this.container.resolveWithError(token);
      if (!resolveResult.ok) {
        return err(
          createFoundryError(
            "PORT_RESOLUTION_FAILED",
            `Failed to resolve port from container`,
            { token: String(token) },
            resolveResult.error
          )
        );
      }
      return ok(castResolvedService(resolveResult.value));
    } catch (error) {
      return err(
        createFoundryError(
          "PORT_RESOLUTION_FAILED",
          `Failed to resolve port from container`,
          { token: String(token) },
          error instanceof Error ? error : new Error(String(error))
        )
      );
    }
  }
};
__name(_PortResolutionStrategy, "PortResolutionStrategy");
let PortResolutionStrategy = _PortResolutionStrategy;
const portSelectionObservabilityToken = createInjectionToken(
  "PortSelectionObservability"
);
const portSelectionPerformanceTrackerToken = createInjectionToken("PortSelectionPerformanceTracker");
const portSelectionObserverToken = createInjectionToken("PortSelectionObserver");
function createMatchError(message2, details) {
  return {
    code: "PORT_SELECTION_FAILED",
    message: message2,
    details
  };
}
__name(createMatchError, "createMatchError");
const _GreedyPortMatchStrategy = class _GreedyPortMatchStrategy {
  /**
   * Selects the highest compatible port version.
   *
   * Algorithm:
   * 1. Never select a port with version > current Foundry version
   *    (prevents using APIs that don't exist yet)
   * 2. Select the highest port version that is <= Foundry version
   *    (use the newest compatible implementation)
   *
   * Time Complexity: O(n) where n = number of registered ports
   * Space Complexity: O(1)
   *
   * @param tokens - Map of version numbers to injection tokens
   * @param foundryVersion - The current Foundry version to match against
   * @returns Result with matched port token and version, or error if no match found
   *
   * @example
   * ```typescript
   * const strategy = new GreedyPortMatchStrategy();
   * const tokens = new Map([
   *   [13, foundryV13GamePortToken],
   *   [14, foundryV14GamePortToken]
   * ]);
   * // Foundry v14: selects v14
   * // Foundry v13: selects v13
   * // Foundry v15: selects v14 (fallback to highest available)
   * const result = strategy.select(tokens, 14);
   * ```
   */
  select(tokens, foundryVersion) {
    let selectedToken;
    let selectedVersion = APP_DEFAULTS.NO_VERSION_SELECTED;
    for (const [portVersion, token] of tokens.entries()) {
      if (portVersion > foundryVersion) {
        continue;
      }
      if (portVersion > selectedVersion) {
        selectedVersion = portVersion;
        selectedToken = token;
      }
    }
    if (selectedToken === void 0) {
      const availableVersions = Array.from(tokens.keys()).sort((a, b) => a - b).join(", ");
      return err(
        createMatchError(`No compatible port found for Foundry version ${foundryVersion}`, {
          version: foundryVersion,
          availableVersions: availableVersions || "none"
        })
      );
    }
    return ok({
      token: selectedToken,
      version: selectedVersion
    });
  }
};
__name(_GreedyPortMatchStrategy, "GreedyPortMatchStrategy");
let GreedyPortMatchStrategy = _GreedyPortMatchStrategy;
const _PortSelector = class _PortSelector {
  constructor(versionDetector, eventEmitter, observability, performanceTracker, observer, container, matchStrategy) {
    this.versionDetector = versionDetector;
    this.eventEmitter = eventEmitter;
    this.observability = observability;
    this.performanceTracker = performanceTracker;
    this.observer = observer;
    this.observability.registerWithObservabilityRegistry(this);
    this.observability.setupObservability(this, this.observer);
    this.resolutionStrategy = new PortResolutionStrategy(container);
    this.matchStrategy = matchStrategy ?? new GreedyPortMatchStrategy();
  }
  /**
   * Subscribe to port selection events.
   *
   * Allows observers to be notified of port selection success/failure for
   * logging, metrics, and other observability concerns.
   *
   * @param callback - Function to call when port selection events occur
   * @returns Unsubscribe function
   *
   * @example
   * ```typescript
   * const selector = new PortSelector();
   * const unsubscribe = selector.onEvent((event) => {
   *   if (event.type === 'success') {
   *     console.log(`Port v${event.selectedVersion} selected`);
   *   }
   * });
   * ```
   */
  onEvent(callback) {
    return this.eventEmitter.subscribe(callback);
  }
  /**
   * Selects and resolves the appropriate port from injection tokens.
   *
   * CRITICAL: Works with token map to avoid eager instantiation.
   * Only the selected token is resolved from the DI container, preventing crashes from
   * incompatible constructors accessing unavailable APIs.
   *
   * @template T - The port type
   * @param tokens - Map of version numbers to injection tokens
   * @param foundryVersion - Optional version override (uses getFoundryVersion() if not provided)
   * @param adapterName - Optional adapter name for observability
   * @returns Result with resolved port or error
   *
   * @example
   * ```typescript
   * const tokens = new Map([
   *   [13, foundryV13GamePortToken],
   *   [14, foundryV14GamePortToken]
   * ]);
   * const selector = new PortSelector(eventEmitter, observability, container);
   * const result = selector.selectPortFromTokens(tokens);
   * // On Foundry v13: resolves only v13 port from container (v14 token never resolved)
   * // On Foundry v14: resolves v14 port from container
   * ```
   */
  selectPortFromTokens(tokens, foundryVersion, adapterName) {
    this.performanceTracker.startTracking();
    let version;
    if (foundryVersion !== void 0) {
      version = foundryVersion;
    } else {
      const versionResult = this.versionDetector.getVersion();
      if (!versionResult.ok) {
        this.performanceTracker.endTracking();
        this.observer.handleEvent({
          type: "failure",
          foundryVersion: 0,
          // Unknown version
          availableVersions: Array.from(tokens.keys()).sort((a, b) => a - b).join(", "),
          ...adapterName !== void 0 ? { adapterName } : {},
          error: createFoundryError(
            "PORT_SELECTION_FAILED",
            "Could not determine Foundry version",
            void 0,
            versionResult.error
          )
        });
        return err(
          createFoundryError(
            "PORT_SELECTION_FAILED",
            "Could not determine Foundry version",
            void 0,
            versionResult.error
          )
        );
      }
      version = versionResult.value;
    }
    const tokensForStrategy = tokens;
    const matchResult = this.matchStrategy.select(tokensForStrategy, version);
    if (!matchResult.ok) {
      this.performanceTracker.endTracking();
      const errorDetails = matchResult.error.details;
      let availableVersions;
      if (typeof errorDetails === "object" && errorDetails !== null && "availableVersions" in errorDetails && typeof errorDetails.availableVersions === "string") {
        availableVersions = errorDetails.availableVersions;
      } else {
        availableVersions = Array.from(tokens.keys()).sort((a, b) => a - b).join(", ");
      }
      this.observer.handleEvent({
        type: "failure",
        foundryVersion: version,
        availableVersions,
        ...adapterName !== void 0 ? { adapterName } : {},
        error: matchResult.error
      });
      return err(matchResult.error);
    }
    const { token: selectedToken, version: selectedVersion } = matchResult.value;
    const typedToken = selectedToken;
    const portResult = this.resolutionStrategy.resolve(typedToken);
    if (!portResult.ok) {
      this.performanceTracker.endTracking();
      this.observer.handleEvent({
        type: "failure",
        foundryVersion: version,
        availableVersions: Array.from(tokens.keys()).sort((a, b) => a - b).join(", "),
        ...adapterName !== void 0 ? { adapterName } : {},
        error: portResult.error
      });
      return err(portResult.error);
    }
    const durationMs = this.performanceTracker.endTracking();
    this.observer.handleEvent({
      type: "success",
      selectedVersion,
      foundryVersion: version,
      ...adapterName !== void 0 ? { adapterName } : {},
      durationMs
    });
    return ok(portResult.value);
  }
};
__name(_PortSelector, "PortSelector");
let PortSelector = _PortSelector;
const _DIPortSelector = class _DIPortSelector extends PortSelector {
  constructor(versionDetector, eventEmitter, observability, performanceTracker, observer, container) {
    super(versionDetector, eventEmitter, observability, performanceTracker, observer, container);
  }
};
__name(_DIPortSelector, "DIPortSelector");
_DIPortSelector.dependencies = [
  foundryVersionDetectorToken,
  portSelectionEventEmitterToken,
  portSelectionObservabilityToken,
  portSelectionPerformanceTrackerToken,
  portSelectionObserverToken,
  serviceContainerToken
];
let DIPortSelector = _DIPortSelector;
let cachedVersion = null;
function detectFoundryVersion() {
  if (typeof game === "undefined") {
    return err("Foundry game object is not available or version cannot be determined");
  }
  const versionString = game.version;
  if (!versionString) {
    return err("Foundry version is not available on the game object");
  }
  const versionStr = versionString.match(/^(\d+)/)?.[1];
  if (!versionStr) {
    return err(`Could not parse Foundry version from: ${versionString}`);
  }
  return ok(Number.parseInt(versionStr, 10));
}
__name(detectFoundryVersion, "detectFoundryVersion");
function getFoundryVersionResult() {
  if (cachedVersion === null) {
    cachedVersion = detectFoundryVersion();
  }
  return cachedVersion;
}
__name(getFoundryVersionResult, "getFoundryVersionResult");
function resetVersionCache() {
  cachedVersion = null;
}
__name(resetVersionCache, "resetVersionCache");
function tryGetFoundryVersion() {
  const result = getFoundryVersionResult();
  return result.ok ? result.value : void 0;
}
__name(tryGetFoundryVersion, "tryGetFoundryVersion");
const _FoundryVersionDetector = class _FoundryVersionDetector {
  /**
   * Gets the major version number of the currently running Foundry VTT instance.
   *
   * @returns Result with major version number (e.g., 13 for "13.348") or FoundryError
   *
   * @example
   * ```typescript
   * const detector = new FoundryVersionDetector();
   * const versionResult = detector.getVersion();
   * if (versionResult.ok) {
   *   console.log(`Foundry version: ${versionResult.value}`);
   * }
   * ```
   */
  getVersion() {
    const versionResult = getFoundryVersionResult();
    if (!versionResult.ok) {
      return err(
        createFoundryError(
          "VERSION_DETECTION_FAILED",
          "Could not determine Foundry version",
          void 0,
          versionResult.error
        )
      );
    }
    return ok(versionResult.value);
  }
};
__name(_FoundryVersionDetector, "FoundryVersionDetector");
let FoundryVersionDetector = _FoundryVersionDetector;
const _DIFoundryVersionDetector = class _DIFoundryVersionDetector extends FoundryVersionDetector {
  constructor() {
    super();
  }
};
__name(_DIFoundryVersionDetector, "DIFoundryVersionDetector");
_DIFoundryVersionDetector.dependencies = [];
let DIFoundryVersionDetector = _DIFoundryVersionDetector;
const _PortRegistry = class _PortRegistry {
  constructor() {
    this.tokens = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a port injection token for a specific Foundry version.
   * @param version - The Foundry version this port supports
   * @param token - Injection token for resolving the port from the DI container
   * @returns Result indicating success or duplicate registration error
   */
  register(version, token) {
    if (this.tokens.has(version)) {
      return err(
        createFoundryError(
          "PORT_REGISTRY_ERROR",
          `Port for version ${version} already registered`,
          { version }
        )
      );
    }
    this.tokens.set(version, token);
    return ok(void 0);
  }
  /**
   * Gets all registered port versions.
   * @returns Array of registered version numbers, sorted ascending
   */
  getAvailableVersions() {
    return Array.from(this.tokens.keys()).sort((a, b) => a - b);
  }
  /**
   * Gets the token map without resolving ports.
   * Use with PortSelector.selectPortFromTokens() for safe lazy instantiation via DI.
   *
   * @returns Map of version numbers to injection tokens (NOT instances)
   *
   * @example
   * ```typescript
   * const registry = new PortRegistry<FoundryGame>();
   * registry.register(13, foundryV13GamePortToken);
   * registry.register(14, foundryGamePortV14Token);
   *
   * const tokens = registry.getTokens();
   * const selector = new PortSelector(container);
   * const result = selector.selectPortFromTokens(tokens);
   * // Only compatible port is resolved from container
   * ```
   */
  getTokens() {
    return new Map(this.tokens);
  }
  /**
   * Checks if a port is registered for a specific version.
   * @param version - The version to check
   * @returns True if a port is registered for this version
   */
  hasVersion(version) {
    return this.tokens.has(version);
  }
  /**
   * Gets the highest registered port version.
   * @returns The highest version number or undefined if no ports are registered
   */
  getHighestVersion() {
    const versions = this.getAvailableVersions();
    return versions.at(-1);
  }
};
__name(_PortRegistry, "PortRegistry");
let PortRegistry = _PortRegistry;
let store$4;
function setGlobalConfig(config$1) {
  store$4 = {
    ...store$4,
    ...config$1
  };
}
__name(setGlobalConfig, "setGlobalConfig");
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config$1) {
  return {
    lang: config$1?.lang ?? store$4?.lang,
    message: config$1?.message,
    abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
    abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
  };
}
__name(getGlobalConfig, "getGlobalConfig");
function deleteGlobalConfig() {
  store$4 = void 0;
}
__name(deleteGlobalConfig, "deleteGlobalConfig");
let store$3;
function setGlobalMessage(message$1, lang) {
  if (!store$3) store$3 = /* @__PURE__ */ new Map();
  store$3.set(lang, message$1);
}
__name(setGlobalMessage, "setGlobalMessage");
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
  return store$3?.get(lang);
}
__name(getGlobalMessage, "getGlobalMessage");
function deleteGlobalMessage(lang) {
  store$3?.delete(lang);
}
__name(deleteGlobalMessage, "deleteGlobalMessage");
let store$2;
function setSchemaMessage(message$1, lang) {
  if (!store$2) store$2 = /* @__PURE__ */ new Map();
  store$2.set(lang, message$1);
}
__name(setSchemaMessage, "setSchemaMessage");
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
  return store$2?.get(lang);
}
__name(getSchemaMessage, "getSchemaMessage");
function deleteSchemaMessage(lang) {
  store$2?.delete(lang);
}
__name(deleteSchemaMessage, "deleteSchemaMessage");
let store$1;
function setSpecificMessage(reference, message$1, lang) {
  if (!store$1) store$1 = /* @__PURE__ */ new Map();
  if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());
  store$1.get(reference).set(lang, message$1);
}
__name(setSpecificMessage, "setSpecificMessage");
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
  return store$1?.get(reference)?.get(lang);
}
__name(getSpecificMessage, "getSpecificMessage");
function deleteSpecificMessage(reference, lang) {
  store$1?.get(reference)?.delete(lang);
}
__name(deleteSpecificMessage, "deleteSpecificMessage");
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
  const type = typeof input;
  if (type === "string") return `"${input}"`;
  if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
  if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  return type;
}
__name(_stringify, "_stringify");
function _addIssue(context, label2, dataset, config$1, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label2}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config$1.lang,
    abortEarly: config$1.abortEarly,
    abortPipeEarly: config$1.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
  if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
  if (isSchema) dataset.typed = false;
  if (dataset.issues) dataset.issues.push(issue);
  else dataset.issues = [issue];
}
__name(_addIssue, "_addIssue");
let textEncoder;
// @__NO_SIDE_EFFECTS__
function _getByteCount(input) {
  if (!textEncoder) textEncoder = new TextEncoder();
  return textEncoder.encode(input).length;
}
__name(_getByteCount, "_getByteCount");
let segmenter;
// @__NO_SIDE_EFFECTS__
function _getGraphemeCount(input) {
  if (!segmenter) segmenter = new Intl.Segmenter();
  const segments = segmenter.segment(input);
  let count = 0;
  for (const _ of segments) count++;
  return count;
}
__name(_getGraphemeCount, "_getGraphemeCount");
// @__NO_SIDE_EFFECTS__
function _getLastMetadata(schema, type) {
  if ("pipe" in schema) {
    const nestedSchemas = [];
    for (let index2 = schema.pipe.length - 1; index2 >= 0; index2--) {
      const item = schema.pipe[index2];
      if (item.kind === "schema" && "pipe" in item) nestedSchemas.push(item);
      else if (item.kind === "metadata" && item.type === type) return item[type];
    }
    for (const nestedSchema of nestedSchemas) {
      const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);
      if (result !== void 0) return result;
    }
  }
}
__name(_getLastMetadata, "_getLastMetadata");
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value$1) {
      return context["~run"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());
    }
  };
}
__name(_getStandardProps, "_getStandardProps");
let store;
// @__NO_SIDE_EFFECTS__
function _getWordCount(locales, input) {
  if (!store) store = /* @__PURE__ */ new Map();
  if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: "word" }));
  const segments = store.get(locales).segment(input);
  let count = 0;
  for (const segment of segments) if (segment.isWordLike) count++;
  return count;
}
__name(_getWordCount, "_getWordCount");
const NON_DIGIT_REGEX = /\D/gu;
// @__NO_SIDE_EFFECTS__
function _isLuhnAlgo(input) {
  const number$1 = input.replace(NON_DIGIT_REGEX, "");
  let length$1 = number$1.length;
  let bit = 1;
  let sum = 0;
  while (length$1) {
    const value$1 = +number$1[--length$1];
    bit ^= 1;
    sum += bit ? [
      0,
      2,
      4,
      6,
      8,
      1,
      3,
      5,
      7,
      9
    ][value$1] : value$1;
  }
  return sum % 10 === 0;
}
__name(_isLuhnAlgo, "_isLuhnAlgo");
// @__NO_SIDE_EFFECTS__
function _isValidObjectKey(object$1, key2) {
  return Object.hasOwn(object$1, key2) && key2 !== "__proto__" && key2 !== "prototype" && key2 !== "constructor";
}
__name(_isValidObjectKey, "_isValidObjectKey");
// @__NO_SIDE_EFFECTS__
function _joinExpects(values$1, separator) {
  const list = [...new Set(values$1)];
  if (list.length > 1) return `(${list.join(` ${separator} `)})`;
  return list[0] ?? "never";
}
__name(_joinExpects, "_joinExpects");
// @__NO_SIDE_EFFECTS__
function entriesFromList(list, schema) {
  const entries$1 = {};
  for (const key2 of list) entries$1[key2] = schema;
  return entries$1;
}
__name(entriesFromList, "entriesFromList");
// @__NO_SIDE_EFFECTS__
function entriesFromObjects(schemas) {
  const entries$1 = {};
  for (const schema of schemas) Object.assign(entries$1, schema.entries);
  return entries$1;
}
__name(entriesFromObjects, "entriesFromObjects");
// @__NO_SIDE_EFFECTS__
function getDotPath(issue) {
  if (issue.path) {
    let key2 = "";
    for (const item of issue.path) if (typeof item.key === "string" || typeof item.key === "number") if (key2) key2 += `.${item.key}`;
    else key2 += item.key;
    else return null;
    return key2;
  }
  return null;
}
__name(getDotPath, "getDotPath");
// @__NO_SIDE_EFFECTS__
function isOfKind(kind, object$1) {
  return object$1.kind === kind;
}
__name(isOfKind, "isOfKind");
// @__NO_SIDE_EFFECTS__
function isOfType(type, object$1) {
  return object$1.type === type;
}
__name(isOfType, "isOfType");
// @__NO_SIDE_EFFECTS__
function isValiError(error) {
  return error instanceof ValiError;
}
__name(isValiError, "isValiError");
var ValiError = (_a = class extends Error {
  /**
  * Creates a Valibot error with useful information.
  *
  * @param issues The error issues.
  */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
}, __name(_a, "ValiError"), _a);
// @__NO_SIDE_EFFECTS__
function args(schema) {
  return {
    kind: "transformation",
    type: "args",
    reference: args,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = (...args_) => {
        const argsDataset = this.schema["~run"]({ value: args_ }, config$1);
        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
        return func(...argsDataset.value);
      };
      return dataset;
    }
  };
}
__name(args, "args");
// @__NO_SIDE_EFFECTS__
function argsAsync(schema) {
  return {
    kind: "transformation",
    type: "args",
    reference: argsAsync,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = async (...args$1) => {
        const argsDataset = await schema["~run"]({ value: args$1 }, config$1);
        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
        return func(...argsDataset.value);
      };
      return dataset;
    }
  };
}
__name(argsAsync, "argsAsync");
// @__NO_SIDE_EFFECTS__
function awaitAsync() {
  return {
    kind: "transformation",
    type: "await",
    reference: awaitAsync,
    async: true,
    async "~run"(dataset) {
      dataset.value = await dataset.value;
      return dataset;
    }
  };
}
__name(awaitAsync, "awaitAsync");
const BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
const BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
const CUID2_REGEX = /^[a-z][\da-z]*$/u;
const DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
const DIGITS_REGEX = /^\d+$/u;
const EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
const EMOJI_REGEX = /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation}))*)+$/u;
const HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
const HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
const IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
const IPV4_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
const IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
const IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
const ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
const ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
const ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
const ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
const ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
const ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
const MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
const MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
const MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
const NANO_ID_REGEX = /^[\w-]+$/u;
const OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
const RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
const ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
const UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
// @__NO_SIDE_EFFECTS__
function base64(message$1) {
  return {
    kind: "validation",
    type: "base64",
    reference: base64,
    async: false,
    expects: null,
    requirement: BASE64_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Base64", dataset, config$1);
      return dataset;
    }
  };
}
__name(base64, "base64");
// @__NO_SIDE_EFFECTS__
function bic(message$1) {
  return {
    kind: "validation",
    type: "bic",
    reference: bic,
    async: false,
    expects: null,
    requirement: BIC_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "BIC", dataset, config$1);
      return dataset;
    }
  };
}
__name(bic, "bic");
// @__NO_SIDE_EFFECTS__
function brand(name) {
  return {
    kind: "transformation",
    type: "brand",
    reference: brand,
    async: false,
    name,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(brand, "brand");
// @__NO_SIDE_EFFECTS__
function bytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "bytes",
    reference: bytes,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 !== this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(bytes, "bytes");
// @__NO_SIDE_EFFECTS__
function check(requirement, message$1) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(check, "check");
// @__NO_SIDE_EFFECTS__
function checkAsync(requirement, message$1) {
  return {
    kind: "validation",
    type: "check",
    reference: checkAsync,
    async: true,
    expects: null,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(checkAsync, "checkAsync");
// @__NO_SIDE_EFFECTS__
function checkItems(requirement, message$1) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItems,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) for (let index2 = 0; index2 < dataset.value.length; index2++) {
        const item = dataset.value[index2];
        if (!this.requirement(item, index2, dataset.value)) _addIssue(this, "item", dataset, config$1, {
          input: item,
          path: [{
            type: "array",
            origin: "value",
            input: dataset.value,
            key: index2,
            value: item
          }]
        });
      }
      return dataset;
    }
  };
}
__name(checkItems, "checkItems");
// @__NO_SIDE_EFFECTS__
function checkItemsAsync(requirement, message$1) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItemsAsync,
    async: true,
    expects: null,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if (dataset.typed) {
        const requirementResults = await Promise.all(dataset.value.map(this.requirement));
        for (let index2 = 0; index2 < dataset.value.length; index2++) if (!requirementResults[index2]) {
          const item = dataset.value[index2];
          _addIssue(this, "item", dataset, config$1, {
            input: item,
            path: [{
              type: "array",
              origin: "value",
              input: dataset.value,
              key: index2,
              value: item
            }]
          });
        }
      }
      return dataset;
    }
  };
}
__name(checkItemsAsync, "checkItemsAsync");
const CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
const SANITIZE_REGEX = /[- ]/gu;
const PROVIDER_REGEX_LIST = [
  /^3[47]\d{13}$/u,
  /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
  /^6(?:011|5\d{2})\d{12,15}$/u,
  /^(?:2131|1800|35\d{3})\d{11}$/u,
  /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
  /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
  /^4\d{12}(?:\d{3,6})?$/u
];
// @__NO_SIDE_EFFECTS__
function creditCard(message$1) {
  return {
    kind: "validation",
    type: "credit_card",
    reference: creditCard,
    async: false,
    expects: null,
    requirement(input) {
      let sanitized;
      return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, "")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "credit card", dataset, config$1);
      return dataset;
    }
  };
}
__name(creditCard, "creditCard");
// @__NO_SIDE_EFFECTS__
function cuid2(message$1) {
  return {
    kind: "validation",
    type: "cuid2",
    reference: cuid2,
    async: false,
    expects: null,
    requirement: CUID2_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Cuid2", dataset, config$1);
      return dataset;
    }
  };
}
__name(cuid2, "cuid2");
// @__NO_SIDE_EFFECTS__
function decimal(message$1) {
  return {
    kind: "validation",
    type: "decimal",
    reference: decimal,
    async: false,
    expects: null,
    requirement: DECIMAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "decimal", dataset, config$1);
      return dataset;
    }
  };
}
__name(decimal, "decimal");
// @__NO_SIDE_EFFECTS__
function description(description_) {
  return {
    kind: "metadata",
    type: "description",
    reference: description,
    description: description_
  };
}
__name(description, "description");
// @__NO_SIDE_EFFECTS__
function digits(message$1) {
  return {
    kind: "validation",
    type: "digits",
    reference: digits,
    async: false,
    expects: null,
    requirement: DIGITS_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "digits", dataset, config$1);
      return dataset;
    }
  };
}
__name(digits, "digits");
// @__NO_SIDE_EFFECTS__
function email(message$1) {
  return {
    kind: "validation",
    type: "email",
    reference: email,
    expects: null,
    async: false,
    requirement: EMAIL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
      return dataset;
    }
  };
}
__name(email, "email");
// @__NO_SIDE_EFFECTS__
function emoji(message$1) {
  return {
    kind: "validation",
    type: "emoji",
    reference: emoji,
    async: false,
    expects: null,
    requirement: EMOJI_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "emoji", dataset, config$1);
      return dataset;
    }
  };
}
__name(emoji, "emoji");
// @__NO_SIDE_EFFECTS__
function empty$1(message$1) {
  return {
    kind: "validation",
    type: "empty",
    reference: empty$1,
    async: false,
    expects: "0",
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length > 0) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(empty$1, "empty$1");
// @__NO_SIDE_EFFECTS__
function endsWith(requirement, message$1) {
  return {
    kind: "validation",
    type: "ends_with",
    reference: endsWith,
    async: false,
    expects: `"${requirement}"`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, "end", dataset, config$1, { received: `"${dataset.value.slice(-this.requirement.length)}"` });
      return dataset;
    }
  };
}
__name(endsWith, "endsWith");
// @__NO_SIDE_EFFECTS__
function entries(requirement, message$1) {
  return {
    kind: "validation",
    type: "entries",
    reference: entries,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count !== this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(entries, "entries");
// @__NO_SIDE_EFFECTS__
function everyItem(requirement, message$1) {
  return {
    kind: "validation",
    type: "every_item",
    reference: everyItem,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
      return dataset;
    }
  };
}
__name(everyItem, "everyItem");
// @__NO_SIDE_EFFECTS__
function examples(examples_) {
  return {
    kind: "metadata",
    type: "examples",
    reference: examples,
    examples: examples_
  };
}
__name(examples, "examples");
// @__NO_SIDE_EFFECTS__
function excludes(requirement, message$1) {
  const received = /* @__PURE__ */ _stringify(requirement);
  return {
    kind: "validation",
    type: "excludes",
    reference: excludes,
    async: false,
    expects: `!${received}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received });
      return dataset;
    }
  };
}
__name(excludes, "excludes");
// @__NO_SIDE_EFFECTS__
function filterItems(operation) {
  return {
    kind: "transformation",
    type: "filter_items",
    reference: filterItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.filter(this.operation);
      return dataset;
    }
  };
}
__name(filterItems, "filterItems");
// @__NO_SIDE_EFFECTS__
function findItem(operation) {
  return {
    kind: "transformation",
    type: "find_item",
    reference: findItem,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.find(this.operation);
      return dataset;
    }
  };
}
__name(findItem, "findItem");
// @__NO_SIDE_EFFECTS__
function finite(message$1) {
  return {
    kind: "validation",
    type: "finite",
    reference: finite,
    async: false,
    expects: null,
    requirement: Number.isFinite,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "finite", dataset, config$1);
      return dataset;
    }
  };
}
__name(finite, "finite");
// @__NO_SIDE_EFFECTS__
function flavor(name) {
  return {
    kind: "transformation",
    type: "flavor",
    reference: flavor,
    async: false,
    name,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(flavor, "flavor");
// @__NO_SIDE_EFFECTS__
function graphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "graphemes",
    reference: graphemes,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count !== this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(graphemes, "graphemes");
// @__NO_SIDE_EFFECTS__
function gtValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "gt_value",
    reference: gtValue,
    async: false,
    expects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(gtValue, "gtValue");
const HASH_LENGTHS = {
  md4: 32,
  md5: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8,
  adler32: 8
};
// @__NO_SIDE_EFFECTS__
function hash$1(types, message$1) {
  return {
    kind: "validation",
    type: "hash",
    reference: hash$1,
    expects: null,
    async: false,
    requirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hash", dataset, config$1);
      return dataset;
    }
  };
}
__name(hash$1, "hash$1");
// @__NO_SIDE_EFFECTS__
function hexadecimal(message$1) {
  return {
    kind: "validation",
    type: "hexadecimal",
    reference: hexadecimal,
    async: false,
    expects: null,
    requirement: HEXADECIMAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hexadecimal", dataset, config$1);
      return dataset;
    }
  };
}
__name(hexadecimal, "hexadecimal");
// @__NO_SIDE_EFFECTS__
function hexColor(message$1) {
  return {
    kind: "validation",
    type: "hex_color",
    reference: hexColor,
    async: false,
    expects: null,
    requirement: HEX_COLOR_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hex color", dataset, config$1);
      return dataset;
    }
  };
}
__name(hexColor, "hexColor");
// @__NO_SIDE_EFFECTS__
function imei(message$1) {
  return {
    kind: "validation",
    type: "imei",
    reference: imei,
    async: false,
    expects: null,
    requirement(input) {
      return IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "IMEI", dataset, config$1);
      return dataset;
    }
  };
}
__name(imei, "imei");
// @__NO_SIDE_EFFECTS__
function includes(requirement, message$1) {
  const expects = /* @__PURE__ */ _stringify(requirement);
  return {
    kind: "validation",
    type: "includes",
    reference: includes,
    async: false,
    expects,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received: `!${expects}` });
      return dataset;
    }
  };
}
__name(includes, "includes");
// @__NO_SIDE_EFFECTS__
function integer(message$1) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
      return dataset;
    }
  };
}
__name(integer, "integer");
// @__NO_SIDE_EFFECTS__
function ip(message$1) {
  return {
    kind: "validation",
    type: "ip",
    reference: ip,
    async: false,
    expects: null,
    requirement: IP_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IP", dataset, config$1);
      return dataset;
    }
  };
}
__name(ip, "ip");
// @__NO_SIDE_EFFECTS__
function ipv4(message$1) {
  return {
    kind: "validation",
    type: "ipv4",
    reference: ipv4,
    async: false,
    expects: null,
    requirement: IPV4_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv4", dataset, config$1);
      return dataset;
    }
  };
}
__name(ipv4, "ipv4");
// @__NO_SIDE_EFFECTS__
function ipv6(message$1) {
  return {
    kind: "validation",
    type: "ipv6",
    reference: ipv6,
    async: false,
    expects: null,
    requirement: IPV6_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv6", dataset, config$1);
      return dataset;
    }
  };
}
__name(ipv6, "ipv6");
// @__NO_SIDE_EFFECTS__
function isoDate(message$1) {
  return {
    kind: "validation",
    type: "iso_date",
    reference: isoDate,
    async: false,
    expects: null,
    requirement: ISO_DATE_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoDate, "isoDate");
// @__NO_SIDE_EFFECTS__
function isoDateTime(message$1) {
  return {
    kind: "validation",
    type: "iso_date_time",
    reference: isoDateTime,
    async: false,
    expects: null,
    requirement: ISO_DATE_TIME_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date-time", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoDateTime, "isoDateTime");
// @__NO_SIDE_EFFECTS__
function isoTime(message$1) {
  return {
    kind: "validation",
    type: "iso_time",
    reference: isoTime,
    async: false,
    expects: null,
    requirement: ISO_TIME_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTime, "isoTime");
// @__NO_SIDE_EFFECTS__
function isoTimeSecond(message$1) {
  return {
    kind: "validation",
    type: "iso_time_second",
    reference: isoTimeSecond,
    async: false,
    expects: null,
    requirement: ISO_TIME_SECOND_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time-second", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTimeSecond, "isoTimeSecond");
// @__NO_SIDE_EFFECTS__
function isoTimestamp(message$1) {
  return {
    kind: "validation",
    type: "iso_timestamp",
    reference: isoTimestamp,
    async: false,
    expects: null,
    requirement: ISO_TIMESTAMP_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "timestamp", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTimestamp, "isoTimestamp");
// @__NO_SIDE_EFFECTS__
function isoWeek(message$1) {
  return {
    kind: "validation",
    type: "iso_week",
    reference: isoWeek,
    async: false,
    expects: null,
    requirement: ISO_WEEK_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "week", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoWeek, "isoWeek");
// @__NO_SIDE_EFFECTS__
function length(requirement, message$1) {
  return {
    kind: "validation",
    type: "length",
    reference: length,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(length, "length");
// @__NO_SIDE_EFFECTS__
function ltValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "lt_value",
    reference: ltValue,
    async: false,
    expects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(ltValue, "ltValue");
// @__NO_SIDE_EFFECTS__
function mac(message$1) {
  return {
    kind: "validation",
    type: "mac",
    reference: mac,
    async: false,
    expects: null,
    requirement: MAC_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac, "mac");
// @__NO_SIDE_EFFECTS__
function mac48(message$1) {
  return {
    kind: "validation",
    type: "mac48",
    reference: mac48,
    async: false,
    expects: null,
    requirement: MAC48_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "48-bit MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac48, "mac48");
// @__NO_SIDE_EFFECTS__
function mac64(message$1) {
  return {
    kind: "validation",
    type: "mac64",
    reference: mac64,
    async: false,
    expects: null,
    requirement: MAC64_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "64-bit MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac64, "mac64");
// @__NO_SIDE_EFFECTS__
function mapItems(operation) {
  return {
    kind: "transformation",
    type: "map_items",
    reference: mapItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.map(this.operation);
      return dataset;
    }
  };
}
__name(mapItems, "mapItems");
// @__NO_SIDE_EFFECTS__
function maxBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_bytes",
    reference: maxBytes,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 > this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(maxBytes, "maxBytes");
// @__NO_SIDE_EFFECTS__
function maxEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_entries",
    reference: maxEntries,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count > this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(maxEntries, "maxEntries");
// @__NO_SIDE_EFFECTS__
function maxGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_graphemes",
    reference: maxGraphemes,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count > this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(maxGraphemes, "maxGraphemes");
// @__NO_SIDE_EFFECTS__
function maxLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(maxLength, "maxLength");
// @__NO_SIDE_EFFECTS__
function maxSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_size",
    reference: maxSize,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(maxSize, "maxSize");
// @__NO_SIDE_EFFECTS__
function maxValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue,
    async: false,
    expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(maxValue, "maxValue");
// @__NO_SIDE_EFFECTS__
function maxWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "max_words",
    reference: maxWords,
    async: false,
    expects: `<=${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count > this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(maxWords, "maxWords");
// @__NO_SIDE_EFFECTS__
function metadata(metadata_) {
  return {
    kind: "metadata",
    type: "metadata",
    reference: metadata,
    metadata: metadata_
  };
}
__name(metadata, "metadata");
// @__NO_SIDE_EFFECTS__
function mimeType(requirement, message$1) {
  return {
    kind: "validation",
    type: "mime_type",
    reference: mimeType,
    async: false,
    expects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `"${option}"`), "|"),
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, "MIME type", dataset, config$1, { received: `"${dataset.value.type}"` });
      return dataset;
    }
  };
}
__name(mimeType, "mimeType");
// @__NO_SIDE_EFFECTS__
function minBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_bytes",
    reference: minBytes,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 < this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(minBytes, "minBytes");
// @__NO_SIDE_EFFECTS__
function minEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_entries",
    reference: minEntries,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count < this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(minEntries, "minEntries");
// @__NO_SIDE_EFFECTS__
function minGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_graphemes",
    reference: minGraphemes,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count < this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(minGraphemes, "minGraphemes");
// @__NO_SIDE_EFFECTS__
function minLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(minLength, "minLength");
// @__NO_SIDE_EFFECTS__
function minSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_size",
    reference: minSize,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(minSize, "minSize");
// @__NO_SIDE_EFFECTS__
function minValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue,
    async: false,
    expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(minValue, "minValue");
// @__NO_SIDE_EFFECTS__
function minWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "min_words",
    reference: minWords,
    async: false,
    expects: `>=${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count < this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(minWords, "minWords");
// @__NO_SIDE_EFFECTS__
function multipleOf(requirement, message$1) {
  return {
    kind: "validation",
    type: "multiple_of",
    reference: multipleOf,
    async: false,
    expects: `%${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, "multiple", dataset, config$1);
      return dataset;
    }
  };
}
__name(multipleOf, "multipleOf");
// @__NO_SIDE_EFFECTS__
function nanoid(message$1) {
  return {
    kind: "validation",
    type: "nanoid",
    reference: nanoid,
    async: false,
    expects: null,
    requirement: NANO_ID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Nano ID", dataset, config$1);
      return dataset;
    }
  };
}
__name(nanoid, "nanoid");
// @__NO_SIDE_EFFECTS__
function nonEmpty(message$1) {
  return {
    kind: "validation",
    type: "non_empty",
    reference: nonEmpty,
    async: false,
    expects: "!0",
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length === 0) _addIssue(this, "length", dataset, config$1, { received: "0" });
      return dataset;
    }
  };
}
__name(nonEmpty, "nonEmpty");
// @__NO_SIDE_EFFECTS__
function normalize(form) {
  return {
    kind: "transformation",
    type: "normalize",
    reference: normalize,
    async: false,
    form,
    "~run"(dataset) {
      dataset.value = dataset.value.normalize(this.form);
      return dataset;
    }
  };
}
__name(normalize, "normalize");
// @__NO_SIDE_EFFECTS__
function notBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_bytes",
    reference: notBytes,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 === this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(notBytes, "notBytes");
// @__NO_SIDE_EFFECTS__
function notEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_entries",
    reference: notEntries,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count === this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(notEntries, "notEntries");
// @__NO_SIDE_EFFECTS__
function notGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_graphemes",
    reference: notGraphemes,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count === this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(notGraphemes, "notGraphemes");
// @__NO_SIDE_EFFECTS__
function notLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_length",
    reference: notLength,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(notLength, "notLength");
// @__NO_SIDE_EFFECTS__
function notSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_size",
    reference: notSize,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(notSize, "notSize");
// @__NO_SIDE_EFFECTS__
function notValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_value",
    reference: notValue,
    async: false,
    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(notValue, "notValue");
// @__NO_SIDE_EFFECTS__
function notValues(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_values",
    reference: notValues,
    async: false,
    expects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(notValues, "notValues");
// @__NO_SIDE_EFFECTS__
function notWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "not_words",
    reference: notWords,
    async: false,
    expects: `!${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count === this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(notWords, "notWords");
// @__NO_SIDE_EFFECTS__
function octal(message$1) {
  return {
    kind: "validation",
    type: "octal",
    reference: octal,
    async: false,
    expects: null,
    requirement: OCTAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "octal", dataset, config$1);
      return dataset;
    }
  };
}
__name(octal, "octal");
// @__NO_SIDE_EFFECTS__
function parseJson(config$1, message$1) {
  return {
    kind: "transformation",
    type: "parse_json",
    reference: parseJson,
    config: config$1,
    message: message$1,
    async: false,
    "~run"(dataset, config$2) {
      try {
        dataset.value = JSON.parse(dataset.value, this.config?.reviver);
      } catch (error) {
        if (error instanceof Error) {
          _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
          dataset.typed = false;
        } else throw error;
      }
      return dataset;
    }
  };
}
__name(parseJson, "parseJson");
// @__NO_SIDE_EFFECTS__
function _isPartiallyTyped(dataset, paths) {
  if (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {
    let typed = false;
    const bound = Math.min(path.length, issue.path?.length ?? 0);
    for (let index2 = 0; index2 < bound; index2++) if (path[index2] !== issue.path[index2].key && (path[index2] !== "$" || issue.path[index2].type !== "array")) {
      typed = true;
      break;
    }
    if (!typed) return false;
  }
  return true;
}
__name(_isPartiallyTyped, "_isPartiallyTyped");
// @__NO_SIDE_EFFECTS__
function partialCheck(paths, requirement, message$1) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheck,
    async: false,
    expects: null,
    paths,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(partialCheck, "partialCheck");
// @__NO_SIDE_EFFECTS__
function partialCheckAsync(paths, requirement, message$1) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheckAsync,
    async: true,
    expects: null,
    paths,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(partialCheckAsync, "partialCheckAsync");
// @__NO_SIDE_EFFECTS__
function rawCheck(action2) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheck,
    async: false,
    expects: null,
    "~run"(dataset, config$1) {
      action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue")
      });
      return dataset;
    }
  };
}
__name(rawCheck, "rawCheck");
// @__NO_SIDE_EFFECTS__
function rawCheckAsync(action2) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheckAsync,
    async: true,
    expects: null,
    async "~run"(dataset, config$1) {
      await action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue")
      });
      return dataset;
    }
  };
}
__name(rawCheckAsync, "rawCheckAsync");
// @__NO_SIDE_EFFECTS__
function rawTransform(action2) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransform,
    async: false,
    "~run"(dataset, config$1) {
      const output = action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue"),
        NEVER: null
      });
      if (dataset.issues) dataset.typed = false;
      else dataset.value = output;
      return dataset;
    }
  };
}
__name(rawTransform, "rawTransform");
// @__NO_SIDE_EFFECTS__
function rawTransformAsync(action2) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransformAsync,
    async: true,
    async "~run"(dataset, config$1) {
      const output = await action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue"),
        NEVER: null
      });
      if (dataset.issues) dataset.typed = false;
      else dataset.value = output;
      return dataset;
    }
  };
}
__name(rawTransformAsync, "rawTransformAsync");
// @__NO_SIDE_EFFECTS__
function readonly$1() {
  return {
    kind: "transformation",
    type: "readonly",
    reference: readonly$1,
    async: false,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(readonly$1, "readonly$1");
// @__NO_SIDE_EFFECTS__
function reduceItems(operation, initial) {
  return {
    kind: "transformation",
    type: "reduce_items",
    reference: reduceItems,
    async: false,
    operation,
    initial,
    "~run"(dataset) {
      dataset.value = dataset.value.reduce(this.operation, this.initial);
      return dataset;
    }
  };
}
__name(reduceItems, "reduceItems");
// @__NO_SIDE_EFFECTS__
function regex(requirement, message$1) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
      return dataset;
    }
  };
}
__name(regex, "regex");
// @__NO_SIDE_EFFECTS__
function returns(schema) {
  return {
    kind: "transformation",
    type: "returns",
    reference: returns,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = (...args_) => {
        const returnsDataset = this.schema["~run"]({ value: func(...args_) }, config$1);
        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
        return returnsDataset.value;
      };
      return dataset;
    }
  };
}
__name(returns, "returns");
// @__NO_SIDE_EFFECTS__
function returnsAsync(schema) {
  return {
    kind: "transformation",
    type: "returns",
    reference: returnsAsync,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = async (...args_) => {
        const returnsDataset = await this.schema["~run"]({ value: await func(...args_) }, config$1);
        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
        return returnsDataset.value;
      };
      return dataset;
    }
  };
}
__name(returnsAsync, "returnsAsync");
// @__NO_SIDE_EFFECTS__
function rfcEmail(message$1) {
  return {
    kind: "validation",
    type: "rfc_email",
    reference: rfcEmail,
    expects: null,
    async: false,
    requirement: RFC_EMAIL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
      return dataset;
    }
  };
}
__name(rfcEmail, "rfcEmail");
// @__NO_SIDE_EFFECTS__
function safeInteger(message$1) {
  return {
    kind: "validation",
    type: "safe_integer",
    reference: safeInteger,
    async: false,
    expects: null,
    requirement: Number.isSafeInteger,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "safe integer", dataset, config$1);
      return dataset;
    }
  };
}
__name(safeInteger, "safeInteger");
// @__NO_SIDE_EFFECTS__
function size(requirement, message$1) {
  return {
    kind: "validation",
    type: "size",
    reference: size,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(size, "size");
// @__NO_SIDE_EFFECTS__
function slug(message$1) {
  return {
    kind: "validation",
    type: "slug",
    reference: slug,
    async: false,
    expects: null,
    requirement: SLUG_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "slug", dataset, config$1);
      return dataset;
    }
  };
}
__name(slug, "slug");
// @__NO_SIDE_EFFECTS__
function someItem(requirement, message$1) {
  return {
    kind: "validation",
    type: "some_item",
    reference: someItem,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, "item", dataset, config$1);
      return dataset;
    }
  };
}
__name(someItem, "someItem");
// @__NO_SIDE_EFFECTS__
function sortItems(operation) {
  return {
    kind: "transformation",
    type: "sort_items",
    reference: sortItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.sort(this.operation);
      return dataset;
    }
  };
}
__name(sortItems, "sortItems");
// @__NO_SIDE_EFFECTS__
function startsWith(requirement, message$1) {
  return {
    kind: "validation",
    type: "starts_with",
    reference: startsWith,
    async: false,
    expects: `"${requirement}"`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, "start", dataset, config$1, { received: `"${dataset.value.slice(0, this.requirement.length)}"` });
      return dataset;
    }
  };
}
__name(startsWith, "startsWith");
// @__NO_SIDE_EFFECTS__
function stringifyJson(config$1, message$1) {
  return {
    kind: "transformation",
    type: "stringify_json",
    reference: stringifyJson,
    message: message$1,
    config: config$1,
    async: false,
    "~run"(dataset, config$2) {
      try {
        const output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);
        if (output === void 0) {
          _addIssue(this, "JSON", dataset, config$2);
          dataset.typed = false;
        }
        dataset.value = output;
      } catch (error) {
        if (error instanceof Error) {
          _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
          dataset.typed = false;
        } else throw error;
      }
      return dataset;
    }
  };
}
__name(stringifyJson, "stringifyJson");
// @__NO_SIDE_EFFECTS__
function title(title_) {
  return {
    kind: "metadata",
    type: "title",
    reference: title,
    title: title_
  };
}
__name(title, "title");
// @__NO_SIDE_EFFECTS__
function toBigint(message$1) {
  return {
    kind: "transformation",
    type: "to_bigint",
    reference: toBigint,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = BigInt(dataset.value);
      } catch {
        _addIssue(this, "bigint", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toBigint, "toBigint");
// @__NO_SIDE_EFFECTS__
function toBoolean() {
  return {
    kind: "transformation",
    type: "to_boolean",
    reference: toBoolean,
    async: false,
    "~run"(dataset) {
      dataset.value = Boolean(dataset.value);
      return dataset;
    }
  };
}
__name(toBoolean, "toBoolean");
// @__NO_SIDE_EFFECTS__
function toDate(message$1) {
  return {
    kind: "transformation",
    type: "to_date",
    reference: toDate,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = new Date(dataset.value);
        if (isNaN(dataset.value)) {
          _addIssue(this, "date", dataset, config$1, { received: '"Invalid Date"' });
          dataset.typed = false;
        }
      } catch {
        _addIssue(this, "date", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toDate, "toDate");
// @__NO_SIDE_EFFECTS__
function toLowerCase() {
  return {
    kind: "transformation",
    type: "to_lower_case",
    reference: toLowerCase,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.toLowerCase();
      return dataset;
    }
  };
}
__name(toLowerCase, "toLowerCase");
// @__NO_SIDE_EFFECTS__
function toMaxValue(requirement) {
  return {
    kind: "transformation",
    type: "to_max_value",
    reference: toMaxValue,
    async: false,
    requirement,
    "~run"(dataset) {
      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}
__name(toMaxValue, "toMaxValue");
// @__NO_SIDE_EFFECTS__
function toMinValue(requirement) {
  return {
    kind: "transformation",
    type: "to_min_value",
    reference: toMinValue,
    async: false,
    requirement,
    "~run"(dataset) {
      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}
__name(toMinValue, "toMinValue");
// @__NO_SIDE_EFFECTS__
function toNumber(message$1) {
  return {
    kind: "transformation",
    type: "to_number",
    reference: toNumber,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = Number(dataset.value);
        if (isNaN(dataset.value)) {
          _addIssue(this, "number", dataset, config$1);
          dataset.typed = false;
        }
      } catch {
        _addIssue(this, "number", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toNumber, "toNumber");
// @__NO_SIDE_EFFECTS__
function toString(message$1) {
  return {
    kind: "transformation",
    type: "to_string",
    reference: toString,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = String(dataset.value);
      } catch {
        _addIssue(this, "string", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toString, "toString");
// @__NO_SIDE_EFFECTS__
function toUpperCase() {
  return {
    kind: "transformation",
    type: "to_upper_case",
    reference: toUpperCase,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.toUpperCase();
      return dataset;
    }
  };
}
__name(toUpperCase, "toUpperCase");
// @__NO_SIDE_EFFECTS__
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
__name(transform, "transform");
// @__NO_SIDE_EFFECTS__
function transformAsync(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transformAsync,
    async: true,
    operation,
    async "~run"(dataset) {
      dataset.value = await this.operation(dataset.value);
      return dataset;
    }
  };
}
__name(transformAsync, "transformAsync");
// @__NO_SIDE_EFFECTS__
function trim() {
  return {
    kind: "transformation",
    type: "trim",
    reference: trim,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trim();
      return dataset;
    }
  };
}
__name(trim, "trim");
// @__NO_SIDE_EFFECTS__
function trimEnd() {
  return {
    kind: "transformation",
    type: "trim_end",
    reference: trimEnd,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trimEnd();
      return dataset;
    }
  };
}
__name(trimEnd, "trimEnd");
// @__NO_SIDE_EFFECTS__
function trimStart() {
  return {
    kind: "transformation",
    type: "trim_start",
    reference: trimStart,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trimStart();
      return dataset;
    }
  };
}
__name(trimStart, "trimStart");
// @__NO_SIDE_EFFECTS__
function ulid(message$1) {
  return {
    kind: "validation",
    type: "ulid",
    reference: ulid,
    async: false,
    expects: null,
    requirement: ULID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "ULID", dataset, config$1);
      return dataset;
    }
  };
}
__name(ulid, "ulid");
// @__NO_SIDE_EFFECTS__
function url(message$1) {
  return {
    kind: "validation",
    type: "url",
    reference: url,
    async: false,
    expects: null,
    requirement(input) {
      try {
        new URL(input);
        return true;
      } catch {
        return false;
      }
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "URL", dataset, config$1);
      return dataset;
    }
  };
}
__name(url, "url");
// @__NO_SIDE_EFFECTS__
function uuid(message$1) {
  return {
    kind: "validation",
    type: "uuid",
    reference: uuid,
    async: false,
    expects: null,
    requirement: UUID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
      return dataset;
    }
  };
}
__name(uuid, "uuid");
// @__NO_SIDE_EFFECTS__
function value(requirement, message$1) {
  return {
    kind: "validation",
    type: "value",
    reference: value,
    async: false,
    expects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(value, "value");
// @__NO_SIDE_EFFECTS__
function values(requirement, message$1) {
  return {
    kind: "validation",
    type: "values",
    reference: values,
    async: false,
    expects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(values, "values");
// @__NO_SIDE_EFFECTS__
function words(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "words",
    reference: words,
    async: false,
    expects: `${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count !== this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(words, "words");
function assert(schema, input) {
  const issues = schema["~run"]({ value: input }, { abortEarly: true }).issues;
  if (issues) throw new ValiError(issues);
}
__name(assert, "assert");
// @__NO_SIDE_EFFECTS__
function config(schema, config$1) {
  return {
    ...schema,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config_) {
      return schema["~run"](dataset, {
        ...config_,
        ...config$1
      });
    }
  };
}
__name(config, "config");
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config$1) {
  return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
}
__name(getFallback, "getFallback");
// @__NO_SIDE_EFFECTS__
function fallback$1(schema, fallback$12) {
  return {
    ...schema,
    fallback: fallback$12,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const outputDataset = schema["~run"](dataset, config$1);
      return outputDataset.issues ? {
        typed: true,
        value: /* @__PURE__ */ getFallback(this, outputDataset, config$1)
      } : outputDataset;
    }
  };
}
__name(fallback$1, "fallback$1");
// @__NO_SIDE_EFFECTS__
function fallbackAsync(schema, fallback$12) {
  return {
    ...schema,
    fallback: fallback$12,
    async: true,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const outputDataset = await schema["~run"](dataset, config$1);
      return outputDataset.issues ? {
        typed: true,
        value: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)
      } : outputDataset;
    }
  };
}
__name(fallbackAsync, "fallbackAsync");
// @__NO_SIDE_EFFECTS__
function flatten$1(issues) {
  const flatErrors = {};
  for (const issue of issues) if (issue.path) {
    const dotPath = /* @__PURE__ */ getDotPath(issue);
    if (dotPath) {
      if (!flatErrors.nested) flatErrors.nested = {};
      if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);
      else flatErrors.nested[dotPath] = [issue.message];
    } else if (flatErrors.other) flatErrors.other.push(issue.message);
    else flatErrors.other = [issue.message];
  } else if (flatErrors.root) flatErrors.root.push(issue.message);
  else flatErrors.root = [issue.message];
  return flatErrors;
}
__name(flatten$1, "flatten$1");
// @__NO_SIDE_EFFECTS__
function forward(action2, path) {
  return {
    ...action2,
    "~run"(dataset, config$1) {
      const prevIssues = dataset.issues && [...dataset.issues];
      dataset = action2["~run"](dataset, config$1);
      if (dataset.issues) {
        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
          let pathInput = dataset.value;
          for (const key2 of path) {
            const pathValue = pathInput[key2];
            const pathItem = {
              type: "unknown",
              origin: "value",
              input: pathInput,
              key: key2,
              value: pathValue
            };
            if (issue.path) issue.path.push(pathItem);
            else issue.path = [pathItem];
            if (!pathValue) break;
            pathInput = pathValue;
          }
        }
      }
      return dataset;
    }
  };
}
__name(forward, "forward");
// @__NO_SIDE_EFFECTS__
function forwardAsync(action2, path) {
  return {
    ...action2,
    async: true,
    async "~run"(dataset, config$1) {
      const prevIssues = dataset.issues && [...dataset.issues];
      dataset = await action2["~run"](dataset, config$1);
      if (dataset.issues) {
        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
          let pathInput = dataset.value;
          for (const key2 of path) {
            const pathValue = pathInput[key2];
            const pathItem = {
              type: "unknown",
              origin: "value",
              input: pathInput,
              key: key2,
              value: pathValue
            };
            if (issue.path) issue.path.push(pathItem);
            else issue.path = [pathItem];
            if (!pathValue) break;
            pathInput = pathValue;
          }
        }
      }
      return dataset;
    }
  };
}
__name(forwardAsync, "forwardAsync");
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config$1) {
  return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
}
__name(getDefault, "getDefault");
// @__NO_SIDE_EFFECTS__
function getDefaults(schema) {
  if ("entries" in schema) {
    const object$1 = {};
    for (const key2 in schema.entries) object$1[key2] = /* @__PURE__ */ getDefaults(schema.entries[key2]);
    return object$1;
  }
  if ("items" in schema) return schema.items.map(getDefaults);
  return /* @__PURE__ */ getDefault(schema);
}
__name(getDefaults, "getDefaults");
// @__NO_SIDE_EFFECTS__
async function getDefaultsAsync(schema) {
  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key2, value$1]) => [key2, await /* @__PURE__ */ getDefaultsAsync(value$1)])));
  if ("items" in schema) return Promise.all(schema.items.map(getDefaultsAsync));
  return /* @__PURE__ */ getDefault(schema);
}
__name(getDefaultsAsync, "getDefaultsAsync");
// @__NO_SIDE_EFFECTS__
function getDescription(schema) {
  return /* @__PURE__ */ _getLastMetadata(schema, "description");
}
__name(getDescription, "getDescription");
// @__NO_SIDE_EFFECTS__
function getExamples(schema) {
  const examples$1 = [];
  function depthFirstCollect(schema$1) {
    if ("pipe" in schema$1) {
      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstCollect(item);
      else if (item.kind === "metadata" && item.type === "examples") examples$1.push(...item.examples);
    }
  }
  __name(depthFirstCollect, "depthFirstCollect");
  depthFirstCollect(schema);
  return examples$1;
}
__name(getExamples, "getExamples");
// @__NO_SIDE_EFFECTS__
function getFallbacks(schema) {
  if ("entries" in schema) {
    const object$1 = {};
    for (const key2 in schema.entries) object$1[key2] = /* @__PURE__ */ getFallbacks(schema.entries[key2]);
    return object$1;
  }
  if ("items" in schema) return schema.items.map(getFallbacks);
  return /* @__PURE__ */ getFallback(schema);
}
__name(getFallbacks, "getFallbacks");
// @__NO_SIDE_EFFECTS__
async function getFallbacksAsync(schema) {
  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key2, value$1]) => [key2, await /* @__PURE__ */ getFallbacksAsync(value$1)])));
  if ("items" in schema) return Promise.all(schema.items.map(getFallbacksAsync));
  return /* @__PURE__ */ getFallback(schema);
}
__name(getFallbacksAsync, "getFallbacksAsync");
// @__NO_SIDE_EFFECTS__
function getMetadata(schema) {
  const result = {};
  function depthFirstMerge(schema$1) {
    if ("pipe" in schema$1) {
      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstMerge(item);
      else if (item.kind === "metadata" && item.type === "metadata") Object.assign(result, item.metadata);
    }
  }
  __name(depthFirstMerge, "depthFirstMerge");
  depthFirstMerge(schema);
  return result;
}
__name(getMetadata, "getMetadata");
// @__NO_SIDE_EFFECTS__
function getTitle(schema) {
  return /* @__PURE__ */ _getLastMetadata(schema, "title");
}
__name(getTitle, "getTitle");
// @__NO_SIDE_EFFECTS__
function is$1(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
__name(is$1, "is$1");
// @__NO_SIDE_EFFECTS__
function any() {
  return {
    kind: "schema",
    type: "any",
    reference: any,
    expects: "any",
    async: false,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
__name(any, "any");
// @__NO_SIDE_EFFECTS__
function array(item, message$1) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < input.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(array, "array");
// @__NO_SIDE_EFFECTS__
function arrayAsync(item, message$1) {
  return {
    kind: "schema",
    type: "array",
    reference: arrayAsync,
    expects: "Array",
    async: true,
    item,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(input.map((value$1) => this.item["~run"]({ value: value$1 }, config$1)));
        for (let key2 = 0; key2 < itemDatasets.length; key2++) {
          const itemDataset = itemDatasets[key2];
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: input[key2]
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(arrayAsync, "arrayAsync");
// @__NO_SIDE_EFFECTS__
function bigint(message$1) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "bigint") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(bigint, "bigint");
// @__NO_SIDE_EFFECTS__
function blob(message$1) {
  return {
    kind: "schema",
    type: "blob",
    reference: blob,
    expects: "Blob",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Blob) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(blob, "blob");
// @__NO_SIDE_EFFECTS__
function boolean(message$1) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "boolean") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(boolean, "boolean");
// @__NO_SIDE_EFFECTS__
function custom(check$1, message$1) {
  return {
    kind: "schema",
    type: "custom",
    reference: custom,
    expects: "unknown",
    async: false,
    check: check$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.check(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(custom, "custom");
// @__NO_SIDE_EFFECTS__
function customAsync(check$1, message$1) {
  return {
    kind: "schema",
    type: "custom",
    reference: customAsync,
    expects: "unknown",
    async: true,
    check: check$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (await this.check(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(customAsync, "customAsync");
// @__NO_SIDE_EFFECTS__
function date(message$1) {
  return {
    kind: "schema",
    type: "date",
    reference: date,
    expects: "Date",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1, { received: '"Invalid Date"' });
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(date, "date");
// @__NO_SIDE_EFFECTS__
function enum_(enum__, message$1) {
  const options = [];
  for (const key2 in enum__) if (`${+key2}` !== key2 || typeof enum__[key2] !== "string" || !Object.is(enum__[enum__[key2]], +key2)) options.push(enum__[key2]);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
    async: false,
    enum: enum__,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.includes(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(enum_, "enum_");
// @__NO_SIDE_EFFECTS__
function exactOptional(wrapped, default_) {
  return {
    kind: "schema",
    type: "exact_optional",
    reference: exactOptional,
    expects: wrapped.expects,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(exactOptional, "exactOptional");
// @__NO_SIDE_EFFECTS__
function exactOptionalAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "exact_optional",
    reference: exactOptionalAsync,
    expects: wrapped.expects,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(exactOptionalAsync, "exactOptionalAsync");
// @__NO_SIDE_EFFECTS__
function file(message$1) {
  return {
    kind: "schema",
    type: "file",
    reference: file,
    expects: "File",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof File) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(file, "file");
// @__NO_SIDE_EFFECTS__
function function_(message$1) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "function") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(function_, "function_");
// @__NO_SIDE_EFFECTS__
function instance(class_, message$1) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance,
    expects: class_.name,
    async: false,
    class: class_,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof this.class) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(instance, "instance");
// @__NO_SIDE_EFFECTS__
function _merge(value1, value2) {
  if (typeof value1 === typeof value2) {
    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };
    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
      for (const key2 in value2) if (key2 in value1) {
        const dataset = /* @__PURE__ */ _merge(value1[key2], value2[key2]);
        if (dataset.issue) return dataset;
        value1[key2] = dataset.value;
      } else value1[key2] = value2[key2];
      return { value: value1 };
    }
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (value1.length === value2.length) {
        for (let index2 = 0; index2 < value1.length; index2++) {
          const dataset = /* @__PURE__ */ _merge(value1[index2], value2[index2]);
          if (dataset.issue) return dataset;
          value1[index2] = dataset.value;
        }
        return { value: value1 };
      }
    }
  }
  return { issue: true };
}
__name(_merge, "_merge");
// @__NO_SIDE_EFFECTS__
function intersect(options, message$1) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersect,
    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "&"),
    async: false,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.length) {
        const input = dataset.value;
        let outputs;
        dataset.typed = true;
        for (const schema of this.options) {
          const optionDataset = schema["~run"]({ value: input }, config$1);
          if (optionDataset.issues) {
            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
            else dataset.issues = optionDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!optionDataset.typed) dataset.typed = false;
          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
          else outputs = [optionDataset.value];
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (let index2 = 1; index2 < outputs.length; index2++) {
            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index2]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(intersect, "intersect");
// @__NO_SIDE_EFFECTS__
function intersectAsync(options, message$1) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersectAsync,
    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "&"),
    async: true,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (this.options.length) {
        const input = dataset.value;
        let outputs;
        dataset.typed = true;
        const optionDatasets = await Promise.all(this.options.map((schema) => schema["~run"]({ value: input }, config$1)));
        for (const optionDataset of optionDatasets) {
          if (optionDataset.issues) {
            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
            else dataset.issues = optionDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!optionDataset.typed) dataset.typed = false;
          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
          else outputs = [optionDataset.value];
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (let index2 = 1; index2 < outputs.length; index2++) {
            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index2]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(intersectAsync, "intersectAsync");
// @__NO_SIDE_EFFECTS__
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return this.getter(dataset.value)["~run"](dataset, config$1);
    }
  };
}
__name(lazy, "lazy");
// @__NO_SIDE_EFFECTS__
function lazyAsync(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazyAsync,
    expects: "unknown",
    async: true,
    getter,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      return (await this.getter(dataset.value))["~run"](dataset, config$1);
    }
  };
}
__name(lazyAsync, "lazyAsync");
// @__NO_SIDE_EFFECTS__
function literal(literal_, message$1) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: /* @__PURE__ */ _stringify(literal_),
    async: false,
    literal: literal_,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === this.literal) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(literal, "literal");
// @__NO_SIDE_EFFECTS__
function looseObject(entries$1, message$1) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) dataset.value[key2] = input[key2];
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseObject, "looseObject");
// @__NO_SIDE_EFFECTS__
function looseObjectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObjectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) dataset.value[key2] = input[key2];
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseObjectAsync, "looseObjectAsync");
// @__NO_SIDE_EFFECTS__
function looseTuple(items, message$1) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) dataset.value.push(input[key2]);
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseTuple, "looseTuple");
// @__NO_SIDE_EFFECTS__
function looseTupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) dataset.value.push(input[key2]);
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseTupleAsync, "looseTupleAsync");
// @__NO_SIDE_EFFECTS__
function map(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "map",
    reference: map,
    expects: "Map",
    async: false,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Map();
        for (const [inputKey, inputValue] of input) {
          const keyDataset = this.key["~run"]({ value: inputKey }, config$1);
          if (keyDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "key",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "value",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          dataset.value.set(keyDataset.value, valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(map, "map");
// @__NO_SIDE_EFFECTS__
function mapAsync(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "map",
    reference: mapAsync,
    expects: "Map",
    async: true,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Map();
        const datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([
          inputKey,
          inputValue,
          this.key["~run"]({ value: inputKey }, config$1),
          this.value["~run"]({ value: inputValue }, config$1)
        ])));
        for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {
          if (keyDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "key",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (valueDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "value",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          dataset.value.set(keyDataset.value, valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(mapAsync, "mapAsync");
// @__NO_SIDE_EFFECTS__
function nan(message$1) {
  return {
    kind: "schema",
    type: "nan",
    reference: nan,
    expects: "NaN",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (Number.isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nan, "nan");
// @__NO_SIDE_EFFECTS__
function never(message$1) {
  return {
    kind: "schema",
    type: "never",
    reference: never,
    expects: "never",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(never, "never");
// @__NO_SIDE_EFFECTS__
function nonNullable(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullable,
    expects: "!null",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value !== null) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullable, "nonNullable");
// @__NO_SIDE_EFFECTS__
function nonNullableAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullableAsync,
    expects: "!null",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value !== null) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullableAsync, "nonNullableAsync");
// @__NO_SIDE_EFFECTS__
function nonNullish(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullish,
    expects: "(!null & !undefined)",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullish, "nonNullish");
// @__NO_SIDE_EFFECTS__
function nonNullishAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullishAsync,
    expects: "(!null & !undefined)",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullishAsync, "nonNullishAsync");
// @__NO_SIDE_EFFECTS__
function nonOptional(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value !== void 0) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonOptional, "nonOptional");
// @__NO_SIDE_EFFECTS__
function nonOptionalAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptionalAsync,
    expects: "!undefined",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value !== void 0) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonOptionalAsync, "nonOptionalAsync");
// @__NO_SIDE_EFFECTS__
function null_(message$1) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(null_, "null_");
// @__NO_SIDE_EFFECTS__
function nullable(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `(${wrapped.expects} | null)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullable, "nullable");
// @__NO_SIDE_EFFECTS__
function nullableAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullable",
    reference: nullableAsync,
    expects: `(${wrapped.expects} | null)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === null) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullableAsync, "nullableAsync");
// @__NO_SIDE_EFFECTS__
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullish, "nullish");
// @__NO_SIDE_EFFECTS__
function nullishAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullishAsync,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullishAsync, "nullishAsync");
// @__NO_SIDE_EFFECTS__
function number(message$1) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(number, "number");
// @__NO_SIDE_EFFECTS__
function object(entries$1, message$1) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(object, "object");
// @__NO_SIDE_EFFECTS__
function objectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "object",
    reference: objectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectAsync, "objectAsync");
// @__NO_SIDE_EFFECTS__
function objectWithRest(entries$1, rest, message$1) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRest,
    expects: "Object",
    async: false,
    entries: entries$1,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) {
            const valueDataset = this.rest["~run"]({ value: input[key2] }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: input[key2]
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectWithRest, "objectWithRest");
// @__NO_SIDE_EFFECTS__
function objectWithRestAsync(entries$1, rest, message$1) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRestAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        })), Promise.all(Object.entries(input).filter(([key2]) => /* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)).map(async ([key2, value$1]) => [
          key2,
          value$1,
          await this.rest["~run"]({ value: value$1 }, config$1)
        ]))]);
        for (const [key2, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) for (const [key2, value$1, valueDataset] of restDatasets) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectWithRestAsync, "objectWithRestAsync");
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(optional, "optional");
// @__NO_SIDE_EFFECTS__
function optionalAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optionalAsync,
    expects: `(${wrapped.expects} | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(optionalAsync, "optionalAsync");
// @__NO_SIDE_EFFECTS__
function picklist(options, message$1) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
    async: false,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.includes(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(picklist, "picklist");
// @__NO_SIDE_EFFECTS__
function promise(message$1) {
  return {
    kind: "schema",
    type: "promise",
    reference: promise,
    expects: "Promise",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Promise) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(promise, "promise");
// @__NO_SIDE_EFFECTS__
function record(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {
          const entryValue = input[entryKey];
          const keyDataset = this.key["~run"]({ value: entryKey }, config$1);
          if (keyDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "key",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of keyDataset.issues) {
              issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          const valueDataset = this.value["~run"]({ value: entryValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(record, "record");
// @__NO_SIDE_EFFECTS__
function recordAsync(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "record",
    reference: recordAsync,
    expects: "Object",
    async: true,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([
          entryKey,
          entryValue,
          this.key["~run"]({ value: entryKey }, config$1),
          this.value["~run"]({ value: entryValue }, config$1)
        ])));
        for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {
          if (keyDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "key",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of keyDataset.issues) {
              issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(recordAsync, "recordAsync");
// @__NO_SIDE_EFFECTS__
function set$1(value$1, message$1) {
  return {
    kind: "schema",
    type: "set",
    reference: set$1,
    expects: "Set",
    async: false,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Set();
        for (const inputValue of input) {
          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "set",
              origin: "value",
              input,
              key: null,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value.add(valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(set$1, "set$1");
// @__NO_SIDE_EFFECTS__
function setAsync(value$1, message$1) {
  return {
    kind: "schema",
    type: "set",
    reference: setAsync,
    expects: "Set",
    async: true,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Set();
        const valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value["~run"]({ value: inputValue }, config$1)]));
        for (const [inputValue, valueDataset] of valueDatasets) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "set",
              origin: "value",
              input,
              key: null,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value.add(valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(setAsync, "setAsync");
// @__NO_SIDE_EFFECTS__
function strictObject(entries$1, message$1) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObject,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (!(key2 in this.entries)) {
            _addIssue(this, "key", dataset, config$1, {
              input: key2,
              expected: "never",
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictObject, "strictObject");
// @__NO_SIDE_EFFECTS__
function strictObjectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObjectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (!(key2 in this.entries)) {
            _addIssue(this, "key", dataset, config$1, {
              input: key2,
              expected: "never",
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictObjectAsync, "strictObjectAsync");
// @__NO_SIDE_EFFECTS__
function strictTuple(items, message$1) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
          input: input[this.items.length],
          expected: "never",
          path: [{
            type: "array",
            origin: "value",
            input,
            key: this.items.length,
            value: input[this.items.length]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictTuple, "strictTuple");
// @__NO_SIDE_EFFECTS__
function strictTupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
          input: input[this.items.length],
          expected: "never",
          path: [{
            type: "array",
            origin: "value",
            input,
            key: this.items.length,
            value: input[this.items.length]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictTupleAsync, "strictTupleAsync");
// @__NO_SIDE_EFFECTS__
function string(message$1) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "string") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(string, "string");
// @__NO_SIDE_EFFECTS__
function symbol(message$1) {
  return {
    kind: "schema",
    type: "symbol",
    reference: symbol,
    expects: "symbol",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "symbol") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(symbol, "symbol");
// @__NO_SIDE_EFFECTS__
function tuple(items, message$1) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tuple, "tuple");
// @__NO_SIDE_EFFECTS__
function tupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleAsync, "tupleAsync");
// @__NO_SIDE_EFFECTS__
function tupleWithRest(items, rest, message$1) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRest,
    expects: "Array",
    async: false,
    items,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.rest["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleWithRest, "tupleWithRest");
// @__NO_SIDE_EFFECTS__
function tupleWithRestAsync(items, rest, message$1) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRestAsync,
    expects: "Array",
    async: true,
    items,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        })), Promise.all(input.slice(this.items.length).map(async (value$1, key2) => {
          return [
            key2 + this.items.length,
            value$1,
            await this.rest["~run"]({ value: value$1 }, config$1)
          ];
        }))]);
        for (const [key2, value$1, itemDataset] of normalDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (const [key2, value$1, itemDataset] of restDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleWithRestAsync, "tupleWithRestAsync");
// @__NO_SIDE_EFFECTS__
function undefined_(message$1) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(undefined_, "undefined_");
// @__NO_SIDE_EFFECTS__
function undefinedable(wrapped, default_) {
  return {
    kind: "schema",
    type: "undefinedable",
    reference: undefinedable,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(undefinedable, "undefinedable");
// @__NO_SIDE_EFFECTS__
function undefinedableAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "undefinedable",
    reference: undefinedableAsync,
    expects: `(${wrapped.expects} | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(undefinedableAsync, "undefinedableAsync");
// @__NO_SIDE_EFFECTS__
function _subIssues(datasets) {
  let issues;
  if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
  else issues = dataset.issues;
  return issues;
}
__name(_subIssues, "_subIssues");
// @__NO_SIDE_EFFECTS__
function union(options, message$1) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "|"),
    async: false,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
        else typedDatasets = [optionDataset];
        else {
          validDataset = optionDataset;
          break;
        }
        else if (untypedDatasets) untypedDatasets.push(optionDataset);
        else untypedDatasets = [optionDataset];
      }
      if (validDataset) return validDataset;
      if (typedDatasets) {
        if (typedDatasets.length === 1) return typedDatasets[0];
        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
      return dataset;
    }
  };
}
__name(union, "union");
// @__NO_SIDE_EFFECTS__
function unionAsync(options, message$1) {
  return {
    kind: "schema",
    type: "union",
    reference: unionAsync,
    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "|"),
    async: true,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = await schema["~run"]({ value: dataset.value }, config$1);
        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
        else typedDatasets = [optionDataset];
        else {
          validDataset = optionDataset;
          break;
        }
        else if (untypedDatasets) untypedDatasets.push(optionDataset);
        else untypedDatasets = [optionDataset];
      }
      if (validDataset) return validDataset;
      if (typedDatasets) {
        if (typedDatasets.length === 1) return typedDatasets[0];
        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
      return dataset;
    }
  };
}
__name(unionAsync, "unionAsync");
// @__NO_SIDE_EFFECTS__
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
__name(unknown, "unknown");
// @__NO_SIDE_EFFECTS__
function variant(key2, options, message$1) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key: key2,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        let outputDataset;
        let maxDiscriminatorPriority = 0;
        let invalidDiscriminatorKey = this.key;
        let expectedDiscriminators = [];
        const parseOptions = /* @__PURE__ */ __name((variant$1, allKeys) => {
          for (const schema of variant$1.options) {
            if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
            else {
              let keysAreValid = true;
              let currentPriority = 0;
              for (const currentKey of allKeys) {
                const discriminatorSchema = schema.entries[currentKey];
                if (currentKey in input ? discriminatorSchema["~run"]({
                  typed: false,
                  value: input[currentKey]
                }, { abortEarly: true }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                  keysAreValid = false;
                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                    maxDiscriminatorPriority = currentPriority;
                    invalidDiscriminatorKey = currentKey;
                    expectedDiscriminators = [];
                  }
                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                  break;
                }
                currentPriority++;
              }
              if (keysAreValid) {
                const optionDataset = schema["~run"]({ value: input }, config$1);
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
              }
            }
            if (outputDataset && !outputDataset.issues) break;
          }
        }, "parseOptions");
        parseOptions(this, /* @__PURE__ */ new Set([this.key]));
        if (outputDataset) return outputDataset;
        _addIssue(this, "type", dataset, config$1, {
          input: input[invalidDiscriminatorKey],
          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
          path: [{
            type: "object",
            origin: "value",
            input,
            key: invalidDiscriminatorKey,
            value: input[invalidDiscriminatorKey]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(variant, "variant");
// @__NO_SIDE_EFFECTS__
function variantAsync(key2, options, message$1) {
  return {
    kind: "schema",
    type: "variant",
    reference: variantAsync,
    expects: "Object",
    async: true,
    key: key2,
    options,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        let outputDataset;
        let maxDiscriminatorPriority = 0;
        let invalidDiscriminatorKey = this.key;
        let expectedDiscriminators = [];
        const parseOptions = /* @__PURE__ */ __name(async (variant$1, allKeys) => {
          for (const schema of variant$1.options) {
            if (schema.type === "variant") await parseOptions(schema, new Set(allKeys).add(schema.key));
            else {
              let keysAreValid = true;
              let currentPriority = 0;
              for (const currentKey of allKeys) {
                const discriminatorSchema = schema.entries[currentKey];
                if (currentKey in input ? (await discriminatorSchema["~run"]({
                  typed: false,
                  value: input[currentKey]
                }, { abortEarly: true })).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                  keysAreValid = false;
                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                    maxDiscriminatorPriority = currentPriority;
                    invalidDiscriminatorKey = currentKey;
                    expectedDiscriminators = [];
                  }
                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                  break;
                }
                currentPriority++;
              }
              if (keysAreValid) {
                const optionDataset = await schema["~run"]({ value: input }, config$1);
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
              }
            }
            if (outputDataset && !outputDataset.issues) break;
          }
        }, "parseOptions");
        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));
        if (outputDataset) return outputDataset;
        _addIssue(this, "type", dataset, config$1, {
          input: input[invalidDiscriminatorKey],
          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
          path: [{
            type: "object",
            origin: "value",
            input,
            key: invalidDiscriminatorKey,
            value: input[invalidDiscriminatorKey]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(variantAsync, "variantAsync");
// @__NO_SIDE_EFFECTS__
function void_(message$1) {
  return {
    kind: "schema",
    type: "void",
    reference: void_,
    expects: "void",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(void_, "void_");
// @__NO_SIDE_EFFECTS__
function keyof(schema, message$1) {
  return /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);
}
__name(keyof, "keyof");
// @__NO_SIDE_EFFECTS__
function message(schema, message_) {
  return {
    ...schema,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return schema["~run"](dataset, {
        ...config$1,
        message: message_
      });
    }
  };
}
__name(message, "message");
// @__NO_SIDE_EFFECTS__
function omit(schema, keys) {
  const entries$1 = { ...schema.entries };
  for (const key2 of keys) delete entries$1[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(omit, "omit");
function parse(schema, input, config$1) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  if (dataset.issues) throw new ValiError(dataset.issues);
  return dataset.value;
}
__name(parse, "parse");
async function parseAsync(schema, input, config$1) {
  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  if (dataset.issues) throw new ValiError(dataset.issues);
  return dataset.value;
}
__name(parseAsync, "parseAsync");
// @__NO_SIDE_EFFECTS__
function parser(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => parse(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(parser, "parser");
// @__NO_SIDE_EFFECTS__
function parserAsync(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => parseAsync(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(parserAsync, "parserAsync");
// @__NO_SIDE_EFFECTS__
function partial(schema, keys) {
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ optional(schema.entries[key2]) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(partial, "partial");
// @__NO_SIDE_EFFECTS__
function partialAsync(schema, keys) {
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ optionalAsync(schema.entries[key2]) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(partialAsync, "partialAsync");
// @__NO_SIDE_EFFECTS__
function pick(schema, keys) {
  const entries$1 = {};
  for (const key2 of keys) entries$1[key2] = schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(pick, "pick");
// @__NO_SIDE_EFFECTS__
function pipe(...pipe$1) {
  return {
    ...pipe$1[0],
    pipe: pipe$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      for (const item of pipe$1) if (item.kind !== "metadata") {
        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
      }
      return dataset;
    }
  };
}
__name(pipe, "pipe");
// @__NO_SIDE_EFFECTS__
function pipeAsync(...pipe$1) {
  return {
    ...pipe$1[0],
    pipe: pipe$1,
    async: true,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      for (const item of pipe$1) if (item.kind !== "metadata") {
        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item["~run"](dataset, config$1);
      }
      return dataset;
    }
  };
}
__name(pipeAsync, "pipeAsync");
// @__NO_SIDE_EFFECTS__
function required(schema, arg2, arg3) {
  const keys = Array.isArray(arg2) ? arg2 : void 0;
  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ nonOptional(schema.entries[key2], message$1) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(required, "required");
// @__NO_SIDE_EFFECTS__
function requiredAsync(schema, arg2, arg3) {
  const keys = Array.isArray(arg2) ? arg2 : void 0;
  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key2], message$1) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(requiredAsync, "requiredAsync");
// @__NO_SIDE_EFFECTS__
function safeParse(schema, input, config$1) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}
__name(safeParse, "safeParse");
// @__NO_SIDE_EFFECTS__
async function safeParseAsync(schema, input, config$1) {
  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}
__name(safeParseAsync, "safeParseAsync");
// @__NO_SIDE_EFFECTS__
function safeParser(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => /* @__PURE__ */ safeParse(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(safeParser, "safeParser");
// @__NO_SIDE_EFFECTS__
function safeParserAsync(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(safeParserAsync, "safeParserAsync");
// @__NO_SIDE_EFFECTS__
function summarize(issues) {
  let summary = "";
  for (const issue of issues) {
    if (summary) summary += "\n";
    summary += `× ${issue.message}`;
    const dotPath = /* @__PURE__ */ getDotPath(issue);
    if (dotPath) summary += `
  → at ${dotPath}`;
  }
  return summary;
}
__name(summarize, "summarize");
// @__NO_SIDE_EFFECTS__
function unwrap(schema) {
  return schema.wrapped;
}
__name(unwrap, "unwrap");
function isStringValue(value2, expectedType) {
  return expectedType === "string" && typeof value2 === "string";
}
__name(isStringValue, "isStringValue");
const JournalEntrySchema = /* @__PURE__ */ object({
  id: /* @__PURE__ */ string(),
  name: /* @__PURE__ */ optional(/* @__PURE__ */ string()),
  flags: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string(), /* @__PURE__ */ unknown())),
  getFlag: /* @__PURE__ */ optional(
    /* @__PURE__ */ custom((val) => typeof val === "function")
  ),
  setFlag: /* @__PURE__ */ optional(
    /* @__PURE__ */ custom(
      (val) => typeof val === "function"
    )
  )
});
function validateJournalEntries(entries2) {
  const result = /* @__PURE__ */ safeParse(/* @__PURE__ */ array(JournalEntrySchema), entries2);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Journal entry validation failed",
        void 0,
        result.issues
      )
    );
  }
  return ok(result.output);
}
__name(validateJournalEntries, "validateJournalEntries");
function validateSettingValue(key2, value2, expectedType, choices) {
  if (expectedType === "string" && typeof value2 !== "string") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected string, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (expectedType === "number" && typeof value2 !== "number") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected number, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (expectedType === "boolean" && typeof value2 !== "boolean") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected boolean, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (choices && isStringValue(value2, expectedType)) {
    if (!choices.includes(value2)) {
      return err(
        createFoundryError(
          "VALIDATION_FAILED",
          `Setting ${key2}: Invalid value "${value2}". Allowed: ${choices.join(", ")}`,
          { key: key2, value: value2, choices }
        )
      );
    }
  }
  return ok(value2);
}
__name(validateSettingValue, "validateSettingValue");
const SettingConfigSchema = /* @__PURE__ */ object({
  name: /* @__PURE__ */ optional(/* @__PURE__ */ string()),
  hint: /* @__PURE__ */ optional(/* @__PURE__ */ string()),
  scope: /* @__PURE__ */ optional(/* @__PURE__ */ picklist(["world", "client", "user"])),
  config: /* @__PURE__ */ optional(/* @__PURE__ */ boolean()),
  type: /* @__PURE__ */ optional(/* @__PURE__ */ any()),
  // typeof String, Number, Boolean - cannot validate constructors
  default: /* @__PURE__ */ optional(/* @__PURE__ */ any()),
  // Default value depends on type
  choices: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string(), /* @__PURE__ */ string())),
  // Record keys must be string in TS
  onChange: /* @__PURE__ */ optional(/* @__PURE__ */ custom((val) => typeof val === "function"))
});
function validateSettingConfig(namespace, key2, config2) {
  if (!namespace || typeof namespace !== "string") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Invalid setting namespace: must be non-empty string",
        { namespace, key: key2 }
      )
    );
  }
  if (!key2 || typeof key2 !== "string") {
    return err(
      createFoundryError("VALIDATION_FAILED", "Invalid setting key: must be non-empty string", {
        namespace,
        key: key2
      })
    );
  }
  if (!config2 || typeof config2 !== "object") {
    return err(
      createFoundryError("VALIDATION_FAILED", "Invalid setting config: must be object", {
        namespace,
        key: key2
      })
    );
  }
  const result = /* @__PURE__ */ safeParse(SettingConfigSchema, config2);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting config validation failed for ${namespace}.${key2}: ${result.issues.map((i) => i.message).join(", ")}`,
        { namespace, key: key2, config: config2, issues: result.issues }
      )
    );
  }
  return ok(result.output);
}
__name(validateSettingConfig, "validateSettingConfig");
function sanitizeId(id) {
  return id.replace(/[^a-zA-Z0-9-_]/g, "");
}
__name(sanitizeId, "sanitizeId");
function sanitizeHtml$1(text2) {
  const div = document.createElement("div");
  div.textContent = text2;
  return div.innerHTML;
}
__name(sanitizeHtml$1, "sanitizeHtml$1");
const FoundryApplicationSchema = /* @__PURE__ */ object({
  // Application should have a string ID
  id: /* @__PURE__ */ string(),
  // Application should have object property (typed as record instead of any)
  object: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string(), /* @__PURE__ */ unknown())),
  // Application should have options property
  options: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string(), /* @__PURE__ */ unknown()))
});
function validateHookApp(app) {
  if (app === null || app === void 0) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Hook app parameter is null or undefined",
        void 0,
        void 0
      )
    );
  }
  const result = /* @__PURE__ */ safeParse(FoundryApplicationSchema, app);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Hook app parameter validation failed",
        void 0,
        result.issues
      )
    );
  }
  return ok(result.output);
}
__name(validateHookApp, "validateHookApp");
const HOOK_THROTTLE_WINDOW_MS = 150;
const VALIDATION_CONSTRAINTS = {
  /** Maximale Länge für IDs und Keys */
  MAX_ID_LENGTH: 100,
  /** Maximale Länge für Namen */
  MAX_NAME_LENGTH: 100,
  /** Maximale Länge für Flag-Keys */
  MAX_FLAG_KEY_LENGTH: 100
};
const METRICS_CONFIG = {
  /** Größe des Circular-Buffers für Resolution-Zeiten */
  RESOLUTION_TIMES_BUFFER_SIZE: 100
};
Object.freeze(VALIDATION_CONSTRAINTS);
Object.freeze(METRICS_CONFIG);
function validateJournalId(id) {
  if (id.length === 0) {
    return err(createFoundryError("VALIDATION_FAILED", "ID cannot be empty"));
  }
  if (id.length > VALIDATION_CONSTRAINTS.MAX_ID_LENGTH) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `ID too long (max ${VALIDATION_CONSTRAINTS.MAX_ID_LENGTH} characters)`
      )
    );
  }
  if (!/^[a-zA-Z0-9-_]+$/.test(id)) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "ID contains invalid characters (allowed: a-z, A-Z, 0-9, -, _)",
        { id }
      )
    );
  }
  return ok(id);
}
__name(validateJournalId, "validateJournalId");
function validateJournalName(name) {
  if (typeof name !== "string" || name.length === 0) {
    return err(createFoundryError("VALIDATION_FAILED", "Name cannot be empty"));
  }
  if (name.length > 255) {
    return err(createFoundryError("VALIDATION_FAILED", "Name too long (max 255 characters)"));
  }
  return ok(name);
}
__name(validateJournalName, "validateJournalName");
function validateFlagKey(key2) {
  if (typeof key2 !== "string" || key2.length === 0 || key2.length > VALIDATION_CONSTRAINTS.MAX_FLAG_KEY_LENGTH) {
    return err(createFoundryError("VALIDATION_FAILED", "Invalid flag key length"));
  }
  if (!/^[a-zA-Z0-9_]+$/.test(key2)) {
    return err(createFoundryError("VALIDATION_FAILED", "Invalid flag key format"));
  }
  return ok(key2);
}
__name(validateFlagKey, "validateFlagKey");
const _FoundryV13GamePort = class _FoundryV13GamePort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed);
    this.foundryAPI = foundryAPI;
    __privateSet(this, _disposed, false);
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
    this.cacheTtlMs = APP_DEFAULTS.CACHE_TTL_MS;
  }
  getJournalEntries() {
    if (__privateGet(this, _disposed)) {
      return err(createFoundryError("DISPOSED", "Cannot get journal entries on disposed port"));
    }
    if (!this.foundryAPI?.journal) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry game API not available"));
    }
    const now2 = Date.now();
    const cacheAge = now2 - this.lastCheckTimestamp;
    if (this.cachedEntries !== null && cacheAge < this.cacheTtlMs) {
      return { ok: true, value: this.cachedEntries };
    }
    const entries2 = tryCatch(
      () => Array.from(this.foundryAPI.journal.contents),
      (error) => createFoundryError("OPERATION_FAILED", "Failed to access journal entries", void 0, error)
    );
    if (!entries2.ok) {
      return entries2;
    }
    const validationResult = validateJournalEntries(entries2.value);
    if (!validationResult.ok) {
      return validationResult;
    }
    this.cachedEntries = entries2.value;
    this.lastCheckTimestamp = now2;
    return { ok: true, value: this.cachedEntries };
  }
  /**
   * Invalidates the journal entries cache.
   * Forces the next getJournalEntries() call to fetch and validate fresh data.
   */
  invalidateCache() {
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
  }
  getJournalEntryById(id) {
    if (__privateGet(this, _disposed)) {
      return err(createFoundryError("DISPOSED", "Cannot get journal entry on disposed port"));
    }
    const validationResult = validateJournalId(id);
    if (!validationResult.ok) {
      return validationResult;
    }
    if (!this.foundryAPI?.journal) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry game API not available"));
    }
    return tryCatch(
      () => {
        const entry = this.foundryAPI.journal.get(validationResult.value);
        return entry ?? null;
      },
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to get journal entry by ID ${validationResult.value}`,
        { id: validationResult.value },
        error
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed)) return;
    __privateSet(this, _disposed, true);
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
  }
};
_disposed = new WeakMap();
__name(_FoundryV13GamePort, "FoundryV13GamePort");
let FoundryV13GamePort = _FoundryV13GamePort;
function createFoundryV13GamePort() {
  if (typeof game === "undefined" || !game?.journal) {
    return new FoundryV13GamePort({
      // type-coverage:ignore-next-line -- Required: null needed when API unavailable, but IFoundryGameAPI["journal"] is non-nullable
      journal: null
    });
  }
  return new FoundryV13GamePort({
    journal: {
      contents: Array.from(game.journal.contents),
      get: /* @__PURE__ */ __name((id) => game.journal.get(id), "get"),
      ...game.journal.directory && game.journal.directory.render ? {
        directory: {
          render: /* @__PURE__ */ __name(() => {
            game.journal.directory?.render();
          }, "render")
        }
      } : {}
    }
  });
}
__name(createFoundryV13GamePort, "createFoundryV13GamePort");
const _FoundryV13HooksPort = class _FoundryV13HooksPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed2, false);
    this.foundryAPI = foundryAPI;
  }
  on(hookName, callback) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot register hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        const hookId = this.foundryAPI.on(hookName, callback);
        return hookId;
      },
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register hook ${hookName}`,
        { hookName },
        error
      )
    );
  }
  once(hookName, callback) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot register one-time hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        const hookId = this.foundryAPI.once(hookName, callback);
        return hookId;
      },
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register one-time hook ${hookName}`,
        { hookName },
        error
      )
    );
  }
  off(hookName, callbackOrId) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot unregister hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        this.foundryAPI.off(hookName, callbackOrId);
        return void 0;
      },
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to unregister hook ${hookName}`,
        { hookName },
        error
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed2)) return;
    __privateSet(this, _disposed2, true);
  }
};
_disposed2 = new WeakMap();
__name(_FoundryV13HooksPort, "FoundryV13HooksPort");
let FoundryV13HooksPort = _FoundryV13HooksPort;
function createFoundryV13HooksPort() {
  if (typeof Hooks === "undefined") {
    throw new Error("Foundry Hooks API is not available");
  }
  return new FoundryV13HooksPort({
    on: /* @__PURE__ */ __name((hookName, callback) => {
      return Hooks.on(
        hookName,
        callback
      );
    }, "on"),
    once: /* @__PURE__ */ __name((hookName, callback) => {
      return Hooks.once(
        hookName,
        callback
      );
    }, "once"),
    off: /* @__PURE__ */ __name((hookName, callbackOrId) => {
      Hooks.off(
        hookName,
        callbackOrId
      );
    }, "off")
  });
}
__name(createFoundryV13HooksPort, "createFoundryV13HooksPort");
function hasMethod(obj, methodName) {
  return obj !== null && obj !== void 0 && typeof obj === "object" && methodName in obj && // type-coverage:ignore-next-line - Runtime type guard requires cast to check method type
  typeof obj[methodName] === "function";
}
__name(hasMethod, "hasMethod");
function hasProperty(obj, propertyName) {
  return obj !== null && obj !== void 0 && typeof obj === "object" && propertyName in obj;
}
__name(hasProperty, "hasProperty");
function isObjectWithMethods(obj, methodNames) {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return false;
  }
  return methodNames.every((methodName) => hasMethod(obj, methodName));
}
__name(isObjectWithMethods, "isObjectWithMethods");
function isInitializable(obj) {
  return hasMethod(obj, "initialize");
}
__name(isInitializable, "isInitializable");
function castFoundrySettingsApi(settings) {
  if (!isObjectWithMethods(settings, ["register", "get", "set"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "game.settings does not have required methods (register, get, set)",
        {
          missingMethods: ["register", "get", "set"]
        }
      )
    );
  }
  return ok(settings);
}
__name(castFoundrySettingsApi, "castFoundrySettingsApi");
function castFoundryDocumentForFlag(document2) {
  if (!isObjectWithMethods(document2, ["getFlag", "setFlag"])) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Document does not have required methods (getFlag, setFlag)",
        {
          missingMethods: ["getFlag", "setFlag"]
        }
      )
    );
  }
  return ok(document2);
}
__name(castFoundryDocumentForFlag, "castFoundryDocumentForFlag");
function castFoundryError(error) {
  return error;
}
__name(castFoundryError, "castFoundryError");
function castDisposablePort(port) {
  if (!port || typeof port !== "object") {
    return null;
  }
  if (hasMethod(port, "dispose")) {
    return port;
  }
  return null;
}
__name(castDisposablePort, "castDisposablePort");
function ensureNonEmptyArray(arr) {
  if (arr.length === 0) {
    return err(
      createFoundryError("VALIDATION_FAILED", "Array must not be empty", { arrayLength: 0 })
    );
  }
  return ok(arr);
}
__name(ensureNonEmptyArray, "ensureNonEmptyArray");
function extractHtmlElement(html2) {
  return html2 instanceof HTMLElement ? html2 : null;
}
__name(extractHtmlElement, "extractHtmlElement");
function getFactoryOrError(factories, version) {
  const factory = factories.get(version);
  if (!factory) {
    return err(
      createFoundryError("PORT_NOT_FOUND", `Factory for version ${version} not found in registry`, {
        version
      })
    );
  }
  return ok(factory);
}
__name(getFactoryOrError, "getFactoryOrError");
function castFoundryDocumentWithUpdate(document2) {
  if (!isObjectWithMethods(document2, ["update"])) {
    return err(
      createFoundryError("VALIDATION_FAILED", "Document does not have required method (update)", {
        missingMethods: ["update"]
      })
    );
  }
  return ok(document2);
}
__name(castFoundryDocumentWithUpdate, "castFoundryDocumentWithUpdate");
function castFoundryJournalEntryClass() {
  if (typeof globalThis !== "object" || globalThis === null || !("JournalEntry" in globalThis)) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "Foundry JournalEntry class not available in globalThis",
        {}
      )
    );
  }
  const journalEntryClass = globalThis.JournalEntry;
  if (!isObjectWithMethods(journalEntryClass, ["create"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "Foundry JournalEntry class does not have required method (create)",
        {
          missingMethods: ["create"]
        }
      )
    );
  }
  return ok(journalEntryClass);
}
__name(castFoundryJournalEntryClass, "castFoundryJournalEntryClass");
function castCreatedJournalEntry(document2) {
  return document2;
}
__name(castCreatedJournalEntry, "castCreatedJournalEntry");
function castFoundryDocumentCollection(collections, documentType) {
  if (!isObjectWithMethods(collections, ["get"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "game.collections does not have required method (get)",
        {
          missingMethods: ["get"]
        }
      )
    );
  }
  const collection = collections.get(documentType);
  if (!collection) {
    return err(
      createFoundryError("NOT_FOUND", `Collection for document type "${documentType}" not found`, {
        documentType
      })
    );
  }
  if (!isObjectWithMethods(collection, ["get", "has"])) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Collection for "${documentType}" does not have required methods (get, has)`,
        {
          documentType,
          missingMethods: ["get", "has"]
        }
      )
    );
  }
  return ok(collection);
}
__name(castFoundryDocumentCollection, "castFoundryDocumentCollection");
function castSvelteStateRune() {
  if (typeof globalThis === "undefined" || globalThis === null) {
    return err(createFoundryError("API_NOT_AVAILABLE", "globalThis is not available", {}));
  }
  const $state = globalThis.$state;
  if (typeof $state !== "function") {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "Svelte 5 $state rune is not available in globalThis",
        {}
      )
    );
  }
  return ok($state);
}
__name(castSvelteStateRune, "castSvelteStateRune");
const _FoundryV13DocumentPort = class _FoundryV13DocumentPort {
  constructor() {
    __privateAdd(this, _disposed3, false);
  }
  async create(documentClass, data) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot create document on disposed port"));
    }
    return fromPromise(
      documentClass.create(data),
      (error) => createFoundryError("OPERATION_FAILED", "Failed to create document", { data }, error)
    );
  }
  async update(document2, changes) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot update document on disposed port"));
    }
    return fromPromise(
      document2.update(changes),
      (error) => createFoundryError("OPERATION_FAILED", "Failed to update document", { changes }, error)
    );
  }
  async delete(document2) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot delete document on disposed port"));
    }
    return fromPromise(
      document2.delete().then(() => void 0),
      (error) => createFoundryError("OPERATION_FAILED", "Failed to delete document", void 0, error)
    );
  }
  getFlag(document2, scope, key2, schema) {
    if (__privateGet(this, _disposed3)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot get flag on disposed port", { scope, key: key2 })
      };
    }
    return tryCatch(
      () => {
        if (!document2?.getFlag) {
          throw new Error("Document does not have getFlag method");
        }
        const rawValue = document2.getFlag(scope, key2);
        if (rawValue === null || rawValue === void 0) {
          return null;
        }
        const parseResult = /* @__PURE__ */ safeParse(schema, rawValue);
        if (!parseResult.success) {
          const error = createFoundryError(
            "VALIDATION_FAILED",
            `Flag ${scope}.${key2} failed validation: ${parseResult.issues.map((i) => i.message).join(", ")}`,
            { scope, key: key2, rawValue, issues: parseResult.issues }
          );
          throw error;
        }
        return parseResult.output;
      },
      (error) => {
        if (error && typeof error === "object" && "code" in error && "message" in error) {
          return castFoundryError(error);
        }
        return createFoundryError(
          "OPERATION_FAILED",
          `Failed to get flag ${scope}.${key2}`,
          { scope, key: key2 },
          error
        );
      }
    );
  }
  async setFlag(document2, scope, key2, value2) {
    if (__privateGet(this, _disposed3)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot set flag on disposed port", { scope, key: key2 })
      };
    }
    return fromPromise(
      (async () => {
        if (!document2?.setFlag) {
          throw new Error("Document does not have setFlag method");
        }
        await document2.setFlag(scope, key2, value2);
      })(),
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to set flag ${scope}.${key2}`,
        { scope, key: key2, value: value2 },
        error
      )
    );
  }
  async unsetFlag(document2, scope, key2) {
    if (__privateGet(this, _disposed3)) {
      return err(
        createFoundryError("DISPOSED", "Cannot unset flag on disposed port", { scope, key: key2 })
      );
    }
    return fromPromise(
      (async () => {
        if (document2.unsetFlag) {
          await document2.unsetFlag(scope, key2);
        } else {
          const docWithUpdateResult = castFoundryDocumentWithUpdate(document2);
          if (!docWithUpdateResult.ok) {
            throw new Error(
              `Document does not support unsetFlag or update: ${docWithUpdateResult.error.message}`
            );
          }
          await docWithUpdateResult.value.update({
            [`flags.${scope}.-=${key2}`]: null
          });
        }
      })(),
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to unset flag ${scope}.${key2}`,
        { scope, key: key2 },
        error
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed3)) return;
    __privateSet(this, _disposed3, true);
  }
};
_disposed3 = new WeakMap();
__name(_FoundryV13DocumentPort, "FoundryV13DocumentPort");
let FoundryV13DocumentPort = _FoundryV13DocumentPort;
const _FoundryV13UIPort = class _FoundryV13UIPort {
  constructor(foundryUIAPI, foundryGameJournalAPI, foundryDocumentAPI) {
    __privateAdd(this, _disposed4, false);
    this.foundryUIAPI = foundryUIAPI;
    this.foundryGameJournalAPI = foundryGameJournalAPI;
    this.foundryDocumentAPI = foundryDocumentAPI;
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    if (__privateGet(this, _disposed4)) {
      return err(
        createFoundryError("DISPOSED", "Cannot remove journal directory entry on disposed port")
      );
    }
    const elementResult = this.getDirectoryElement(directoryId);
    if (!elementResult.ok) {
      return err(elementResult.error);
    }
    const html2 = elementResult.value;
    if (!html2) {
      return err(
        createFoundryError(
          "NOT_FOUND",
          `Directory element not found for directory: ${directoryId}`,
          { directoryId, journalId, journalName }
        )
      );
    }
    const safeId = sanitizeId(journalId);
    const element2 = html2.querySelector(
      `li.directory-item[data-document-id="${safeId}"], li.directory-item[data-entry-id="${safeId}"]`
    );
    if (!element2) {
      return err(
        createFoundryError(
          "NOT_FOUND",
          `Could not find directory entry for journal: ${journalName}`,
          { journalName, journalId: safeId }
        )
      );
    }
    try {
      element2.remove();
      return ok(void 0);
    } catch (error) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to remove element from DOM",
          { journalName, journalId: safeId },
          error
        )
      );
    }
  }
  findElement(container, selector) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot find element on disposed port"));
    }
    const element2 = container.querySelector(selector);
    return ok(element2);
  }
  notify(message2, type, options) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot show notification on disposed port"));
    }
    if (!this.foundryUIAPI?.notifications) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry UI notifications not available"));
    }
    try {
      switch (type) {
        case "info":
          this.foundryUIAPI.notifications.info(message2, options);
          break;
        case "warning":
          this.foundryUIAPI.notifications.warn(message2, options);
          break;
        case "error":
          this.foundryUIAPI.notifications.error(message2, options);
          break;
      }
      return ok(void 0);
    } catch (error) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to show notification",
          { message: message2, type },
          error
        )
      );
    }
  }
  getDirectoryElement(directoryId) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot get directory element on disposed port"));
    }
    try {
      if (directoryId === "journal") {
        const element2 = this.foundryDocumentAPI.querySelector("#journal");
        return ok(element2);
      }
      return ok(null);
    } catch (error) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to get directory element",
          { directoryId },
          error
        )
      );
    }
  }
  rerenderJournalDirectory() {
    if (__privateGet(this, _disposed4)) {
      return err(
        createFoundryError("DISPOSED", "Cannot rerender journal directory on disposed port")
      );
    }
    try {
      const journalElement = this.foundryDocumentAPI.querySelector("#journal");
      if (!journalElement) {
        return ok(false);
      }
      let rendered = false;
      if (this.foundryGameJournalAPI.directory?.render) {
        this.foundryGameJournalAPI.directory.render();
        rendered = true;
      }
      return ok(rendered);
    } catch (error) {
      return err(
        createFoundryError("OPERATION_FAILED", "Failed to re-render journal directory", {}, error)
      );
    }
  }
  dispose() {
    if (__privateGet(this, _disposed4)) return;
    __privateSet(this, _disposed4, true);
  }
};
_disposed4 = new WeakMap();
__name(_FoundryV13UIPort, "FoundryV13UIPort");
let FoundryV13UIPort = _FoundryV13UIPort;
function createFoundryV13UIPort() {
  if (typeof ui === "undefined" || !ui?.notifications) {
    throw new Error("Foundry UI API not available");
  }
  if (typeof game === "undefined" || !game?.journal) {
    throw new Error("Foundry game API not available");
  }
  const uiAPI = {
    notifications: {
      info: /* @__PURE__ */ __name((message2, options) => {
        if (ui.notifications) {
          ui.notifications.info(message2, options);
        }
      }, "info"),
      warn: /* @__PURE__ */ __name((message2, options) => {
        if (ui.notifications) {
          ui.notifications.warn(message2, options);
        }
      }, "warn"),
      error: /* @__PURE__ */ __name((message2, options) => {
        if (ui.notifications) {
          ui.notifications.error(message2, options);
        }
      }, "error")
    }
  };
  return new FoundryV13UIPort(
    uiAPI,
    {
      contents: Array.from(game.journal.contents),
      get: /* @__PURE__ */ __name((id) => game.journal.get(id), "get"),
      ...game.journal.directory && game.journal.directory.render ? {
        directory: {
          render: /* @__PURE__ */ __name(() => {
            game.journal.directory?.render();
          }, "render")
        }
      } : {}
    },
    {
      querySelector: /* @__PURE__ */ __name((selector) => document.querySelector(selector), "querySelector")
    }
  );
}
__name(createFoundryV13UIPort, "createFoundryV13UIPort");
const _FoundryV13SettingsPort = class _FoundryV13SettingsPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed5, false);
    this.foundryAPI = foundryAPI;
  }
  register(namespace, key2, config2) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot register setting on disposed port", {
          namespace,
          key: key2
        })
      );
    }
    const configValidation = validateSettingConfig(namespace, key2, config2);
    if (!configValidation.ok) {
      return err(configValidation.error);
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    const api = this.foundryAPI;
    return tryCatch(
      () => {
        api.register(namespace, key2, config2);
        return void 0;
      },
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register setting ${namespace}.${key2}`,
        { namespace, key: key2 },
        error
      )
    );
  }
  get(namespace, key2, schema) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot get setting on disposed port", { namespace, key: key2 })
      );
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    const api = this.foundryAPI;
    return tryCatch(
      () => {
        const rawValue = api.get(namespace, key2);
        const parseResult = /* @__PURE__ */ safeParse(schema, rawValue);
        if (!parseResult.success) {
          const error = createFoundryError(
            "VALIDATION_FAILED",
            `Setting ${namespace}.${key2} failed validation: ${parseResult.issues.map((i) => i.message).join(", ")}`,
            { namespace, key: key2, rawValue, issues: parseResult.issues }
          );
          throw error;
        }
        return parseResult.output;
      },
      (error) => {
        if (error && typeof error === "object" && "code" in error && error.code === "VALIDATION_FAILED") {
          return castFoundryError(error);
        }
        return createFoundryError(
          "OPERATION_FAILED",
          `Failed to get setting ${namespace}.${key2}`,
          { namespace, key: key2 },
          error
        );
      }
    );
  }
  async set(namespace, key2, value2) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot set setting on disposed port", { namespace, key: key2 })
      );
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    return fromPromise(
      this.foundryAPI.set(namespace, key2, value2).then(() => void 0),
      (error) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to set setting ${namespace}.${key2}`,
        { namespace, key: key2, value: value2 },
        error
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed5)) return;
    __privateSet(this, _disposed5, true);
  }
};
_disposed5 = new WeakMap();
__name(_FoundryV13SettingsPort, "FoundryV13SettingsPort");
let FoundryV13SettingsPort = _FoundryV13SettingsPort;
function createFoundryV13SettingsPort() {
  if (typeof game === "undefined" || game === null || game.settings === void 0) {
    return new FoundryV13SettingsPort(null);
  }
  const settingsResult = castFoundrySettingsApi(game.settings);
  if (!settingsResult.ok) {
    const castError = settingsResult.error;
    return new FoundryV13SettingsPort({
      register: /* @__PURE__ */ __name(() => {
        throw castError;
      }, "register"),
      get: /* @__PURE__ */ __name(() => {
        throw castError;
      }, "get"),
      set: /* @__PURE__ */ __name(async () => {
        throw castError;
      }, "set")
    });
  }
  const settings = settingsResult.value;
  return new FoundryV13SettingsPort({
    register: /* @__PURE__ */ __name((namespace, key2, config2) => {
      settings.register(namespace, key2, config2);
    }, "register"),
    get: /* @__PURE__ */ __name((namespace, key2) => {
      return settings.get(namespace, key2);
    }, "get"),
    set: /* @__PURE__ */ __name((namespace, key2, value2) => {
      return settings.set(namespace, key2, value2).then(() => void 0);
    }, "set")
  });
}
__name(createFoundryV13SettingsPort, "createFoundryV13SettingsPort");
const _FoundryV13I18nPort = class _FoundryV13I18nPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed6, false);
    this.foundryAPI = foundryAPI;
  }
  /**
   * Localizes a translation key using Foundry's i18n system.
   *
   * @param key - Translation key
   * @returns Result with translated string (returns key itself if not found)
   */
  localize(key2) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot localize on disposed port", { key: key2 })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(key2);
      }
      const translated = this.foundryAPI.localize(key2);
      return ok(translated);
    } catch {
      return ok(key2);
    }
  }
  /**
   * Formats a translation key with placeholder values.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @returns Result with formatted string
   */
  format(key2, data) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot format translation on disposed port", {
          key: key2
        })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(key2);
      }
      const stringData = {};
      for (const [k, v] of Object.entries(data)) {
        stringData[k] = String(v);
      }
      const formatted = this.foundryAPI.format(key2, stringData);
      return ok(formatted);
    } catch {
      return ok(key2);
    }
  }
  /**
   * Checks if a translation key exists.
   *
   * @param key - Translation key to check
   * @returns Result with boolean indicating existence
   */
  has(key2) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot check translation key on disposed port", {
          key: key2
        })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(false);
      }
      const exists = this.foundryAPI.has(key2);
      return ok(exists);
    } catch {
      return ok(false);
    }
  }
  dispose() {
    if (__privateGet(this, _disposed6)) return;
    __privateSet(this, _disposed6, true);
  }
};
_disposed6 = new WeakMap();
__name(_FoundryV13I18nPort, "FoundryV13I18nPort");
_FoundryV13I18nPort.dependencies = [];
let FoundryV13I18nPort = _FoundryV13I18nPort;
function createFoundryV13I18nPort() {
  if (typeof game === "undefined" || !game?.i18n) {
    return new FoundryV13I18nPort(null);
  }
  return new FoundryV13I18nPort({
    localize: /* @__PURE__ */ __name((key2) => game.i18n.localize(key2), "localize"),
    format: /* @__PURE__ */ __name((key2, data) => game.i18n.format(key2, data), "format"),
    has: /* @__PURE__ */ __name((key2) => game.i18n.has(key2), "has")
  });
}
__name(createFoundryV13I18nPort, "createFoundryV13I18nPort");
const _FoundryV13ModulePort = class _FoundryV13ModulePort {
  setModuleReady(moduleId) {
    if (typeof game === "undefined" || !game?.modules) {
      return false;
    }
    const mod = game.modules.get(moduleId);
    if (!mod) {
      return false;
    }
    mod.ready = true;
    return true;
  }
};
__name(_FoundryV13ModulePort, "FoundryV13ModulePort");
let FoundryV13ModulePort = _FoundryV13ModulePort;
function createFoundryV13ModulePort() {
  return new FoundryV13ModulePort();
}
__name(createFoundryV13ModulePort, "createFoundryV13ModulePort");
const foundryV13GamePortToken = createInjectionToken("FoundryV13GamePort");
const foundryV13HooksPortToken = createInjectionToken("FoundryV13HooksPort");
const foundryV13DocumentPortToken = createInjectionToken("FoundryV13DocumentPort");
const foundryV13UIPortToken = createInjectionToken("FoundryV13UIPort");
const foundryV13SettingsPortToken = createInjectionToken("FoundryV13SettingsPort");
const foundryV13I18nPortToken = createInjectionToken("FoundryV13I18nPort");
const foundryV13ModulePortToken = createInjectionToken("FoundryV13ModulePort");
function registerPortToRegistry(registry, version, token, portName, errors) {
  const result = registry.register(version, token);
  if (isErr(result)) {
    errors.push(`${portName} v${version}: ${result.error}`);
  }
}
__name(registerPortToRegistry, "registerPortToRegistry");
function registerV13Ports(registries, container) {
  const portRegistrationErrors = [];
  const gamePortResult = container.registerFactory(
    foundryV13GamePortToken,
    createFoundryV13GamePort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(gamePortResult)) {
    portRegistrationErrors.push(`FoundryGame: ${gamePortResult.error.message}`);
  }
  const hooksPortResult = container.registerFactory(
    foundryV13HooksPortToken,
    createFoundryV13HooksPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(hooksPortResult)) {
    portRegistrationErrors.push(`FoundryHooks: ${hooksPortResult.error.message}`);
  }
  container.registerClass(
    foundryV13DocumentPortToken,
    FoundryV13DocumentPort,
    ServiceLifecycle.SINGLETON
  );
  const uiPortResult = container.registerFactory(
    foundryV13UIPortToken,
    createFoundryV13UIPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(uiPortResult)) {
    portRegistrationErrors.push(`FoundryUI: ${uiPortResult.error.message}`);
  }
  const settingsPortResult = container.registerFactory(
    foundryV13SettingsPortToken,
    createFoundryV13SettingsPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(settingsPortResult)) {
    portRegistrationErrors.push(`FoundrySettings: ${settingsPortResult.error.message}`);
  }
  const i18nPortResult = container.registerFactory(
    foundryV13I18nPortToken,
    createFoundryV13I18nPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(i18nPortResult)) {
    portRegistrationErrors.push(`FoundryI18n: ${i18nPortResult.error.message}`);
  }
  container.registerValue(foundryV13ModulePortToken, createFoundryV13ModulePort());
  registerPortToRegistry(
    registries.gamePortRegistry,
    13,
    foundryV13GamePortToken,
    "FoundryGame",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.hooksPortRegistry,
    13,
    foundryV13HooksPortToken,
    "FoundryHooks",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.documentPortRegistry,
    13,
    foundryV13DocumentPortToken,
    "FoundryDocument",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.uiPortRegistry,
    13,
    foundryV13UIPortToken,
    "FoundryUI",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.settingsPortRegistry,
    13,
    foundryV13SettingsPortToken,
    "FoundrySettings",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.i18nPortRegistry,
    13,
    foundryV13I18nPortToken,
    "FoundryI18n",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.modulePortRegistry,
    13,
    foundryV13ModulePortToken,
    "FoundryModule",
    portRegistrationErrors
  );
  if (portRegistrationErrors.length > 0) {
    return err(`Port registration failed: ${portRegistrationErrors.join("; ")}`);
  }
  return ok(void 0);
}
__name(registerV13Ports, "registerV13Ports");
const foundryUIToken = createInjectionToken("FoundryUI");
const _FoundryUIAdapter = class _FoundryUIAdapter {
  constructor(foundryUI) {
    this.foundryUI = foundryUI;
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    const result = this.foundryUI.removeJournalDirectoryEntry(directoryId, journalId, journalName);
    if (!result.ok) {
      return err({
        code: "DOM_MANIPULATION_FAILED",
        message: `Failed to remove journal directory entry '${journalName}' (${journalId}) from directory '${directoryId}': ${result.error.message}`,
        operation: "removeJournalDirectoryEntry",
        details: { directoryId, journalId, journalName, cause: result.error }
      });
    }
    return ok(void 0);
  }
  getDirectoryElement(directoryId) {
    const result = this.foundryUI.getDirectoryElement(directoryId);
    if (!result.ok) {
      return err({
        code: "DOM_ACCESS_FAILED",
        message: `Failed to get directory element for '${directoryId}': ${result.error.message}`,
        operation: "getDirectoryElement",
        details: { directoryId, cause: result.error }
      });
    }
    return ok(result.value);
  }
  rerenderJournalDirectory() {
    const result = this.foundryUI.rerenderJournalDirectory();
    if (!result.ok) {
      return err({
        code: "RERENDER_FAILED",
        message: `Failed to re-render journal directory: ${result.error.message}`,
        operation: "rerenderJournalDirectory",
        details: { cause: result.error }
      });
    }
    return ok(result.value);
  }
  notify(message2, type) {
    const result = this.foundryUI.notify(message2, type);
    if (!result.ok) {
      return err({
        code: result.error.code,
        message: result.error.message,
        operation: "notify",
        details: { cause: result.error }
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryUIAdapter, "FoundryUIAdapter");
let FoundryUIAdapter = _FoundryUIAdapter;
const _DIFoundryUIAdapter = class _DIFoundryUIAdapter extends FoundryUIAdapter {
  constructor(foundryUI) {
    super(foundryUI);
  }
};
__name(_DIFoundryUIAdapter, "DIFoundryUIAdapter");
_DIFoundryUIAdapter.dependencies = [foundryUIToken];
let DIFoundryUIAdapter = _DIFoundryUIAdapter;
const LOG_LEVEL_SCHEMA = /* @__PURE__ */ picklist([
  LogLevel.DEBUG,
  LogLevel.INFO,
  LogLevel.WARN,
  LogLevel.ERROR
]);
const _ValibotValidationAdapter = class _ValibotValidationAdapter {
  /**
   * Validates a log level value using Valibot schema.
   *
   * @param value - The value to validate
   * @returns Result with validated LogLevel or validation error
   */
  validateLogLevel(value2) {
    const validationResult = /* @__PURE__ */ safeParse(LOG_LEVEL_SCHEMA, value2);
    if (!validationResult.success) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Invalid log level value: ${String(value2)}. Must be one of: ${LogLevel.DEBUG}, ${LogLevel.INFO}, ${LogLevel.WARN}, ${LogLevel.ERROR}`,
        details: validationResult.issues
      });
    }
    return ok(validationResult.output);
  }
};
__name(_ValibotValidationAdapter, "ValibotValidationAdapter");
let ValibotValidationAdapter = _ValibotValidationAdapter;
const _DIValibotValidationAdapter = class _DIValibotValidationAdapter extends ValibotValidationAdapter {
  constructor() {
    super();
  }
};
__name(_DIValibotValidationAdapter, "DIValibotValidationAdapter");
_DIValibotValidationAdapter.dependencies = [];
let DIValibotValidationAdapter = _DIValibotValidationAdapter;
const _MetricsSnapshotAdapter = class _MetricsSnapshotAdapter {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
  }
  getSnapshot() {
    return this.metricsCollector.getSnapshot();
  }
};
__name(_MetricsSnapshotAdapter, "MetricsSnapshotAdapter");
let MetricsSnapshotAdapter = _MetricsSnapshotAdapter;
const _DIMetricsSnapshotAdapter = class _DIMetricsSnapshotAdapter extends MetricsSnapshotAdapter {
  constructor(metricsCollector) {
    super(metricsCollector);
  }
};
__name(_DIMetricsSnapshotAdapter, "DIMetricsSnapshotAdapter");
_DIMetricsSnapshotAdapter.dependencies = [metricsCollectorToken];
let DIMetricsSnapshotAdapter = _DIMetricsSnapshotAdapter;
function createPortRegistries(container) {
  const gamePortRegistry = new PortRegistry();
  const hooksPortRegistry = new PortRegistry();
  const documentPortRegistry = new PortRegistry();
  const uiPortRegistry = new PortRegistry();
  const settingsPortRegistry = new PortRegistry();
  const i18nPortRegistry = new PortRegistry();
  const modulePortRegistry = new PortRegistry();
  const v13RegistrationResult = registerV13Ports(
    {
      gamePortRegistry,
      hooksPortRegistry,
      documentPortRegistry,
      uiPortRegistry,
      settingsPortRegistry,
      i18nPortRegistry,
      modulePortRegistry
    },
    container
  );
  if (isErr(v13RegistrationResult)) {
    return v13RegistrationResult;
  }
  return ok({
    gamePortRegistry,
    hooksPortRegistry,
    documentPortRegistry,
    uiPortRegistry,
    settingsPortRegistry,
    i18nPortRegistry,
    modulePortRegistry
  });
}
__name(createPortRegistries, "createPortRegistries");
function registerPortInfrastructure(container) {
  const versionDetectorResult = container.registerClass(
    foundryVersionDetectorToken,
    DIFoundryVersionDetector,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(versionDetectorResult)) {
    return err(`Failed to register FoundryVersionDetector: ${versionDetectorResult.error.message}`);
  }
  const portSelectorResult = container.registerClass(
    portSelectorToken,
    DIPortSelector,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(portSelectorResult)) {
    return err(`Failed to register PortSelector: ${portSelectorResult.error.message}`);
  }
  const platformUIPortResult = container.registerClass(
    platformUIPortToken,
    DIFoundryUIAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(platformUIPortResult)) {
    return err(`Failed to register PlatformUIPort: ${platformUIPortResult.error.message}`);
  }
  const journalDirectoryUiAliasResult = container.registerAlias(
    platformJournalDirectoryUiPortToken,
    platformUIPortToken
  );
  if (isErr(journalDirectoryUiAliasResult)) {
    return err(
      `Failed to register PlatformJournalDirectoryUiPort alias: ${journalDirectoryUiAliasResult.error.message}`
    );
  }
  const uiNotificationAliasResult = container.registerAlias(
    platformUINotificationPortToken,
    platformUIPortToken
  );
  if (isErr(uiNotificationAliasResult)) {
    return err(
      `Failed to register UINotificationPort alias: ${uiNotificationAliasResult.error.message}`
    );
  }
  const platformValidationPortResult = container.registerClass(
    platformValidationPortToken,
    DIValibotValidationAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(platformValidationPortResult)) {
    return err(
      `Failed to register PlatformValidationPort: ${platformValidationPortResult.error.message}`
    );
  }
  const loggingPortAliasResult = container.registerAlias(platformLoggingPortToken, loggerToken);
  if (isErr(loggingPortAliasResult)) {
    return err(
      `Failed to register PlatformLoggingPort alias: ${loggingPortAliasResult.error.message}`
    );
  }
  const metricsSnapshotPortResult = container.registerClass(
    platformMetricsSnapshotPortToken,
    DIMetricsSnapshotAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(metricsSnapshotPortResult)) {
    return err(
      `Failed to register PlatformMetricsSnapshotPort: ${metricsSnapshotPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerPortInfrastructure, "registerPortInfrastructure");
function registerPortRegistries(container) {
  const portsResult = createPortRegistries(container);
  if (isErr(portsResult)) return portsResult;
  const {
    gamePortRegistry,
    hooksPortRegistry,
    documentPortRegistry,
    uiPortRegistry,
    settingsPortRegistry,
    i18nPortRegistry,
    modulePortRegistry
  } = portsResult.value;
  const gameRegistryResult = container.registerValue(
    foundryGamePortRegistryToken,
    gamePortRegistry
  );
  if (isErr(gameRegistryResult)) {
    return err(`Failed to register FoundryGame PortRegistry: ${gameRegistryResult.error.message}`);
  }
  const hooksRegistryResult = container.registerValue(
    foundryHooksPortRegistryToken,
    hooksPortRegistry
  );
  if (isErr(hooksRegistryResult)) {
    return err(
      `Failed to register FoundryHooks PortRegistry: ${hooksRegistryResult.error.message}`
    );
  }
  const documentRegistryResult = container.registerValue(
    foundryDocumentPortRegistryToken,
    documentPortRegistry
  );
  if (isErr(documentRegistryResult)) {
    return err(
      `Failed to register FoundryDocument PortRegistry: ${documentRegistryResult.error.message}`
    );
  }
  const uiRegistryResult = container.registerValue(foundryUIPortRegistryToken, uiPortRegistry);
  if (isErr(uiRegistryResult)) {
    return err(`Failed to register FoundryUI PortRegistry: ${uiRegistryResult.error.message}`);
  }
  const settingsRegistryResult = container.registerValue(
    foundrySettingsPortRegistryToken,
    settingsPortRegistry
  );
  if (isErr(settingsRegistryResult)) {
    return err(
      `Failed to register FoundrySettings PortRegistry: ${settingsRegistryResult.error.message}`
    );
  }
  const i18nRegistryResult = container.registerValue(
    foundryI18nPortRegistryToken,
    i18nPortRegistry
  );
  if (isErr(i18nRegistryResult)) {
    return err(`Failed to register FoundryI18n PortRegistry: ${i18nRegistryResult.error.message}`);
  }
  const moduleRegistryResult = container.registerValue(
    foundryModulePortRegistryToken,
    modulePortRegistry
  );
  if (isErr(moduleRegistryResult)) {
    return err(
      `Failed to register FoundryModule PortRegistry: ${moduleRegistryResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerPortRegistries, "registerPortRegistries");
registerDependencyStep({
  name: "PortInfrastructure",
  priority: 60,
  execute: registerPortInfrastructure
});
const cacheServiceConfigToken = createInjectionToken("CacheServiceConfig");
const cacheServiceToken = createInjectionToken("CacheService");
const cacheConfigSyncToken = createInjectionToken("CacheConfigSync");
const cacheMaintenancePortToken = createInjectionToken("CacheMaintenancePort");
const _CacheStore = class _CacheStore {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  get(key2) {
    return this.store.get(key2);
  }
  set(key2, entry) {
    this.store.set(key2, entry);
  }
  delete(key2) {
    return this.store.delete(key2);
  }
  has(key2) {
    return this.store.has(key2);
  }
  clear() {
    const size2 = this.store.size;
    this.store.clear();
    return size2;
  }
  get size() {
    return this.store.size;
  }
  entries() {
    return this.store.entries();
  }
};
__name(_CacheStore, "CacheStore");
let CacheStore = _CacheStore;
function clampTtl$1(ttl, fallback2) {
  if (typeof ttl !== "number" || Number.isNaN(ttl)) {
    return fallback2;
  }
  return ttl < 0 ? 0 : ttl;
}
__name(clampTtl$1, "clampTtl$1");
function defaultClock() {
  return Date.now();
}
__name(defaultClock, "defaultClock");
const _CacheExpirationManager = class _CacheExpirationManager {
  constructor(clock) {
    this.clock = clock ?? defaultClock;
  }
  isExpired(entry, now2) {
    return typeof entry.expiresAt === "number" && entry.expiresAt > 0 && entry.expiresAt <= now2;
  }
  createMetadata(key2, options, now2, defaultTtlMs) {
    const ttlMs = clampTtl$1(options?.ttlMs, defaultTtlMs);
    const expiresAt = ttlMs > 0 ? now2 + ttlMs : null;
    const tags = options?.tags ? Array.from(new Set(options.tags.map((tag2) => String(tag2)))) : [];
    return {
      key: key2,
      createdAt: now2,
      expiresAt,
      lastAccessedAt: now2,
      hits: 0,
      tags
    };
  }
  handleExpiration(key2, store2) {
    return store2.delete(key2);
  }
};
__name(_CacheExpirationManager, "CacheExpirationManager");
let CacheExpirationManager = _CacheExpirationManager;
const _CacheStatisticsCollector = class _CacheStatisticsCollector {
  constructor(metricsObserver) {
    this.metricsObserver = metricsObserver;
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0
    };
  }
  recordHit(key2) {
    this.metricsObserver.onCacheHit(key2);
    this.stats.hits++;
  }
  recordMiss(key2) {
    this.metricsObserver.onCacheMiss(key2);
    this.stats.misses++;
  }
  recordEviction(key2) {
    this.metricsObserver.onCacheEviction(key2);
    this.stats.evictions++;
  }
  getStatistics(size2, enabled) {
    return {
      hits: this.stats.hits,
      misses: this.stats.misses,
      evictions: this.stats.evictions,
      size: size2,
      enabled
    };
  }
  reset() {
    this.stats.hits = 0;
    this.stats.misses = 0;
    this.stats.evictions = 0;
  }
};
__name(_CacheStatisticsCollector, "CacheStatisticsCollector");
let CacheStatisticsCollector = _CacheStatisticsCollector;
const DEFAULT_CACHE_SERVICE_CONFIG$1 = {
  enabled: true,
  defaultTtlMs: APP_DEFAULTS.CACHE_TTL_MS,
  namespace: "global"
};
function clampTtl(ttl, fallback2) {
  if (typeof ttl !== "number" || Number.isNaN(ttl)) {
    return fallback2;
  }
  return ttl < 0 ? 0 : ttl;
}
__name(clampTtl, "clampTtl");
const _CacheConfigManager = class _CacheConfigManager {
  constructor(config2 = DEFAULT_CACHE_SERVICE_CONFIG$1) {
    const resolvedMaxEntries = typeof config2?.maxEntries === "number" && config2.maxEntries > 0 ? config2.maxEntries : void 0;
    this.config = {
      ...DEFAULT_CACHE_SERVICE_CONFIG$1,
      ...config2,
      defaultTtlMs: clampTtl(config2?.defaultTtlMs, DEFAULT_CACHE_SERVICE_CONFIG$1.defaultTtlMs),
      ...resolvedMaxEntries !== void 0 ? { maxEntries: resolvedMaxEntries } : {}
    };
  }
  updateConfig(partial2) {
    const merged = {
      ...this.config,
      ...partial2
    };
    merged.defaultTtlMs = clampTtl(merged.defaultTtlMs, DEFAULT_CACHE_SERVICE_CONFIG$1.defaultTtlMs);
    this.config = merged;
  }
  getConfig() {
    return { ...this.config };
  }
  isEnabled() {
    return this.config.enabled;
  }
};
__name(_CacheConfigManager, "CacheConfigManager");
let CacheConfigManager = _CacheConfigManager;
const _CacheCapacityManager = class _CacheCapacityManager {
  constructor(strategy, store2) {
    this.strategy = strategy;
    this.store = store2;
  }
  /**
   * Enforces capacity limit by evicting entries using the configured strategy.
   *
   * @param maxEntries - The maximum number of entries allowed
   * @returns Array of cache keys that were evicted
   */
  enforceCapacity(maxEntries2) {
    if (this.store.size <= maxEntries2) {
      return [];
    }
    const entriesMap = /* @__PURE__ */ new Map();
    for (const [key2, entry] of this.store.entries()) {
      entriesMap.set(key2, entry);
    }
    const keysToEvict = this.strategy.selectForEviction(entriesMap, maxEntries2);
    for (const key2 of keysToEvict) {
      this.store.delete(key2);
    }
    return keysToEvict;
  }
};
__name(_CacheCapacityManager, "CacheCapacityManager");
let CacheCapacityManager = _CacheCapacityManager;
const _LRUEvictionStrategy = class _LRUEvictionStrategy {
  /**
   * Selects entries for eviction using LRU algorithm.
   *
   * Sorts entries by lastAccessedAt (ascending) and selects the oldest entries
   * until the cache size is within maxEntries limit.
   *
   * @param entries - The current cache entries
   * @param maxEntries - The maximum number of entries allowed
   * @returns Array of cache keys to evict (oldest first)
   */
  selectForEviction(entries2, maxEntries2) {
    const toRemove = entries2.size - maxEntries2;
    if (toRemove <= 0) {
      return [];
    }
    const sorted = Array.from(entries2.entries()).sort(
      (a, b) => a[1].metadata.lastAccessedAt - b[1].metadata.lastAccessedAt
    );
    return sorted.slice(0, toRemove).map(([key2]) => key2);
  }
};
__name(_LRUEvictionStrategy, "LRUEvictionStrategy");
let LRUEvictionStrategy = _LRUEvictionStrategy;
const _EvictionStrategyRegistry = class _EvictionStrategyRegistry {
  constructor() {
    this.strategies = /* @__PURE__ */ new Map();
  }
  /**
   * Gets the singleton instance of the registry.
   *
   * @returns The singleton registry instance
   */
  static getInstance() {
    if (!_EvictionStrategyRegistry.instance) {
      _EvictionStrategyRegistry.instance = new _EvictionStrategyRegistry();
    }
    return _EvictionStrategyRegistry.instance;
  }
  /**
   * Registers a strategy with the given key.
   *
   * If a strategy with the same key already exists, it will be replaced.
   * This allows for runtime strategy updates.
   *
   * @param key - Unique identifier for the strategy (e.g., "lru", "fifo", "lfu")
   * @param strategy - The strategy instance to register
   * @returns true if a strategy was replaced, false if it's a new registration
   */
  register(key2, strategy) {
    const wasReplaced = this.strategies.has(key2);
    this.strategies.set(key2, strategy);
    return wasReplaced;
  }
  /**
   * Gets a strategy by key.
   *
   * @param key - The strategy key
   * @returns The strategy if found, undefined otherwise
   */
  get(key2) {
    return this.strategies.get(key2);
  }
  /**
   * Gets a strategy by key, or returns the default strategy if not found.
   *
   * @param key - The strategy key
   * @param defaultKey - The key of the default strategy to use if key is not found
   * @returns The strategy if found, the default strategy if defaultKey is found, undefined otherwise
   */
  getOrDefault(key2, defaultKey) {
    if (!key2) {
      return this.get(defaultKey);
    }
    return this.get(key2) ?? this.get(defaultKey);
  }
  /**
   * Checks if a strategy is registered.
   *
   * @param key - The strategy key
   * @returns true if the strategy is registered, false otherwise
   */
  has(key2) {
    return this.strategies.has(key2);
  }
  /**
   * Unregisters a strategy.
   *
   * @param key - The strategy key to unregister
   * @returns true if a strategy was removed, false if it didn't exist
   */
  unregister(key2) {
    return this.strategies.delete(key2);
  }
  /**
   * Gets all registered strategy keys.
   *
   * @returns Array of all registered strategy keys
   */
  getRegisteredKeys() {
    return Array.from(this.strategies.keys());
  }
  /**
   * Clears all registered strategies.
   * Useful for testing or reset scenarios.
   */
  clear() {
    this.strategies.clear();
  }
};
__name(_EvictionStrategyRegistry, "EvictionStrategyRegistry");
_EvictionStrategyRegistry.instance = null;
let EvictionStrategyRegistry = _EvictionStrategyRegistry;
const _CacheMetricsCollector = class _CacheMetricsCollector {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
  }
  /**
   * Records a cache hit.
   *
   * @param _key - The cache key that was hit
   */
  onCacheHit(_key) {
    this.metricsCollector?.recordCacheAccess(true);
  }
  /**
   * Records a cache miss.
   *
   * @param _key - The cache key that was missed
   */
  onCacheMiss(_key) {
    this.metricsCollector?.recordCacheAccess(false);
  }
  /**
   * Records a cache eviction.
   *
   * @param _key - The cache key that was evicted
   */
  onCacheEviction(_key) {
  }
};
__name(_CacheMetricsCollector, "CacheMetricsCollector");
let CacheMetricsCollector = _CacheMetricsCollector;
function toStringKeyArray(allowed) {
  return allowed;
}
__name(toStringKeyArray, "toStringKeyArray");
function castCacheValue(value2) {
  return value2;
}
__name(castCacheValue, "castCacheValue");
function getFirstArrayElement$1(array2) {
  return array2[0];
}
__name(getFirstArrayElement$1, "getFirstArrayElement$1");
function getFirstElementIfArray(value2, typeGuard) {
  if (Array.isArray(value2) && value2.length > 0) {
    const firstElement = value2[0];
    if (typeGuard(firstElement)) {
      return firstElement;
    }
  }
  return null;
}
__name(getFirstElementIfArray, "getFirstElementIfArray");
function castToRecord(value2) {
  return value2;
}
__name(castToRecord, "castToRecord");
function normalizeToRecord(value2) {
  return Object.assign({}, value2);
}
__name(normalizeToRecord, "normalizeToRecord");
function assertCacheKey(value2) {
  return value2;
}
__name(assertCacheKey, "assertCacheKey");
const _CacheRuntime = class _CacheRuntime {
  constructor(store2, expirationManager, configManager, telemetry, policy, clock) {
    this.store = store2;
    this.expirationManager = expirationManager;
    this.configManager = configManager;
    this.telemetry = telemetry;
    this.policy = policy;
    this.clock = clock;
  }
  get(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) {
      return null;
    }
    const entry = this.store.get(key2);
    if (!entry) {
      this.telemetry.recordMiss(key2);
      return null;
    }
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      this.handleExpiration(key2, entry);
      this.telemetry.recordEviction(key2);
      this.telemetry.recordMiss(key2);
      return null;
    }
    entry.metadata.hits += 1;
    entry.metadata.lastAccessedAt = now2;
    this.telemetry.recordHit(key2);
    return {
      hit: true,
      value: castCacheValue(entry.value),
      metadata: this.cloneMetadata(entry.metadata)
    };
  }
  set(key2, value2, options) {
    const now2 = this.clock();
    const config2 = this.configManager.getConfig();
    const metadata2 = this.expirationManager.createMetadata(key2, options, now2, config2.defaultTtlMs);
    if (!config2.enabled) {
      return metadata2;
    }
    const entry = {
      value: value2,
      expiresAt: metadata2.expiresAt,
      metadata: metadata2
    };
    this.store.set(key2, entry);
    const evictedKeys = this.policy.enforceCapacity(this.store.size, config2);
    for (const evictedKey of evictedKeys) {
      this.telemetry.recordEviction(evictedKey);
    }
    return { ...metadata2, tags: [...metadata2.tags] };
  }
  async getOrSet(key2, factory, options) {
    const existing = this.get(key2);
    if (existing) {
      return ok(existing);
    }
    let factoryValue;
    try {
      const factoryResult = factory();
      if (factoryResult instanceof Promise) {
        const asyncResult = await fromPromise(
          factoryResult,
          (error) => `Factory failed for cache key ${String(key2)}: ${String(error)}`
        );
        if (!asyncResult.ok) {
          return asyncResult;
        }
        factoryValue = asyncResult.value;
      } else {
        factoryValue = factoryResult;
      }
    } catch (error) {
      return err(`Factory failed for cache key ${String(key2)}: ${String(error)}`);
    }
    const metadata2 = this.set(key2, factoryValue, options);
    return ok({
      hit: false,
      value: factoryValue,
      metadata: metadata2
    });
  }
  handleExpiration(key2, entry) {
    const now2 = this.clock();
    if (this.expirationManager.isExpired(entry, now2)) {
      this.expirationManager.handleExpiration(key2, this.store);
    }
  }
  cloneMetadata(metadata2) {
    return {
      ...metadata2,
      tags: [...metadata2.tags]
    };
  }
};
__name(_CacheRuntime, "CacheRuntime");
let CacheRuntime = _CacheRuntime;
const _CachePolicy = class _CachePolicy {
  constructor(capacityManager) {
    this.capacityManager = capacityManager;
  }
  enforceCapacity(currentSize, config2) {
    if (!config2.maxEntries || currentSize <= config2.maxEntries) {
      return [];
    }
    return this.capacityManager.enforceCapacity(config2.maxEntries);
  }
  shouldExpire(expiresAt, now2) {
    if (expiresAt === null) {
      return false;
    }
    return now2 >= expiresAt;
  }
};
__name(_CachePolicy, "CachePolicy");
let CachePolicy = _CachePolicy;
const _CacheTelemetry = class _CacheTelemetry {
  constructor(statisticsCollector) {
    this.statisticsCollector = statisticsCollector;
  }
  recordHit(key2) {
    this.statisticsCollector.recordHit(key2);
  }
  recordMiss(key2) {
    this.statisticsCollector.recordMiss(key2);
  }
  recordEviction(key2) {
    this.statisticsCollector.recordEviction(key2);
  }
  getStatistics(currentSize, enabled) {
    return this.statisticsCollector.getStatistics(currentSize, enabled);
  }
};
__name(_CacheTelemetry, "CacheTelemetry");
let CacheTelemetry = _CacheTelemetry;
const _CacheCompositionFactory = class _CacheCompositionFactory {
  /**
   * Creates a complete cache composition from configuration.
   *
   * @param config - Cache service configuration
   * @param metricsCollector - Optional metrics collector
   * @param clock - Clock function (defaults to Date.now)
   * @param capacityManager - Optional capacity manager (created if not provided)
   * @param metricsObserver - Optional metrics observer (created if not provided)
   * @param store - Optional store (created if not provided)
   * @param expirationManager - Optional expiration manager (created if not provided)
   * @param statisticsCollector - Optional statistics collector (created if not provided)
   * @param configManager - Optional config manager (created if not provided)
   * @param runtime - Optional runtime (created if not provided)
   * @param policy - Optional policy (created if not provided)
   * @param telemetry - Optional telemetry (created if not provided)
   * @returns Complete cache composition
   */
  create(config2, metricsCollector, clock = () => Date.now(), capacityManager, metricsObserver, store2, expirationManager, statisticsCollector, configManager, runtime, policy, telemetry) {
    const resolvedStore = store2 ?? new CacheStore();
    const resolvedConfigManager = configManager ?? new CacheConfigManager(config2);
    const resolvedExpirationManager = expirationManager ?? new CacheExpirationManager(clock);
    let resolvedCapacityManager = capacityManager;
    if (!resolvedCapacityManager) {
      const registry = EvictionStrategyRegistry.getInstance();
      if (!registry.has("lru")) {
        registry.register("lru", new LRUEvictionStrategy());
      }
      const strategyKey = config2.evictionStrategyKey ?? "lru";
      const strategy = registry.getOrDefault(strategyKey, "lru");
      if (!strategy) {
        resolvedCapacityManager = new CacheCapacityManager(
          new LRUEvictionStrategy(),
          resolvedStore
        );
      } else {
        resolvedCapacityManager = new CacheCapacityManager(strategy, resolvedStore);
      }
    }
    const resolvedMetricsObserver = metricsObserver ?? new CacheMetricsCollector(metricsCollector);
    const resolvedStatisticsCollector = statisticsCollector ?? new CacheStatisticsCollector(resolvedMetricsObserver);
    const resolvedTelemetry = telemetry ?? new CacheTelemetry(resolvedStatisticsCollector);
    const resolvedPolicy = policy ?? new CachePolicy(resolvedCapacityManager);
    const resolvedRuntime = runtime ?? new CacheRuntime(
      resolvedStore,
      resolvedExpirationManager,
      resolvedConfigManager,
      resolvedTelemetry,
      resolvedPolicy,
      clock
    );
    return {
      runtime: resolvedRuntime,
      policy: resolvedPolicy,
      telemetry: resolvedTelemetry,
      store: resolvedStore,
      configManager: resolvedConfigManager,
      expirationManager: resolvedExpirationManager
    };
  }
};
__name(_CacheCompositionFactory, "CacheCompositionFactory");
let CacheCompositionFactory = _CacheCompositionFactory;
const DEFAULT_CACHE_SERVICE_CONFIG = {
  enabled: true,
  defaultTtlMs: APP_DEFAULTS.CACHE_TTL_MS,
  namespace: "global"
};
const _CacheService = class _CacheService {
  constructor(runtime, policy, telemetry, store2, configManager, expirationManager, clock = () => Date.now()) {
    this.runtime = runtime;
    this.policy = policy;
    this.telemetry = telemetry;
    this.store = store2;
    this.configManager = configManager;
    this.expirationManager = expirationManager;
    this.clock = clock;
  }
  get isEnabled() {
    return this.configManager.isEnabled();
  }
  get size() {
    return this.store.size;
  }
  get(key2) {
    return this.runtime.get(key2);
  }
  async getOrSet(key2, factory, options) {
    return this.runtime.getOrSet(key2, factory, options);
  }
  set(key2, value2, options) {
    return this.runtime.set(key2, value2, options);
  }
  delete(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return false;
    const removed = this.store.delete(key2);
    if (removed) {
      this.telemetry.recordEviction(key2);
    }
    return removed;
  }
  has(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return false;
    const entry = this.store.get(key2);
    if (!entry) {
      return false;
    }
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      this.expirationManager.handleExpiration(key2, this.store);
      this.telemetry.recordEviction(key2);
      return false;
    }
    return true;
  }
  clear() {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return 0;
    const keysToEvict = [];
    for (const [key2] of this.store.entries()) {
      keysToEvict.push(key2);
    }
    const removed = this.store.clear();
    if (removed > 0) {
      for (const key2 of keysToEvict) {
        this.telemetry.recordEviction(key2);
      }
    }
    return removed;
  }
  invalidateWhere(predicate) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return 0;
    let removed = 0;
    const keysToEvict = [];
    for (const [key2, entry] of this.store.entries()) {
      if (predicate(entry.metadata)) {
        keysToEvict.push(key2);
      }
    }
    for (const key2 of keysToEvict) {
      if (this.store.delete(key2)) {
        removed++;
        this.telemetry.recordEviction(key2);
      }
    }
    return removed;
  }
  getMetadata(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return null;
    const entry = this.store.get(key2);
    if (!entry) return null;
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      const wasRemoved = this.expirationManager.handleExpiration(key2, this.store);
      if (wasRemoved) {
        this.telemetry.recordEviction(key2);
      }
      return null;
    }
    return this.cloneMetadata(entry.metadata);
  }
  getStatistics() {
    return this.telemetry.getStatistics(this.store.size, this.isEnabled);
  }
  getConfigManager() {
    return this.configManager;
  }
  getStore() {
    return this.store;
  }
  getPolicy() {
    return this.policy;
  }
  cloneMetadata(metadata2) {
    return {
      ...metadata2,
      tags: [...metadata2.tags]
    };
  }
};
__name(_CacheService, "CacheService");
let CacheService = _CacheService;
const _DICacheService = class _DICacheService extends CacheService {
  constructor(_config, _metrics) {
    const factory = new CacheCompositionFactory();
    const composition = factory.create(_config, _metrics);
    super(
      composition.runtime,
      composition.policy,
      composition.telemetry,
      composition.store,
      composition.configManager,
      composition.expirationManager
    );
  }
};
__name(_DICacheService, "DICacheService");
_DICacheService.dependencies = [cacheServiceConfigToken, metricsCollectorToken];
let DICacheService = _DICacheService;
const _CacheConfigSyncObserver = class _CacheConfigSyncObserver {
  constructor(store2, policy, configManager) {
    this.store = store2;
    this.policy = policy;
    this.configManager = configManager;
  }
  /**
   * Called when cache configuration is updated.
   * Implements CacheConfigObserver to react to configuration changes.
   *
   * @param config - The updated cache configuration
   */
  onConfigUpdated(config2) {
    if (!config2.enabled) {
      this.clearStore();
      return;
    }
    const currentConfig = this.configManager.getConfig();
    if (typeof config2.maxEntries === "number" && config2.maxEntries !== currentConfig.maxEntries) {
      this.enforceCapacity(config2);
    }
  }
  clearStore() {
    this.store.clear();
  }
  enforceCapacity(config2) {
    if (!config2.maxEntries) {
      return;
    }
    this.policy.enforceCapacity(this.store.size, config2);
  }
};
__name(_CacheConfigSyncObserver, "CacheConfigSyncObserver");
let CacheConfigSyncObserver = _CacheConfigSyncObserver;
const _CacheConfigSync = class _CacheConfigSync {
  constructor(runtimeConfig, cacheMaintenance) {
    this.runtimeConfig = runtimeConfig;
    this.cacheMaintenance = cacheMaintenance;
    this.unsubscribe = null;
    this.observer = new CacheConfigSyncObserver(
      cacheMaintenance.getStore(),
      cacheMaintenance.getPolicy(),
      cacheMaintenance.getConfigManager()
    );
  }
  /**
   * Binds RuntimeConfig changes to CacheService.
   * Returns unsubscribe function for cleanup.
   *
   * @returns Unsubscribe function to clean up all subscriptions
   */
  bind() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
    const unsubscribers = [];
    unsubscribers.push(
      this.runtimeConfig.onChange("enableCacheService", (enabled) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({ enabled });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    unsubscribers.push(
      this.runtimeConfig.onChange("cacheDefaultTtlMs", (ttl) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({ defaultTtlMs: ttl });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    unsubscribers.push(
      this.runtimeConfig.onChange("cacheMaxEntries", (maxEntries2) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({
          maxEntries: typeof maxEntries2 === "number" && maxEntries2 > 0 ? maxEntries2 : void 0
        });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    this.unsubscribe = () => {
      for (const unsubscribe of unsubscribers) {
        unsubscribe();
      }
      this.unsubscribe = null;
    };
    return this.unsubscribe;
  }
  /**
   * Unbinds RuntimeConfig synchronization.
   */
  unbind() {
    this.unsubscribe?.();
  }
};
__name(_CacheConfigSync, "CacheConfigSync");
let CacheConfigSync = _CacheConfigSync;
const _DICacheConfigSync = class _DICacheConfigSync extends CacheConfigSync {
  constructor(runtimeConfig, cacheMaintenance) {
    super(runtimeConfig, cacheMaintenance);
  }
};
__name(_DICacheConfigSync, "DICacheConfigSync");
_DICacheConfigSync.dependencies = [runtimeConfigToken];
let DICacheConfigSync = _DICacheConfigSync;
const _CachePortAdapter = class _CachePortAdapter {
  constructor(cacheService) {
    this.cacheService = cacheService;
  }
  /**
   * Maps Domain cache key (plain string) to Infrastructure cache key (branded type).
   */
  mapDomainKeyToInfrastructure(key2) {
    return assertCacheKey(key2);
  }
  /**
   * Maps Infrastructure cache key (branded type) to Domain cache key (plain string).
   */
  mapInfrastructureKeyToDomain(key2) {
    return key2;
  }
  /**
   * Maps Domain cache options to Infrastructure cache options.
   */
  mapDomainOptionsToInfrastructure(options) {
    if (!options) return void 0;
    const result = {};
    if (options.ttlMs !== void 0) {
      result.ttlMs = options.ttlMs;
    }
    if (options.tags !== void 0) {
      result.tags = options.tags;
    }
    return Object.keys(result).length > 0 ? result : void 0;
  }
  /**
   * Maps Infrastructure cache metadata to Domain cache metadata.
   */
  mapInfrastructureMetadataToDomain(metadata2) {
    return {
      key: this.mapInfrastructureKeyToDomain(metadata2.key),
      createdAt: metadata2.createdAt,
      expiresAt: metadata2.expiresAt,
      lastAccessedAt: metadata2.lastAccessedAt,
      hits: metadata2.hits,
      tags: metadata2.tags
    };
  }
  /**
   * Maps Infrastructure cache lookup result to Domain cache lookup result.
   */
  mapInfrastructureLookupResultToDomain(result) {
    const domainResult = {
      hit: result.hit,
      metadata: this.mapInfrastructureMetadataToDomain(result.metadata)
    };
    if (result.value !== void 0) {
      domainResult.value = result.value;
    }
    return domainResult;
  }
  /**
   * Maps Infrastructure cache statistics to Domain cache statistics.
   */
  mapInfrastructureStatisticsToDomain(statistics) {
    return {
      hits: statistics.hits,
      misses: statistics.misses,
      evictions: statistics.evictions,
      size: statistics.size,
      enabled: statistics.enabled
    };
  }
  /**
   * Maps Domain invalidation predicate to Infrastructure invalidation predicate.
   */
  mapDomainPredicateToInfrastructure(predicate) {
    return (entry) => {
      const domainEntry = this.mapInfrastructureMetadataToDomain(entry);
      return predicate(domainEntry);
    };
  }
  get isEnabled() {
    return this.cacheService.isEnabled;
  }
  get size() {
    return this.cacheService.size;
  }
  get(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const result = this.cacheService.get(infraKey);
    if (!result) return null;
    return this.mapInfrastructureLookupResultToDomain(result);
  }
  set(key2, value2, options) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const infraOptions = this.mapDomainOptionsToInfrastructure(options);
    const metadata2 = this.cacheService.set(infraKey, value2, infraOptions);
    return this.mapInfrastructureMetadataToDomain(metadata2);
  }
  delete(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    return this.cacheService.delete(infraKey);
  }
  has(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    return this.cacheService.has(infraKey);
  }
  clear() {
    return this.cacheService.clear();
  }
  invalidateWhere(predicate) {
    const infraPredicate = this.mapDomainPredicateToInfrastructure(predicate);
    return this.cacheService.invalidateWhere(infraPredicate);
  }
  getMetadata(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const metadata2 = this.cacheService.getMetadata(infraKey);
    if (!metadata2) return null;
    return this.mapInfrastructureMetadataToDomain(metadata2);
  }
  getStatistics() {
    const statistics = this.cacheService.getStatistics();
    return this.mapInfrastructureStatisticsToDomain(statistics);
  }
  async getOrSet(key2, factory, options) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const infraOptions = this.mapDomainOptionsToInfrastructure(options);
    const result = await this.cacheService.getOrSet(infraKey, factory, infraOptions);
    if (!result.ok) {
      return result;
    }
    return {
      ok: true,
      value: this.mapInfrastructureLookupResultToDomain(result.value)
    };
  }
};
__name(_CachePortAdapter, "CachePortAdapter");
let CachePortAdapter = _CachePortAdapter;
const _DICachePortAdapter = class _DICachePortAdapter extends CachePortAdapter {
  constructor(cacheService) {
    super(cacheService);
  }
};
__name(_DICachePortAdapter, "DICachePortAdapter");
_DICachePortAdapter.dependencies = [cacheServiceToken];
let DICachePortAdapter = _DICachePortAdapter;
function registerCacheServices(container) {
  const runtimeConfig = container.getRegisteredValue(runtimeConfigToken);
  if (!runtimeConfig) {
    return err("PlatformRuntimeConfigPort not registered");
  }
  const maxEntries2 = runtimeConfig.get("cacheMaxEntries");
  const config2 = {
    enabled: runtimeConfig.get("enableCacheService"),
    defaultTtlMs: runtimeConfig.get("cacheDefaultTtlMs"),
    namespace: MODULE_METADATA.ID,
    ...typeof maxEntries2 === "number" && maxEntries2 > 0 ? { maxEntries: maxEntries2 } : {}
  };
  const configResult = container.registerValue(cacheServiceConfigToken, config2);
  if (isErr(configResult)) {
    return err(`Failed to register CacheServiceConfig: ${configResult.error.message}`);
  }
  const serviceResult = container.registerFactory(
    cacheServiceToken,
    () => {
      const configResult2 = container.resolveWithError(cacheServiceConfigToken);
      if (!configResult2.ok) {
        throw new Error(`Failed to resolve CacheServiceConfig: ${configResult2.error.message}`);
      }
      const metricsResult = container.resolveWithError(
        metricsCollectorToken
      );
      const metricsCollector = metricsResult.ok ? metricsResult.value : void 0;
      const factory = new CacheCompositionFactory();
      const composition = factory.create(configResult2.value, metricsCollector);
      return new CacheService(
        composition.runtime,
        composition.policy,
        composition.telemetry,
        composition.store,
        composition.configManager,
        composition.expirationManager
      );
    },
    ServiceLifecycle.SINGLETON,
    [cacheServiceConfigToken, metricsCollectorToken]
  );
  if (isErr(serviceResult)) {
    return err(`Failed to register CacheService: ${serviceResult.error.message}`);
  }
  const maintenancePortResult = container.registerFactory(
    cacheMaintenancePortToken,
    () => {
      const serviceResult2 = container.resolveWithError(cacheServiceToken);
      if (!serviceResult2.ok) {
        throw new Error(`Failed to resolve CacheService: ${serviceResult2.error.message}`);
      }
      return serviceResult2.value;
    },
    ServiceLifecycle.SINGLETON,
    [cacheServiceToken]
  );
  if (isErr(maintenancePortResult)) {
    return err(`Failed to register CacheMaintenancePort: ${maintenancePortResult.error.message}`);
  }
  const readerPortResult = container.registerClass(
    cacheReaderPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(readerPortResult)) {
    return err(`Failed to register CacheReaderPort: ${readerPortResult.error.message}`);
  }
  const writerPortResult = container.registerClass(
    cacheWriterPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(writerPortResult)) {
    return err(`Failed to register CacheWriterPort: ${writerPortResult.error.message}`);
  }
  const invalidationPortResult = container.registerClass(
    cacheInvalidationPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(invalidationPortResult)) {
    return err(`Failed to register CacheInvalidationPort: ${invalidationPortResult.error.message}`);
  }
  const statsPortResult = container.registerClass(
    cacheStatsPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(statsPortResult)) {
    return err(`Failed to register CacheStatsPort: ${statsPortResult.error.message}`);
  }
  const computePortResult = container.registerClass(
    cacheComputePortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(computePortResult)) {
    return err(`Failed to register CacheComputePort: ${computePortResult.error.message}`);
  }
  const configSyncResult = container.registerFactory(
    cacheConfigSyncToken,
    () => {
      const runtimeConfigResult = container.resolveWithError(runtimeConfigToken);
      if (!runtimeConfigResult.ok) {
        throw new Error(
          `Failed to resolve PlatformRuntimeConfigPort: ${runtimeConfigResult.error.message}`
        );
      }
      const maintenancePortResult2 = container.resolveWithError(cacheMaintenancePortToken);
      if (!maintenancePortResult2.ok) {
        throw new Error(
          `Failed to resolve CacheMaintenancePort: ${maintenancePortResult2.error.message}`
        );
      }
      return new DICacheConfigSync(runtimeConfigResult.value, maintenancePortResult2.value);
    },
    ServiceLifecycle.SINGLETON,
    [runtimeConfigToken, cacheMaintenancePortToken]
  );
  if (isErr(configSyncResult)) {
    return err(`Failed to register CacheConfigSync: ${configSyncResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerCacheServices, "registerCacheServices");
function initializeCacheConfigSync(container) {
  const configSyncResult = container.resolveWithError(cacheConfigSyncToken);
  if (!configSyncResult.ok) {
    return ok(void 0);
  }
  const configSync = configSyncResult.value;
  configSync.bind();
  return ok(void 0);
}
__name(initializeCacheConfigSync, "initializeCacheConfigSync");
registerDependencyStep({
  name: "CacheServices",
  priority: 50,
  execute: registerCacheServices
});
const platformBootstrapEventPortToken = createInjectionToken(
  "PlatformBootstrapEventPort"
);
const metricsRecorderToken = createInjectionToken("MetricsRecorder");
const metricsSamplerToken = createInjectionToken("MetricsSampler");
const metricsReporterToken = createInjectionToken("MetricsReporter");
const traceContextToken = createInjectionToken("TraceContext");
const metricsStorageToken = createInjectionToken("MetricsStorage");
const metricsAggregatorToken = createInjectionToken("MetricsAggregator");
const metricsPersistenceManagerToken = createInjectionToken(
  "MetricsPersistenceManager"
);
const metricsStateManagerToken = createInjectionToken("MetricsStateManager");
const moduleApiInitializerToken = createInjectionToken("ModuleApiInitializer");
const moduleHealthServiceToken = createInjectionToken("ModuleHealthService");
function isValidMetricDefinition(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  return "key" in value2 && typeof value2.key === "string" && "initialValue" in value2 && typeof value2.initialValue !== "undefined" && "reducer" in value2 && typeof value2.reducer === "function" && "serializer" in value2 && typeof value2.serializer === "function";
}
__name(isValidMetricDefinition, "isValidMetricDefinition");
function castToMetricDefinition(definition) {
  if (!isValidMetricDefinition(definition)) {
    throw new Error(`Invalid metric definition structure for key "${definition.key}"`);
  }
  return definition;
}
__name(castToMetricDefinition, "castToMetricDefinition");
function castMetricValue(value2, key2) {
  if (value2 === void 0) {
    throw new Error(
      `Metric value for key "${key2}" is undefined. This indicates a registry initialization issue.`
    );
  }
  return value2;
}
__name(castMetricValue, "castMetricValue");
const _MetricDefinitionRegistry = class _MetricDefinitionRegistry {
  constructor() {
    this.definitions = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a metric definition.
   *
   * @param definition - Metric definition to register
   * @throws Error if a definition with the same key already exists or if the definition is invalid
   */
  register(definition) {
    if (this.definitions.has(definition.key)) {
      throw new Error(
        `Metric definition with key "${definition.key}" already exists. Use a different key or remove the existing definition first.`
      );
    }
    this.definitions.set(definition.key, castToMetricDefinition(definition));
  }
  /**
   * Gets a metric definition by key.
   *
   * @param key - Metric key
   * @returns Metric definition or undefined if not found
   */
  get(key2) {
    return this.definitions.get(key2);
  }
  /**
   * Gets all registered metric definitions.
   *
   * @returns Array of all metric definitions
   */
  getAll() {
    return Array.from(this.definitions.values());
  }
  /**
   * Checks if a metric definition exists.
   *
   * @param key - Metric key
   * @returns True if definition exists
   */
  has(key2) {
    return this.definitions.has(key2);
  }
  /**
   * Removes a metric definition.
   *
   * @param key - Metric key to remove
   * @returns True if definition was removed, false if it didn't exist
   */
  remove(key2) {
    return this.definitions.delete(key2);
  }
  /**
   * Clears all registered definitions.
   */
  clear() {
    this.definitions.clear();
  }
  /**
   * Gets the number of registered definitions.
   *
   * @returns Number of registered definitions
   */
  size() {
    return this.definitions.size;
  }
};
__name(_MetricDefinitionRegistry, "MetricDefinitionRegistry");
let MetricDefinitionRegistry = _MetricDefinitionRegistry;
function isResolutionEvent(event2) {
  return typeof event2 === "object" && event2 !== null && "durationMs" in event2 && typeof event2.durationMs === "number" && "success" in event2 && typeof event2.success === "boolean";
}
__name(isResolutionEvent, "isResolutionEvent");
function isPortSelectionEvent(event2) {
  return typeof event2 === "object" && event2 !== null && "version" in event2 && typeof event2.version === "number";
}
__name(isPortSelectionEvent, "isPortSelectionEvent");
function isCacheAccessEvent(event2) {
  return typeof event2 === "object" && event2 !== null && "hit" in event2 && typeof event2.hit === "boolean";
}
__name(isCacheAccessEvent, "isCacheAccessEvent");
const containerResolutionsDefinition = {
  key: "containerResolutions",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, _event) => current + 1, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const resolutionErrorsDefinition = {
  key: "resolutionErrors",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isResolutionEvent(event2)) {
      return current;
    }
    return event2.success ? current : current + 1;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const cacheHitsDefinition = {
  key: "cacheHits",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isCacheAccessEvent(event2)) {
      return current;
    }
    return event2.hit ? current + 1 : current;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const cacheMissesDefinition = {
  key: "cacheMisses",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isCacheAccessEvent(event2)) {
      return current;
    }
    return event2.hit ? current : current + 1;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const portSelectionsDefinition = {
  key: "portSelections",
  initialValue: /* @__PURE__ */ new Map(),
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isPortSelectionEvent(event2)) {
      return current;
    }
    const count = current.get(event2.version) ?? 0;
    const updated = new Map(current);
    updated.set(event2.version, count + 1);
    return updated;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => Object.fromEntries(value2), "serializer")
};
const portSelectionFailuresDefinition = {
  key: "portSelectionFailures",
  initialValue: /* @__PURE__ */ new Map(),
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isPortSelectionEvent(event2)) {
      return current;
    }
    const count = current.get(event2.version) ?? 0;
    const updated = new Map(current);
    updated.set(event2.version, count + 1);
    return updated;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => Object.fromEntries(value2), "serializer")
};
const resolutionTimesDefinition = {
  key: "resolutionTimes",
  initialValue: {
    buffer: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
    index: 0,
    count: 0
  },
  reducer: /* @__PURE__ */ __name((current, event2) => {
    if (!isResolutionEvent(event2)) {
      return current;
    }
    const buffer = new Float64Array(current.buffer);
    const maxSize2 = METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE;
    buffer[current.index] = event2.durationMs;
    const newIndex = (current.index + 1) % maxSize2;
    const newCount = Math.min(current.count + 1, maxSize2);
    return {
      buffer,
      index: newIndex,
      count: newCount
    };
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => ({
    buffer: Array.from(value2.buffer),
    index: value2.index,
    count: value2.count
  }), "serializer")
};
function createDefaultMetricDefinitionRegistry() {
  const registry = new MetricDefinitionRegistry();
  registry.register(containerResolutionsDefinition);
  registry.register(resolutionErrorsDefinition);
  registry.register(cacheHitsDefinition);
  registry.register(cacheMissesDefinition);
  registry.register(portSelectionsDefinition);
  registry.register(portSelectionFailuresDefinition);
  registry.register(resolutionTimesDefinition);
  return registry;
}
__name(createDefaultMetricDefinitionRegistry, "createDefaultMetricDefinitionRegistry");
const _MetricsCollector = class _MetricsCollector {
  constructor(config2, aggregator, persistenceManager, stateManager, registry) {
    this.config = config2;
    this.metricStates = /* @__PURE__ */ new Map();
    this.registry = registry ?? createDefaultMetricDefinitionRegistry();
    this.initializeMetricStates();
    this.aggregator = aggregator;
    this.persistenceManager = persistenceManager;
    this.stateManager = stateManager;
  }
  /**
   * Initializes metric states from registry definitions.
   * Private method called during construction.
   */
  initializeMetricStates() {
    for (const definition of this.registry.getAll()) {
      this.metricStates.set(definition.key, {
        value: definition.initialValue,
        definition
      });
    }
  }
  /**
   * Updates a metric using its reducer function.
   *
   * @param key - Metric key
   * @param event - Event data for the reducer
   */
  updateMetric(key2, event2) {
    const state2 = this.metricStates.get(key2);
    if (!state2) {
      return;
    }
    const newValue = state2.definition.reducer(state2.value, event2);
    this.metricStates.set(key2, {
      value: newValue,
      definition: state2.definition
    });
  }
  /**
   * Records a service resolution attempt.
   *
   * @param token - The injection token that was resolved
   * @param durationMs - Time taken to resolve in milliseconds
   * @param success - Whether resolution succeeded
   */
  recordResolution(token, durationMs, success) {
    const event2 = { token, durationMs, success };
    this.updateMetric("containerResolutions", event2);
    this.updateMetric("resolutionErrors", event2);
    this.updateMetric("resolutionTimes", event2);
    this.notifyStateChanged();
  }
  /**
   * Records a port selection event.
   *
   * @param version - The Foundry version for which a port was selected
   */
  recordPortSelection(version) {
    this.updateMetric("portSelections", { version });
    this.notifyStateChanged();
  }
  /**
   * Records a port selection failure.
   *
   * Useful for tracking when no compatible port is available for a version.
   *
   * @param version - The Foundry version for which port selection failed
   */
  recordPortSelectionFailure(version) {
    this.updateMetric("portSelectionFailures", { version });
    this.notifyStateChanged();
  }
  /**
   * Records a cache access (hit or miss).
   *
   * @param hit - True if cache hit, false if cache miss
   */
  recordCacheAccess(hit) {
    const event2 = { hit };
    this.updateMetric("cacheHits", event2);
    this.updateMetric("cacheMisses", event2);
    this.notifyStateChanged();
  }
  /**
   * Gets a snapshot of current metrics.
   * Delegates aggregation to MetricsAggregator.
   *
   * @returns Immutable snapshot of metrics data
   */
  getSnapshot() {
    return this.aggregator.aggregate(this.getRawMetrics());
  }
  /**
   * Gets raw metrics data without aggregation.
   * Used internally by aggregator and persistence manager.
   *
   * Converts from generic Map structure to IRawMetrics for backward compatibility.
   *
   * @returns Raw metrics data
   */
  getRawMetrics() {
    const containerResolutions = this.getMetricValue("containerResolutions") ?? 0;
    const resolutionErrors = this.getMetricValue("resolutionErrors") ?? 0;
    const cacheHits = this.getMetricValue("cacheHits") ?? 0;
    const cacheMisses = this.getMetricValue("cacheMisses") ?? 0;
    const portSelectionsRaw = this.getMetricValue("portSelections");
    const portSelections = portSelectionsRaw instanceof Map ? portSelectionsRaw : /* @__PURE__ */ new Map();
    const portSelectionFailuresRaw = this.getMetricValue("portSelectionFailures");
    const portSelectionFailures = portSelectionFailuresRaw instanceof Map ? portSelectionFailuresRaw : /* @__PURE__ */ new Map();
    const resolutionTimesState = this.getMetricValue("resolutionTimes");
    return {
      containerResolutions,
      resolutionErrors,
      cacheHits,
      cacheMisses,
      portSelections,
      portSelectionFailures,
      resolutionTimes: resolutionTimesState?.buffer ?? new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: resolutionTimesState?.index ?? 0,
      resolutionTimesCount: resolutionTimesState?.count ?? 0
    };
  }
  /**
   * Gets a metric value by key.
   *
   * @param key - Metric key
   * @returns Metric value or undefined if not found
   */
  getMetricValue(key2) {
    const state2 = this.metricStates.get(key2);
    if (!state2) {
      return void 0;
    }
    return castMetricValue(state2.value, key2);
  }
  /**
   * Resets all collected metrics.
   * Useful for testing or starting fresh measurements.
   */
  reset() {
    for (const definition of this.registry.getAll()) {
      this.metricStates.set(definition.key, {
        value: definition.initialValue,
        definition
      });
    }
    this.stateManager.reset();
    this.notifyStateChanged();
  }
  /**
   * Hook invoked after state mutations. Subclasses can override to react
   * (e.g., persist metrics).
   */
  onStateChanged() {
    this.stateManager.notifyStateChanged();
  }
  /**
   * Notifies state manager of state changes.
   * Internal method that can be overridden by subclasses.
   */
  notifyStateChanged() {
    this.onStateChanged();
  }
  /**
   * Captures the internal state for persistence.
   * Delegates to MetricsPersistenceManager.
   *
   * @returns Serializable metrics state
   */
  getPersistenceState() {
    return this.persistenceManager.serialize(this.getRawMetrics());
  }
  /**
   * Restores internal state from a persisted snapshot.
   * Delegates to MetricsPersistenceManager.
   *
   * @param state - Persisted metrics state
   */
  restoreFromPersistenceState(state2) {
    const rawMetrics = this.persistenceManager.deserialize(state2);
    this.applyRawMetrics(rawMetrics);
  }
  /**
   * Applies raw metrics to internal state.
   * Internal method used by restoreFromPersistenceState.
   * Converts from IRawMetrics to generic Map structure.
   *
   * @param rawMetrics - Raw metrics to apply
   */
  applyRawMetrics(rawMetrics) {
    this.setMetricValue("containerResolutions", rawMetrics.containerResolutions);
    this.setMetricValue("resolutionErrors", rawMetrics.resolutionErrors);
    this.setMetricValue("cacheHits", rawMetrics.cacheHits);
    this.setMetricValue("cacheMisses", rawMetrics.cacheMisses);
    this.setMetricValue("portSelections", rawMetrics.portSelections);
    this.setMetricValue("portSelectionFailures", rawMetrics.portSelectionFailures);
    const resolutionTimesState = this.metricStates.get("resolutionTimes");
    if (resolutionTimesState) {
      const buffer = new Float64Array(rawMetrics.resolutionTimes);
      this.setMetricValue("resolutionTimes", {
        buffer,
        index: rawMetrics.resolutionTimesIndex,
        count: rawMetrics.resolutionTimesCount
      });
    }
  }
  /**
   * Sets a metric value by key.
   *
   * @param key - Metric key
   * @param value - New metric value
   */
  setMetricValue(key2, value2) {
    const state2 = this.metricStates.get(key2);
    if (state2) {
      this.metricStates.set(key2, {
        value: value2,
        definition: state2.definition
      });
    }
  }
};
__name(_MetricsCollector, "MetricsCollector");
_MetricsCollector.dependencies = [runtimeConfigToken];
let MetricsCollector = _MetricsCollector;
const _DIMetricsCollector = class _DIMetricsCollector extends MetricsCollector {
  constructor(config2, aggregator, persistenceManager, stateManager, registry) {
    super(config2, aggregator, persistenceManager, stateManager, registry);
  }
};
__name(_DIMetricsCollector, "DIMetricsCollector");
_DIMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsAggregatorToken,
  metricsPersistenceManagerToken,
  metricsStateManagerToken
];
let DIMetricsCollector = _DIMetricsCollector;
const _PersistentMetricsCollector = class _PersistentMetricsCollector extends MetricsCollector {
  constructor(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry) {
    super(config2, aggregator, persistenceManager, stateManager, registry);
    this.metricsStorage = metricsStorage;
    this.suppressPersistence = false;
    this.initialized = false;
  }
  /**
   * Initializes the collector by restoring state from storage.
   * Must be called explicitly after construction.
   *
   * @returns Result indicating success or error
   */
  initialize() {
    if (this.initialized) {
      return ok(void 0);
    }
    try {
      this.restoreFromStorage();
      this.initialized = true;
      return ok(void 0);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return err(`Failed to initialize PersistentMetricsCollector: ${errorMessage}`);
    }
  }
  clearPersistentState() {
    this.metricsStorage.clear?.();
    this.suppressPersistence = true;
    try {
      super.reset();
    } finally {
      this.suppressPersistence = false;
    }
  }
  onStateChanged() {
    super.onStateChanged();
    if (this.suppressPersistence) {
      return;
    }
    this.persist();
  }
  restoreFromStorage() {
    let state2 = null;
    try {
      state2 = this.metricsStorage.load();
    } catch {
      state2 = null;
    }
    if (!state2) {
      return;
    }
    this.suppressPersistence = true;
    try {
      this.restoreFromPersistenceState(state2);
    } finally {
      this.suppressPersistence = false;
    }
  }
  persist() {
    try {
      this.metricsStorage.save(this.getPersistenceState());
    } catch {
    }
  }
};
__name(_PersistentMetricsCollector, "PersistentMetricsCollector");
_PersistentMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsStorageToken
];
let PersistentMetricsCollector = _PersistentMetricsCollector;
const _DIPersistentMetricsCollector = class _DIPersistentMetricsCollector extends PersistentMetricsCollector {
  constructor(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry) {
    super(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry);
  }
};
__name(_DIPersistentMetricsCollector, "DIPersistentMetricsCollector");
_DIPersistentMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsStorageToken,
  metricsAggregatorToken,
  metricsPersistenceManagerToken,
  metricsStateManagerToken
];
let DIPersistentMetricsCollector = _DIPersistentMetricsCollector;
const _MetricsAggregator = class _MetricsAggregator {
  /**
   * Aggregates raw metrics into a snapshot.
   *
   * @param metrics - Raw metrics data
   * @returns Aggregated metrics snapshot
   */
  aggregate(metrics) {
    const avgTime = this.calculateAverage(metrics.resolutionTimes, metrics.resolutionTimesCount);
    const cacheHitRate = this.calculateCacheHitRate(metrics.cacheHits, metrics.cacheMisses);
    return {
      containerResolutions: metrics.containerResolutions,
      resolutionErrors: metrics.resolutionErrors,
      avgResolutionTimeMs: avgTime,
      portSelections: Object.fromEntries(metrics.portSelections),
      portSelectionFailures: Object.fromEntries(metrics.portSelectionFailures),
      cacheHitRate
    };
  }
  /**
   * Calculates the average of resolution times.
   *
   * @param times - Array of resolution times
   * @param count - Number of valid entries in the array
   * @returns Average time in milliseconds
   */
  calculateAverage(times, count) {
    if (count === 0) {
      return 0;
    }
    const slice = times.slice(0, count);
    const sum = slice.reduce((acc, time) => acc + time, 0);
    return sum / count;
  }
  /**
   * Calculates the cache hit rate as a percentage.
   *
   * @param hits - Number of cache hits
   * @param misses - Number of cache misses
   * @returns Cache hit rate (0-100)
   */
  calculateCacheHitRate(hits, misses) {
    const totalAccess = hits + misses;
    if (totalAccess === 0) {
      return 0;
    }
    return hits / totalAccess * 100;
  }
};
__name(_MetricsAggregator, "MetricsAggregator");
let MetricsAggregator = _MetricsAggregator;
const _MetricsPersistenceManager = class _MetricsPersistenceManager {
  /**
   * Serializes raw metrics into a persistence state.
   *
   * @param metrics - Raw metrics data
   * @returns Serializable persistence state
   */
  serialize(metrics) {
    return {
      metrics: {
        containerResolutions: metrics.containerResolutions,
        resolutionErrors: metrics.resolutionErrors,
        cacheHits: metrics.cacheHits,
        cacheMisses: metrics.cacheMisses,
        portSelections: Object.fromEntries(metrics.portSelections),
        portSelectionFailures: Object.fromEntries(metrics.portSelectionFailures)
      },
      resolutionTimes: Array.from(metrics.resolutionTimes),
      resolutionTimesIndex: metrics.resolutionTimesIndex,
      resolutionTimesCount: metrics.resolutionTimesCount
    };
  }
  /**
   * Deserializes a persistence state into raw metrics.
   *
   * @param state - Persisted state (can be null or undefined)
   * @returns Raw metrics data
   */
  deserialize(state2) {
    if (!state2) {
      return this.createEmptyRawMetrics();
    }
    const { metrics, resolutionTimes, resolutionTimesCount, resolutionTimesIndex } = state2;
    const rawMetrics = {
      containerResolutions: Math.max(0, metrics?.containerResolutions ?? 0),
      resolutionErrors: Math.max(0, metrics?.resolutionErrors ?? 0),
      cacheHits: Math.max(0, metrics?.cacheHits ?? 0),
      cacheMisses: Math.max(0, metrics?.cacheMisses ?? 0),
      portSelections: new Map(
        Object.entries(metrics?.portSelections ?? {}).map(([key2, value2]) => [
          Number(key2),
          Number.isFinite(Number(value2)) ? Number(value2) : 0
        ])
      ),
      portSelectionFailures: new Map(
        Object.entries(metrics?.portSelectionFailures ?? {}).map(([key2, value2]) => [
          Number(key2),
          Number.isFinite(Number(value2)) ? Number(value2) : 0
        ])
      ),
      resolutionTimes: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: 0,
      resolutionTimesCount: 0
    };
    if (Array.isArray(resolutionTimes)) {
      const maxLength2 = Math.min(resolutionTimes.length, rawMetrics.resolutionTimes.length);
      for (let index2 = 0; index2 < maxLength2; index2++) {
        const value2 = Number(resolutionTimes[index2]);
        rawMetrics.resolutionTimes[index2] = Number.isFinite(value2) ? value2 : 0;
      }
      const safeIndex = Number.isFinite(resolutionTimesIndex) ? Number(resolutionTimesIndex) : 0;
      const safeCount = Number.isFinite(resolutionTimesCount) ? Number(resolutionTimesCount) : 0;
      rawMetrics.resolutionTimesIndex = Math.min(
        Math.max(0, safeIndex),
        METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE - 1
      );
      rawMetrics.resolutionTimesCount = Math.min(
        Math.max(0, safeCount),
        METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE
      );
    } else {
      rawMetrics.resolutionTimesIndex = 0;
      rawMetrics.resolutionTimesCount = 0;
    }
    return rawMetrics;
  }
  /**
   * Creates an empty raw metrics structure.
   *
   * @returns Empty raw metrics
   */
  createEmptyRawMetrics() {
    return {
      containerResolutions: 0,
      resolutionErrors: 0,
      cacheHits: 0,
      cacheMisses: 0,
      portSelections: /* @__PURE__ */ new Map(),
      portSelectionFailures: /* @__PURE__ */ new Map(),
      resolutionTimes: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: 0,
      resolutionTimesCount: 0
    };
  }
};
__name(_MetricsPersistenceManager, "MetricsPersistenceManager");
let MetricsPersistenceManager = _MetricsPersistenceManager;
const _MetricsStateManager = class _MetricsStateManager {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
  }
  /**
   * Resets the state manager.
   * Clears all registered callbacks.
   */
  reset() {
    this.callbacks.clear();
  }
  /**
   * Subscribes to state changes.
   *
   * @param callback - Callback to invoke on state changes
   */
  onStateChanged(callback) {
    this.callbacks.add(callback);
  }
  /**
   * Unsubscribes from state changes.
   *
   * @param callback - Callback to remove
   */
  unsubscribe(callback) {
    this.callbacks.delete(callback);
  }
  /**
   * Notifies all registered callbacks of a state change.
   * Internal method used by MetricsCollector.
   */
  notifyStateChanged() {
    for (const callback of this.callbacks) {
      try {
        callback();
      } catch (error) {
        console.error("Error in metrics state change callback:", error);
      }
    }
  }
};
__name(_MetricsStateManager, "MetricsStateManager");
let MetricsStateManager = _MetricsStateManager;
const _MetricsSampler = class _MetricsSampler {
  constructor(config2) {
    this.config = config2;
  }
  /**
   * Determines if a performance operation should be sampled based on sampling rate.
   *
   * In production mode, uses probabilistic sampling to reduce overhead.
   * In development mode, always samples (returns true).
   *
   * @returns True if the operation should be measured/recorded
   *
   * @example
   * ```typescript
   * const sampler = container.resolve(metricsSamplerToken);
   * if (sampler.shouldSample()) {
   *   performance.mark('operation-start');
   *   // ... operation ...
   *   performance.mark('operation-end');
   *   performance.measure('operation', 'operation-start', 'operation-end');
   * }
   * ```
   */
  shouldSample() {
    if (this.config.get("isDevelopment")) {
      return true;
    }
    return Math.random() < this.config.get("performanceSamplingRate");
  }
};
__name(_MetricsSampler, "MetricsSampler");
let MetricsSampler = _MetricsSampler;
const _DIMetricsSampler = class _DIMetricsSampler extends MetricsSampler {
  constructor(config2) {
    super(config2);
  }
};
__name(_DIMetricsSampler, "DIMetricsSampler");
_DIMetricsSampler.dependencies = [runtimeConfigToken];
let DIMetricsSampler = _DIMetricsSampler;
const _MetricsReporter = class _MetricsReporter {
  constructor(collector, logger) {
    this.collector = collector;
    this.logger = logger;
  }
  /**
   * Logs a formatted metrics summary to the console.
   * Uses console.table() for easy-to-read tabular output.
   */
  logSummary() {
    const snapshot2 = this.collector.getSnapshot();
    const tableData = {
      "Total Resolutions": snapshot2.containerResolutions,
      Errors: snapshot2.resolutionErrors,
      "Avg Time (ms)": snapshot2.avgResolutionTimeMs.toFixed(2),
      "Cache Hit Rate": `${snapshot2.cacheHitRate.toFixed(1)}%`
    };
    console.table(tableData);
  }
  /**
   * Gibt Metrics als JSON zurück.
   *
   * @returns JSON string representation of metrics snapshot
   */
  toJSON() {
    return JSON.stringify(this.collector.getSnapshot(), null, 2);
  }
};
__name(_MetricsReporter, "MetricsReporter");
let MetricsReporter = _MetricsReporter;
const _DIMetricsReporter = class _DIMetricsReporter extends MetricsReporter {
  constructor(collector, logger) {
    super(collector, logger);
  }
};
__name(_DIMetricsReporter, "DIMetricsReporter");
_DIMetricsReporter.dependencies = [metricsCollectorToken, loggerToken];
let DIMetricsReporter = _DIMetricsReporter;
const _LocalStorageMetricsStorage = class _LocalStorageMetricsStorage {
  constructor(storageKey, storage = getStorage()) {
    this.storageKey = storageKey;
    this.storage = storage;
  }
  load() {
    if (!this.storage) {
      return null;
    }
    try {
      const raw = this.storage.getItem(this.storageKey);
      if (!raw) {
        return null;
      }
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }
  save(state2) {
    if (!this.storage) {
      return;
    }
    try {
      this.storage.setItem(this.storageKey, JSON.stringify(state2));
    } catch {
    }
  }
  clear() {
    if (!this.storage) {
      return;
    }
    try {
      this.storage.removeItem(this.storageKey);
    } catch {
    }
  }
};
__name(_LocalStorageMetricsStorage, "LocalStorageMetricsStorage");
let LocalStorageMetricsStorage = _LocalStorageMetricsStorage;
function getStorage() {
  try {
    if (typeof globalThis !== "undefined" && "localStorage" in globalThis) {
      return globalThis.localStorage;
    }
  } catch {
  }
  return null;
}
__name(getStorage, "getStorage");
function createMetricsStorage(key2) {
  return new LocalStorageMetricsStorage(key2);
}
__name(createMetricsStorage, "createMetricsStorage");
function createInMemoryMetricsStorage() {
  let state2 = null;
  return {
    load() {
      return state2;
    },
    save(newState) {
      state2 = newState;
    },
    clear() {
      state2 = null;
    }
  };
}
__name(createInMemoryMetricsStorage, "createInMemoryMetricsStorage");
const _TracedLogger = class _TracedLogger {
  constructor(baseLogger, traceId) {
    this.baseLogger = baseLogger;
    this.traceId = traceId;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatMessage(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatMessage(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatMessage(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatMessage(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatMessage(message2), ...optionalParams);
  }
  withTraceId(newTraceId) {
    return new _TracedLogger(this.baseLogger, `${this.traceId}/${newTraceId}`);
  }
  formatMessage(message2) {
    return `[${this.traceId}] ${message2}`;
  }
};
__name(_TracedLogger, "TracedLogger");
let TracedLogger = _TracedLogger;
const _BaseConsoleLogger = class _BaseConsoleLogger {
  constructor(minLevel) {
    this.minLevel = minLevel;
  }
  setMinLevel(level) {
    this.minLevel = level;
  }
  log(message2, ...optionalParams) {
    console.log(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    if (LogLevel.ERROR < this.minLevel) return;
    console.error(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    if (LogLevel.WARN < this.minLevel) return;
    console.warn(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    if (LogLevel.INFO < this.minLevel) return;
    console.info(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    if (LogLevel.DEBUG < this.minLevel) return;
    console.debug(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  withTraceId(traceId) {
    return new TracedLogger(this, traceId);
  }
};
__name(_BaseConsoleLogger, "BaseConsoleLogger");
let BaseConsoleLogger = _BaseConsoleLogger;
const _RuntimeConfigLoggerDecorator = class _RuntimeConfigLoggerDecorator {
  constructor(baseLogger, runtimeConfig) {
    this.baseLogger = baseLogger;
    this.runtimeConfig = runtimeConfig;
    this.unsubscribe = null;
    this.syncLogLevel();
  }
  syncLogLevel() {
    this.baseLogger.setMinLevel?.(this.runtimeConfig.get("logLevel"));
    this.unsubscribe?.();
    this.unsubscribe = this.runtimeConfig.onChange("logLevel", (level) => {
      this.baseLogger.setMinLevel?.(level);
    });
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(message2, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(message2, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(message2, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(message2, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(message2, ...optionalParams);
  }
  withTraceId(traceId) {
    return this.baseLogger.withTraceId?.(traceId) ?? this.baseLogger;
  }
  dispose() {
    this.unsubscribe?.();
  }
};
__name(_RuntimeConfigLoggerDecorator, "RuntimeConfigLoggerDecorator");
let RuntimeConfigLoggerDecorator = _RuntimeConfigLoggerDecorator;
const _StackTraceLoggerDecorator = class _StackTraceLoggerDecorator {
  constructor(baseLogger, runtimeConfig) {
    this.baseLogger = baseLogger;
    this.runtimeConfig = runtimeConfig;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  /**
   * Extracts the caller information from stack trace when debug mode is enabled.
   * Filters out logger-related frames to show the actual source of the log call.
   *
   * @returns Caller info in format "filename:line" or undefined if not in debug mode or extraction fails
   */
  getCallerInfo() {
    const currentLogLevel = this.runtimeConfig.get("logLevel");
    if (currentLogLevel !== LogLevel.DEBUG) {
      return void 0;
    }
    try {
      const stack2 = new Error().stack;
      if (!stack2) return void 0;
      const lines = stack2.split("\n");
      const loggerPatterns = [
        /StackTraceLoggerDecorator/,
        /BaseConsoleLogger/,
        /ConsoleLoggerService/,
        /RuntimeConfigLoggerDecorator/,
        /TraceContextLoggerDecorator/,
        /TracedLogger/,
        /at Object\./
      ];
      for (let i = 3; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const isLoggerFrame = loggerPatterns.some((pattern) => pattern.test(line));
        if (!isLoggerFrame && line.trim()) {
          const match2 = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/) || line.match(/at\s+(.+?):(\d+):(\d+)/);
          if (match2) {
            const filePath = match2[2] || match2[1];
            const lineNum = match2[3] || match2[2];
            if (filePath && lineNum) {
              const fileName = filePath.split(/[/\\]/).pop() || filePath;
              return `${fileName}:${lineNum}`;
            }
          }
          return line.trim().replace(/^at\s+/, "");
        }
      }
    } catch {
    }
    return void 0;
  }
  formatWithCallerInfo(message2) {
    const callerInfo = this.getCallerInfo();
    return callerInfo ? `${message2} [${callerInfo}]` : message2;
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  withTraceId(traceId) {
    return this.baseLogger.withTraceId?.(traceId) ?? this.baseLogger;
  }
};
__name(_StackTraceLoggerDecorator, "StackTraceLoggerDecorator");
let StackTraceLoggerDecorator = _StackTraceLoggerDecorator;
const _TraceContextLoggerDecorator = class _TraceContextLoggerDecorator {
  constructor(baseLogger, traceContext) {
    this.baseLogger = baseLogger;
    this.traceContext = traceContext;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  formatWithTrace(message2) {
    const traceId = this.traceContext?.getCurrentTraceId();
    return traceId ? `[${traceId}] ${message2}` : message2;
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatWithTrace(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatWithTrace(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatWithTrace(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatWithTrace(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatWithTrace(message2), ...optionalParams);
  }
  withTraceId(traceId) {
    return new TracedLogger(this, traceId);
  }
};
__name(_TraceContextLoggerDecorator, "TraceContextLoggerDecorator");
let TraceContextLoggerDecorator = _TraceContextLoggerDecorator;
const _LoggerCompositionFactory = class _LoggerCompositionFactory {
  /**
   * Creates a composed logger with all necessary decorators.
   *
   * @param config - Runtime configuration port
   * @param traceContext - Optional trace context for trace ID injection
   * @returns Composed logger instance
   */
  createLogger(config2, traceContext) {
    const baseLogger = new BaseConsoleLogger(config2.get("logLevel"));
    const withConfig = new RuntimeConfigLoggerDecorator(baseLogger, config2);
    const withStackTrace = new StackTraceLoggerDecorator(withConfig, config2);
    return traceContext ? new TraceContextLoggerDecorator(withStackTrace, traceContext) : withStackTrace;
  }
};
__name(_LoggerCompositionFactory, "LoggerCompositionFactory");
let LoggerCompositionFactory = _LoggerCompositionFactory;
const _ConsoleLoggerService = class _ConsoleLoggerService {
  constructor(config2, traceContext, factory) {
    const compositionFactory = factory ?? new LoggerCompositionFactory();
    this.logger = compositionFactory.createLogger(config2, traceContext);
  }
  // Delegate all methods to composed logger
  setMinLevel(level) {
    this.logger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.logger.log(message2, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.logger.error(message2, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.logger.warn(message2, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.logger.info(message2, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.logger.debug(message2, ...optionalParams);
  }
  withTraceId(traceId) {
    return this.logger.withTraceId?.(traceId) ?? this.logger;
  }
};
__name(_ConsoleLoggerService, "ConsoleLoggerService");
let ConsoleLoggerService = _ConsoleLoggerService;
const _DIConsoleLoggerService = class _DIConsoleLoggerService extends ConsoleLoggerService {
  constructor(config2, traceContext) {
    super(config2, traceContext);
  }
};
__name(_DIConsoleLoggerService, "DIConsoleLoggerService");
_DIConsoleLoggerService.dependencies = [runtimeConfigToken, traceContextToken];
let DIConsoleLoggerService = _DIConsoleLoggerService;
function generateTraceId() {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 10);
  return `${timestamp}-${random}`;
}
__name(generateTraceId, "generateTraceId");
function getTraceTimestamp(traceId) {
  const parts = traceId.split("-");
  if (parts.length !== 2) {
    return null;
  }
  const [timestampStr, randomStr] = parts;
  if (!timestampStr || !randomStr) {
    return null;
  }
  const timestamp = parseInt(timestampStr, 10);
  return isNaN(timestamp) ? null : timestamp;
}
__name(getTraceTimestamp, "getTraceTimestamp");
const _TraceContext = class _TraceContext {
  constructor() {
    this.currentTraceId = null;
  }
  /**
   * Executes a synchronous function with trace context.
   *
   * Automatically generates a trace ID if not provided.
   * Maintains a context stack for nested traces.
   * Ensures proper cleanup via try/finally.
   *
   * @template T - The return type of the function
   * @param fn - Function to execute with trace context
   * @param options - Trace options (trace ID, operation name, metadata)
   * @returns The result of the function execution
   *
   * @example
   * ```typescript
   * const result = traceContext.trace(() => {
   *   logger.info("Processing"); // Automatically traced
   *   return processData();
   * });
   * ```
   */
  trace(fn, options) {
    const opts = typeof options === "string" ? { traceId: options } : options;
    const traceId = opts?.traceId ?? generateTraceId();
    const previousTraceId = this.currentTraceId;
    this.currentTraceId = traceId;
    try {
      return fn();
    } finally {
      this.currentTraceId = previousTraceId;
    }
  }
  /**
   * Executes an asynchronous function with trace context.
   *
   * Similar to trace() but for async operations.
   * Automatically generates a trace ID if not provided.
   * Maintains a context stack for nested traces.
   * Ensures proper cleanup via try/finally.
   *
   * @template T - The return type of the async function
   * @param fn - Async function to execute with trace context
   * @param options - Trace options (trace ID, operation name, metadata)
   * @returns Promise resolving to the result of the function execution
   *
   * @example
   * ```typescript
   * const result = await traceContext.traceAsync(async () => {
   *   logger.info("Fetching data"); // Automatically traced
   *   return await fetchData();
   * });
   * ```
   */
  async traceAsync(fn, options) {
    const opts = typeof options === "string" ? { traceId: options } : options;
    const traceId = opts?.traceId ?? generateTraceId();
    const previousTraceId = this.currentTraceId;
    this.currentTraceId = traceId;
    try {
      return await fn();
    } finally {
      this.currentTraceId = previousTraceId;
    }
  }
  /**
   * Gets the current trace ID from the context stack.
   *
   * Returns null if not currently in a traced context.
   * Useful for services that need to access the current trace ID
   * without having it passed as a parameter.
   *
   * @returns Current trace ID or null if not in traced context
   *
   * @example
   * ```typescript
   * const traceId = traceContext.getCurrentTraceId();
   * if (traceId) {
   *   console.log(`Current trace: ${traceId}`);
   * }
   * ```
   */
  getCurrentTraceId() {
    return this.currentTraceId;
  }
  /**
   * Cleans up resources.
   * For TraceContext, this resets the current trace ID.
   */
  dispose() {
    this.currentTraceId = null;
  }
};
__name(_TraceContext, "TraceContext");
_TraceContext.dependencies = [];
let TraceContext = _TraceContext;
const _DITraceContext = class _DITraceContext extends TraceContext {
  constructor() {
    super();
  }
};
__name(_DITraceContext, "DITraceContext");
_DITraceContext.dependencies = [];
let DITraceContext = _DITraceContext;
const _ModuleHealthService = class _ModuleHealthService {
  constructor(registry) {
    this.registry = registry;
    this.healthChecksInitialized = false;
  }
  /**
   * Gets the current health status of the module.
   *
   * Health is determined by running all registered health checks.
   * Overall status:
   * - "healthy": All checks pass
   * - "unhealthy": Container check fails
   * - "degraded": Other checks fail
   *
   * @returns HealthStatus with overall status, individual checks, and timestamp
   *
   * @example
   * ```typescript
   * const healthService = container.resolve(moduleHealthServiceToken);
   * const health = healthService.getHealth();
   *
   * if (health.status !== 'healthy') {
   *   console.warn('Module is not healthy:', health.checks);
   * }
   * ```
   */
  getHealth() {
    if (!this.healthChecksInitialized) {
      this.healthChecksInitialized = true;
    }
    const results = this.registry.runAll();
    const allHealthy = Array.from(results.values()).every((result) => result);
    const status = allHealthy ? "healthy" : results.get("container") === false ? "unhealthy" : "degraded";
    const checks = this.registry.getAllChecks();
    let lastError = null;
    for (const check2 of checks) {
      const result = results.get(check2.name);
      if (!result && check2.getDetails) {
        lastError = check2.getDetails();
      }
    }
    return {
      status,
      checks: {
        containerValidated: results.get("container") ?? true,
        portsSelected: results.get("metrics") ?? true,
        lastError
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
__name(_ModuleHealthService, "ModuleHealthService");
let ModuleHealthService = _ModuleHealthService;
const _DIModuleHealthService = class _DIModuleHealthService extends ModuleHealthService {
  constructor(registry) {
    super(registry);
  }
};
__name(_DIModuleHealthService, "DIModuleHealthService");
_DIModuleHealthService.dependencies = [healthCheckRegistryToken];
let DIModuleHealthService = _DIModuleHealthService;
const notificationCenterToken = createInjectionToken("NotificationCenter");
const journalVisibilityServiceToken = createInjectionToken("JournalVisibilityService");
const journalVisibilityConfigToken = createInjectionToken("JournalVisibilityConfig");
const hideJournalContextMenuHandlerToken = createInjectionToken(
  "HideJournalContextMenuHandler"
);
const journalContextMenuHandlersToken = createInjectionToken(
  "JournalContextMenuHandlers"
);
const journalDirectoryProcessorToken = createInjectionToken(
  "JournalDirectoryProcessor"
);
const runtimeConfigSyncToken = createInjectionToken("RuntimeConfigSync");
const runtimeConfigSettingsSyncToken = createInjectionToken(
  "RuntimeConfigSettingsSync"
);
const settingRegistrationErrorMapperToken = createInjectionToken(
  "SettingRegistrationErrorMapper"
);
const settingDefinitionRegistryToken = createInjectionToken(
  "SettingDefinitionRegistry"
);
const runtimeConfigBindingRegistryToken = createInjectionToken(
  "RuntimeConfigBindingRegistry"
);
const batchUpdateContextServiceToken = createInjectionToken(
  "BatchUpdateContextService"
);
const journalDirectoryRerenderSchedulerToken = createInjectionToken(
  "JournalDirectoryRerenderScheduler"
);
const eventRegistrarRegistryToken = createInjectionToken("EventRegistrarRegistry");
const i18nFacadeToken = createInjectionToken("I18nFacadeService");
const foundryGameToken = createInjectionToken("FoundryGame");
const foundryHooksToken = createInjectionToken("FoundryHooks");
const foundryDocumentToken = createInjectionToken("FoundryDocument");
const foundrySettingsToken = createInjectionToken("FoundrySettings");
const foundryJournalFacadeToken = createInjectionToken("FoundryJournalFacade");
function createApiTokens() {
  return {
    notificationCenterToken: markAsApiSafe(notificationCenterToken),
    journalVisibilityServiceToken: markAsApiSafe(journalVisibilityServiceToken),
    journalDirectoryProcessorToken: markAsApiSafe(journalDirectoryProcessorToken),
    foundryGameToken: markAsApiSafe(foundryGameToken),
    foundryHooksToken: markAsApiSafe(foundryHooksToken),
    foundryDocumentToken: markAsApiSafe(foundryDocumentToken),
    foundryUIToken: markAsApiSafe(foundryUIToken),
    foundrySettingsToken: markAsApiSafe(foundrySettingsToken),
    i18nFacadeToken: markAsApiSafe(i18nFacadeToken),
    foundryJournalFacadeToken: markAsApiSafe(foundryJournalFacadeToken)
  };
}
__name(createApiTokens, "createApiTokens");
const _ModuleApiBuilder = class _ModuleApiBuilder {
  constructor(serviceResolver, healthMetricsProvider) {
    this.serviceResolver = serviceResolver;
    this.healthMetricsProvider = healthMetricsProvider;
  }
  /**
   * Creates the well-known API tokens collection.
   *
   * @returns Type-safe token collection for external modules
   */
  createApiTokens() {
    return createApiTokens();
  }
  /**
   * Creates the complete ModuleApi object with all methods.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Complete ModuleApi object
   */
  createApi(container, wellKnownTokens) {
    return {
      version: PUBLIC_API_VERSION,
      // Overloaded resolve method (throws on error)
      resolve: this.serviceResolver.createResolveFunction(container, wellKnownTokens),
      // Result-Pattern method (safe, never throws)
      resolveWithError: this.serviceResolver.createResolveWithErrorFunction(
        container,
        wellKnownTokens
      ),
      getAvailableTokens: /* @__PURE__ */ __name(() => {
        const tokenMap = /* @__PURE__ */ new Map();
        const tokenEntries = [
          ["journalVisibilityServiceToken", journalVisibilityServiceToken],
          ["journalDirectoryProcessorToken", journalDirectoryProcessorToken],
          ["foundryGameToken", foundryGameToken],
          ["foundryHooksToken", foundryHooksToken],
          ["foundryDocumentToken", foundryDocumentToken],
          ["foundryUIToken", foundryUIToken],
          ["foundrySettingsToken", foundrySettingsToken],
          ["i18nFacadeToken", i18nFacadeToken],
          ["foundryJournalFacadeToken", foundryJournalFacadeToken],
          ["notificationCenterToken", notificationCenterToken]
        ];
        for (const [, token] of tokenEntries) {
          const isRegisteredResult = container.isRegistered(token);
          tokenMap.set(token, {
            description: String(token).replace("Symbol(", "").replace(")", ""),
            isRegistered: getRegistrationStatus(isRegisteredResult)
          });
        }
        return tokenMap;
      }, "getAvailableTokens"),
      tokens: wellKnownTokens,
      getMetrics: /* @__PURE__ */ __name(() => this.healthMetricsProvider.getMetrics(container), "getMetrics"),
      getHealth: /* @__PURE__ */ __name(() => this.healthMetricsProvider.getHealth(container), "getHealth")
    };
  }
};
__name(_ModuleApiBuilder, "ModuleApiBuilder");
let ModuleApiBuilder = _ModuleApiBuilder;
const _ApiWrapperStrategyRegistry = class _ApiWrapperStrategyRegistry {
  constructor() {
    this.strategies = [];
  }
  /**
   * Registers a wrapper strategy.
   *
   * @param strategy - Strategy to register
   */
  register(strategy) {
    this.strategies.push(strategy);
  }
  /**
   * Registers multiple wrapper strategies.
   *
   * @param strategies - Array of strategies to register
   */
  registerAll(strategies) {
    for (const strategy of strategies) {
      this.register(strategy);
    }
  }
  /**
   * Gets all registered strategies, sorted by priority (lower = higher priority).
   *
   * @returns Array of strategies in priority order
   */
  getAll() {
    return [...this.strategies].sort((a, b) => {
      const priorityA = a.getPriority?.() ?? 100;
      const priorityB = b.getPriority?.() ?? 100;
      return priorityA - priorityB;
    });
  }
  /**
   * Finds the first strategy that supports the given token.
   *
   * @param token - API token to find strategy for
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Strategy that supports the token, or null if none found
   */
  findStrategy(token, wellKnownTokens) {
    const sortedStrategies = this.getAll();
    for (const strategy of sortedStrategies) {
      if (strategy.supports(token, wellKnownTokens)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * Clears all registered strategies.
   * Useful for testing or reset scenarios.
   */
  clear() {
    this.strategies.length = 0;
  }
};
__name(_ApiWrapperStrategyRegistry, "ApiWrapperStrategyRegistry");
let ApiWrapperStrategyRegistry = _ApiWrapperStrategyRegistry;
function isAllowedKey(prop2, allowed) {
  if (typeof prop2 !== "string") {
    return false;
  }
  return allowed.includes(prop2);
}
__name(isAllowedKey, "isAllowedKey");
function createReadOnlyWrapper(service, allowedMethods) {
  return new Proxy(service, {
    get(target, prop2, receiver) {
      if (isAllowedKey(prop2, allowedMethods)) {
        const value2 = Reflect.get(target, prop2, receiver);
        if (typeof value2 === "function") {
          return value2.bind(target);
        }
        return value2;
      }
      throw new Error(
        `Property "${String(prop2)}" is not accessible via Public API. Only these methods are allowed: ${allowedMethods.map(String).join(", ")}`
      );
    },
    set() {
      throw new Error("Cannot modify services via Public API (read-only)");
    },
    deleteProperty() {
      throw new Error("Cannot delete properties via Public API (read-only)");
    }
  });
}
__name(createReadOnlyWrapper, "createReadOnlyWrapper");
function createPublicLogger(logger) {
  return createReadOnlyWrapper(logger, [
    "log",
    "debug",
    "info",
    "warn",
    "error",
    "withTraceId"
    // Decorator pattern for trace context
  ]);
}
__name(createPublicLogger, "createPublicLogger");
function createPublicI18n(i18n) {
  return createReadOnlyWrapper(i18n, ["translate", "format", "has"]);
}
__name(createPublicI18n, "createPublicI18n");
function createPublicNotificationCenter(notificationCenter) {
  return createReadOnlyWrapper(notificationCenter, [
    "debug",
    "info",
    "warn",
    "error",
    "getChannelNames"
  ]);
}
__name(createPublicNotificationCenter, "createPublicNotificationCenter");
function createPublicFoundrySettings(foundrySettings) {
  return createReadOnlyWrapper(foundrySettings, ["get"]);
}
__name(createPublicFoundrySettings, "createPublicFoundrySettings");
function wrapI18nService(service, create) {
  return create(service);
}
__name(wrapI18nService, "wrapI18nService");
function wrapNotificationCenterService(service, create) {
  return create(service);
}
__name(wrapNotificationCenterService, "wrapNotificationCenterService");
function wrapFoundrySettingsPort(service, create) {
  return create(service);
}
__name(wrapFoundrySettingsPort, "wrapFoundrySettingsPort");
const _I18nWrapperStrategy = class _I18nWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.i18nFacadeToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapI18nService(service, createPublicI18n);
  }
  getPriority() {
    return 10;
  }
};
__name(_I18nWrapperStrategy, "I18nWrapperStrategy");
let I18nWrapperStrategy = _I18nWrapperStrategy;
const _NotificationWrapperStrategy = class _NotificationWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.notificationCenterToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapNotificationCenterService(service, createPublicNotificationCenter);
  }
  getPriority() {
    return 10;
  }
};
__name(_NotificationWrapperStrategy, "NotificationWrapperStrategy");
let NotificationWrapperStrategy = _NotificationWrapperStrategy;
const _SettingsWrapperStrategy = class _SettingsWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.foundrySettingsToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapFoundrySettingsPort(service, createPublicFoundrySettings);
  }
  getPriority() {
    return 10;
  }
};
__name(_SettingsWrapperStrategy, "SettingsWrapperStrategy");
let SettingsWrapperStrategy = _SettingsWrapperStrategy;
const _NoopWrapperStrategy = class _NoopWrapperStrategy {
  supports(_token, _wellKnownTokens) {
    return true;
  }
  wrap(service, _token, _wellKnownTokens) {
    return service;
  }
  getPriority() {
    return 1e3;
  }
};
__name(_NoopWrapperStrategy, "NoopWrapperStrategy");
let NoopWrapperStrategy = _NoopWrapperStrategy;
const _ServiceWrapperFactory = class _ServiceWrapperFactory {
  constructor(strategyRegistry) {
    this.strategyRegistry = strategyRegistry ?? this.createDefaultRegistry();
  }
  /**
   * Creates the default strategy registry with standard wrapper strategies.
   *
   * @returns Registry with I18n, Notification, Settings, and Noop strategies
   */
  createDefaultRegistry() {
    const registry = new ApiWrapperStrategyRegistry();
    registry.registerAll([
      new I18nWrapperStrategy(),
      new NotificationWrapperStrategy(),
      new SettingsWrapperStrategy(),
      new NoopWrapperStrategy()
      // Fallback strategy
    ]);
    return registry;
  }
  /**
   * Applies read-only wrappers when API consumers resolve sensitive services.
   *
   * Delegates to registered strategies following Open/Closed Principle.
   * No token-specific if/else chains - all logic is in strategies.
   *
   * @param token - API token used for resolution
   * @param service - Service resolved from the container
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Wrapped service when applicable
   */
  wrapSensitiveService(token, service, wellKnownTokens) {
    const strategy = this.strategyRegistry.findStrategy(token, wellKnownTokens);
    if (strategy) {
      return strategy.wrap(service, token, wellKnownTokens);
    }
    return service;
  }
};
__name(_ServiceWrapperFactory, "ServiceWrapperFactory");
let ServiceWrapperFactory = _ServiceWrapperFactory;
function formatReplacementInfo(replacement) {
  return replacement ? `Use "${replacement}" instead.
` : "";
}
__name(formatReplacementInfo, "formatReplacementInfo");
const deprecationMetadata = /* @__PURE__ */ new Map();
function markAsDeprecated(token, reason, replacement, removedInVersion) {
  const apiSafeToken = markAsApiSafe(token);
  deprecationMetadata.set(apiSafeToken, {
    reason,
    replacement: replacement ? String(replacement) : null,
    removedInVersion,
    warningShown: false
  });
  return apiSafeToken;
}
__name(markAsDeprecated, "markAsDeprecated");
function getDeprecationInfo(token) {
  if (!token || typeof token !== "symbol") {
    return null;
  }
  return deprecationMetadata.get(token) || null;
}
__name(getDeprecationInfo, "getDeprecationInfo");
const _DeprecationHandler = class _DeprecationHandler {
  /**
   * Checks if a token is deprecated.
   *
   * @param token - Token to check
   * @returns DeprecationInfo if deprecated, null otherwise
   */
  checkDeprecation(token) {
    return getDeprecationInfo(token) ?? null;
  }
  /**
   * Handles deprecation warnings for tokens.
   * Logs warning to console if token is deprecated and warning hasn't been shown yet.
   *
   * Uses console.warn instead of Logger because:
   * - Deprecation warnings are for external API consumers (not internal logs)
   * - Should be visible even if Logger is disabled/configured differently
   * - Follows npm/Node.js convention for deprecation warnings
   *
   * @param token - Token to check for deprecation
   */
  handleDeprecationWarning(token) {
    const deprecationInfo = getDeprecationInfo(token);
    if (deprecationInfo && !deprecationInfo.warningShown) {
      const replacementInfo = formatReplacementInfo(deprecationInfo.replacement);
      console.warn(
        `[${MODULE_METADATA.ID}] DEPRECATED: Token "${String(token)}" is deprecated.
Reason: ${deprecationInfo.reason}
` + replacementInfo + `This token will be removed in version ${deprecationInfo.removedInVersion}.`
      );
      deprecationInfo.warningShown = true;
    }
  }
};
__name(_DeprecationHandler, "DeprecationHandler");
let DeprecationHandler = _DeprecationHandler;
const _ApiServiceResolver = class _ApiServiceResolver {
  constructor(deprecationHandler, serviceWrapperFactory) {
    this.deprecationHandler = deprecationHandler;
    this.serviceWrapperFactory = serviceWrapperFactory;
  }
  /**
   * Creates the resolve() function for the public API.
   * Resolves services and applies wrappers (throws on error).
   *
   * @param container - PlatformContainerPort for resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Resolve function for ModuleApi
   */
  createResolveFunction(container, wellKnownTokens) {
    return (token) => {
      this.deprecationHandler.handleDeprecationWarning(token);
      const service = container.resolve(token);
      return this.serviceWrapperFactory.wrapSensitiveService(token, service, wellKnownTokens);
    };
  }
  /**
   * Creates the resolveWithError() function for the public API.
   * Resolves services with Result pattern (never throws).
   *
   * @param container - PlatformContainerPort for resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns ResolveWithError function for ModuleApi
   */
  createResolveWithErrorFunction(container, wellKnownTokens) {
    return (token) => {
      this.deprecationHandler.handleDeprecationWarning(token);
      const result = container.resolveWithError(token);
      if (!result.ok) {
        const containerError = {
          code: castContainerErrorCode(result.error.code),
          message: result.error.message,
          cause: result.error.cause,
          tokenDescription: result.error.message
        };
        return err(containerError);
      }
      const service = castResolvedService(result.value);
      const wrappedService = this.serviceWrapperFactory.wrapSensitiveService(
        token,
        service,
        wellKnownTokens
      );
      return ok(wrappedService);
    };
  }
};
__name(_ApiServiceResolver, "ApiServiceResolver");
let ApiServiceResolver = _ApiServiceResolver;
const _ApiHealthMetricsProvider = class _ApiHealthMetricsProvider {
  /**
   * Gets a snapshot of performance metrics.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Current metrics snapshot
   */
  getMetrics(container) {
    const metricsResult = container.resolveWithError(metricsCollectorToken);
    if (!metricsResult.ok) {
      return {
        containerResolutions: 0,
        resolutionErrors: 0,
        avgResolutionTimeMs: 0,
        portSelections: {},
        portSelectionFailures: {},
        cacheHitRate: 0
      };
    }
    const metricsCollector = castResolvedService(metricsResult.value);
    return metricsCollector.getSnapshot();
  }
  /**
   * Gets module health status.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Health status with checks and overall status
   */
  getHealth(container) {
    const healthServiceResult = container.resolveWithError(moduleHealthServiceToken);
    if (!healthServiceResult.ok) {
      return {
        status: "unhealthy",
        checks: {
          containerValidated: false,
          portsSelected: false,
          lastError: "ModuleHealthService not available"
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    const healthService = castResolvedService(healthServiceResult.value);
    return healthService.getHealth();
  }
};
__name(_ApiHealthMetricsProvider, "ApiHealthMetricsProvider");
let ApiHealthMetricsProvider = _ApiHealthMetricsProvider;
const _ModuleApiInitializer = class _ModuleApiInitializer {
  constructor(deprecationHandler, serviceWrapperFactory, apiServiceResolver, healthMetricsProvider, apiBuilder) {
    this.deprecationHandler = deprecationHandler ?? new DeprecationHandler();
    this.serviceWrapperFactory = serviceWrapperFactory ?? new ServiceWrapperFactory();
    this.apiServiceResolver = apiServiceResolver ?? new ApiServiceResolver(this.deprecationHandler, this.serviceWrapperFactory);
    this.healthMetricsProvider = healthMetricsProvider ?? new ApiHealthMetricsProvider();
    this.apiBuilder = apiBuilder ?? new ModuleApiBuilder(this.apiServiceResolver, this.healthMetricsProvider);
  }
  /**
   * Exposes the module's public API to game.modules.get(MODULE_ID).api
   *
   * This method coordinates all components to create and expose the API.
   * It acts as a Facade, delegating to specialized components.
   *
   * @param container - Initialized and validated PlatformContainerPort
   * @returns Result<void, string> - Ok if successful, Err with error message
   */
  expose(container) {
    if (typeof game === "undefined" || !game?.modules) {
      return err("Game modules not available - API cannot be exposed");
    }
    const mod = game.modules.get(MODULE_METADATA.ID);
    if (!mod) {
      return err(`Module '${MODULE_METADATA.ID}' not found in game.modules`);
    }
    const wellKnownTokens = this.apiBuilder.createApiTokens();
    const api = this.apiBuilder.createApi(container, wellKnownTokens);
    mod.api = api;
    return ok(void 0);
  }
};
__name(_ModuleApiInitializer, "ModuleApiInitializer");
_ModuleApiInitializer.dependencies = [];
let ModuleApiInitializer = _ModuleApiInitializer;
const _DIModuleApiInitializer = class _DIModuleApiInitializer extends ModuleApiInitializer {
  constructor() {
    super();
  }
};
__name(_DIModuleApiInitializer, "DIModuleApiInitializer");
_DIModuleApiInitializer.dependencies = [];
let DIModuleApiInitializer = _DIModuleApiInitializer;
const _HealthCheckRegistry = class _HealthCheckRegistry {
  constructor() {
    this.checks = /* @__PURE__ */ new Map();
  }
  register(check2) {
    this.checks.set(check2.name, check2);
  }
  unregister(name) {
    this.checks.delete(name);
  }
  runAll() {
    const results = /* @__PURE__ */ new Map();
    for (const [name, check2] of this.checks) {
      results.set(name, check2.check());
    }
    return results;
  }
  getCheck(name) {
    return this.checks.get(name);
  }
  getAllChecks() {
    return Array.from(this.checks.values());
  }
  dispose() {
    for (const check2 of this.checks.values()) {
      check2.dispose();
    }
    this.checks.clear();
  }
};
__name(_HealthCheckRegistry, "HealthCheckRegistry");
_HealthCheckRegistry.dependencies = [];
let HealthCheckRegistry = _HealthCheckRegistry;
const _DIHealthCheckRegistry = class _DIHealthCheckRegistry extends HealthCheckRegistry {
  constructor() {
    super();
  }
};
__name(_DIHealthCheckRegistry, "DIHealthCheckRegistry");
_DIHealthCheckRegistry.dependencies = [];
let DIHealthCheckRegistry = _DIHealthCheckRegistry;
const _HealthCheckRegistryAdapter = class _HealthCheckRegistryAdapter {
  constructor() {
    this.registry = new HealthCheckRegistry();
  }
  register(check2) {
    this.registry.register(check2);
  }
  unregister(name) {
    this.registry.unregister(name);
  }
  runAll() {
    return this.registry.runAll();
  }
  getCheck(name) {
    return this.registry.getCheck(name);
  }
  getAllChecks() {
    return this.registry.getAllChecks();
  }
};
__name(_HealthCheckRegistryAdapter, "HealthCheckRegistryAdapter");
let HealthCheckRegistryAdapter = _HealthCheckRegistryAdapter;
const _InitPhaseRegistry = class _InitPhaseRegistry {
  /**
   * Creates a new registry with the provided phases.
   *
   * @param phases - Array of init phases (will be sorted by priority)
   */
  constructor(phases = []) {
    this.phases = [];
    this.phases = [...phases];
    this.sortPhases();
  }
  /**
   * Returns all phases sorted by priority (ascending).
   *
   * @returns Sorted array of init phases
   */
  getAll() {
    return [...this.phases];
  }
  /**
   * Adds a phase to the registry and re-sorts.
   *
   * @param phase - Phase to add
   */
  add(phase) {
    this.phases.push(phase);
    this.sortPhases();
  }
  /**
   * Sorts phases by priority (ascending).
   */
  sortPhases() {
    this.phases.sort((a, b) => a.priority - b.priority);
  }
};
__name(_InitPhaseRegistry, "InitPhaseRegistry");
let InitPhaseRegistry = _InitPhaseRegistry;
var InitPhaseCriticality = /* @__PURE__ */ ((InitPhaseCriticality2) => {
  InitPhaseCriticality2["HALT_ON_ERROR"] = "haltOnError";
  InitPhaseCriticality2["WARN_AND_CONTINUE"] = "warnAndContinue";
  return InitPhaseCriticality2;
})(InitPhaseCriticality || {});
const _MetricsBootstrapper = class _MetricsBootstrapper {
  /**
   * Initializes metrics collector if it supports persistence.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success (warnings logged but don't fail bootstrap)
   */
  static initializeMetrics(container) {
    const metricsResult = container.resolveWithError(metricsCollectorToken);
    if (!metricsResult.ok) {
      return ok(void 0);
    }
    const collector = metricsResult.value;
    if (isInitializable(collector)) {
      const initResult = collector.initialize();
      if (!initResult.ok) {
        return ok(void 0);
      }
    }
    return ok(void 0);
  }
};
__name(_MetricsBootstrapper, "MetricsBootstrapper");
let MetricsBootstrapper = _MetricsBootstrapper;
const _MetricsInitPhase = class _MetricsInitPhase {
  constructor() {
    this.id = "metrics-initialization";
    this.priority = 1;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return MetricsBootstrapper.initializeMetrics(ctx.container);
  }
};
__name(_MetricsInitPhase, "MetricsInitPhase");
let MetricsInitPhase = _MetricsInitPhase;
const queuedUIChannelToken = createInjectionToken("QueuedUIChannel");
const _NotificationBootstrapper = class _NotificationBootstrapper {
  /**
   * Attaches UI notification channel to NotificationCenter.
   *
   * Uses QueuedUIChannel which queues notifications before UI is available
   * and flushes them when UI becomes available.
   *
   * This phase is optional - failures are logged as warnings but don't fail bootstrap.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static attachNotificationChannels(container) {
    const notificationCenterResult = container.resolveWithError(notificationCenterToken);
    if (!notificationCenterResult.ok) {
      return err(
        `NotificationCenter could not be resolved: ${notificationCenterResult.error.message}`
      );
    }
    const queuedUIChannelResult = container.resolveWithError(queuedUIChannelToken);
    if (!queuedUIChannelResult.ok) {
      return err(`QueuedUIChannel could not be resolved: ${queuedUIChannelResult.error.message}`);
    }
    const notificationCenter = castResolvedService(
      notificationCenterResult.value
    );
    const queuedUIChannel = castResolvedService(queuedUIChannelResult.value);
    notificationCenter.addChannel(queuedUIChannel);
    return ok(void 0);
  }
};
__name(_NotificationBootstrapper, "NotificationBootstrapper");
let NotificationBootstrapper = _NotificationBootstrapper;
const _NotificationInitPhase = class _NotificationInitPhase {
  constructor() {
    this.id = "notification-channels";
    this.priority = 2;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return NotificationBootstrapper.attachNotificationChannels(ctx.container);
  }
};
__name(_NotificationInitPhase, "NotificationInitPhase");
let NotificationInitPhase = _NotificationInitPhase;
const _ApiBootstrapper = class _ApiBootstrapper {
  /**
   * Exposes the module's public API.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static exposeApi(container) {
    const apiInitializerResult = container.resolveWithError(moduleApiInitializerToken);
    if (!apiInitializerResult.ok) {
      return err(`Failed to resolve ModuleApiInitializer: ${apiInitializerResult.error.message}`);
    }
    const apiInitializer = castResolvedService(apiInitializerResult.value);
    const exposeResult = apiInitializer.expose(container);
    if (!exposeResult.ok) {
      return err(`Failed to expose API: ${exposeResult.error}`);
    }
    return ok(void 0);
  }
};
__name(_ApiBootstrapper, "ApiBootstrapper");
let ApiBootstrapper = _ApiBootstrapper;
const _ApiInitPhase = class _ApiInitPhase {
  constructor() {
    this.id = "api-exposure";
    this.priority = 3;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return ApiBootstrapper.exposeApi(ctx.container);
  }
};
__name(_ApiInitPhase, "ApiInitPhase");
let ApiInitPhase = _ApiInitPhase;
const moduleSettingsRegistrarToken = createInjectionToken("ModuleSettingsRegistrar");
const _SettingsBootstrapper = class _SettingsBootstrapper {
  /**
   * Registers all module settings.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static registerSettings(container) {
    const settingsRegistrarResult = container.resolveWithError(moduleSettingsRegistrarToken);
    if (!settingsRegistrarResult.ok) {
      return err(
        `Failed to resolve ModuleSettingsRegistrar: ${settingsRegistrarResult.error.message}`
      );
    }
    const settingsRegistrar = castResolvedService(
      settingsRegistrarResult.value
    );
    settingsRegistrar.registerAll();
    return ok(void 0);
  }
};
__name(_SettingsBootstrapper, "SettingsBootstrapper");
let SettingsBootstrapper = _SettingsBootstrapper;
const _SettingsInitPhase = class _SettingsInitPhase {
  constructor() {
    this.id = "settings-registration";
    this.priority = 4;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return SettingsBootstrapper.registerSettings(ctx.container);
  }
};
__name(_SettingsInitPhase, "SettingsInitPhase");
let SettingsInitPhase = _SettingsInitPhase;
const _LoggingBootstrapper = class _LoggingBootstrapper {
  /**
   * Configures logger with current setting value.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger instance to configure
   * @returns Result indicating success (always succeeds, settings are optional)
   */
  static configureLogging(container, logger) {
    const settingsResult = container.resolveWithError(foundrySettingsToken);
    if (!settingsResult.ok) {
      return ok(void 0);
    }
    const settings = castResolvedService(settingsResult.value);
    const logLevelResult = settings.get(
      MODULE_METADATA.ID,
      SETTING_KEYS.LOG_LEVEL,
      LOG_LEVEL_SCHEMA
    );
    if (logLevelResult.ok && logger.setMinLevel) {
      logger.setMinLevel(logLevelResult.value);
      logger.debug(`Logger configured with level: ${LogLevel[logLevelResult.value]}`);
    }
    return ok(void 0);
  }
};
__name(_LoggingBootstrapper, "LoggingBootstrapper");
let LoggingBootstrapper = _LoggingBootstrapper;
const _LoggingInitPhase = class _LoggingInitPhase {
  constructor() {
    this.id = "logging-configuration";
    this.priority = 5;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return LoggingBootstrapper.configureLogging(ctx.container, ctx.logger);
  }
};
__name(_LoggingInitPhase, "LoggingInitPhase");
let LoggingInitPhase = _LoggingInitPhase;
const invalidateJournalCacheOnChangeUseCaseToken = createInjectionToken(
  "InvalidateJournalCacheOnChangeUseCase"
);
const processJournalDirectoryOnRenderUseCaseToken = createInjectionToken(
  "ProcessJournalDirectoryOnRenderUseCase"
);
const triggerJournalDirectoryReRenderUseCaseToken = createInjectionToken(
  "TriggerJournalDirectoryReRenderUseCase"
);
const registerContextMenuUseCaseToken = createInjectionToken(
  "RegisterContextMenuUseCase"
);
const showAllHiddenJournalsUseCaseToken = createInjectionToken(
  "ShowAllHiddenJournalsUseCase"
);
const sidebarButtonBootstrapperToken = createInjectionToken(
  "SidebarButtonBootstrapper"
);
const moduleEventRegistrarToken = createInjectionToken("ModuleEventRegistrar");
const windowFactoryToken = createInjectionToken("WindowFactory");
const windowRegistryToken = createInjectionToken("WindowRegistry");
const windowControllerToken = createInjectionToken("WindowController");
const eventBusToken = createInjectionToken("EventBus");
const stateStoreToken = createInjectionToken("StateStore");
const actionDispatcherToken = createInjectionToken("ActionDispatcher");
const rendererRegistryToken = createInjectionToken("RendererRegistry");
const bindingEngineToken = createInjectionToken("BindingEngine");
const viewModelBuilderToken = createInjectionToken("ViewModelBuilder");
const remoteSyncGateToken = createInjectionToken("RemoteSyncGate");
const persistAdapterToken = createInjectionToken("PersistAdapter");
const foundryWindowAdapterToken = createInjectionToken("FoundryWindowAdapter");
const statePortFactoryToken = createInjectionToken("StatePortFactory");
const sharedDocumentCacheToken = createInjectionToken("SharedDocumentCache");
const windowPositionManagerToken = createInjectionToken("WindowPositionManager");
const windowHooksServiceToken = createInjectionToken("WindowHooksService");
const _EventsBootstrapper = class _EventsBootstrapper {
  /**
   * Registers all event listeners.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static registerEvents(container) {
    const eventRegistrarResult = container.resolveWithError(moduleEventRegistrarToken);
    if (!eventRegistrarResult.ok) {
      return err(`Failed to resolve ModuleEventRegistrar: ${eventRegistrarResult.error.message}`);
    }
    const eventRegistrar = castResolvedService(eventRegistrarResult.value);
    const eventRegistrationResult = eventRegistrar.registerAll();
    if (!eventRegistrationResult.ok) {
      const errorMessages = eventRegistrationResult.error.map((e) => e.message).join(", ");
      return err(`Failed to register one or more event listeners: ${errorMessages}`);
    }
    const windowHooksResult = container.resolveWithError(windowHooksServiceToken);
    if (windowHooksResult.ok) {
      const windowHooksService = castResolvedService(windowHooksResult.value);
      windowHooksService.register();
    }
    return ok(void 0);
  }
};
__name(_EventsBootstrapper, "EventsBootstrapper");
let EventsBootstrapper = _EventsBootstrapper;
const _EventsInitPhase = class _EventsInitPhase {
  constructor() {
    this.id = "event-registration";
    this.priority = 6;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return EventsBootstrapper.registerEvents(ctx.container);
  }
};
__name(_EventsInitPhase, "EventsInitPhase");
let EventsInitPhase = _EventsInitPhase;
const journalContextMenuLibWrapperServiceToken = createInjectionToken("JournalContextMenuLibWrapperService");
const _ContextMenuBootstrapper = class _ContextMenuBootstrapper {
  /**
   * Registers context menu libWrapper and callbacks.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static registerContextMenu(container) {
    const contextMenuLibWrapperResult = container.resolveWithError(
      journalContextMenuLibWrapperServiceToken
    );
    if (!contextMenuLibWrapperResult.ok) {
      return err(
        `JournalContextMenuLibWrapperService could not be resolved: ${contextMenuLibWrapperResult.error.message}`
      );
    }
    const contextMenuLibWrapper = castResolvedService(
      contextMenuLibWrapperResult.value
    );
    const registerResult = contextMenuLibWrapper.register();
    if (!registerResult.ok) {
      return err(`Context menu libWrapper registration failed: ${registerResult.error.message}`);
    }
    const contextMenuUseCaseResult = container.resolveWithError(registerContextMenuUseCaseToken);
    if (!contextMenuUseCaseResult.ok) {
      return err(
        `RegisterContextMenuUseCase could not be resolved: ${contextMenuUseCaseResult.error.message}`
      );
    }
    const contextMenuUseCase = castResolvedService(
      contextMenuUseCaseResult.value
    );
    const callbackRegisterResult = contextMenuUseCase.register();
    if (!callbackRegisterResult.ok) {
      return err(
        `Context menu callback registration failed: ${callbackRegisterResult.error.message}`
      );
    }
    return ok(void 0);
  }
};
__name(_ContextMenuBootstrapper, "ContextMenuBootstrapper");
let ContextMenuBootstrapper = _ContextMenuBootstrapper;
const _ContextMenuInitPhase = class _ContextMenuInitPhase {
  constructor() {
    this.id = "context-menu-registration";
    this.priority = 7;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return ContextMenuBootstrapper.registerContextMenu(ctx.container);
  }
};
__name(_ContextMenuInitPhase, "ContextMenuInitPhase");
let ContextMenuInitPhase = _ContextMenuInitPhase;
const _SidebarButtonBootstrapper = class _SidebarButtonBootstrapper {
  /**
   * Registers sidebar button for journal tab.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static registerSidebarButton(container) {
    const useCaseResult = container.resolveWithError(showAllHiddenJournalsUseCaseToken);
    if (!useCaseResult.ok) {
      return err(
        `ShowAllHiddenJournalsUseCase could not be resolved: ${useCaseResult.error.message}`
      );
    }
    const useCase = castResolvedService(useCaseResult.value);
    const hooksResult = container.resolveWithError(foundryHooksToken);
    if (!hooksResult.ok) {
      return err(`FoundryHooksPort could not be resolved: ${hooksResult.error.message}`);
    }
    const hooks = castResolvedService(hooksResult.value);
    const hookRegistrationResult = hooks.on("renderJournalDirectory", (...args2) => {
      if (args2.length < 2) {
        return;
      }
      const htmlArg = args2[1];
      if (!(htmlArg instanceof HTMLElement)) {
        return;
      }
      const html2 = htmlArg;
      const existingButton = html2.querySelector(".show-all-hidden-journals-button");
      if (existingButton) {
        return;
      }
      const button = document.createElement("button");
      button.className = "show-all-hidden-journals-button";
      button.type = "button";
      button.title = "Alle versteckten Journale wieder einblenden";
      button.innerHTML = '<i class="fas fa-eye"></i> Alle Journale einblenden';
      button.addEventListener("click", async () => {
        const result = await useCase.execute();
        if (result.ok) {
        } else {
        }
      });
      const actionButtons = html2.querySelector(".header-actions.action-buttons");
      if (actionButtons) {
        actionButtons.appendChild(button);
      } else {
        const directoryHeader = html2.querySelector(".directory-header");
        if (directoryHeader) {
          directoryHeader.appendChild(button);
        } else {
          html2.insertBefore(button, html2.firstChild);
        }
      }
    });
    if (!hookRegistrationResult.ok) {
      return err(`Failed to register sidebar button hook: ${hookRegistrationResult.error.message}`);
    }
    return ok(void 0);
  }
};
__name(_SidebarButtonBootstrapper, "SidebarButtonBootstrapper");
let SidebarButtonBootstrapper = _SidebarButtonBootstrapper;
const _SidebarButtonInitPhase = class _SidebarButtonInitPhase {
  constructor() {
    this.id = "sidebar-button-registration";
    this.priority = 8;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return SidebarButtonBootstrapper.registerSidebarButton(ctx.container);
  }
};
__name(_SidebarButtonInitPhase, "SidebarButtonInitPhase");
let SidebarButtonInitPhase = _SidebarButtonInitPhase;
function createDefaultInitPhaseRegistry() {
  return new InitPhaseRegistry([
    new MetricsInitPhase(),
    new NotificationInitPhase(),
    new ApiInitPhase(),
    new SettingsInitPhase(),
    new LoggingInitPhase(),
    new EventsInitPhase(),
    new ContextMenuInitPhase(),
    new SidebarButtonInitPhase()
  ]);
}
__name(createDefaultInitPhaseRegistry, "createDefaultInitPhaseRegistry");
const _InitPhaseErrorHandler = class _InitPhaseErrorHandler {
  /**
   * Handles an error from a phase execution.
   *
   * @param phase - The phase that failed
   * @param error - The error message from the phase
   * @param errors - Array to collect critical errors (mutated if phase is critical)
   * @param logger - Logger for error reporting
   */
  handlePhaseError(phase, error, errors, logger) {
    if (phase.criticality === InitPhaseCriticality.HALT_ON_ERROR) {
      errors.push({
        phase: phase.id,
        message: error
      });
      logger.error(`Failed to execute phase '${phase.id}': ${error}`);
    } else {
      logger.warn(`Phase '${phase.id}' failed: ${error}`);
    }
  }
};
__name(_InitPhaseErrorHandler, "InitPhaseErrorHandler");
let InitPhaseErrorHandler = _InitPhaseErrorHandler;
const _InitOrchestrator = class _InitOrchestrator {
  /**
   * Creates a new InitOrchestrator instance.
   *
   * @param registry - Registry providing init phases (defaults to standard phases)
   */
  constructor(registry) {
    this.registry = registry ?? createDefaultInitPhaseRegistry();
  }
  /**
   * Executes the complete initialization sequence.
   *
   * Phases are executed in priority order (ascending). Error handling
   * follows each phase's criticality setting:
   * - HALT_ON_ERROR: Errors are collected and returned, stopping bootstrap
   * - WARN_AND_CONTINUE: Errors are logged as warnings but don't stop bootstrap
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger for error reporting
   * @returns Result indicating success or aggregated errors
   */
  execute(container, logger) {
    const errors = [];
    const phases = this.registry.getAll();
    const ctx = { container, logger };
    const errorHandler = new InitPhaseErrorHandler();
    for (const phase of phases) {
      const result = phase.execute(ctx);
      if (!result.ok) {
        errorHandler.handlePhaseError(phase, result.error, errors, logger);
      }
    }
    if (errors.length > 0) {
      return err(errors);
    }
    return ok(void 0);
  }
  /**
   * Static convenience method for backward compatibility.
   *
   * Creates a new orchestrator with default registry and executes.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger for error reporting
   * @returns Result indicating success or aggregated errors
   */
  static execute(container, logger) {
    const orchestrator = new _InitOrchestrator();
    return orchestrator.execute(container, logger);
  }
};
__name(_InitOrchestrator, "InitOrchestrator");
let InitOrchestrator = _InitOrchestrator;
const _BootstrapInitHookService = class _BootstrapInitHookService {
  constructor(logger, container, bootstrapEvents) {
    this.logger = logger;
    this.container = container;
    this.bootstrapEvents = bootstrapEvents;
  }
  /**
   * Registers the init event via PlatformBootstrapEventPort.
   * Must be called before the platform's init hook fires.
   */
  register() {
    const result = this.bootstrapEvents.onInit(() => this.handleInit());
    if (!result.ok) {
      this.logger.warn(
        `Init hook registration failed: ${result.error.message}`,
        result.error.details
      );
    }
  }
  /* v8 ignore start -- @preserve */
  /* Foundry-Hooks und UI-spezifische Pfade hängen stark von der Laufzeitumgebung ab
   * und werden primär über Integrations-/E2E-Tests abgesichert. Für das aktuelle Quality-Gateway
   * blenden wir diese verzweigten Pfade temporär aus und reduzieren die Ignores später gezielt. */
  handleInit() {
    this.logger.info("init-phase");
    const result = InitOrchestrator.execute(this.container, this.logger);
    if (!result.ok) {
      const errorMessages = result.error.map((e) => `${e.phase}: ${e.message}`).join("; ");
      this.logger.error(`Init phase completed with errors: ${errorMessages}`);
    } else {
      this.logger.info("init-phase completed");
    }
  }
  /* v8 ignore stop -- @preserve */
};
__name(_BootstrapInitHookService, "BootstrapInitHookService");
let BootstrapInitHookService = _BootstrapInitHookService;
const _DIBootstrapInitHookService = class _DIBootstrapInitHookService extends BootstrapInitHookService {
  constructor(logger, container, bootstrapEvents) {
    super(logger, container, bootstrapEvents);
  }
};
__name(_DIBootstrapInitHookService, "DIBootstrapInitHookService");
_DIBootstrapInitHookService.dependencies = [
  loggerToken,
  platformContainerPortToken,
  platformBootstrapEventPortToken
];
let DIBootstrapInitHookService = _DIBootstrapInitHookService;
const _ModuleReadyService = class _ModuleReadyService {
  constructor(moduleReadyPort, loggingPort) {
    this.moduleReadyPort = moduleReadyPort;
    this.loggingPort = loggingPort;
  }
  /**
   * Sets module.ready to true (ready state).
   * Should be called when bootstrap-ready-hook completes.
   */
  setReady() {
    const result = this.moduleReadyPort.setReady();
    if (!result.ok) {
      this.loggingPort.warn(
        `Failed to set module.ready: ${result.error.message}`,
        result.error.details
      );
    } else {
      this.loggingPort.info("module.ready set to true");
    }
  }
};
__name(_ModuleReadyService, "ModuleReadyService");
let ModuleReadyService = _ModuleReadyService;
const _DIModuleReadyService = class _DIModuleReadyService extends ModuleReadyService {
  constructor(moduleReadyPort, loggingPort) {
    super(moduleReadyPort, loggingPort);
  }
};
__name(_DIModuleReadyService, "DIModuleReadyService");
_DIModuleReadyService.dependencies = [platformModuleReadyPortToken, platformLoggingPortToken];
let DIModuleReadyService = _DIModuleReadyService;
const moduleReadyServiceToken = createInjectionToken("ModuleReadyService");
const _BootstrapReadyHookService = class _BootstrapReadyHookService {
  constructor(logger, bootstrapEvents, moduleReadyService) {
    this.logger = logger;
    this.bootstrapEvents = bootstrapEvents;
    this.moduleReadyService = moduleReadyService;
  }
  /**
   * Registers the ready event via PlatformBootstrapEventPort.
   * Must be called before the platform's ready hook fires.
   */
  register() {
    const result = this.bootstrapEvents.onReady(() => this.handleReady());
    if (!result.ok) {
      this.logger.warn(
        `Ready hook registration failed: ${result.error.message}`,
        result.error.details
      );
    }
  }
  /* v8 ignore start -- @preserve */
  /* Foundry-Hooks und UI-spezifische Pfade hängen stark von der Laufzeitumgebung ab
   * und werden primär über Integrations-/E2E-Tests abgesichert. Für das aktuelle Quality-Gateway
   * blenden wir diese verzweigten Pfade temporär aus und reduzieren die Ignores später gezielt. */
  handleReady() {
    this.logger.info("ready-phase");
    this.moduleReadyService.setReady();
    this.logger.info("ready-phase completed");
  }
  /* v8 ignore stop -- @preserve */
};
__name(_BootstrapReadyHookService, "BootstrapReadyHookService");
let BootstrapReadyHookService = _BootstrapReadyHookService;
const _DIBootstrapReadyHookService = class _DIBootstrapReadyHookService extends BootstrapReadyHookService {
  constructor(logger, bootstrapEvents, moduleReadyService) {
    super(logger, bootstrapEvents, moduleReadyService);
  }
};
__name(_DIBootstrapReadyHookService, "DIBootstrapReadyHookService");
_DIBootstrapReadyHookService.dependencies = [
  loggerToken,
  platformBootstrapEventPortToken,
  moduleReadyServiceToken
];
let DIBootstrapReadyHookService = _DIBootstrapReadyHookService;
const _FoundryBootstrapEventAdapter = class _FoundryBootstrapEventAdapter {
  onInit(callback) {
    if (typeof Hooks === "undefined") {
      return err({
        code: "PLATFORM_NOT_AVAILABLE",
        message: "Foundry Hooks API not available"
      });
    }
    try {
      Hooks.on("init", callback);
      return ok(void 0);
    } catch (error) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register init event: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  onReady(callback) {
    if (typeof Hooks === "undefined") {
      return err({
        code: "PLATFORM_NOT_AVAILABLE",
        message: "Foundry Hooks API not available"
      });
    }
    try {
      Hooks.on("ready", callback);
      return ok(void 0);
    } catch (error) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register ready event: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
};
__name(_FoundryBootstrapEventAdapter, "FoundryBootstrapEventAdapter");
let FoundryBootstrapEventAdapter = _FoundryBootstrapEventAdapter;
const _DIFoundryBootstrapEventAdapter = class _DIFoundryBootstrapEventAdapter extends FoundryBootstrapEventAdapter {
};
__name(_DIFoundryBootstrapEventAdapter, "DIFoundryBootstrapEventAdapter");
_DIFoundryBootstrapEventAdapter.dependencies = [];
let DIFoundryBootstrapEventAdapter = _DIFoundryBootstrapEventAdapter;
const retryServiceToken = createInjectionToken("RetryService");
const _PortLoader = class _PortLoader {
  constructor(portSelector, portRegistry) {
    this.port = null;
    this.portSelector = portSelector;
    this.portRegistry = portRegistry;
  }
  /**
   * Lazy-loads the appropriate port based on Foundry version.
   * Uses PortSelector with token-based selection to resolve ports from the DI container.
   *
   * CRITICAL: This prevents crashes when newer port constructors access
   * APIs not available in the current Foundry version. Ports are resolved
   * from the DI container, ensuring DIP (Dependency Inversion Principle) compliance.
   *
   * @param adapterName - Name for logging purposes (e.g., "FoundryGame")
   * @returns Result containing the port or a FoundryError if no compatible port can be selected
   */
  loadPort(adapterName) {
    if (this.port === null) {
      const tokens = this.portRegistry.getTokens();
      const portResult = this.portSelector.selectPortFromTokens(tokens, void 0, adapterName);
      if (!portResult.ok) {
        return portResult;
      }
      this.port = portResult.value;
    }
    return { ok: true, value: this.port };
  }
  /**
   * Gets the currently loaded port without triggering lazy loading.
   * Useful for operations that don't need retry logic but need to check if port is loaded.
   *
   * @returns The loaded port or null if not yet loaded
   */
  getLoadedPort() {
    return this.port;
  }
  /**
   * Clears the cached port.
   * This forces the next loadPort() call to reload the port.
   * Useful for testing or when ports need to be refreshed.
   */
  clearCache() {
    this.port = null;
  }
};
__name(_PortLoader, "PortLoader");
let PortLoader = _PortLoader;
const _RetryableOperation = class _RetryableOperation {
  constructor(retryService) {
    this.retryService = retryService;
  }
  /**
   * Executes a Foundry API operation with automatic retry on transient failures.
   *
   * Use this for any port method call to handle:
   * - Race conditions (Foundry not fully initialized)
   * - Timing issues (DOM/Settings not ready)
   * - Transient port selection failures
   *
   * @template T - The success type
   * @param fn - Function to execute (should call port methods)
   * @param operationName - Operation name for logging (e.g., "FoundryGame.getJournalEntries")
   * @param maxAttempts - Max retry attempts (default: 2 = 1 retry)
   * @returns Result from operation or mapped error
   *
   * @example
   * ```typescript
   * const result = retryable.execute(
   *   () => {
   *     const portResult = portLoader.loadPort("FoundryGame");
   *     if (!portResult.ok) return portResult;
   *     return portResult.value.getJournalEntries();
   *   },
   *   "FoundryGame.getJournalEntries"
   * );
   * ```
   */
  execute(fn, operationName, maxAttempts = 2) {
    return this.retryService.retrySync(fn, {
      maxAttempts,
      operationName,
      mapException: /* @__PURE__ */ __name((error, _attempt) => ({
        code: "OPERATION_FAILED",
        message: `${operationName} failed: ${String(error)}`,
        cause: error instanceof Error ? error : void 0
      }), "mapException")
    });
  }
  /**
   * Async variant of execute for async operations.
   *
   * @template T - The success type
   * @param fn - Async function to execute
   * @param operationName - Operation name for logging
   * @param maxAttempts - Max retry attempts (default: 2)
   * @returns Promise resolving to Result
   *
   * @example
   * ```typescript
   * const result = await retryable.executeAsync(
   *   async () => {
   *     const portResult = portLoader.loadPort("FoundryDocument");
   *     if (!portResult.ok) return portResult;
   *     return await portResult.value.setFlag(doc, scope, key, value);
   *   },
   *   "FoundryDocument.setFlag"
   * );
   * ```
   */
  async executeAsync(fn, operationName, maxAttempts = 2) {
    return this.retryService.retry(fn, {
      maxAttempts,
      delayMs: 100,
      // 100ms delay between retries
      operationName,
      mapException: /* @__PURE__ */ __name((error, _attempt) => ({
        code: "OPERATION_FAILED",
        message: `${operationName} failed: ${String(error)}`,
        cause: error instanceof Error ? error : void 0
      }), "mapException")
    });
  }
};
__name(_RetryableOperation, "RetryableOperation");
let RetryableOperation = _RetryableOperation;
const _FoundryModuleReadyPort = class _FoundryModuleReadyPort {
  constructor(portSelector, portRegistry, retryService, moduleId) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
    this.moduleId = moduleId;
  }
  setReady() {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryModule");
      if (!portResult.ok) {
        return {
          ok: false,
          error: createFoundryError(
            "PORT_SELECTION_FAILED",
            portResult.error.message,
            portResult.error.details
          )
        };
      }
      const success = portResult.value.setModuleReady(this.moduleId);
      if (!success) {
        return {
          ok: false,
          error: createFoundryError("OPERATION_FAILED", `Module ${this.moduleId} not found`)
        };
      }
      return { ok: true, value: void 0 };
    }, "FoundryModule.setReady");
    if (!result.ok) {
      let errorCode;
      if (result.error.code === "PORT_SELECTION_FAILED" || result.error.code === "API_NOT_AVAILABLE") {
        errorCode = "PLATFORM_NOT_AVAILABLE";
      } else if (result.error.code === "OPERATION_FAILED") {
        errorCode = "OPERATION_FAILED";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return {
        ok: false,
        error: {
          code: errorCode,
          message: result.error.message,
          details: result.error.details
        }
      };
    }
    return { ok: true, value: void 0 };
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryModuleReadyPort, "FoundryModuleReadyPort");
let FoundryModuleReadyPort = _FoundryModuleReadyPort;
const _DIFoundryModuleReadyPort = class _DIFoundryModuleReadyPort extends FoundryModuleReadyPort {
  constructor(portSelector, portRegistry, retryService, moduleId) {
    super(portSelector, portRegistry, retryService, moduleId);
  }
};
__name(_DIFoundryModuleReadyPort, "DIFoundryModuleReadyPort");
_DIFoundryModuleReadyPort.dependencies = [
  portSelectorToken,
  foundryModulePortRegistryToken,
  retryServiceToken,
  moduleIdToken
];
let DIFoundryModuleReadyPort = _DIFoundryModuleReadyPort;
function registerCoreServices(container) {
  const runtimeConfig = container.getRegisteredValue(runtimeConfigToken);
  if (!runtimeConfig) {
    return err("RuntimeConfigService not registered");
  }
  const enablePersistence = runtimeConfig.get("enableMetricsPersistence") === true;
  const aggregatorResult = container.registerClass(
    metricsAggregatorToken,
    MetricsAggregator,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(aggregatorResult)) {
    return err(`Failed to register MetricsAggregator: ${aggregatorResult.error.message}`);
  }
  const persistenceManagerResult = container.registerClass(
    metricsPersistenceManagerToken,
    MetricsPersistenceManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(persistenceManagerResult)) {
    return err(
      `Failed to register MetricsPersistenceManager: ${persistenceManagerResult.error.message}`
    );
  }
  const stateManagerResult = container.registerClass(
    metricsStateManagerToken,
    MetricsStateManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(stateManagerResult)) {
    return err(`Failed to register MetricsStateManager: ${stateManagerResult.error.message}`);
  }
  if (enablePersistence) {
    const metricsKey = runtimeConfig.get("metricsPersistenceKey") ?? "fvtt_relationship_app_module.metrics";
    const storageInstance = createMetricsStorage(metricsKey);
    const storageResult = container.registerValue(metricsStorageToken, storageInstance);
    if (isErr(storageResult)) {
      return err(`Failed to register MetricsStorage: ${storageResult.error.message}`);
    }
    const persistentResult = container.registerClass(
      metricsCollectorToken,
      DIPersistentMetricsCollector,
      ServiceLifecycle.SINGLETON
    );
    if (isErr(persistentResult)) {
      return err(
        `Failed to register PersistentMetricsCollector: ${persistentResult.error.message}`
      );
    }
  } else {
    const metricsResult = container.registerClass(
      metricsCollectorToken,
      DIMetricsCollector,
      ServiceLifecycle.SINGLETON
    );
    if (isErr(metricsResult)) {
      return err(`Failed to register MetricsCollector: ${metricsResult.error.message}`);
    }
  }
  const samplerResult = container.registerClass(
    metricsSamplerToken,
    DIMetricsSampler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(samplerResult)) {
    return err(`Failed to register MetricsSampler: ${samplerResult.error.message}`);
  }
  container.registerAlias(metricsRecorderToken, metricsCollectorToken);
  const traceContextResult = container.registerClass(
    traceContextToken,
    DITraceContext,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(traceContextResult)) {
    return err(`Failed to register TraceContext: ${traceContextResult.error.message}`);
  }
  const loggerResult = container.registerClass(
    loggerToken,
    DIConsoleLoggerService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(loggerResult)) {
    return err(`Failed to register Logger: ${loggerResult.error.message}`);
  }
  const reporterResult = container.registerClass(
    metricsReporterToken,
    DIMetricsReporter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(reporterResult)) {
    return err(`Failed to register MetricsReporter: ${reporterResult.error.message}`);
  }
  const registryResult = container.registerClass(
    healthCheckRegistryToken,
    HealthCheckRegistryAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(registryResult)) {
    return err(`Failed to register HealthCheckRegistry: ${registryResult.error.message}`);
  }
  const healthResult = container.registerClass(
    moduleHealthServiceToken,
    DIModuleHealthService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(healthResult)) {
    return err(`Failed to register ModuleHealthService: ${healthResult.error.message}`);
  }
  const apiInitResult = container.registerClass(
    moduleApiInitializerToken,
    DIModuleApiInitializer,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(apiInitResult)) {
    return err(`Failed to register ModuleApiInitializer: ${apiInitResult.error.message}`);
  }
  const bootstrapEventsResult = container.registerClass(
    platformBootstrapEventPortToken,
    DIFoundryBootstrapEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(bootstrapEventsResult)) {
    return err(
      `Failed to register PlatformBootstrapEventPort: ${bootstrapEventsResult.error.message}`
    );
  }
  const initHookResult = container.registerClass(
    bootstrapInitHookServiceToken,
    DIBootstrapInitHookService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(initHookResult)) {
    return err(`Failed to register BootstrapInitHookService: ${initHookResult.error.message}`);
  }
  const moduleReadyPortResult = container.registerClass(
    platformModuleReadyPortToken,
    DIFoundryModuleReadyPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(moduleReadyPortResult)) {
    return err(
      `Failed to register PlatformModuleReadyPort: ${moduleReadyPortResult.error.message}`
    );
  }
  const moduleReadyResult = container.registerClass(
    moduleReadyServiceToken,
    DIModuleReadyService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(moduleReadyResult)) {
    return err(`Failed to register ModuleReadyService: ${moduleReadyResult.error.message}`);
  }
  const readyHookResult = container.registerClass(
    bootstrapReadyHookServiceToken,
    DIBootstrapReadyHookService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(readyHookResult)) {
    return err(`Failed to register BootstrapReadyHookService: ${readyHookResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerCoreServices, "registerCoreServices");
registerDependencyStep({
  name: "CoreServices",
  priority: 20,
  execute: registerCoreServices
});
const observabilityRegistryToken = createInjectionToken("ObservabilityRegistry");
const _PortSelectionEventEmitter = class _PortSelectionEventEmitter {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Set();
  }
  subscribe(callback) {
    this.subscribers.add(callback);
    let active = true;
    return () => {
      if (!active) {
        return;
      }
      active = false;
      this.subscribers.delete(callback);
    };
  }
  emit(event2) {
    for (const callback of this.subscribers) {
      try {
        callback(event2);
      } catch (error) {
        console.error("PortSelectionEventEmitter subscriber error", error);
      }
    }
  }
  clear() {
    this.subscribers.clear();
  }
  getSubscriberCount() {
    return this.subscribers.size;
  }
};
__name(_PortSelectionEventEmitter, "PortSelectionEventEmitter");
let PortSelectionEventEmitter = _PortSelectionEventEmitter;
const _DIPortSelectionEventEmitter = class _DIPortSelectionEventEmitter extends PortSelectionEventEmitter {
};
__name(_DIPortSelectionEventEmitter, "DIPortSelectionEventEmitter");
_DIPortSelectionEventEmitter.dependencies = [];
let DIPortSelectionEventEmitter = _DIPortSelectionEventEmitter;
const _ObservabilityRegistry = class _ObservabilityRegistry {
  constructor(logger, metrics) {
    this.logger = logger;
    this.metrics = metrics;
    this.subscriptions = [];
  }
  /**
   * Register a PortSelector for observability.
   * Wires event emission to logging and metrics.
   *
   * @param service - Observable service that emits PortSelectionEvents
   */
  registerPortSelector(service) {
    const unsubscribe = service.onEvent((event2) => {
      if (event2.type === "success") {
        const adapterSuffix = event2.adapterName ? ` for ${event2.adapterName}` : "";
        this.logger.debug(
          `Port v${event2.selectedVersion} selected in ${event2.durationMs.toFixed(2)}ms${adapterSuffix}`
        );
        this.metrics.recordPortSelection(event2.selectedVersion);
      } else {
        this.logger.error("Port selection failed", {
          foundryVersion: event2.foundryVersion,
          availableVersions: event2.availableVersions,
          adapterName: event2.adapterName
        });
        this.metrics.recordPortSelectionFailure(event2.foundryVersion);
      }
    });
    this.subscriptions.push(unsubscribe);
  }
  /**
   * Disposes all registered observers and clears internal state.
   * Intended to be called when the DI container is disposed.
   */
  dispose() {
    while (this.subscriptions.length > 0) {
      const unsubscribe = this.subscriptions.pop();
      try {
        unsubscribe?.();
      } catch {
      }
    }
  }
  // Future: Add more registration methods for other observable services
  // registerSomeOtherService(service: ObservableService<OtherEvent>): void { ... }
};
__name(_ObservabilityRegistry, "ObservabilityRegistry");
let ObservabilityRegistry = _ObservabilityRegistry;
const _DIObservabilityRegistry = class _DIObservabilityRegistry extends ObservabilityRegistry {
  constructor(logger, metrics) {
    super(logger, metrics);
  }
};
__name(_DIObservabilityRegistry, "DIObservabilityRegistry");
_DIObservabilityRegistry.dependencies = [loggerToken, metricsRecorderToken];
let DIObservabilityRegistry = _DIObservabilityRegistry;
const _PortSelectionObservability = class _PortSelectionObservability {
  constructor(observabilityRegistry) {
    this.observabilityRegistry = observabilityRegistry;
  }
  /**
   * Register PortSelector with ObservabilityRegistry.
   * This enables automatic logging and metrics collection.
   */
  registerWithObservabilityRegistry(selector) {
    this.observabilityRegistry.registerPortSelector(selector);
  }
  /**
   * Setup observability for PortSelector.
   * Wires PortSelector events to PortSelectionObserver.
   */
  setupObservability(selector, observer) {
    selector.onEvent((event2) => {
      observer.handleEvent(event2);
    });
  }
};
__name(_PortSelectionObservability, "PortSelectionObservability");
let PortSelectionObservability = _PortSelectionObservability;
const _DIPortSelectionObservability = class _DIPortSelectionObservability extends PortSelectionObservability {
  constructor(observabilityRegistry) {
    super(observabilityRegistry);
  }
};
__name(_DIPortSelectionObservability, "DIPortSelectionObservability");
_DIPortSelectionObservability.dependencies = [observabilityRegistryToken];
let DIPortSelectionObservability = _DIPortSelectionObservability;
const _PortSelectionPerformanceTracker = class _PortSelectionPerformanceTracker {
  /**
   * Start performance tracking.
   * Records the current high-resolution timestamp.
   */
  startTracking() {
    this.startTime = performance.now();
  }
  /**
   * End performance tracking and return duration in milliseconds.
   * @returns Duration in milliseconds, or 0 if tracking was not started
   */
  endTracking() {
    if (this.startTime === void 0) {
      return 0;
    }
    const durationMs = performance.now() - this.startTime;
    this.startTime = void 0;
    return durationMs;
  }
};
__name(_PortSelectionPerformanceTracker, "PortSelectionPerformanceTracker");
let PortSelectionPerformanceTracker = _PortSelectionPerformanceTracker;
const _DIPortSelectionPerformanceTracker = class _DIPortSelectionPerformanceTracker extends PortSelectionPerformanceTracker {
  constructor() {
    super();
  }
};
__name(_DIPortSelectionPerformanceTracker, "DIPortSelectionPerformanceTracker");
_DIPortSelectionPerformanceTracker.dependencies = [];
let DIPortSelectionPerformanceTracker = _DIPortSelectionPerformanceTracker;
const _PortSelectionObserver = class _PortSelectionObserver {
  constructor(logger, metrics, eventEmitter) {
    this.logger = logger;
    this.metrics = metrics;
    this.eventEmitter = eventEmitter;
  }
  /**
   * Handle a port selection event.
   *
   * Performs appropriate logging, metrics recording, and event emission.
   *
   * @param event - The port selection event to handle
   */
  handleEvent(event2) {
    this.eventEmitter.emit(event2);
    if (event2.type === "success") {
      this.handleSuccess(event2);
    } else {
      this.handleFailure(event2);
    }
  }
  /**
   * Handle successful port selection.
   *
   * Logs debug message and records metrics.
   */
  handleSuccess(event2) {
    this.logger.debug(
      `Port selection completed in ${event2.durationMs.toFixed(2)}ms (selected: v${event2.selectedVersion}${event2.adapterName ? ` for ${event2.adapterName}` : ""})`
    );
    this.metrics.recordPortSelection(event2.selectedVersion);
  }
  /**
   * Handle failed port selection.
   *
   * Logs error and records failure metrics.
   */
  handleFailure(event2) {
    this.logger.error("No compatible port found", {
      foundryVersion: event2.foundryVersion,
      availableVersions: event2.availableVersions,
      adapterName: event2.adapterName
    });
    this.metrics.recordPortSelectionFailure(event2.foundryVersion);
  }
};
__name(_PortSelectionObserver, "PortSelectionObserver");
let PortSelectionObserver = _PortSelectionObserver;
const _DIPortSelectionObserver = class _DIPortSelectionObserver extends PortSelectionObserver {
  constructor(logger, metrics, eventEmitter) {
    super(logger, metrics, eventEmitter);
  }
};
__name(_DIPortSelectionObserver, "DIPortSelectionObserver");
_DIPortSelectionObserver.dependencies = [
  loggerToken,
  metricsRecorderToken,
  portSelectionEventEmitterToken
];
let DIPortSelectionObserver = _DIPortSelectionObserver;
function registerObservability(container) {
  const emitterResult = container.registerClass(
    portSelectionEventEmitterToken,
    DIPortSelectionEventEmitter,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(emitterResult)) {
    return err(`Failed to register PortSelectionEventEmitter: ${emitterResult.error.message}`);
  }
  const registryResult = container.registerClass(
    observabilityRegistryToken,
    DIObservabilityRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(registryResult)) {
    return err(`Failed to register ObservabilityRegistry: ${registryResult.error.message}`);
  }
  const observabilityResult = container.registerClass(
    portSelectionObservabilityToken,
    DIPortSelectionObservability,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(observabilityResult)) {
    return err(
      `Failed to register PortSelectionObservability: ${observabilityResult.error.message}`
    );
  }
  const performanceTrackerResult = container.registerClass(
    portSelectionPerformanceTrackerToken,
    DIPortSelectionPerformanceTracker,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(performanceTrackerResult)) {
    return err(
      `Failed to register PortSelectionPerformanceTracker: ${performanceTrackerResult.error.message}`
    );
  }
  const observerResult = container.registerClass(
    portSelectionObserverToken,
    DIPortSelectionObserver,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(observerResult)) {
    return err(`Failed to register PortSelectionObserver: ${observerResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerObservability, "registerObservability");
registerDependencyStep({
  name: "Observability",
  priority: 30,
  execute: registerObservability
});
const _FoundryGamePort = class _FoundryGamePort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  getJournalEntries() {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryGame");
      if (!portResult.ok) return portResult;
      return portResult.value.getJournalEntries();
    }, "FoundryGame.getJournalEntries");
  }
  getJournalEntryById(id) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryGame");
      if (!portResult.ok) return portResult;
      return portResult.value.getJournalEntryById(id);
    }, "FoundryGame.getJournalEntryById");
  }
  invalidateCache() {
    const portResult = this.portLoader.loadPort("FoundryGame");
    if (portResult.ok) {
      portResult.value.invalidateCache();
    }
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryGamePort, "FoundryGamePort");
let FoundryGamePort = _FoundryGamePort;
const _DIFoundryGamePort = class _DIFoundryGamePort extends FoundryGamePort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryGamePort, "DIFoundryGamePort");
_DIFoundryGamePort.dependencies = [
  portSelectorToken,
  foundryGamePortRegistryToken,
  retryServiceToken
];
let DIFoundryGamePort = _DIFoundryGamePort;
const _FoundryHooksPort = class _FoundryHooksPort {
  constructor(portSelector, portRegistry, retryService, logger) {
    this.registeredHooks = /* @__PURE__ */ new Map();
    this.callbackToIdMap = /* @__PURE__ */ new Map();
    this.idToHookNameMap = /* @__PURE__ */ new Map();
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
    this.logger = logger;
  }
  on(hookName, callback) {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.on(hookName, callback);
    }, "FoundryHooks.on");
    if (result.ok) {
      let hookMap = this.registeredHooks.get(hookName);
      if (!hookMap) {
        hookMap = /* @__PURE__ */ new Map();
        this.registeredHooks.set(hookName, hookMap);
      }
      hookMap.set(result.value, callback);
      const existing = this.callbackToIdMap.get(callback) || [];
      existing.push({ hookName, id: result.value });
      this.callbackToIdMap.set(callback, existing);
      this.idToHookNameMap.set(result.value, hookName);
    }
    return result;
  }
  once(hookName, callback) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.once(hookName, callback);
    }, "FoundryHooks.once");
  }
  off(hookName, callbackOrId) {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.off(hookName, callbackOrId);
    }, "FoundryHooks.off");
    if (result.ok) {
      if (typeof callbackOrId === "number") {
        const hooks = this.registeredHooks.get(hookName);
        if (hooks) {
          const callback = hooks.get(callbackOrId);
          hooks.delete(callbackOrId);
          if (callback) {
            const hookInfos = this.callbackToIdMap.get(callback);
            if (hookInfos) {
              const filtered = hookInfos.filter(
                (info) => !(info.hookName === hookName && info.id === callbackOrId)
              );
              if (filtered.length === 0) {
                this.callbackToIdMap.delete(callback);
              } else {
                this.callbackToIdMap.set(callback, filtered);
              }
            }
          }
          this.idToHookNameMap.delete(callbackOrId);
        }
      } else {
        const hookInfos = this.callbackToIdMap.get(callbackOrId);
        if (hookInfos) {
          const matchingInfos = hookInfos.filter((info) => info.hookName === hookName);
          const hooks = this.registeredHooks.get(hookName);
          if (hooks) {
            for (const info of matchingInfos) {
              hooks.delete(info.id);
            }
          }
          const filtered = hookInfos.filter((info) => info.hookName !== hookName);
          if (filtered.length === 0) {
            this.callbackToIdMap.delete(callbackOrId);
          } else {
            this.callbackToIdMap.set(callbackOrId, filtered);
          }
        }
      }
    }
    return result;
  }
  /**
   * Cleans up all registered hooks.
   * Called automatically when the container is disposed.
   */
  dispose() {
    for (const [callback, hookInfos] of this.callbackToIdMap) {
      for (const info of hookInfos) {
        try {
          if (typeof Hooks !== "undefined") {
            Hooks.off(info.hookName, callback);
          }
        } catch (error) {
          this.logger.warn("Failed to unregister hook", {
            hookName: info.hookName,
            hookId: info.id,
            error
          });
        }
      }
    }
    this.registeredHooks.clear();
    this.callbackToIdMap.clear();
    this.idToHookNameMap.clear();
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
  // ===== PlatformEventPort Implementation =====
  /**
   * Register a listener for platform events.
   * Delegates to FoundryHooks.on() for Foundry-specific implementation.
   * Wraps the PlatformEventPort callback to receive Foundry hook arguments as an array.
   */
  registerListener(eventType, callback) {
    const foundryCallback = /* @__PURE__ */ __name((...args2) => {
      callback(args2);
    }, "foundryCallback");
    const result = this.on(eventType, foundryCallback);
    if (!result.ok) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register listener for event "${eventType}": ${result.error.message}`,
        details: result.error
      });
    }
    return ok(result.value);
  }
  /**
   * Unregister a previously registered listener.
   * Requires mapping from registration ID to hook name.
   */
  unregisterListener(registrationId) {
    const id = typeof registrationId === "string" ? Number.parseInt(registrationId, 10) : registrationId;
    if (Number.isNaN(id)) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `Invalid registration ID: ${String(registrationId)}`
      });
    }
    const hookName = this.idToHookNameMap.get(id);
    if (!hookName) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `No registration found for ID ${id}`
      });
    }
    const result = this.off(hookName, id);
    if (!result.ok) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `Failed to unregister listener for event "${hookName}": ${result.error.message}`,
        details: result.error
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryHooksPort, "FoundryHooksPort");
let FoundryHooksPort = _FoundryHooksPort;
const _DIFoundryHooksPort = class _DIFoundryHooksPort extends FoundryHooksPort {
  constructor(portSelector, portRegistry, retryService, logger) {
    super(portSelector, portRegistry, retryService, logger);
  }
};
__name(_DIFoundryHooksPort, "DIFoundryHooksPort");
_DIFoundryHooksPort.dependencies = [
  portSelectorToken,
  foundryHooksPortRegistryToken,
  retryServiceToken,
  loggerToken
];
let DIFoundryHooksPort = _DIFoundryHooksPort;
const _FoundryDocumentPort = class _FoundryDocumentPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  async create(documentClass, data) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.create(documentClass, data);
    }, "FoundryDocument.create");
  }
  async update(document2, changes) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.update(document2, changes);
    }, "FoundryDocument.update");
  }
  async delete(document2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.delete(document2);
    }, "FoundryDocument.delete");
  }
  getFlag(document2, scope, key2, schema) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return portResult.value.getFlag(document2, scope, key2, schema);
    }, "FoundryDocument.getFlag");
  }
  async setFlag(document2, scope, key2, value2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.setFlag(document2, scope, key2, value2);
    }, "FoundryDocument.setFlag");
  }
  async unsetFlag(document2, scope, key2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.unsetFlag(document2, scope, key2);
    }, "FoundryDocument.unsetFlag");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryDocumentPort, "FoundryDocumentPort");
let FoundryDocumentPort = _FoundryDocumentPort;
const _DIFoundryDocumentPort = class _DIFoundryDocumentPort extends FoundryDocumentPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryDocumentPort, "DIFoundryDocumentPort");
_DIFoundryDocumentPort.dependencies = [
  portSelectorToken,
  foundryDocumentPortRegistryToken,
  retryServiceToken
];
let DIFoundryDocumentPort = _DIFoundryDocumentPort;
const _FoundryUIPort = class _FoundryUIPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.removeJournalDirectoryEntry(directoryId, journalId, journalName);
    }, "FoundryUI.removeJournalDirectoryEntry");
  }
  findElement(container, selector) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.findElement(container, selector);
    }, "FoundryUI.findElement");
  }
  notify(message2, type, options) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.notify(message2, type, options);
    }, "FoundryUI.notify");
  }
  getDirectoryElement(directoryId) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.getDirectoryElement(directoryId);
    }, "FoundryUI.getDirectoryElement");
  }
  rerenderJournalDirectory() {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.rerenderJournalDirectory();
    }, "FoundryUI.rerenderJournalDirectory");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryUIPort, "FoundryUIPort");
let FoundryUIPort = _FoundryUIPort;
const _DIFoundryUIPort = class _DIFoundryUIPort extends FoundryUIPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryUIPort, "DIFoundryUIPort");
_DIFoundryUIPort.dependencies = [portSelectorToken, foundryUIPortRegistryToken, retryServiceToken];
let DIFoundryUIPort = _DIFoundryUIPort;
const _FoundrySettingsPort = class _FoundrySettingsPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  register(namespace, key2, config2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.register(namespace, key2, config2);
    }, "FoundrySettings.register");
  }
  get(namespace, key2, schema) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.get(namespace, key2, schema);
    }, "FoundrySettings.get");
  }
  async set(namespace, key2, value2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.set(namespace, key2, value2);
    }, "FoundrySettings.set");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundrySettingsPort, "FoundrySettingsPort");
let FoundrySettingsPort = _FoundrySettingsPort;
const _DIFoundrySettingsPort = class _DIFoundrySettingsPort extends FoundrySettingsPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundrySettingsPort, "DIFoundrySettingsPort");
_DIFoundrySettingsPort.dependencies = [
  portSelectorToken,
  foundrySettingsPortRegistryToken,
  retryServiceToken
];
let DIFoundrySettingsPort = _DIFoundrySettingsPort;
const _FoundryJournalFacade = class _FoundryJournalFacade {
  constructor(game2, document2, ui2, moduleId) {
    this.game = game2;
    this.document = document2;
    this.ui = ui2;
    this.moduleId = moduleId;
  }
  /**
   * Get all journal entries from Foundry.
   *
   * Delegates to FoundryGame.getJournalEntries().
   */
  getJournalEntries() {
    return this.game.getJournalEntries();
  }
  /**
   * Get a module flag from a journal entry with runtime validation.
   *
   * Delegates to FoundryDocument.getFlag() with module scope and schema.
   *
   * @template T - The flag value type
   * @param entry - The Foundry journal entry
   * @param key - The flag key
   * @param schema - Valibot schema for validation
   */
  getEntryFlag(entry, key2, schema) {
    const documentResult = castFoundryDocumentForFlag(entry);
    if (!documentResult.ok) {
      return documentResult;
    }
    return this.document.getFlag(documentResult.value, this.moduleId, key2, schema);
  }
  /**
   * Set a module flag on a journal entry.
   *
   * Delegates to FoundryDocument.setFlag() with module scope.
   *
   * @param entry - The Foundry journal entry
   * @param key - The flag key
   * @param value - The boolean value to set
   * @returns Result indicating success or error
   */
  async setEntryFlag(entry, key2, value2) {
    const documentResult = castFoundryDocumentForFlag(entry);
    if (!documentResult.ok) {
      return documentResult;
    }
    return await this.document.setFlag(documentResult.value, this.moduleId, key2, value2);
  }
};
__name(_FoundryJournalFacade, "FoundryJournalFacade");
let FoundryJournalFacade = _FoundryJournalFacade;
const _DIFoundryJournalFacade = class _DIFoundryJournalFacade extends FoundryJournalFacade {
  constructor(game2, document2, ui2, moduleId) {
    super(game2, document2, ui2, moduleId);
  }
};
__name(_DIFoundryJournalFacade, "DIFoundryJournalFacade");
_DIFoundryJournalFacade.dependencies = [
  foundryGameToken,
  foundryDocumentToken,
  foundryUIToken,
  moduleIdToken
];
let DIFoundryJournalFacade = _DIFoundryJournalFacade;
function sanitizeHtml(text2) {
  const div = document.createElement("div");
  div.textContent = text2;
  return div.innerHTML;
}
__name(sanitizeHtml, "sanitizeHtml");
const HIDDEN_JOURNAL_CACHE_TAG = "journal:hidden";
const _JournalVisibilityService = class _JournalVisibilityService {
  constructor(journalCollection, journalRepository, notifications, cacheReader, cacheWriter, config2) {
    this.journalCollection = journalCollection;
    this.journalRepository = journalRepository;
    this.notifications = notifications;
    this.cacheReader = cacheReader;
    this.cacheWriter = cacheWriter;
    this.config = config2;
  }
  /**
   * Gets journal entries marked as hidden via module flag.
   * Logs warnings for entries where flag reading fails to aid diagnosis.
   */
  getHiddenJournalEntries() {
    const cacheKey = this.config.cacheKeyFactory("hidden-directory");
    const cached = this.cacheReader.get(cacheKey);
    if (cached?.hit && cached.value) {
      this.notifications.debug(
        `Serving ${cached.value.length} hidden journal entries from cache (ttl=${cached.metadata.expiresAt ?? "∞"})`,
        { context: { cached } },
        { channels: ["ConsoleChannel"] }
      );
      return { ok: true, value: cached.value };
    }
    const allEntriesResult = this.journalCollection.getAll();
    if (!allEntriesResult.ok) {
      return {
        ok: false,
        error: {
          code: "PLATFORM_ERROR",
          message: allEntriesResult.error.message
        }
      };
    }
    const hidden = [];
    for (const journal of allEntriesResult.value) {
      const flagResult = this.journalRepository.getFlag(
        journal.id,
        this.config.moduleNamespace,
        this.config.hiddenFlagKey
      );
      if (flagResult.ok) {
        if (flagResult.value === true) {
          hidden.push(journal);
        }
      } else {
        const journalIdentifier = journal.name ?? journal.id;
        this.notifications.warn(
          `Failed to read hidden flag for journal "${sanitizeHtml(journalIdentifier)}"`,
          {
            errorCode: flagResult.error.code,
            errorMessage: flagResult.error.message
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    this.cacheWriter.set(cacheKey, hidden.slice(), {
      tags: [HIDDEN_JOURNAL_CACHE_TAG]
    });
    return { ok: true, value: hidden };
  }
};
__name(_JournalVisibilityService, "JournalVisibilityService");
let JournalVisibilityService = _JournalVisibilityService;
const _DIJournalVisibilityService = class _DIJournalVisibilityService extends JournalVisibilityService {
  constructor(journalCollection, journalRepository, notifications, cacheReader, cacheWriter, config2) {
    super(journalCollection, journalRepository, notifications, cacheReader, cacheWriter, config2);
  }
};
__name(_DIJournalVisibilityService, "DIJournalVisibilityService");
_DIJournalVisibilityService.dependencies = [
  platformJournalCollectionPortToken,
  platformJournalRepositoryToken,
  notificationPublisherPortToken,
  cacheReaderPortToken,
  cacheWriterPortToken,
  journalVisibilityConfigToken
];
let DIJournalVisibilityService = _DIJournalVisibilityService;
function isNonEmptyArray(array2) {
  return array2.length > 0;
}
__name(isNonEmptyArray, "isNonEmptyArray");
function getFirstArrayElement(array2) {
  if (!isNonEmptyArray(array2)) {
    throw new Error("Array must have length > 0 (caller violated precondition)");
  }
  return array2[0];
}
__name(getFirstArrayElement, "getFirstArrayElement");
function getFirstArrayElementSafe(array2) {
  return isNonEmptyArray(array2) ? array2[0] : null;
}
__name(getFirstArrayElementSafe, "getFirstArrayElementSafe");
const _JournalDirectoryProcessor = class _JournalDirectoryProcessor {
  constructor(journalDirectoryUI, notifications, config2) {
    this.journalDirectoryUI = journalDirectoryUI;
    this.notifications = notifications;
    this.config = config2;
  }
  /**
   * Processes journal directory to hide flagged journal directory entries.
   *
   * A journal directory entry is the list position in the sidebar that displays a journal.
   * This is NOT a journal entry (which is a page within a journal).
   *
   * DIP-compliant: Works with directoryId instead of HTMLElement.
   * @param directoryId - The identifier for the directory (e.g., "journal" for Foundry)
   * @param hiddenEntries - Array of journals whose directory entries should be hidden
   * @returns Result indicating success or failure with aggregated errors
   */
  processDirectory(directoryId, hiddenEntries) {
    this.notifications.debug(
      "Processing journal directory for hidden entries",
      { context: { directoryId, hiddenCount: hiddenEntries.length } },
      {
        channels: ["ConsoleChannel"]
      }
    );
    if (hiddenEntries.length === 0) {
      this.notifications.debug(
        "No hidden entries to process",
        { context: {} },
        {
          channels: ["ConsoleChannel"]
        }
      );
      return { ok: true, value: void 0 };
    }
    this.notifications.debug(
      `Found ${hiddenEntries.length} hidden journal entries`,
      { context: { hidden: hiddenEntries } },
      {
        channels: ["ConsoleChannel"]
      }
    );
    return this.hideEntries(directoryId, hiddenEntries);
  }
  /**
   * Hides multiple journal directory entries in the directory.
   *
   * A journal directory entry is the list position in the sidebar that displays a journal.
   * This is NOT a journal entry (which is a page within a journal).
   *
   * DIP-compliant: Uses directoryId instead of HTMLElement.
   * @param directoryId - The identifier for the directory
   * @param entries - Array of journals whose directory entries should be hidden
   * @returns Result indicating success or failure with aggregated errors
   */
  hideEntries(directoryId, entries2) {
    const errors = [];
    for (const journal of entries2) {
      const journalName = journal.name ?? this.config.unknownName;
      const removeResult = this.journalDirectoryUI.removeJournalDirectoryEntry(
        directoryId,
        journal.id,
        journalName
      );
      if (!removeResult.ok) {
        const journalError = {
          code: "DOM_MANIPULATION_FAILED",
          entryId: journal.id,
          message: removeResult.error.message
        };
        errors.push(journalError);
        this.notifications.warn("Error removing journal directory entry", journalError, {
          channels: ["ConsoleChannel"]
        });
      } else {
        this.notifications.debug(
          `Removing journal directory entry: ${sanitizeHtml(journalName)}`,
          { context: { journal } },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return { ok: false, error: firstError };
    }
    return { ok: true, value: void 0 };
  }
};
__name(_JournalDirectoryProcessor, "JournalDirectoryProcessor");
let JournalDirectoryProcessor = _JournalDirectoryProcessor;
const _DIJournalDirectoryProcessor = class _DIJournalDirectoryProcessor extends JournalDirectoryProcessor {
  constructor(journalDirectoryUI, notifications, config2) {
    super(journalDirectoryUI, notifications, config2);
  }
};
__name(_DIJournalDirectoryProcessor, "DIJournalDirectoryProcessor");
_DIJournalDirectoryProcessor.dependencies = [
  platformJournalDirectoryUiPortToken,
  notificationPublisherPortToken,
  journalVisibilityConfigToken
];
let DIJournalDirectoryProcessor = _DIJournalDirectoryProcessor;
const _FoundryLibWrapperService = class _FoundryLibWrapperService {
  constructor(moduleId, logger) {
    this.moduleId = moduleId;
    this.logger = logger;
    this.registeredTargets = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  register(target, wrapperFn, type) {
    if (typeof globalThis.libWrapper === "undefined") {
      return err({
        code: "LIBWRAPPER_NOT_AVAILABLE",
        message: "libWrapper is not available"
      });
    }
    if (this.registeredTargets.has(target)) {
      return err({
        code: "REGISTRATION_FAILED",
        message: `Target "${target}" is already registered`,
        details: { target }
      });
    }
    const result = tryCatch(
      () => {
        const libWrapperInstance = globalThis.libWrapper;
        if (typeof libWrapperInstance === "undefined") {
          throw new Error("libWrapper is not available");
        }
        libWrapperInstance.register(this.moduleId, target, wrapperFn, type);
        this.registeredTargets.set(target, true);
        const registrationId = this.nextId++;
        return registrationId;
      },
      (error) => ({
        code: "REGISTRATION_FAILED",
        message: `Failed to register wrapper for target "${target}": ${String(error)}`,
        details: { target, error }
      })
    );
    if (result.ok) {
      return ok(result.value);
    }
    return result;
  }
  unregister(target) {
    if (!this.registeredTargets.has(target)) {
      return err({
        code: "TARGET_NOT_REGISTERED",
        message: `Target "${target}" is not registered`,
        details: { target }
      });
    }
    if (typeof globalThis.libWrapper === "undefined") {
      return err({
        code: "LIBWRAPPER_NOT_AVAILABLE",
        message: "libWrapper is not available"
      });
    }
    const result = tryCatch(
      () => {
        const libWrapperInstance = globalThis.libWrapper;
        if (typeof libWrapperInstance === "undefined") {
          throw new Error("libWrapper is not available");
        }
        libWrapperInstance.unregister(this.moduleId, target);
        this.registeredTargets.delete(target);
      },
      (error) => ({
        code: "UNREGISTRATION_FAILED",
        message: `Failed to unregister wrapper for target "${target}": ${String(error)}`,
        details: { target, error }
      })
    );
    if (result.ok) {
      return ok(void 0);
    }
    return result;
  }
  /**
   * Cleanup all registered wrappers.
   * Should be called during module shutdown.
   */
  dispose() {
    const targets = Array.from(this.registeredTargets.keys());
    for (const target of targets) {
      const result = this.unregister(target);
      if (!result.ok) {
        this.logger.warn("Failed to unregister libWrapper target during dispose", {
          target,
          error: result.error
        });
      }
    }
    this.registeredTargets.clear();
  }
};
__name(_FoundryLibWrapperService, "FoundryLibWrapperService");
let FoundryLibWrapperService = _FoundryLibWrapperService;
const _DIFoundryLibWrapperService = class _DIFoundryLibWrapperService extends FoundryLibWrapperService {
  constructor(moduleId, logger) {
    super(moduleId, logger);
  }
};
__name(_DIFoundryLibWrapperService, "DIFoundryLibWrapperService");
_DIFoundryLibWrapperService.dependencies = [moduleIdToken, loggerToken];
let DIFoundryLibWrapperService = _DIFoundryLibWrapperService;
const libWrapperServiceToken = createInjectionToken("LibWrapperService");
const menuItemJournalIdMap = /* @__PURE__ */ new WeakMap();
const _JournalContextMenuLibWrapperService = class _JournalContextMenuLibWrapperService {
  constructor(libWrapperService, logger) {
    this.libWrapperService = libWrapperService;
    this.logger = logger;
    this.libWrapperRegistered = false;
    this.callbacks = [];
  }
  /**
   * Register libWrapper for ContextMenu.render.
   * Should be called once during module initialization.
   *
   * @returns Success or error if registration failed
   */
  register() {
    if (this.libWrapperRegistered) {
      return ok(void 0);
    }
    const contextMenuClass = globalThis.foundry?.applications?.ux?.ContextMenu?.implementation;
    if (!contextMenuClass) {
      return err(new Error("ContextMenu is not available"));
    }
    const wrapperFn = this.createWrapperFunction();
    const result = this.libWrapperService.register(
      "foundry.applications.ux.ContextMenu.implementation.prototype.render",
      wrapperFn,
      "WRAPPER"
    );
    if (!result.ok) {
      return err(new Error(result.error.message));
    }
    this.registrationId = result.value;
    this.libWrapperRegistered = true;
    this.logger.debug("Journal context menu libWrapper registered");
    return ok(void 0);
  }
  /**
   * Add a callback that will be called when a journal context menu is rendered.
   *
   * @param callback - Callback function that receives the context menu event
   */
  addCallback(callback) {
    this.callbacks.push(callback);
  }
  /**
   * Remove a previously registered callback.
   *
   * @param callback - The callback function to remove
   */
  removeCallback(callback) {
    const index2 = this.callbacks.indexOf(callback);
    if (index2 > -1) {
      this.callbacks.splice(index2, 1);
    }
  }
  /**
   * Cleanup: Unregister libWrapper.
   * Should be called during module shutdown.
   */
  dispose() {
    if (this.libWrapperRegistered) {
      const result = this.libWrapperService.unregister(
        "foundry.applications.ux.ContextMenu.implementation.prototype.render"
      );
      if (!result.ok) {
        this.logger.warn("Failed to unregister context menu libWrapper", {
          error: result.error
        });
      }
      this.libWrapperRegistered = false;
      this.registrationId = void 0;
    }
    this.callbacks = [];
  }
  /**
   * Create the wrapper function for libWrapper.
   * This function intercepts ContextMenu.render calls and allows
   * registered callbacks to modify the menu options.
   */
  createWrapperFunction() {
    const callbacksRef = this.callbacks;
    const loggerRef = this.logger;
    return function(wrapped, ...args2) {
      const firstArg = args2[0];
      const target = firstArg instanceof HTMLElement ? firstArg : void 0;
      if (!target) {
        return wrapped.call(this, ...args2);
      }
      const menuItemsRaw = this.menuItems;
      if (!menuItemsRaw) {
        return wrapped.call(this, ...args2);
      }
      const menuItems = menuItemsRaw;
      const journalId = target.getAttribute?.("data-entry-id") || target.getAttribute?.("data-document-id");
      if (journalId) {
        const ourOptionName = "Journal ausblenden";
        for (let i = menuItems.length - 1; i >= 0; i--) {
          const item = menuItems[i];
          if (item?.name === ourOptionName) {
            menuItemJournalIdMap.delete(item);
            menuItems.splice(i, 1);
          }
        }
        const event2 = {
          journalId,
          options: menuItems.map((item) => ({
            name: item.name,
            icon: item.icon,
            // ContextMenuOption.callback erwartet jetzt journalId statt HTMLElement
            callback: /* @__PURE__ */ __name((_id) => {
              item.callback();
            }, "callback")
          })),
          timestamp: Date.now()
        };
        for (const cb of callbacksRef) {
          cb(event2);
        }
        const existingNames = new Set(menuItems.map((item) => item.name));
        for (const newOption of event2.options) {
          if (!existingNames.has(newOption.name)) {
            const menuItem = {
              name: newOption.name,
              icon: newOption.icon,
              callback: /* @__PURE__ */ __name(() => {
                const dynamicJournalId = menuItemJournalIdMap.get(menuItem);
                if (!dynamicJournalId) {
                  loggerRef.error("Failed to determine journalId dynamically from WeakMap", {
                    menuItemName: menuItem.name,
                    fallbackJournalId: journalId
                  });
                  const contextMenuElement = document.querySelector(".context-menu");
                  if (contextMenuElement) {
                    const journalElement = contextMenuElement.closest("[data-entry-id], [data-document-id]") || document.querySelector(`[data-entry-id], [data-document-id]`);
                    if (journalElement) {
                      const domJournalId = journalElement.getAttribute("data-entry-id") || journalElement.getAttribute("data-document-id");
                      if (domJournalId) {
                        const result2 = newOption.callback(domJournalId);
                        if (result2 instanceof Promise) {
                          result2.catch(() => {
                          });
                        }
                        return;
                      }
                    }
                  }
                  return;
                }
                const result = newOption.callback(dynamicJournalId);
                if (result instanceof Promise) {
                  result.catch(() => {
                  });
                }
              }, "callback")
            };
            menuItemJournalIdMap.set(menuItem, journalId);
            menuItems.push(menuItem);
            existingNames.add(newOption.name);
          }
        }
      }
      return wrapped.call(this, ...args2);
    };
  }
};
__name(_JournalContextMenuLibWrapperService, "JournalContextMenuLibWrapperService");
let JournalContextMenuLibWrapperService = _JournalContextMenuLibWrapperService;
const _DIJournalContextMenuLibWrapperService = class _DIJournalContextMenuLibWrapperService extends JournalContextMenuLibWrapperService {
  constructor(libWrapperService, logger) {
    super(libWrapperService, logger);
  }
};
__name(_DIJournalContextMenuLibWrapperService, "DIJournalContextMenuLibWrapperService");
_DIJournalContextMenuLibWrapperService.dependencies = [libWrapperServiceToken, loggerToken];
let DIJournalContextMenuLibWrapperService = _DIJournalContextMenuLibWrapperService;
const _FoundrySettingsRegistrationAdapter = class _FoundrySettingsRegistrationAdapter {
  constructor(foundrySettings) {
    this.foundrySettings = foundrySettings;
  }
  registerSetting(namespace, key2, config2) {
    const foundryConfig = {
      name: config2.name,
      ...config2.hint !== void 0 && { hint: config2.hint },
      scope: config2.scope,
      config: config2.config,
      type: config2.type,
      ...config2.choices !== void 0 && { choices: config2.choices },
      default: config2.default,
      ...config2.onChange !== void 0 && { onChange: config2.onChange }
    };
    const result = this.foundrySettings.register(namespace, key2, foundryConfig);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "register", key2)
      };
    }
    return { ok: true, value: void 0 };
  }
  getSettingValue(namespace, key2, validator) {
    const permissiveSchema = /* @__PURE__ */ unknown();
    const result = this.foundrySettings.get(namespace, key2, permissiveSchema);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "get", key2)
      };
    }
    if (!validator(result.value)) {
      return {
        ok: false,
        error: {
          code: "INVALID_SETTING_VALUE",
          message: `Setting "${namespace}.${key2}" has invalid value type`,
          details: { value: result.value }
        }
      };
    }
    return { ok: true, value: result.value };
  }
  async setSettingValue(namespace, key2, value2) {
    const result = await this.foundrySettings.set(namespace, key2, value2);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "set", key2)
      };
    }
    return { ok: true, value: void 0 };
  }
  // ===== Private Helpers =====
  mapFoundryError(foundryError, operation, key2) {
    let code;
    switch (foundryError.code) {
      case "API_NOT_AVAILABLE":
        code = "PLATFORM_NOT_AVAILABLE";
        break;
      case "VALIDATION_FAILED":
        code = "INVALID_SETTING_VALUE";
        break;
      case "OPERATION_FAILED":
        if (operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else if (operation === "get") {
          code = "SETTING_READ_FAILED";
        } else {
          code = "SETTING_WRITE_FAILED";
        }
        break;
      default:
        code = operation === "register" ? "SETTING_REGISTRATION_FAILED" : operation === "get" ? "SETTING_READ_FAILED" : "SETTING_WRITE_FAILED";
    }
    return {
      code,
      message: `Failed to ${operation} setting "${key2}": ${foundryError.message}`,
      details: foundryError
    };
  }
};
__name(_FoundrySettingsRegistrationAdapter, "FoundrySettingsRegistrationAdapter");
let FoundrySettingsRegistrationAdapter = _FoundrySettingsRegistrationAdapter;
const _DIFoundrySettingsRegistrationAdapter = class _DIFoundrySettingsRegistrationAdapter extends FoundrySettingsRegistrationAdapter {
  constructor(foundrySettings) {
    super(foundrySettings);
  }
};
__name(_DIFoundrySettingsRegistrationAdapter, "DIFoundrySettingsRegistrationAdapter");
_DIFoundrySettingsRegistrationAdapter.dependencies = [foundrySettingsToken];
let DIFoundrySettingsRegistrationAdapter = _DIFoundrySettingsRegistrationAdapter;
function registerFoundryServices(container) {
  const gameServiceResult = container.registerClass(
    foundryGameToken,
    DIFoundryGamePort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(gameServiceResult)) {
    return err(`Failed to register FoundryGame service: ${gameServiceResult.error.message}`);
  }
  const hooksServiceResult = container.registerClass(
    foundryHooksToken,
    DIFoundryHooksPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(hooksServiceResult)) {
    return err(`Failed to register FoundryHooks service: ${hooksServiceResult.error.message}`);
  }
  const documentServiceResult = container.registerClass(
    foundryDocumentToken,
    DIFoundryDocumentPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(documentServiceResult)) {
    return err(
      `Failed to register FoundryDocument service: ${documentServiceResult.error.message}`
    );
  }
  const uiServiceResult = container.registerClass(
    foundryUIToken,
    DIFoundryUIPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiServiceResult)) {
    return err(`Failed to register FoundryUI service: ${uiServiceResult.error.message}`);
  }
  const settingsServiceResult = container.registerClass(
    foundrySettingsToken,
    DIFoundrySettingsPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsServiceResult)) {
    return err(
      `Failed to register FoundrySettings service: ${settingsServiceResult.error.message}`
    );
  }
  const settingsRegistrationResult = container.registerClass(
    platformSettingsRegistrationPortToken,
    DIFoundrySettingsRegistrationAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsRegistrationResult)) {
    return err(
      `Failed to register PlatformSettingsRegistrationPort: ${settingsRegistrationResult.error.message}`
    );
  }
  const journalFacadeResult = container.registerClass(
    foundryJournalFacadeToken,
    DIFoundryJournalFacade,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalFacadeResult)) {
    return err(`Failed to register FoundryJournalFacade: ${journalFacadeResult.error.message}`);
  }
  const journalVisibilityResult = container.registerClass(
    journalVisibilityServiceToken,
    DIJournalVisibilityService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalVisibilityResult)) {
    return err(
      `Failed to register JournalVisibility service: ${journalVisibilityResult.error.message}`
    );
  }
  const journalDirectoryProcessorResult = container.registerClass(
    journalDirectoryProcessorToken,
    DIJournalDirectoryProcessor,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalDirectoryProcessorResult)) {
    return err(
      `Failed to register JournalDirectoryProcessor: ${journalDirectoryProcessorResult.error.message}`
    );
  }
  const libWrapperServiceResult = container.registerClass(
    libWrapperServiceToken,
    DIFoundryLibWrapperService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(libWrapperServiceResult)) {
    return err(`Failed to register LibWrapperService: ${libWrapperServiceResult.error.message}`);
  }
  const contextMenuLibWrapperResult = container.registerClass(
    journalContextMenuLibWrapperServiceToken,
    DIJournalContextMenuLibWrapperService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(contextMenuLibWrapperResult)) {
    return err(
      `Failed to register JournalContextMenuLibWrapperService: ${contextMenuLibWrapperResult.error.message}`
    );
  }
  const contextMenuPortResult = container.registerAlias(
    platformContextMenuRegistrationPortToken,
    journalContextMenuLibWrapperServiceToken
  );
  if (isErr(contextMenuPortResult)) {
    return err(
      `Failed to register PlatformContextMenuRegistrationPort: ${contextMenuPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerFoundryServices, "registerFoundryServices");
registerDependencyStep({
  name: "FoundryServices",
  priority: 80,
  execute: registerFoundryServices
});
const performanceTrackingServiceToken = createInjectionToken(
  "PerformanceTrackingService"
);
const _PerformanceTrackingService = class _PerformanceTrackingService extends PerformanceTrackerImpl {
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_PerformanceTrackingService, "PerformanceTrackingService");
let PerformanceTrackingService = _PerformanceTrackingService;
const _DIPerformanceTrackingService = class _DIPerformanceTrackingService extends PerformanceTrackingService {
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_DIPerformanceTrackingService, "DIPerformanceTrackingService");
_DIPerformanceTrackingService.dependencies = [runtimeConfigToken, metricsSamplerToken];
let DIPerformanceTrackingService = _DIPerformanceTrackingService;
const _BaseRetryService = class _BaseRetryService {
  /**
   * Retries an async operation with exponential backoff.
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options
   * @returns Promise resolving to the Result (success or last error)
   */
  async retry(fn, options) {
    const maxAttempts = options.maxAttempts ?? 3;
    const delayMs = options.delayMs ?? 100;
    const backoffFactor = options.backoffFactor ?? 1;
    const { mapException } = options;
    if (maxAttempts < 1) {
      return err(mapException("maxAttempts must be >= 1", 0));
    }
    let lastError = mapException("Initial retry error", 0);
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const result = await fn();
        if (result.ok) {
          return result;
        }
        lastError = result.error;
        if (attempt === maxAttempts) {
          break;
        }
        const delay = delayMs * Math.pow(attempt, backoffFactor);
        await new Promise((resolve) => setTimeout(resolve, delay));
      } catch (error) {
        lastError = mapException(error, attempt);
        if (attempt === maxAttempts) {
          break;
        }
        const delay = delayMs * Math.pow(attempt, backoffFactor);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    return err(lastError);
  }
  /**
   * Retries a synchronous operation.
   * Similar to retry but for sync functions.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options (without delayMs and backoffFactor)
   * @returns The Result (success or last error)
   */
  retrySync(fn, options) {
    const maxAttempts = options.maxAttempts ?? 3;
    const { mapException } = options;
    if (maxAttempts < 1) {
      return err(mapException("maxAttempts must be >= 1", 0));
    }
    let lastError = mapException("Initial retry error", 0);
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const result = fn();
        if (result.ok) {
          return result;
        }
        lastError = result.error;
        if (attempt === maxAttempts) {
          break;
        }
      } catch (error) {
        lastError = mapException(error, attempt);
        if (attempt === maxAttempts) {
          break;
        }
      }
    }
    return err(lastError);
  }
};
__name(_BaseRetryService, "BaseRetryService");
let BaseRetryService = _BaseRetryService;
const _RetryObservabilityDecorator = class _RetryObservabilityDecorator extends BaseRetryService {
  constructor(logger) {
    super();
    this.logger = logger;
  }
  /**
   * Retries an async operation with exponential backoff and observability.
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options with optional observability
   * @returns Promise resolving to the Result (success or last error)
   */
  async retry(fn, options) {
    const { operationName, ...baseOptions } = options;
    const startTime = performance.now();
    let attemptCount = 0;
    const wrappedFn = /* @__PURE__ */ __name(async () => {
      attemptCount++;
      try {
        const result2 = await fn();
        if (!result2.ok && attemptCount < (baseOptions.maxAttempts ?? 3)) {
          if (operationName) {
            this.logger.debug(
              `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} failed for "${operationName}"`,
              { error: result2.error }
            );
          }
        }
        return result2;
      } catch (error) {
        if (attemptCount < (baseOptions.maxAttempts ?? 3) && operationName) {
          this.logger.warn(
            `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} threw exception for "${operationName}"`,
            { error }
          );
        }
        throw error;
      }
    }, "wrappedFn");
    const result = await super.retry(wrappedFn, baseOptions);
    const duration = performance.now() - startTime;
    if (operationName) {
      if (result.ok && attemptCount > 1) {
        this.logger.debug(
          `Retry succeeded for "${operationName}" after ${attemptCount} attempts (${duration.toFixed(2)}ms)`
        );
      } else if (!result.ok) {
        this.logger.warn(
          `All retry attempts exhausted for "${operationName}" after ${baseOptions.maxAttempts ?? 3} attempts (${duration.toFixed(2)}ms)`
        );
      }
    }
    return result;
  }
  /**
   * Retries a synchronous operation with observability.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options (without delayMs and backoffFactor)
   * @returns The Result (success or last error)
   */
  retrySync(fn, options) {
    const { operationName, ...baseOptions } = options;
    let attemptCount = 0;
    const wrappedFn = /* @__PURE__ */ __name(() => {
      attemptCount++;
      try {
        const result2 = fn();
        if (!result2.ok && attemptCount < (baseOptions.maxAttempts ?? 3)) {
          if (operationName) {
            this.logger.debug(
              `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} failed for "${operationName}"`,
              { error: result2.error }
            );
          }
        }
        return result2;
      } catch (error) {
        if (attemptCount < (baseOptions.maxAttempts ?? 3) && operationName) {
          this.logger.warn(
            `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} threw exception for "${operationName}"`,
            { error }
          );
        }
        throw error;
      }
    }, "wrappedFn");
    const result = super.retrySync(wrappedFn, baseOptions);
    if (operationName && !result.ok) {
      this.logger.warn(
        `All retry attempts exhausted for "${operationName}" after ${baseOptions.maxAttempts ?? 3} attempts`
      );
    } else if (operationName && result.ok && attemptCount > 1) {
      this.logger.debug(`Retry succeeded for "${operationName}" after ${attemptCount} attempts`);
    }
    return result;
  }
};
__name(_RetryObservabilityDecorator, "RetryObservabilityDecorator");
let RetryObservabilityDecorator = _RetryObservabilityDecorator;
function isLogger(value2) {
  return !(value2 instanceof BaseRetryService);
}
__name(isLogger, "isLogger");
const _RetryService = class _RetryService {
  constructor(loggerOrBaseService, observabilityDecorator) {
    if (observabilityDecorator) {
      this.composedService = observabilityDecorator;
    } else {
      if (!isLogger(loggerOrBaseService)) {
        throw new Error("BaseRetryService cannot be used without RetryObservabilityDecorator");
      }
      this.composedService = new RetryObservabilityDecorator(loggerOrBaseService);
    }
  }
  /**
   * Retries an async operation with exponential backoff.
   *
   * Useful for handling transient failures in external APIs (e.g., Foundry API calls).
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options
   * @returns Promise resolving to the Result (success or last error)
   *
   * @example
   * ```typescript
   * const result = await retryService.retry(
   *   () => foundryApi.fetchData(),
   *   {
   *     maxAttempts: 3,
   *     delayMs: 100,
   *     operationName: "fetchData",
   *     mapException: (error, attempt) => ({
   *       code: 'OPERATION_FAILED' as const,
   *       message: `Attempt ${attempt} failed: ${String(error)}`
   *     })
   *   }
   * );
   * ```
   */
  async retry(fn, options) {
    return this.composedService.retry(fn, options);
  }
  /**
   * Retries a synchronous operation.
   * Similar to retry but for sync functions.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options
   * @returns The Result (success or last error)
   *
   * @example
   * ```typescript
   * const result = retryService.retrySync(
   *   () => parseData(input),
   *   {
   *     maxAttempts: 3,
   *     operationName: "parseData",
   *     mapException: (error, attempt) => ({
   *       code: 'PARSE_FAILED' as const,
   *       message: `Parse attempt ${attempt} failed: ${String(error)}`
   *     })
   *   }
   * );
   * ```
   */
  retrySync(fn, options) {
    return this.composedService.retrySync(fn, options);
  }
};
__name(_RetryService, "RetryService");
let RetryService = _RetryService;
const _DIRetryService = class _DIRetryService extends RetryService {
  constructor(logger) {
    super(logger);
  }
};
__name(_DIRetryService, "DIRetryService");
_DIRetryService.dependencies = [loggerToken];
let DIRetryService = _DIRetryService;
function registerUtilityServices(container) {
  const perfTrackingResult = container.registerClass(
    performanceTrackingServiceToken,
    DIPerformanceTrackingService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(perfTrackingResult)) {
    return err(
      `Failed to register PerformanceTrackingService: ${perfTrackingResult.error.message}`
    );
  }
  const retryServiceResult = container.registerClass(
    retryServiceToken,
    DIRetryService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(retryServiceResult)) {
    return err(`Failed to register RetryService: ${retryServiceResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerUtilityServices, "registerUtilityServices");
registerDependencyStep({
  name: "UtilityServices",
  priority: 40,
  execute: registerUtilityServices
});
const foundryI18nToken = createInjectionToken("FoundryI18nPort");
const localI18nToken = createInjectionToken("LocalI18nService");
const foundryTranslationHandlerToken = createInjectionToken(
  "FoundryTranslationHandler"
);
const localTranslationHandlerToken = createInjectionToken("LocalTranslationHandler");
const fallbackTranslationHandlerToken = createInjectionToken(
  "FallbackTranslationHandler"
);
const translationHandlerChainToken = createInjectionToken("TranslationHandlerChain");
const translationHandlersToken = createInjectionToken("TranslationHandlers");
const _FoundryI18nPort = class _FoundryI18nPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  localize(key2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.localize(key2);
    }, "FoundryI18n.localize");
  }
  format(key2, data) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.format(key2, data);
    }, "FoundryI18n.format");
  }
  has(key2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.has(key2);
    }, "FoundryI18n.has");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryI18nPort, "FoundryI18nPort");
let FoundryI18nPort = _FoundryI18nPort;
const _DIFoundryI18nPort = class _DIFoundryI18nPort extends FoundryI18nPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryI18nPort, "DIFoundryI18nPort");
_DIFoundryI18nPort.dependencies = [
  portSelectorToken,
  foundryI18nPortRegistryToken,
  retryServiceToken
];
let DIFoundryI18nPort = _DIFoundryI18nPort;
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
const _LocalI18nService = class _LocalI18nService {
  constructor() {
    this.translations = /* @__PURE__ */ new Map();
    this.currentLocale = "en";
    this.detectLocale();
  }
  /**
   * Detects browser locale and sets current language.
   * Falls back to 'en' if detection fails.
   */
  detectLocale() {
    if (typeof navigator !== "undefined" && navigator.language) {
      const lang = navigator.language.split("-")[0];
      this.currentLocale = lang ?? "en";
    }
  }
  /**
   * Loads translations from a JSON object.
   * Useful for testing or pre-loaded translation data.
   *
   * @param translations - Object with key-value pairs
   *
   * @example
   * ```typescript
   * const i18n = new LocalI18nService();
   * i18n.loadTranslations({
   *   "MODULE.SETTINGS.logLevel.name": "Log Level",
   *   "MODULE.WELCOME": "Welcome, {name}!"
   * });
   * ```
   */
  loadTranslations(translations) {
    for (const [key2, value2] of Object.entries(translations)) {
      this.translations.set(key2, value2);
    }
  }
  /**
   * Translates a key using local translations.
   *
   * @param key - Translation key
   * @returns Result with translated string (or key itself if not found)
   *
   * @example
   * ```typescript
   * const result = i18n.translate("MODULE.SETTINGS.logLevel.name");
   * if (result.ok) {
   *   console.log(result.value); // "Enable Feature" or key if not found
   * }
   * ```
   */
  translate(key2) {
    const value2 = this.translations.get(key2);
    return ok(value2 ?? key2);
  }
  /**
   * Formats a string with placeholders.
   * Simple implementation: replaces `{key}` with values from data object.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @returns Result with formatted string
   *
   * @example
   * ```typescript
   * // Translation: "Welcome, {name}!"
   * const result = i18n.format("MODULE.WELCOME", { name: "Alice" });
   * if (result.ok) {
   *   console.log(result.value); // "Welcome, Alice!"
   * }
   * ```
   */
  format(key2, data) {
    const template = this.translations.get(key2) ?? key2;
    let formatted = template;
    for (const [placeholder, value2] of Object.entries(data)) {
      const escapedPlaceholder = escapeRegex(placeholder);
      const regex2 = new RegExp(`\\{${escapedPlaceholder}\\}`, "g");
      formatted = formatted.replace(regex2, String(value2));
    }
    return ok(formatted);
  }
  /**
   * Checks if a translation key exists.
   *
   * @param key - Translation key to check
   * @returns Result with boolean
   */
  has(key2) {
    return ok(this.translations.has(key2));
  }
  /**
   * Gets the current locale.
   *
   * @returns Current locale string (e.g., "en", "de")
   */
  getCurrentLocale() {
    return this.currentLocale;
  }
  /**
   * Sets the current locale.
   * Note: Changing locale requires reloading translations for the new language.
   *
   * @param locale - Locale code (e.g., "en", "de", "fr")
   */
  setLocale(locale) {
    this.currentLocale = locale;
  }
};
__name(_LocalI18nService, "LocalI18nService");
_LocalI18nService.dependencies = [];
let LocalI18nService = _LocalI18nService;
const _DILocalI18nService = class _DILocalI18nService extends LocalI18nService {
  constructor() {
    super();
  }
};
__name(_DILocalI18nService, "DILocalI18nService");
_DILocalI18nService.dependencies = [];
let DILocalI18nService = _DILocalI18nService;
const _I18nFacadeService = class _I18nFacadeService {
  constructor(handlerChain, localI18n) {
    this.handlerChain = handlerChain;
    this.localI18n = localI18n;
  }
  /**
   * Translates a key using the handler chain: Foundry → Local → Fallback.
   *
   * @param key - Translation key
   * @param fallback - Optional fallback string (defaults to key itself)
   * @returns Result with translated string or fallback
   *
   * @example
   * ```typescript
   * // With fallback
   * const result = i18n.translate("MODULE.UNKNOWN_KEY", "Default Text");
   * if (result.ok) {
   *   console.log(result.value); // "Default Text"
   * }
   *
   * // Without fallback (returns key as fallback)
   * const result2 = i18n.translate("MODULE.UNKNOWN_KEY");
   * if (result2.ok) {
   *   console.log(result2.value); // "MODULE.UNKNOWN_KEY"
   * }
   * ```
   */
  translate(key2, fallback2) {
    return this.handlerChain.handle(key2, void 0, fallback2);
  }
  /**
   * Formats a string with placeholders using the handler chain.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @param fallback - Optional fallback string
   * @returns Result with formatted string or fallback
   *
   * @example
   * ```typescript
   * const result = i18n.format("MODULE.WELCOME", { name: "Alice" }, "Welcome!");
   * if (result.ok) {
   *   console.log(result.value); // "Welcome, Alice!" or "Welcome!"
   * }
   * ```
   */
  format(key2, data, fallback2) {
    return this.handlerChain.handle(key2, data, fallback2);
  }
  /**
   * Checks if a translation key exists in the handler chain.
   * Checks Foundry → Local (Fallback always returns false for has()).
   *
   * @param key - Translation key to check
   * @returns Result with true if key exists in Foundry or local i18n
   */
  has(key2) {
    return this.handlerChain.has(key2);
  }
  /**
   * Loads local translations from a JSON object.
   * Useful for initializing translations on module startup.
   *
   * @param translations - Object with key-value pairs
   *
   * @example
   * ```typescript
   * i18n.loadLocalTranslations({
   *   "MODULE.SETTINGS.logLevel.name": "Log Level",
   *   "MODULE.WELCOME": "Welcome, {name}!"
   * });
   * ```
   */
  loadLocalTranslations(translations) {
    this.localI18n.loadTranslations(translations);
  }
};
__name(_I18nFacadeService, "I18nFacadeService");
let I18nFacadeService = _I18nFacadeService;
const _DII18nFacadeService = class _DII18nFacadeService extends I18nFacadeService {
  constructor(handlerChain, localI18n) {
    super(handlerChain, localI18n);
  }
};
__name(_DII18nFacadeService, "DII18nFacadeService");
_DII18nFacadeService.dependencies = [translationHandlerChainToken, localI18nToken];
let DII18nFacadeService = _DII18nFacadeService;
const _AbstractTranslationHandler = class _AbstractTranslationHandler {
  constructor() {
    this.nextHandler = null;
  }
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  handle(key2, data, fallback2) {
    const result = this.doHandle(key2, data, fallback2);
    if (result.ok) {
      return result;
    }
    if (this.nextHandler) {
      return this.nextHandler.handle(key2, data, fallback2);
    }
    if (fallback2 !== void 0) {
      return ok(fallback2);
    }
    return err(`Translation key not found: ${key2}`);
  }
  has(key2) {
    const ourResult = this.doHas(key2);
    if (!ourResult.ok) {
      return ourResult;
    }
    if (ourResult.value) {
      return ok(true);
    }
    if (this.nextHandler) {
      return this.nextHandler.has(key2);
    }
    return ok(false);
  }
};
__name(_AbstractTranslationHandler, "AbstractTranslationHandler");
let AbstractTranslationHandler = _AbstractTranslationHandler;
const _FoundryTranslationHandler = class _FoundryTranslationHandler extends AbstractTranslationHandler {
  constructor(foundryI18n) {
    super();
    this.foundryI18n = foundryI18n;
  }
  doHandle(key2, data, _fallback) {
    const result = data ? this.foundryI18n.format(key2, data) : this.foundryI18n.localize(key2);
    if (result.ok && result.value !== key2) {
      return ok(result.value);
    }
    return err(`Foundry i18n could not translate key: ${key2}`);
  }
  doHas(key2) {
    const result = this.foundryI18n.has(key2);
    if (!result.ok) {
      return err(`Failed to check Foundry i18n for key: ${key2}`);
    }
    return ok(result.value);
  }
};
__name(_FoundryTranslationHandler, "FoundryTranslationHandler");
let FoundryTranslationHandler = _FoundryTranslationHandler;
const _DIFoundryTranslationHandler = class _DIFoundryTranslationHandler extends FoundryTranslationHandler {
  constructor(foundryI18n) {
    super(foundryI18n);
  }
};
__name(_DIFoundryTranslationHandler, "DIFoundryTranslationHandler");
_DIFoundryTranslationHandler.dependencies = [foundryI18nToken];
let DIFoundryTranslationHandler = _DIFoundryTranslationHandler;
const _LocalTranslationHandler = class _LocalTranslationHandler extends AbstractTranslationHandler {
  constructor(localI18n) {
    super();
    this.localI18n = localI18n;
  }
  doHandle(key2, data, _fallback) {
    const result = data ? this.localI18n.format(key2, data) : this.localI18n.translate(key2);
    if (result.ok && result.value !== key2) {
      return ok(result.value);
    }
    return err(`Local i18n could not translate key: ${key2}`);
  }
  doHas(key2) {
    const result = this.localI18n.has(key2);
    if (!result.ok) {
      return err(`Failed to check local i18n for key: ${key2}`);
    }
    return ok(result.value);
  }
};
__name(_LocalTranslationHandler, "LocalTranslationHandler");
let LocalTranslationHandler = _LocalTranslationHandler;
const _DILocalTranslationHandler = class _DILocalTranslationHandler extends LocalTranslationHandler {
  constructor(localI18n) {
    super(localI18n);
  }
};
__name(_DILocalTranslationHandler, "DILocalTranslationHandler");
_DILocalTranslationHandler.dependencies = [localI18nToken];
let DILocalTranslationHandler = _DILocalTranslationHandler;
const _FallbackTranslationHandler = class _FallbackTranslationHandler extends AbstractTranslationHandler {
  doHandle(key2, _data, fallback2) {
    return ok(fallback2 ?? key2);
  }
  doHas(_key) {
    return ok(false);
  }
};
__name(_FallbackTranslationHandler, "FallbackTranslationHandler");
_FallbackTranslationHandler.dependencies = [];
let FallbackTranslationHandler = _FallbackTranslationHandler;
const _DIFallbackTranslationHandler = class _DIFallbackTranslationHandler extends FallbackTranslationHandler {
  constructor() {
    super();
  }
};
__name(_DIFallbackTranslationHandler, "DIFallbackTranslationHandler");
_DIFallbackTranslationHandler.dependencies = [];
let DIFallbackTranslationHandler = _DIFallbackTranslationHandler;
const _TranslationHandlerChain = class _TranslationHandlerChain {
  constructor(handlers2) {
    assertNonEmptyHandlers(handlers2);
    const [head2, ...rest] = handlers2;
    this.head = head2;
    let current = head2;
    for (const handler of rest) {
      current = current.setNext(handler);
    }
  }
  setNext(handler) {
    return this.head.setNext(handler);
  }
  handle(key2, data, fallback2) {
    return this.head.handle(key2, data, fallback2);
  }
  has(key2) {
    return this.head.has(key2);
  }
};
__name(_TranslationHandlerChain, "TranslationHandlerChain");
let TranslationHandlerChain = _TranslationHandlerChain;
const _DITranslationHandlerChain = class _DITranslationHandlerChain extends TranslationHandlerChain {
  constructor(handlers2) {
    super(handlers2);
  }
};
__name(_DITranslationHandlerChain, "DITranslationHandlerChain");
_DITranslationHandlerChain.dependencies = [translationHandlersToken];
let DITranslationHandlerChain = _DITranslationHandlerChain;
function assertNonEmptyHandlers(handlers2) {
  if (handlers2.length === 0) {
    throw new Error("TranslationHandlerChain requires at least one handler");
  }
}
__name(assertNonEmptyHandlers, "assertNonEmptyHandlers");
const _I18nPortAdapter = class _I18nPortAdapter {
  constructor(i18nFacade) {
    this.i18nFacade = i18nFacade;
  }
  translate(key2, fallback2) {
    return this.i18nFacade.translate(key2, fallback2);
  }
  format(key2, data, fallback2) {
    return this.i18nFacade.format(key2, data, fallback2);
  }
  has(key2) {
    return this.i18nFacade.has(key2);
  }
  loadLocalTranslations(translations) {
    this.i18nFacade.loadLocalTranslations(translations);
  }
};
__name(_I18nPortAdapter, "I18nPortAdapter");
let I18nPortAdapter = _I18nPortAdapter;
const _DII18nPortAdapter = class _DII18nPortAdapter extends I18nPortAdapter {
  constructor(i18nFacade) {
    super(i18nFacade);
  }
};
__name(_DII18nPortAdapter, "DII18nPortAdapter");
_DII18nPortAdapter.dependencies = [i18nFacadeToken];
let DII18nPortAdapter = _DII18nPortAdapter;
function resolveMultipleServices$1(container, tokens) {
  const results = [];
  for (const { token, name } of tokens) {
    const result = container.resolveWithError(token);
    if (!result.ok) {
      throw new Error(`Failed to resolve ${name}: ${result.error.message}`);
    }
    results.push(castResolvedService(result.value));
  }
  return results;
}
__name(resolveMultipleServices$1, "resolveMultipleServices$1");
function registerI18nServices(container) {
  const foundryI18nResult = container.registerClass(
    foundryI18nToken,
    DIFoundryI18nPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryI18nResult)) {
    return err(`Failed to register FoundryI18nPort: ${foundryI18nResult.error.message}`);
  }
  const localI18nResult = container.registerClass(
    localI18nToken,
    DILocalI18nService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(localI18nResult)) {
    return err(`Failed to register LocalI18nService: ${localI18nResult.error.message}`);
  }
  const foundryHandlerResult = container.registerClass(
    foundryTranslationHandlerToken,
    DIFoundryTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryHandlerResult)) {
    return err(
      `Failed to register FoundryTranslationHandler: ${foundryHandlerResult.error.message}`
    );
  }
  const localHandlerResult = container.registerClass(
    localTranslationHandlerToken,
    DILocalTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(localHandlerResult)) {
    return err(`Failed to register LocalTranslationHandler: ${localHandlerResult.error.message}`);
  }
  const fallbackHandlerResult = container.registerClass(
    fallbackTranslationHandlerToken,
    DIFallbackTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(fallbackHandlerResult)) {
    return err(
      `Failed to register FallbackTranslationHandler: ${fallbackHandlerResult.error.message}`
    );
  }
  const handlersArrayResult = container.registerFactory(
    translationHandlersToken,
    () => {
      return resolveMultipleServices$1(container, [
        { token: foundryTranslationHandlerToken, name: "FoundryTranslationHandler" },
        { token: localTranslationHandlerToken, name: "LocalTranslationHandler" },
        { token: fallbackTranslationHandlerToken, name: "FallbackTranslationHandler" }
      ]);
    },
    ServiceLifecycle.SINGLETON,
    [foundryTranslationHandlerToken, localTranslationHandlerToken, fallbackTranslationHandlerToken]
  );
  if (isErr(handlersArrayResult)) {
    return err(
      `Failed to register TranslationHandlers array: ${handlersArrayResult.error.message}`
    );
  }
  const chainResult = container.registerClass(
    translationHandlerChainToken,
    DITranslationHandlerChain,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(chainResult)) {
    return err(`Failed to register TranslationHandlerChain: ${chainResult.error.message}`);
  }
  const facadeResult = container.registerClass(
    i18nFacadeToken,
    DII18nFacadeService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(facadeResult)) {
    return err(`Failed to register I18nFacadeService: ${facadeResult.error.message}`);
  }
  const i18nPortResult = container.registerClass(
    platformI18nPortToken,
    DII18nPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(i18nPortResult)) {
    return err(`Failed to register PlatformI18nPort: ${i18nPortResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerI18nServices, "registerI18nServices");
registerDependencyStep({
  name: "I18nServices",
  priority: 120,
  execute: registerI18nServices
});
const consoleChannelToken = createInjectionToken("ConsoleChannel");
const uiChannelToken = createInjectionToken("UIChannel");
const notificationQueueToken = createInjectionToken("NotificationQueue");
const _NotificationCenter = class _NotificationCenter {
  constructor(initialChannels) {
    this.channels = [...initialChannels];
  }
  debug(context, data, options) {
    const payload = data === void 0 ? {} : { data };
    return this.notify("debug", context, payload, options);
  }
  info(context, data, options) {
    const payload = data === void 0 ? {} : { data };
    return this.notify("info", context, payload, options);
  }
  warn(context, data, options) {
    const payload = data === void 0 ? {} : { data };
    return this.notify("warn", context, payload, options);
  }
  error(context, error, options) {
    const payload = error === void 0 ? {} : { error };
    return this.notify("error", context, payload, options);
  }
  addChannel(channel) {
    const alreadyRegistered = this.channels.some((existing) => existing.name === channel.name);
    if (!alreadyRegistered) {
      this.channels.push(channel);
    }
  }
  removeChannel(name) {
    const index2 = this.channels.findIndex((channel) => channel.name === name);
    if (index2 === -1) {
      return false;
    }
    this.channels.splice(index2, 1);
    return true;
  }
  getChannelNames() {
    return this.channels.map((channel) => channel.name);
  }
  notify(level, context, payload, options) {
    const notification = {
      level,
      context,
      timestamp: /* @__PURE__ */ new Date(),
      ...payload.data !== void 0 ? { data: payload.data } : {},
      ...payload.error !== void 0 ? { error: payload.error } : {},
      ...options?.traceId !== void 0 ? { traceId: options.traceId } : {},
      ...options?.uiOptions !== void 0 ? { uiOptions: options.uiOptions } : {}
    };
    const targetChannels = this.selectChannels(options?.channels);
    let attempted = false;
    let succeeded = false;
    const failures = [];
    for (const channel of targetChannels) {
      if (!channel.canHandle(notification)) {
        continue;
      }
      attempted = true;
      const result = channel.send(notification);
      if (result.ok) {
        succeeded = true;
      } else {
        failures.push(`${channel.name}: ${result.error.message}`);
      }
    }
    if (!attempted) {
      if (options?.channels && options.channels.length > 0) {
        return err(
          `No channels attempted to handle notification (requested: ${options.channels.join(", ")})`
        );
      }
      return ok(void 0);
    }
    if (succeeded) {
      return ok(void 0);
    }
    return err(`All channels failed: ${failures.join("; ")}`);
  }
  selectChannels(channelNames) {
    if (!channelNames || channelNames.length === 0) {
      return this.channels;
    }
    return this.channels.filter((channel) => channelNames.includes(channel.name));
  }
};
__name(_NotificationCenter, "NotificationCenter");
let NotificationCenter = _NotificationCenter;
const _DINotificationCenter = class _DINotificationCenter extends NotificationCenter {
  constructor(consoleChannel, uiChannel) {
    super([consoleChannel, uiChannel]);
  }
};
__name(_DINotificationCenter, "DINotificationCenter");
_DINotificationCenter.dependencies = [consoleChannelToken, uiChannelToken];
let DINotificationCenter = _DINotificationCenter;
const _ConsoleChannel = class _ConsoleChannel {
  constructor(logger) {
    this.logger = logger;
    this.name = "ConsoleChannel";
  }
  canHandle() {
    return true;
  }
  send(notification) {
    const { level, context, data, error } = notification;
    const payload = level === "error" ? error ?? data : data ?? error;
    this.log(level, context, payload);
    return ok(void 0);
  }
  log(level, message2, data) {
    switch (level) {
      case "debug":
        this.logger.debug(message2, data);
        break;
      case "info":
        this.logger.info(message2, data);
        break;
      case "warn":
        this.logger.warn(message2, data);
        break;
      case "error":
        this.logger.error(message2, data);
        break;
    }
  }
};
__name(_ConsoleChannel, "ConsoleChannel");
let ConsoleChannel = _ConsoleChannel;
const _DIConsoleChannel = class _DIConsoleChannel extends ConsoleChannel {
  constructor(logger) {
    super(logger);
  }
};
__name(_DIConsoleChannel, "DIConsoleChannel");
_DIConsoleChannel.dependencies = [platformLoggingPortToken];
let DIConsoleChannel = _DIConsoleChannel;
const _UIChannel = class _UIChannel {
  constructor(platformUI, config2) {
    this.platformUI = platformUI;
    this.config = config2;
    this.name = "UIChannel";
  }
  canHandle(notification) {
    return notification.level !== "debug";
  }
  send(notification) {
    const sanitizedMessage = this.sanitizeForUI(notification);
    const uiTypeResult = this.mapLevelToUIType(notification.level);
    if (!uiTypeResult.ok) {
      return err({
        code: "MAPPING_FAILED",
        message: uiTypeResult.error,
        channelName: this.name
      });
    }
    const result = this.platformUI.notify(sanitizedMessage, uiTypeResult.value);
    if (!result.ok) {
      return err({
        code: "UI_NOTIFICATION_FAILED",
        message: result.error.message,
        channelName: this.name,
        details: result.error
      });
    }
    return ok(void 0);
  }
  notify(message2, type) {
    const result = this.platformUI.notify(message2, type);
    if (!result.ok) {
      return err({
        code: "UI_NOTIFICATION_FAILED",
        message: result.error.message,
        channelName: this.name,
        details: result.error
      });
    }
    return ok(void 0);
  }
  /**
   * Sanitizes notification message for UI display.
   *
   * Development: Shows detailed messages
   * Production: Shows generic messages to prevent information leakage
   */
  sanitizeForUI(notification) {
    const { level, context, data, error } = notification;
    if (this.config.get("isDevelopment")) {
      if (level === "error" && error) {
        return `${context}: ${error.message}`;
      }
      if (data && typeof data === "object" && "message" in data) {
        return `${context}: ${String(data.message)}`;
      }
      return context;
    }
    if (level === "error" && error) {
      return `${context}. Please try again or contact support. (Error: ${error.code})`;
    }
    return context;
  }
  /**
   * Maps notification level to UI notification type.
   * Protected to allow testing of exhaustive type check.
   */
  mapLevelToUIType(level) {
    switch (level) {
      case "info":
        return ok("info");
      case "warn":
        return ok("warning");
      case "error":
        return ok("error");
      case "debug": {
        return err(`Debug level should be filtered by canHandle(). Received: ${level}`);
      }
    }
  }
};
__name(_UIChannel, "UIChannel");
let UIChannel = _UIChannel;
const _DIUIChannel = class _DIUIChannel extends UIChannel {
  constructor(platformUI, config2) {
    super(platformUI, config2);
  }
};
__name(_DIUIChannel, "DIUIChannel");
_DIUIChannel.dependencies = [platformUINotificationPortToken, runtimeConfigToken];
let DIUIChannel = _DIUIChannel;
const _QueuedUIChannel = class _QueuedUIChannel {
  constructor(queue, uiAvailability, container) {
    this.queue = queue;
    this.uiAvailability = uiAvailability;
    this.container = container;
    this.name = "UIChannel";
    this.realChannel = null;
    this.hasFlushed = false;
  }
  /**
   * Gets or creates the real UIChannel.
   * Uses lazy initialization to avoid creating channel before UI is available.
   */
  getRealChannel() {
    if (this.realChannel) {
      return this.realChannel;
    }
    const channelResult = this.container.resolveWithError(uiChannelToken);
    if (!channelResult.ok) {
      return null;
    }
    this.realChannel = channelResult.value;
    return this.realChannel;
  }
  /**
   * Determines if this channel should handle the notification.
   * Delegates to real channel if available, otherwise uses same logic as UIChannel.
   */
  canHandle(notification) {
    if (notification.level === "debug") {
      return false;
    }
    const realChannel = this.getRealChannel();
    if (realChannel) {
      return realChannel.canHandle(notification);
    }
    return true;
  }
  /**
   * Sends notification to UI or queues it if UI is not available.
   */
  send(notification) {
    if (this.uiAvailability.isAvailable()) {
      if (!this.hasFlushed && this.queue.size > 0) {
        const realChannel2 = this.getRealChannel();
        if (realChannel2) {
          this.queue.flush((n) => {
            realChannel2.send(n);
          });
        }
        this.hasFlushed = true;
      }
      const realChannel = this.getRealChannel();
      if (!realChannel) {
        this.queue.enqueue(notification);
        return ok(void 0);
      }
      return realChannel.send(notification);
    }
    if (notification.level === "debug") {
      return ok(void 0);
    }
    this.queue.enqueue(notification);
    return ok(void 0);
  }
  /**
   * Sends notification directly to UI (bypasses queue).
   * Used for immediate notifications when UI is available.
   */
  notify(message2, type) {
    if (this.uiAvailability.isAvailable()) {
      const realChannel = this.getRealChannel();
      if (!realChannel) {
        return err({
          code: "CHANNEL_NOT_AVAILABLE",
          message: "UIChannel could not be resolved",
          channelName: this.name
        });
      }
      return realChannel.notify(message2, type);
    }
    return err({
      code: "UI_NOT_AVAILABLE",
      message: "UI is not available for immediate notifications",
      channelName: this.name
    });
  }
};
__name(_QueuedUIChannel, "QueuedUIChannel");
let QueuedUIChannel = _QueuedUIChannel;
const _DIQueuedUIChannel = class _DIQueuedUIChannel extends QueuedUIChannel {
  constructor(queue, uiAvailability, container) {
    super(queue, uiAvailability, container);
  }
};
__name(_DIQueuedUIChannel, "DIQueuedUIChannel");
_DIQueuedUIChannel.dependencies = [
  notificationQueueToken,
  platformUIAvailabilityPortToken,
  platformContainerPortToken
];
let DIQueuedUIChannel = _DIQueuedUIChannel;
const _NotificationPortAdapter = class _NotificationPortAdapter {
  constructor(notificationCenter) {
    this.notificationCenter = notificationCenter;
  }
  debug(context, data, options) {
    const centerOptions = this.mapToCenterOptions(options);
    const result = this.notificationCenter.debug(context, data, centerOptions);
    return this.mapResult(result);
  }
  info(context, data, options) {
    const centerOptions = this.mapToCenterOptions(options);
    const result = this.notificationCenter.info(context, data, centerOptions);
    return this.mapResult(result);
  }
  warn(context, data, options) {
    const centerOptions = this.mapToCenterOptions(options);
    const result = this.notificationCenter.warn(context, data, centerOptions);
    return this.mapResult(result);
  }
  error(context, error, options) {
    const centerOptions = this.mapToCenterOptions(options);
    const result = this.notificationCenter.error(context, error, centerOptions);
    return this.mapResult(result);
  }
  addChannel(_channelName) {
    return err({
      code: "OPERATION_NOT_SUPPORTED",
      message: "Dynamic channel addition via name not supported. Use NotificationCenter.addChannel() directly.",
      operation: "addChannel"
    });
  }
  removeChannel(channelName) {
    const removed = this.notificationCenter.removeChannel(channelName);
    return ok(removed);
  }
  getChannelNames() {
    const names = this.notificationCenter.getChannelNames();
    return ok(names);
  }
  // ===== Private Helpers =====
  /**
   * Maps platform-agnostic options to NotificationCenter options.
   * Handles Foundry-specific options via type guard if present.
   */
  mapToCenterOptions(options) {
    if (!options) return void 0;
    const centerOptions = {
      ...options.channels !== void 0 && { channels: options.channels },
      ...options.traceId !== void 0 && { traceId: options.traceId }
    };
    if (this.isFoundryNotificationOptions(options)) {
      const foundryOptions = {
        ...options.permanent !== void 0 && { permanent: options.permanent },
        ...options.console !== void 0 && { console: options.console },
        ...options.localize !== void 0 && { localize: options.localize },
        ...options.progress !== void 0 && { progress: options.progress },
        ...options.clean !== void 0 && { clean: options.clean },
        ...options.escape !== void 0 && { escape: options.escape },
        ...options.format !== void 0 && { format: options.format }
      };
      centerOptions.uiOptions = foundryOptions;
    }
    return centerOptions;
  }
  /**
   * Type guard to detect Foundry-specific notification options.
   * This allows adapters to pass Foundry options without exposing them in the domain interface.
   */
  isFoundryNotificationOptions(options) {
    return typeof options === "object" && options !== null && ("permanent" in options || "console" in options || "localize" in options || "progress" in options || "clean" in options || "escape" in options || "format" in options);
  }
  /**
   * Maps NotificationCenter Result to PlatformNotificationPort Result.
   */
  mapResult(result) {
    if (result.ok) {
      return ok(void 0);
    }
    return err({
      code: "NOTIFICATION_FAILED",
      message: result.error,
      operation: "notify"
    });
  }
};
__name(_NotificationPortAdapter, "NotificationPortAdapter");
let NotificationPortAdapter = _NotificationPortAdapter;
const _DINotificationPortAdapter = class _DINotificationPortAdapter extends NotificationPortAdapter {
  constructor(notificationCenter) {
    super(notificationCenter);
  }
};
__name(_DINotificationPortAdapter, "DINotificationPortAdapter");
_DINotificationPortAdapter.dependencies = [notificationCenterToken];
let DINotificationPortAdapter = _DINotificationPortAdapter;
const _NotificationQueue = class _NotificationQueue {
  constructor(runtimeConfig, env) {
    this.runtimeConfig = runtimeConfig;
    this.env = env;
    this.queue = [];
  }
  /**
   * Gets the maximum queue size from RuntimeConfig, with ENV fallback.
   */
  getMaxSize() {
    const value2 = this.runtimeConfig.get("notificationQueueMaxSize");
    return value2 ?? this.env.notificationQueueDefaultSize;
  }
  /**
   * Adds a notification to the queue.
   * If the queue is full, removes the oldest notification.
   */
  enqueue(notification) {
    const maxSize2 = this.getMaxSize();
    if (this.queue.length >= maxSize2) {
      this.queue.shift();
    }
    this.queue.push(notification);
  }
  /**
   * Flushes all queued notifications by calling the handler for each.
   * Queue is cleared after flushing.
   */
  flush(handler) {
    for (const notification of this.queue) {
      try {
        handler(notification);
      } catch (_error) {
      }
    }
    this.queue.length = 0;
  }
  /**
   * Clears all queued notifications without processing them.
   */
  clear() {
    this.queue.length = 0;
  }
  /**
   * Gets the current number of queued notifications.
   */
  get size() {
    return this.queue.length;
  }
};
__name(_NotificationQueue, "NotificationQueue");
let NotificationQueue = _NotificationQueue;
const _DINotificationQueue = class _DINotificationQueue extends NotificationQueue {
  constructor(runtimeConfig, env) {
    super(runtimeConfig, env);
  }
};
__name(_DINotificationQueue, "DINotificationQueue");
_DINotificationQueue.dependencies = [runtimeConfigToken, environmentConfigToken];
let DINotificationQueue = _DINotificationQueue;
const _FoundryUIAvailabilityPort = class _FoundryUIAvailabilityPort {
  /**
   * Checks if Foundry UI is available.
   * UI is available when `ui` is defined and `ui.notifications` exists.
   */
  isAvailable() {
    return typeof ui !== "undefined" && ui?.notifications !== void 0;
  }
  /**
   * Optional callback registration for when UI becomes available.
   * Not implemented for now - can be extended with event-based approach later.
   */
  onAvailable(_callback) {
  }
};
__name(_FoundryUIAvailabilityPort, "FoundryUIAvailabilityPort");
let FoundryUIAvailabilityPort = _FoundryUIAvailabilityPort;
const _DIFoundryUIAvailabilityPort = class _DIFoundryUIAvailabilityPort extends FoundryUIAvailabilityPort {
  constructor() {
    super();
  }
};
__name(_DIFoundryUIAvailabilityPort, "DIFoundryUIAvailabilityPort");
_DIFoundryUIAvailabilityPort.dependencies = [];
let DIFoundryUIAvailabilityPort = _DIFoundryUIAvailabilityPort;
function registerNotifications(container) {
  const notificationQueueResult = container.registerClass(
    notificationQueueToken,
    DINotificationQueue,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationQueueResult)) {
    return err(`Failed to register NotificationQueue: ${notificationQueueResult.error.message}`);
  }
  const uiAvailabilityResult = container.registerClass(
    platformUIAvailabilityPortToken,
    DIFoundryUIAvailabilityPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiAvailabilityResult)) {
    return err(
      `Failed to register PlatformUIAvailabilityPort: ${uiAvailabilityResult.error.message}`
    );
  }
  const consoleChannelResult = container.registerClass(
    consoleChannelToken,
    DIConsoleChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(consoleChannelResult)) {
    return err(`Failed to register ConsoleChannel: ${consoleChannelResult.error.message}`);
  }
  const uiChannelResult = container.registerClass(
    uiChannelToken,
    DIUIChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiChannelResult)) {
    return err(`Failed to register UIChannel: ${uiChannelResult.error.message}`);
  }
  const queuedUIChannelResult = container.registerClass(
    queuedUIChannelToken,
    DIQueuedUIChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(queuedUIChannelResult)) {
    return err(`Failed to register QueuedUIChannel: ${queuedUIChannelResult.error.message}`);
  }
  const notificationCenterResult = container.registerClass(
    notificationCenterToken,
    DINotificationCenter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationCenterResult)) {
    return err(`Failed to register NotificationCenter: ${notificationCenterResult.error.message}`);
  }
  const notificationPortResult = container.registerClass(
    platformNotificationPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationPortResult)) {
    return err(
      `Failed to register PlatformNotificationPort: ${notificationPortResult.error.message}`
    );
  }
  const publisherPortResult = container.registerClass(
    notificationPublisherPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(publisherPortResult)) {
    return err(
      `Failed to register NotificationPublisherPort: ${publisherPortResult.error.message}`
    );
  }
  const channelRegistryPortResult = container.registerClass(
    notificationChannelRegistryPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(channelRegistryPortResult)) {
    return err(
      `Failed to register NotificationChannelRegistryPort: ${channelRegistryPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerNotifications, "registerNotifications");
registerDependencyStep({
  name: "Notifications",
  priority: 130,
  execute: registerNotifications
});
const _ModuleSettingsRegistrar = class _ModuleSettingsRegistrar {
  constructor(settings, runtimeConfigSettingsSync, errorMapper, notifications, i18n, logger, validator, settingDefinitionRegistry, runtimeConfigBindingRegistry) {
    this.settings = settings;
    this.runtimeConfigSettingsSync = runtimeConfigSettingsSync;
    this.errorMapper = errorMapper;
    this.notifications = notifications;
    this.i18n = i18n;
    this.logger = logger;
    this.validator = validator;
    this.settingDefinitionRegistry = settingDefinitionRegistry;
    this.runtimeConfigBindingRegistry = runtimeConfigBindingRegistry;
  }
  /**
   * Registers all module settings.
   * Must be called during or after the 'init' hook.
   *
   * Iterates over settings from SettingDefinitionRegistry and applies
   * corresponding bindings from RuntimeConfigBindingRegistry.
   *
   * Implements Open/Closed Principle: New settings can be added via registry
   * extension without modifying this method.
   */
  registerAll() {
    const definitions = this.settingDefinitionRegistry.getAll();
    const bindings = this.runtimeConfigBindingRegistry.getAll();
    for (const definition of definitions) {
      const binding = bindings.get(definition.key);
      this.registerDefinition(
        definition,
        binding,
        this.settings,
        this.runtimeConfigSettingsSync,
        this.errorMapper,
        this.i18n,
        this.logger,
        this.validator
      );
    }
  }
  registerDefinition(definition, binding, settings, runtimeConfigSettingsSync, errorMapper, i18n, logger, validator) {
    const config2 = definition.createConfig(i18n, logger, validator);
    const configWithRuntimeBridge = binding ? runtimeConfigSettingsSync.attachBinding(config2, binding) : config2;
    const result = settings.registerSetting(
      MODULE_METADATA.ID,
      definition.key,
      configWithRuntimeBridge
    );
    if (!result.ok) {
      errorMapper.mapAndNotify(result.error, definition.key);
      return;
    }
    if (binding) {
      runtimeConfigSettingsSync.syncInitialValue(settings, binding, definition.key);
    }
  }
};
__name(_ModuleSettingsRegistrar, "ModuleSettingsRegistrar");
let ModuleSettingsRegistrar = _ModuleSettingsRegistrar;
const _DIModuleSettingsRegistrar = class _DIModuleSettingsRegistrar extends ModuleSettingsRegistrar {
  constructor(settings, runtimeConfigSettingsSync, errorMapper, notifications, i18n, logger, validator, settingDefinitionRegistry, runtimeConfigBindingRegistry) {
    super(
      settings,
      runtimeConfigSettingsSync,
      errorMapper,
      notifications,
      i18n,
      logger,
      validator,
      settingDefinitionRegistry,
      runtimeConfigBindingRegistry
    );
  }
};
__name(_DIModuleSettingsRegistrar, "DIModuleSettingsRegistrar");
_DIModuleSettingsRegistrar.dependencies = [
  platformSettingsRegistrationPortToken,
  runtimeConfigSettingsSyncToken,
  settingRegistrationErrorMapperToken,
  notificationPublisherPortToken,
  platformI18nPortToken,
  platformLoggingPortToken,
  platformValidationPortToken,
  settingDefinitionRegistryToken,
  runtimeConfigBindingRegistryToken
];
let DIModuleSettingsRegistrar = _DIModuleSettingsRegistrar;
const _RuntimeConfigSync = class _RuntimeConfigSync {
  constructor(runtimeConfig, notifications) {
    this.runtimeConfig = runtimeConfig;
    this.notifications = notifications;
  }
  /**
   * Bindet RuntimeConfig-Synchronisation an ein Setting.
   *
   * Wraps the original onChange callback and adds RuntimeConfig synchronization.
   *
   * @param config - The Setting configuration
   * @param binding - Binding configuration for RuntimeConfig sync
   * @returns Modified config with RuntimeConfig bridge attached
   */
  attachBinding(config2, binding) {
    const originalOnChange = config2.onChange;
    return {
      ...config2,
      onChange: /* @__PURE__ */ __name((value2) => {
        const normalized = binding.normalize(value2);
        this.runtimeConfig.setFromPlatform(binding.runtimeKey, normalized);
        originalOnChange?.(value2);
      }, "onChange")
    };
  }
  /**
   * Synchronisiert initialen Setting-Wert zu RuntimeConfig.
   *
   * Reads the current Setting value and updates RuntimeConfig accordingly.
   *
   * @param settings - Settings port for reading values
   * @param binding - Binding configuration for RuntimeConfig sync
   * @param settingKey - The Setting key to read
   */
  syncInitialValue(settings, binding, settingKey) {
    const currentValue = settings.getSettingValue(
      MODULE_METADATA.ID,
      settingKey,
      binding.validator
    );
    if (!currentValue.ok) {
      this.notifications.warn(
        `Failed to read initial value for ${settingKey}`,
        currentValue.error,
        {
          channels: ["ConsoleChannel"]
        }
      );
      return;
    }
    this.runtimeConfig.setFromPlatform(binding.runtimeKey, binding.normalize(currentValue.value));
  }
};
__name(_RuntimeConfigSync, "RuntimeConfigSync");
let RuntimeConfigSync = _RuntimeConfigSync;
const _DIRuntimeConfigSync = class _DIRuntimeConfigSync extends RuntimeConfigSync {
  constructor(runtimeConfig, notifications) {
    super(runtimeConfig, notifications);
  }
};
__name(_DIRuntimeConfigSync, "DIRuntimeConfigSync");
_DIRuntimeConfigSync.dependencies = [runtimeConfigToken, notificationPublisherPortToken];
let DIRuntimeConfigSync = _DIRuntimeConfigSync;
const _RuntimeConfigSettingsSync = class _RuntimeConfigSettingsSync {
  constructor(runtimeConfigSync) {
    this.runtimeConfigSync = runtimeConfigSync;
  }
  /**
   * Attaches RuntimeConfig synchronization binding to a setting configuration.
   *
   * Delegates to RuntimeConfigSync.attachBinding().
   *
   * @param config - The Setting configuration
   * @param binding - Binding configuration for RuntimeConfig sync
   * @returns Modified config with RuntimeConfig bridge attached
   */
  attachBinding(config2, binding) {
    return this.runtimeConfigSync.attachBinding(config2, binding);
  }
  /**
   * Synchronizes initial Setting value to RuntimeConfig.
   *
   * Delegates to RuntimeConfigSync.syncInitialValue().
   *
   * @param settings - Settings port for reading values
   * @param binding - Binding configuration for RuntimeConfig sync
   * @param settingKey - The Setting key to read
   */
  syncInitialValue(settings, binding, settingKey) {
    this.runtimeConfigSync.syncInitialValue(settings, binding, settingKey);
  }
};
__name(_RuntimeConfigSettingsSync, "RuntimeConfigSettingsSync");
let RuntimeConfigSettingsSync = _RuntimeConfigSettingsSync;
const _DIRuntimeConfigSettingsSync = class _DIRuntimeConfigSettingsSync extends RuntimeConfigSettingsSync {
  constructor(runtimeConfigSync) {
    super(runtimeConfigSync);
  }
};
__name(_DIRuntimeConfigSettingsSync, "DIRuntimeConfigSettingsSync");
_DIRuntimeConfigSettingsSync.dependencies = [runtimeConfigSyncToken];
let DIRuntimeConfigSettingsSync = _DIRuntimeConfigSettingsSync;
const _SettingRegistrationErrorMapper = class _SettingRegistrationErrorMapper {
  constructor(notifications) {
    this.notifications = notifications;
  }
  mapAndNotify(error, settingKey) {
    const notificationError = {
      code: error.code,
      message: error.message,
      ...error.details !== void 0 && { details: error.details }
    };
    this.notifications.error(`Failed to register ${settingKey} setting`, notificationError, {
      channels: ["ConsoleChannel"]
    });
  }
};
__name(_SettingRegistrationErrorMapper, "SettingRegistrationErrorMapper");
let SettingRegistrationErrorMapper = _SettingRegistrationErrorMapper;
const _DISettingRegistrationErrorMapper = class _DISettingRegistrationErrorMapper extends SettingRegistrationErrorMapper {
  constructor(notifications) {
    super(notifications);
  }
};
__name(_DISettingRegistrationErrorMapper, "DISettingRegistrationErrorMapper");
_DISettingRegistrationErrorMapper.dependencies = [notificationPublisherPortToken];
let DISettingRegistrationErrorMapper = _DISettingRegistrationErrorMapper;
function castSettingDefinitionToUnknown(definition) {
  return definition;
}
__name(castSettingDefinitionToUnknown, "castSettingDefinitionToUnknown");
function castBindingToUnknown(binding) {
  return binding;
}
__name(castBindingToUnknown, "castBindingToUnknown");
function validateAndSetLogLevel(value2, logger, validator) {
  const validationResult = validator.validateLogLevel(value2);
  if (!validationResult.ok) {
    logger.warn(`Invalid log level value received: ${value2}, using default INFO`);
    if (logger.setMinLevel) {
      logger.setMinLevel(LogLevel.INFO);
    }
    return;
  }
  if (logger.setMinLevel) {
    logger.setMinLevel(validationResult.value);
    logger.info(`Log level changed to: ${LogLevel[validationResult.value]}`);
  }
}
__name(validateAndSetLogLevel, "validateAndSetLogLevel");
const logLevelSetting = {
  key: SETTING_KEYS.LOG_LEVEL,
  createConfig(i18n, logger, validator) {
    return {
      name: unwrapOr(i18n.translate("MODULE.SETTINGS.logLevel.name", "Log Level"), "Log Level"),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.logLevel.hint",
          "Minimum log level for module output. DEBUG shows all logs, ERROR only critical errors."
        ),
        "Minimum log level for module output. DEBUG shows all logs, ERROR only critical errors."
      ),
      scope: "world",
      config: true,
      type: Number,
      choices: {
        [LogLevel.DEBUG]: unwrapOr(
          i18n.translate(
            "MODULE.SETTINGS.logLevel.choices.debug",
            "DEBUG (All logs - for debugging)"
          ),
          "DEBUG (All logs - for debugging)"
        ),
        [LogLevel.INFO]: unwrapOr(
          i18n.translate("MODULE.SETTINGS.logLevel.choices.info", "INFO (Standard)"),
          "INFO (Standard)"
        ),
        [LogLevel.WARN]: unwrapOr(
          i18n.translate(
            "MODULE.SETTINGS.logLevel.choices.warn",
            "WARN (Warnings and errors only)"
          ),
          "WARN (Warnings and errors only)"
        ),
        [LogLevel.ERROR]: unwrapOr(
          i18n.translate("MODULE.SETTINGS.logLevel.choices.error", "ERROR (Critical errors only)"),
          "ERROR (Critical errors only)"
        )
      },
      default: LogLevel.INFO,
      onChange: /* @__PURE__ */ __name((value2) => {
        validateAndSetLogLevel(value2, logger, validator);
      }, "onChange")
    };
  }
};
const cacheEnabledSetting = {
  key: SETTING_KEYS.CACHE_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheEnabled.name", "Enable Cache Service"),
        "Enable Cache Service"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheEnabled.hint",
          "Toggle the global CacheService. When disabled, all cache interactions bypass the cache layer."
        ),
        "Toggle the global CacheService. When disabled, all cache interactions bypass the cache layer."
      ),
      scope: "world",
      config: true,
      type: Boolean,
      default: true,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`CacheService ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const cacheDefaultTtlSetting = {
  key: SETTING_KEYS.CACHE_TTL_MS,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheDefaultTtlMs.name", "Cache TTL (ms)"),
        "Cache TTL (ms)"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheDefaultTtlMs.hint",
          "Default lifetime for cache entries in milliseconds. Use 0 to disable TTL (entries live until invalidated)."
        ),
        "Default lifetime for cache entries in milliseconds. Use 0 to disable TTL (entries live until invalidated)."
      ),
      scope: "world",
      config: true,
      type: Number,
      default: APP_DEFAULTS.CACHE_TTL_MS,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const sanitized = Number.isFinite(numericValue) && numericValue >= 0 ? numericValue : 0;
        logger.info(`Cache TTL updated via settings: ${sanitized}ms`);
      }, "onChange")
    };
  }
};
const cacheMaxEntriesSetting = {
  key: SETTING_KEYS.CACHE_MAX_ENTRIES,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheMaxEntries.name", "Cache Max Entries"),
        "Cache Max Entries"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheMaxEntries.hint",
          "Optional LRU limit. Use 0 to allow unlimited cache entries."
        ),
        "Optional LRU limit. Use 0 to allow unlimited cache entries."
      ),
      scope: "world",
      config: true,
      type: Number,
      default: 0,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const sanitized = Number.isFinite(numericValue) && numericValue > 0 ? Math.floor(numericValue) : 0;
        if (sanitized === 0) {
          logger.info("Cache max entries reset to unlimited via settings.");
        } else {
          logger.info(`Cache max entries updated via settings: ${sanitized}`);
        }
      }, "onChange")
    };
  }
};
const performanceTrackingSetting = {
  key: SETTING_KEYS.PERFORMANCE_TRACKING_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.performanceTracking.name", "Performance Tracking"),
        "Performance Tracking"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.performanceTracking.hint",
          "Enables internal performance instrumentation (requires sampling)."
        ),
        "Enables internal performance instrumentation (requires sampling)."
      ),
      scope: "world",
      config: true,
      type: Boolean,
      default: false,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`Performance tracking ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const performanceSamplingSetting = {
  key: SETTING_KEYS.PERFORMANCE_SAMPLING_RATE,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.performanceSamplingRate.name", "Performance Sampling Rate"),
        "Performance Sampling Rate"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.performanceSamplingRate.hint",
          "Fraction of operations to instrument (0 = 0%, 1 = 100%)."
        ),
        "Fraction of operations to instrument (0 = 0%, 1 = 100%)."
      ),
      scope: "world",
      config: true,
      type: Number,
      default: 1,
      onChange: /* @__PURE__ */ __name((value2) => {
        const clamped = Math.max(0, Math.min(1, Number(value2) || 0));
        logger.info(
          `Performance sampling rate updated via settings: ${(clamped * 100).toFixed(1)}%`
        );
      }, "onChange")
    };
  }
};
const metricsPersistenceEnabledSetting = {
  key: SETTING_KEYS.METRICS_PERSISTENCE_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.metricsPersistenceEnabled.name", "Persist Metrics"),
        "Persist Metrics"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.metricsPersistenceEnabled.hint",
          "Keeps observability metrics across Foundry restarts (uses LocalStorage)."
        ),
        "Keeps observability metrics across Foundry restarts (uses LocalStorage)."
      ),
      scope: "world",
      config: true,
      type: Boolean,
      default: false,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`Metrics persistence ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const metricsPersistenceKeySetting = {
  key: SETTING_KEYS.METRICS_PERSISTENCE_KEY,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.metricsPersistenceKey.name", "Metrics Storage Key"),
        "Metrics Storage Key"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.metricsPersistenceKey.hint",
          "LocalStorage key used when metrics persistence is enabled."
        ),
        "LocalStorage key used when metrics persistence is enabled."
      ),
      scope: "world",
      config: true,
      type: String,
      default: `${MODULE_METADATA.ID}.metrics`,
      onChange: /* @__PURE__ */ __name((value2) => {
        logger.info(`Metrics persistence key set to: ${value2 || "(empty)"}`);
      }, "onChange")
    };
  }
};
const NOTIFICATION_QUEUE_CONSTANTS = {
  minSize: 10,
  maxSize: 1e3,
  defaultSize: 50
};
function getNotificationQueueConstants() {
  return NOTIFICATION_QUEUE_CONSTANTS;
}
__name(getNotificationQueueConstants, "getNotificationQueueConstants");
const notificationQueueMaxSizeSetting = {
  key: SETTING_KEYS.NOTIFICATION_QUEUE_MAX_SIZE,
  createConfig(i18n, logger, _validator) {
    const constants = getNotificationQueueConstants();
    return {
      name: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.notificationQueueMaxSize.name",
          "Notification Queue Max Size"
        ),
        "Notification Queue Max Size"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.notificationQueueMaxSize.hint",
          `Maximum number of notifications queued before UI is available. Range: ${constants.minSize}-${constants.maxSize}.`
        ),
        `Maximum number of notifications queued before UI is available. Range: ${constants.minSize}-${constants.maxSize}.`
      ),
      scope: "world",
      config: true,
      type: Number,
      default: constants.defaultSize,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const clamped = Math.max(
          constants.minSize,
          Math.min(constants.maxSize, Math.floor(numericValue))
        );
        if (clamped !== numericValue) {
          logger.info(
            `Notification queue max size clamped from ${numericValue} to ${clamped} (range: ${constants.minSize}-${constants.maxSize})`
          );
        } else {
          logger.info(`Notification queue max size updated via settings: ${clamped}`);
        }
      }, "onChange")
    };
  }
};
const _DefaultSettingDefinitionRegistry = class _DefaultSettingDefinitionRegistry {
  getAll() {
    return [
      castSettingDefinitionToUnknown(logLevelSetting),
      castSettingDefinitionToUnknown(cacheEnabledSetting),
      castSettingDefinitionToUnknown(cacheDefaultTtlSetting),
      castSettingDefinitionToUnknown(cacheMaxEntriesSetting),
      castSettingDefinitionToUnknown(performanceTrackingSetting),
      castSettingDefinitionToUnknown(performanceSamplingSetting),
      castSettingDefinitionToUnknown(metricsPersistenceEnabledSetting),
      castSettingDefinitionToUnknown(metricsPersistenceKeySetting),
      castSettingDefinitionToUnknown(notificationQueueMaxSizeSetting)
    ];
  }
};
__name(_DefaultSettingDefinitionRegistry, "DefaultSettingDefinitionRegistry");
let DefaultSettingDefinitionRegistry = _DefaultSettingDefinitionRegistry;
function createSettingValidators() {
  const customValidators = /* @__PURE__ */ new Map();
  const standardValidators = {
    /**
     * Validates that value is a boolean.
     */
    boolean: /* @__PURE__ */ __name((value2) => typeof value2 === "boolean", "boolean"),
    /**
     * Validates that value is a number.
     */
    number: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2), "number"),
    /**
     * Validates that value is a non-negative number.
     */
    nonNegativeNumber: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2) && value2 >= 0, "nonNegativeNumber"),
    /**
     * Validates that value is a non-negative integer.
     */
    nonNegativeInteger: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && Number.isInteger(value2) && value2 >= 0, "nonNegativeInteger"),
    /**
     * Validates that value is a positive integer (greater than 0).
     */
    positiveInteger: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && Number.isInteger(value2) && value2 > 0, "positiveInteger"),
    /**
     * Validates that value is a string.
     */
    string: /* @__PURE__ */ __name((value2) => typeof value2 === "string", "string"),
    /**
     * Validates that value is a non-empty string.
     */
    nonEmptyString: /* @__PURE__ */ __name((value2) => typeof value2 === "string" && value2.length > 0, "nonEmptyString"),
    /**
     * Validates that value is a number between 0 and 1 (inclusive).
     */
    samplingRate: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2) && value2 >= 0 && value2 <= 1, "samplingRate"),
    /**
     * Creates a validator for enum values.
     */
    oneOf: /* @__PURE__ */ __name((validValues) => {
      return (value2) => (typeof value2 === "string" || typeof value2 === "number") && validValues.includes(value2);
    }, "oneOf")
  };
  const registry = {
    register(name, validator) {
      if (name in standardValidators) {
        throw new Error(
          `Cannot override built-in validator: ${name}. Use a different name for your custom validator.`
        );
      }
      if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
        throw new Error(`Invalid validator name: ${name}. Must be a valid JavaScript identifier.`);
      }
      customValidators.set(name, validator);
    },
    get(name) {
      const standard = standardValidators[name];
      if (standard) {
        return standard;
      }
      return customValidators.get(name);
    },
    has(name) {
      return name in standardValidators || customValidators.has(name);
    }
  };
  return new Proxy({ ...standardValidators, ...registry }, {
    get(target, prop2) {
      if (typeof prop2 === "symbol") {
        return target[prop2];
      }
      if (prop2 in standardValidators) {
        return standardValidators[prop2];
      }
      if (prop2 in registry) {
        return registry[prop2];
      }
      const custom2 = customValidators.get(prop2);
      if (custom2) {
        return custom2;
      }
      return target[prop2];
    }
  });
}
__name(createSettingValidators, "createSettingValidators");
const SettingValidators = createSettingValidators();
const isLogLevel = /* @__PURE__ */ __name((value2) => typeof value2 === "number" && value2 >= 0 && value2 <= 3, "isLogLevel");
const runtimeConfigBindings = {
  [SETTING_KEYS.LOG_LEVEL]: {
    runtimeKey: "logLevel",
    validator: isLogLevel,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_ENABLED]: {
    runtimeKey: "enableCacheService",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_TTL_MS]: {
    runtimeKey: "cacheDefaultTtlMs",
    validator: SettingValidators.nonNegativeNumber,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_MAX_ENTRIES]: {
    runtimeKey: "cacheMaxEntries",
    validator: SettingValidators.nonNegativeInteger,
    normalize: /* @__PURE__ */ __name((value2) => value2 > 0 ? value2 : void 0, "normalize")
  },
  [SETTING_KEYS.PERFORMANCE_TRACKING_ENABLED]: {
    runtimeKey: "enablePerformanceTracking",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.PERFORMANCE_SAMPLING_RATE]: {
    runtimeKey: "performanceSamplingRate",
    validator: SettingValidators.samplingRate,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.METRICS_PERSISTENCE_ENABLED]: {
    runtimeKey: "enableMetricsPersistence",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.METRICS_PERSISTENCE_KEY]: {
    runtimeKey: "metricsPersistenceKey",
    validator: SettingValidators.nonEmptyString,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.NOTIFICATION_QUEUE_MAX_SIZE]: {
    runtimeKey: "notificationQueueMaxSize",
    validator: SettingValidators.positiveInteger,
    normalize: /* @__PURE__ */ __name((value2) => {
      const constants = getNotificationQueueConstants();
      return Math.max(constants.minSize, Math.min(constants.maxSize, Math.floor(value2)));
    }, "normalize")
  }
};
const _DefaultRuntimeConfigBindingRegistry = class _DefaultRuntimeConfigBindingRegistry {
  getAll() {
    const map2 = /* @__PURE__ */ new Map();
    Object.entries(runtimeConfigBindings).forEach(([key2, binding]) => {
      map2.set(key2, castBindingToUnknown(binding));
    });
    return map2;
  }
};
__name(_DefaultRuntimeConfigBindingRegistry, "DefaultRuntimeConfigBindingRegistry");
let DefaultRuntimeConfigBindingRegistry = _DefaultRuntimeConfigBindingRegistry;
function registerRegistrars(container) {
  const runtimeConfigSyncResult = container.registerClass(
    runtimeConfigSyncToken,
    DIRuntimeConfigSync,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigSyncResult)) {
    return err(`Failed to register RuntimeConfigSync: ${runtimeConfigSyncResult.error.message}`);
  }
  const runtimeConfigSettingsSyncResult = container.registerClass(
    runtimeConfigSettingsSyncToken,
    DIRuntimeConfigSettingsSync,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigSettingsSyncResult)) {
    return err(
      `Failed to register RuntimeConfigSettingsSync: ${runtimeConfigSettingsSyncResult.error.message}`
    );
  }
  const errorMapperResult = container.registerClass(
    settingRegistrationErrorMapperToken,
    DISettingRegistrationErrorMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(errorMapperResult)) {
    return err(
      `Failed to register SettingRegistrationErrorMapper: ${errorMapperResult.error.message}`
    );
  }
  const settingDefinitionRegistryResult = container.registerClass(
    settingDefinitionRegistryToken,
    DefaultSettingDefinitionRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingDefinitionRegistryResult)) {
    return err(
      `Failed to register SettingDefinitionRegistry: ${settingDefinitionRegistryResult.error.message}`
    );
  }
  const runtimeConfigBindingRegistryResult = container.registerClass(
    runtimeConfigBindingRegistryToken,
    DefaultRuntimeConfigBindingRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigBindingRegistryResult)) {
    return err(
      `Failed to register RuntimeConfigBindingRegistry: ${runtimeConfigBindingRegistryResult.error.message}`
    );
  }
  const settingsRegistrarResult = container.registerClass(
    moduleSettingsRegistrarToken,
    DIModuleSettingsRegistrar,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsRegistrarResult)) {
    return err(
      `Failed to register ModuleSettingsRegistrar: ${settingsRegistrarResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerRegistrars, "registerRegistrars");
registerDependencyStep({
  name: "Registrars",
  priority: 150,
  execute: registerRegistrars
});
const _FoundryJournalEventAdapter = class _FoundryJournalEventAdapter {
  constructor(foundryHooksPort) {
    this.foundryHooksPort = foundryHooksPort;
    this.registrations = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  // ===== Specialized Journal Methods =====
  onJournalCreated(callback) {
    return this.registerFoundryHook(
      "createJournalEntry",
      // Foundry-spezifischer Hook-Name
      (...args2) => {
        const [foundryEntry] = args2;
        const event2 = {
          journalId: this.extractId(foundryEntry),
          timestamp: Date.now()
        };
        callback(event2);
      }
    );
  }
  onJournalUpdated(callback) {
    return this.registerFoundryHook(
      "updateJournalEntry",
      // Foundry-spezifisch
      (...args2) => {
        const [foundryEntry, changes] = args2;
        const event2 = {
          journalId: this.extractId(foundryEntry),
          changes: this.normalizeChanges(changes),
          timestamp: Date.now()
        };
        callback(event2);
      }
    );
  }
  onJournalDeleted(callback) {
    return this.registerFoundryHook("deleteJournalEntry", (...args2) => {
      const [foundryEntry] = args2;
      const event2 = {
        journalId: this.extractId(foundryEntry),
        timestamp: Date.now()
      };
      callback(event2);
    });
  }
  unregisterListener(registrationId) {
    const cleanup = this.registrations.get(registrationId);
    if (!cleanup) {
      return {
        ok: false,
        error: {
          code: "EVENT_UNREGISTRATION_FAILED",
          message: `No registration found for ID ${registrationId}`
        }
      };
    }
    cleanup();
    this.registrations.delete(registrationId);
    return { ok: true, value: void 0 };
  }
  // ===== Lifecycle =====
  /**
   * Cleanup all registered listeners.
   * Should be called during module shutdown.
   */
  dispose() {
    for (const cleanup of this.registrations.values()) {
      cleanup();
    }
    this.registrations.clear();
  }
  // ===== Private Helpers =====
  registerFoundryHook(hookName, callback) {
    const platformCallback = /* @__PURE__ */ __name((event2) => {
      function isArrayOfUnknown(value2) {
        return Array.isArray(value2);
      }
      __name(isArrayOfUnknown, "isArrayOfUnknown");
      if (isArrayOfUnknown(event2)) {
        let isValidArg = /* @__PURE__ */ __name(function(arg) {
          return arg !== null && arg !== void 0;
        }, "isValidArg");
        const validArgs = event2.filter(isValidArg);
        if (validArgs.length > 0) {
          callback(...validArgs);
        }
      } else {
        let isNotNullOrUndefined = /* @__PURE__ */ __name(function(value2) {
          return value2 !== null && value2 !== void 0;
        }, "isNotNullOrUndefined");
        if (isNotNullOrUndefined(event2)) {
          callback(event2);
        }
      }
    }, "platformCallback");
    const result = this.foundryHooksPort.registerListener(hookName, platformCallback);
    if (!result.ok) {
      return result;
    }
    const registrationId = result.value;
    this.registrations.set(registrationId, () => {
      this.foundryHooksPort.unregisterListener(registrationId);
    });
    return { ok: true, value: registrationId };
  }
  extractId(foundryEntry) {
    if (typeof foundryEntry === "object" && foundryEntry !== null && "id" in foundryEntry) {
      const entry = castToRecord(foundryEntry);
      if (typeof entry.id === "string") {
        return entry.id;
      }
    }
    return "";
  }
  normalizeChanges(foundryChanges) {
    if (!foundryChanges || typeof foundryChanges !== "object") {
      return {};
    }
    const changes = normalizeToRecord(foundryChanges);
    const result = { ...changes };
    if (changes.flags !== void 0 && typeof changes.flags === "object" && changes.flags !== null) {
      result.flags = normalizeToRecord(changes.flags);
    }
    if (changes.name !== void 0 && typeof changes.name === "string") {
      result.name = changes.name;
    }
    return result;
  }
};
__name(_FoundryJournalEventAdapter, "FoundryJournalEventAdapter");
let FoundryJournalEventAdapter = _FoundryJournalEventAdapter;
const _DIFoundryJournalEventAdapter = class _DIFoundryJournalEventAdapter extends FoundryJournalEventAdapter {
  constructor(foundryHooksPort) {
    super(foundryHooksPort);
  }
};
__name(_DIFoundryJournalEventAdapter, "DIFoundryJournalEventAdapter");
_DIFoundryJournalEventAdapter.dependencies = [foundryHooksToken];
let DIFoundryJournalEventAdapter = _DIFoundryJournalEventAdapter;
const _FoundryJournalUiEventAdapter = class _FoundryJournalUiEventAdapter {
  constructor(foundryHooksPort) {
    this.foundryHooksPort = foundryHooksPort;
    this.registrations = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  // ===== UI Event Methods =====
  onJournalDirectoryRendered(callback) {
    return this.registerFoundryHook("renderJournalDirectory", (app, html2) => {
      const directoryId = this.extractDirectoryId(app);
      if (!directoryId) {
        return;
      }
      const htmlElement = this.extractHtmlElement(html2);
      if (!htmlElement) {
        return;
      }
      const event2 = {
        directoryId,
        timestamp: Date.now()
      };
      callback(event2);
    });
  }
  // ===== Generic Methods (from PlatformEventPort) =====
  registerListener(eventType, callback) {
    return this.registerFoundryHook(eventType, (...args2) => {
      if (args2.length > 0 && typeof args2[0] === "object" && args2[0] !== null) {
        const candidate = args2[0];
        const event2 = this.toJournalUiEvent(candidate);
        if (event2) {
          callback(event2);
        }
      }
    });
  }
  /**
   * Type guard function to convert unknown to JournalUiEvent without type assertion.
   *
   * NOTE: This method is only called from registerListener, which already ensures
   * that candidate is an object and not null. The redundant check was removed
   * to achieve 100% code coverage.
   */
  toJournalUiEvent(candidate) {
    const record2 = castToRecord(candidate);
    if ("directoryId" in record2 && typeof record2.directoryId === "string") {
      return {
        directoryId: record2.directoryId,
        timestamp: typeof record2.timestamp === "number" ? record2.timestamp : Date.now()
      };
    }
    if ("journalId" in record2 && typeof record2.journalId === "string" && "options" in record2 && Array.isArray(record2.options)) {
      return {
        journalId: record2.journalId,
        // type-coverage:ignore-next-line - Fallback path for generic registerListener, not used in practice
        options: record2.options,
        timestamp: typeof record2.timestamp === "number" ? record2.timestamp : Date.now()
      };
    }
    return null;
  }
  unregisterListener(registrationId) {
    const cleanup = this.registrations.get(registrationId);
    if (!cleanup) {
      return {
        ok: false,
        error: {
          code: "EVENT_UNREGISTRATION_FAILED",
          message: `No registration found for ID ${registrationId}`
        }
      };
    }
    cleanup();
    this.registrations.delete(registrationId);
    return { ok: true, value: void 0 };
  }
  // ===== Lifecycle =====
  /**
   * Cleanup all registered listeners.
   * Should be called during module shutdown.
   */
  dispose() {
    for (const cleanup of this.registrations.values()) {
      cleanup();
    }
    this.registrations.clear();
  }
  // ===== Private Helpers =====
  registerFoundryHook(hookName, callback) {
    const platformCallback = /* @__PURE__ */ __name((event2) => {
      function isArrayOfUnknown(value2) {
        return Array.isArray(value2);
      }
      __name(isArrayOfUnknown, "isArrayOfUnknown");
      if (isArrayOfUnknown(event2)) {
        let isValidArg = /* @__PURE__ */ __name(function(arg) {
          return arg !== null && arg !== void 0;
        }, "isValidArg");
        const validArgs = event2.filter(isValidArg);
        if (validArgs.length > 0) {
          callback(...validArgs);
        }
      } else {
        let isNotNullOrUndefined = /* @__PURE__ */ __name(function(value2) {
          return value2 !== null && value2 !== void 0;
        }, "isNotNullOrUndefined");
        if (isNotNullOrUndefined(event2)) {
          callback(event2);
        }
      }
    }, "platformCallback");
    const result = this.foundryHooksPort.registerListener(hookName, platformCallback);
    if (!result.ok) {
      return result;
    }
    const registrationId = result.value;
    this.registrations.set(registrationId, () => {
      this.foundryHooksPort.unregisterListener(registrationId);
    });
    return { ok: true, value: registrationId };
  }
  extractDirectoryId(app) {
    if (typeof app === "object" && app !== null) {
      if ("id" in app && typeof app.id === "string") {
        return app.id;
      }
      if ("tabName" in app && typeof app.tabName === "string") {
        return app.tabName;
      }
    }
    return "journal";
  }
  extractHtmlElement(htmlInput) {
    if (htmlInput instanceof HTMLElement) return htmlInput;
    return getFirstElementIfArray(htmlInput, (el) => el instanceof HTMLElement);
  }
};
__name(_FoundryJournalUiEventAdapter, "FoundryJournalUiEventAdapter");
let FoundryJournalUiEventAdapter = _FoundryJournalUiEventAdapter;
const _DIFoundryJournalUiEventAdapter = class _DIFoundryJournalUiEventAdapter extends FoundryJournalUiEventAdapter {
  constructor(foundryHooksPort) {
    super(foundryHooksPort);
  }
};
__name(_DIFoundryJournalUiEventAdapter, "DIFoundryJournalUiEventAdapter");
_DIFoundryJournalUiEventAdapter.dependencies = [foundryHooksToken];
let DIFoundryJournalUiEventAdapter = _DIFoundryJournalUiEventAdapter;
const _InvalidateJournalCacheOnChangeUseCase = class _InvalidateJournalCacheOnChangeUseCase {
  constructor(journalEvents, cache, notifications) {
    this.journalEvents = journalEvents;
    this.cache = cache;
    this.notifications = notifications;
    this.registrationIds = [];
  }
  /**
   * Register event listeners for journal change events.
   */
  register() {
    const results = [
      this.journalEvents.onJournalCreated((event2) => {
        this.invalidateCache("created", event2.journalId);
      }),
      this.journalEvents.onJournalUpdated((event2) => {
        this.invalidateCache("updated", event2.journalId);
        if (event2.changes.flags?.["hidden"] !== void 0) {
          this.triggerUIUpdate(event2.journalId);
        }
      }),
      this.journalEvents.onJournalDeleted((event2) => {
        this.invalidateCache("deleted", event2.journalId);
      })
    ];
    const errors = [];
    for (const result of results) {
      if (result.ok) {
        this.registrationIds.push(result.value);
      } else {
        const error = new Error(
          `Failed to register journal event listener: ${result.error.message}`
        );
        errors.push(error);
        this.notifications.error(
          "Failed to register journal event listener",
          {
            code: result.error.code,
            message: result.error.message,
            details: result.error.details
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (errors.length > 0) {
      this.dispose();
      return err(getFirstArrayElement(errors));
    }
    return ok(void 0);
  }
  /**
   * Invalidate cache entries related to journals.
   */
  invalidateCache(reason, journalId) {
    const removed = this.cache.invalidateWhere((meta) => meta.tags.includes("journal:hidden"));
    if (removed > 0) {
      this.notifications.debug(
        `Invalidated ${removed} journal cache entries (${reason})`,
        { journalId },
        { channels: ["ConsoleChannel"] }
      );
    }
  }
  /**
   * Trigger UI update when journal visibility changes.
   */
  triggerUIUpdate(journalId) {
    this.notifications.debug(
      "Journal hidden flag changed, UI update needed",
      { journalId },
      { channels: ["ConsoleChannel"] }
    );
  }
  /**
   * Cleanup: Unregister all event listeners.
   */
  dispose() {
    for (const id of this.registrationIds) {
      this.journalEvents.unregisterListener(id);
    }
    this.registrationIds = [];
  }
};
__name(_InvalidateJournalCacheOnChangeUseCase, "InvalidateJournalCacheOnChangeUseCase");
let InvalidateJournalCacheOnChangeUseCase = _InvalidateJournalCacheOnChangeUseCase;
const _DIInvalidateJournalCacheOnChangeUseCase = class _DIInvalidateJournalCacheOnChangeUseCase extends InvalidateJournalCacheOnChangeUseCase {
  constructor(journalEvents, cache, notifications) {
    super(journalEvents, cache, notifications);
  }
};
__name(_DIInvalidateJournalCacheOnChangeUseCase, "DIInvalidateJournalCacheOnChangeUseCase");
_DIInvalidateJournalCacheOnChangeUseCase.dependencies = [
  platformJournalEventPortToken,
  cacheInvalidationPortToken,
  notificationPublisherPortToken
];
let DIInvalidateJournalCacheOnChangeUseCase = _DIInvalidateJournalCacheOnChangeUseCase;
const _ProcessJournalDirectoryOnRenderUseCase = class _ProcessJournalDirectoryOnRenderUseCase {
  constructor(journalUiEvents, journalDirectoryUI, journalVisibility, directoryProcessor, notifications) {
    this.journalUiEvents = journalUiEvents;
    this.journalDirectoryUI = journalDirectoryUI;
    this.journalVisibility = journalVisibility;
    this.directoryProcessor = directoryProcessor;
    this.notifications = notifications;
  }
  /**
   * Register event listener for directory render events.
   */
  register() {
    const result = this.journalUiEvents.onJournalDirectoryRendered((event2) => {
      this.notifications.debug(
        "Journal directory rendered, processing visibility",
        { timestamp: event2.timestamp, directoryId: event2.directoryId },
        { channels: ["ConsoleChannel"] }
      );
      const hiddenResult = this.journalVisibility.getHiddenJournalEntries();
      if (!hiddenResult.ok) {
        this.notifications.error("Failed to get hidden entries", hiddenResult.error, {
          channels: ["ConsoleChannel"]
        });
        return;
      }
      const processResult = this.directoryProcessor.processDirectory(
        event2.directoryId,
        hiddenResult.value
      );
      if (!processResult.ok) {
        this.notifications.error("Failed to process directory", processResult.error, {
          channels: ["ConsoleChannel"]
        });
      }
    });
    if (result.ok) {
      this.registrationId = result.value;
      return ok(void 0);
    } else {
      return err(new Error(result.error.message));
    }
  }
  /**
   * Cleanup: Unregister event listener.
   */
  dispose() {
    if (this.registrationId !== void 0) {
      this.journalUiEvents.unregisterListener(this.registrationId);
      this.registrationId = void 0;
    }
  }
};
__name(_ProcessJournalDirectoryOnRenderUseCase, "ProcessJournalDirectoryOnRenderUseCase");
let ProcessJournalDirectoryOnRenderUseCase = _ProcessJournalDirectoryOnRenderUseCase;
const _DIProcessJournalDirectoryOnRenderUseCase = class _DIProcessJournalDirectoryOnRenderUseCase extends ProcessJournalDirectoryOnRenderUseCase {
  constructor(journalUiEvents, journalDirectoryUI, journalVisibility, directoryProcessor, notifications) {
    super(
      journalUiEvents,
      journalDirectoryUI,
      journalVisibility,
      directoryProcessor,
      notifications
    );
  }
};
__name(_DIProcessJournalDirectoryOnRenderUseCase, "DIProcessJournalDirectoryOnRenderUseCase");
_DIProcessJournalDirectoryOnRenderUseCase.dependencies = [
  platformJournalUiEventPortToken,
  platformJournalDirectoryUiPortToken,
  journalVisibilityServiceToken,
  journalDirectoryProcessorToken,
  notificationPublisherPortToken
];
let DIProcessJournalDirectoryOnRenderUseCase = _DIProcessJournalDirectoryOnRenderUseCase;
const DOMAIN_FLAGS = {
  /** Flag key für versteckte Journal-Einträge */
  HIDDEN: "hidden"
};
const DOMAIN_EVENTS = {
  /** Event: Journal Directory wird gerendert */
  RENDER_JOURNAL_DIRECTORY: "renderJournalDirectory",
  /** Event: System-Initialisierung */
  INIT: "init",
  /** Event: System ist bereit */
  READY: "ready",
  /** Event: Journal Entry wird erstellt */
  CREATE_JOURNAL_ENTRY: "createJournalEntry",
  /** Event: Journal Entry wird aktualisiert */
  UPDATE_JOURNAL_ENTRY: "updateJournalEntry",
  /** Event: Journal Entry wird gelöscht */
  DELETE_JOURNAL_ENTRY: "deleteJournalEntry"
};
Object.freeze(DOMAIN_FLAGS);
Object.freeze(DOMAIN_EVENTS);
const _TriggerJournalDirectoryReRenderUseCase = class _TriggerJournalDirectoryReRenderUseCase {
  constructor(journalEvents, scheduler, notifications) {
    this.journalEvents = journalEvents;
    this.scheduler = scheduler;
    this.notifications = notifications;
  }
  /**
   * Register event listener for journal update events.
   */
  register() {
    const result = this.journalEvents.onJournalUpdated((event2) => {
      const moduleId = MODULE_METADATA.ID;
      const flagKey = DOMAIN_FLAGS.HIDDEN;
      const moduleFlags = event2.changes.flags?.[moduleId];
      if (moduleFlags && typeof moduleFlags === "object" && flagKey in moduleFlags) {
        this.scheduler.requestRerender();
      }
    });
    if (result.ok) {
      this.registrationId = result.value;
      return ok(void 0);
    } else {
      return err(new Error(result.error.message));
    }
  }
  /**
   * Cleanup: Unregister event listener.
   */
  dispose() {
    if (this.registrationId !== void 0) {
      this.journalEvents.unregisterListener(this.registrationId);
      this.registrationId = void 0;
    }
  }
};
__name(_TriggerJournalDirectoryReRenderUseCase, "TriggerJournalDirectoryReRenderUseCase");
let TriggerJournalDirectoryReRenderUseCase = _TriggerJournalDirectoryReRenderUseCase;
const _DITriggerJournalDirectoryReRenderUseCase = class _DITriggerJournalDirectoryReRenderUseCase extends TriggerJournalDirectoryReRenderUseCase {
  constructor(journalEvents, scheduler, notifications) {
    super(journalEvents, scheduler, notifications);
  }
};
__name(_DITriggerJournalDirectoryReRenderUseCase, "DITriggerJournalDirectoryReRenderUseCase");
_DITriggerJournalDirectoryReRenderUseCase.dependencies = [
  platformJournalEventPortToken,
  journalDirectoryRerenderSchedulerToken,
  notificationPublisherPortToken
];
let DITriggerJournalDirectoryReRenderUseCase = _DITriggerJournalDirectoryReRenderUseCase;
const _RegisterContextMenuUseCase = class _RegisterContextMenuUseCase {
  constructor(contextMenuRegistration, handlers2, logger) {
    this.contextMenuRegistration = contextMenuRegistration;
    this.handlers = handlers2;
    this.logger = logger;
  }
  /**
   * Register callback for context menu events.
   * All handlers are called for each context menu event.
   * Errors in individual handlers are caught and logged, but don't stop other handlers.
   */
  register() {
    this.callback = (event2) => {
      for (const handler of this.handlers) {
        try {
          handler.handle(event2);
        } catch (error) {
          const handlerError = error instanceof Error ? error : new Error(String(error));
          this.logger.warn(`Context menu handler failed: ${handlerError.message}`, {
            error: handlerError,
            handler: handler.constructor.name
          });
        }
      }
    };
    this.contextMenuRegistration.addCallback(this.callback);
    return ok(void 0);
  }
  /**
   * Cleanup: Unregister callback.
   */
  dispose() {
    if (this.callback !== void 0) {
      this.contextMenuRegistration.removeCallback(this.callback);
      this.callback = void 0;
    }
  }
};
__name(_RegisterContextMenuUseCase, "RegisterContextMenuUseCase");
let RegisterContextMenuUseCase = _RegisterContextMenuUseCase;
const _DIRegisterContextMenuUseCase = class _DIRegisterContextMenuUseCase extends RegisterContextMenuUseCase {
  constructor(contextMenuRegistration, handlers2, logger) {
    super(contextMenuRegistration, handlers2, logger);
  }
};
__name(_DIRegisterContextMenuUseCase, "DIRegisterContextMenuUseCase");
_DIRegisterContextMenuUseCase.dependencies = [
  platformContextMenuRegistrationPortToken,
  journalContextMenuHandlersToken,
  platformLoggingPortToken
];
let DIRegisterContextMenuUseCase = _DIRegisterContextMenuUseCase;
const _ShowAllHiddenJournalsUseCase = class _ShowAllHiddenJournalsUseCase {
  constructor(journalCollection, journalRepository, scheduler, notifications, config2) {
    this.journalCollection = journalCollection;
    this.journalRepository = journalRepository;
    this.scheduler = scheduler;
    this.notifications = notifications;
    this.config = config2;
  }
  /**
   * Execute the use-case: Show all hidden journals.
   *
   * @returns Result with number of journals that were unhidden, or error
   */
  async execute() {
    const allJournalsResult = this.journalCollection.getAll();
    if (!allJournalsResult.ok) {
      return err(new Error(`Failed to get all journals: ${allJournalsResult.error.message}`));
    }
    const allJournals = allJournalsResult.value;
    const journalsToUpdate = [];
    for (const journal of allJournals) {
      try {
        const flagResult = this.journalRepository.getFlag(
          journal.id,
          this.config.moduleNamespace,
          this.config.hiddenFlagKey
        );
        if (!flagResult.ok) {
          this.notifications.warn(
            `Failed to read hidden flag for journal "${journal.name ?? journal.id}"`,
            {
              errorCode: flagResult.error.code,
              errorMessage: flagResult.error.message,
              journalId: journal.id
            },
            { channels: ["ConsoleChannel"] }
          );
          continue;
        }
        const currentFlag = flagResult.value;
        if (currentFlag !== false) {
          journalsToUpdate.push({ journal, journalId: journal.id });
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.notifications.warn(
          `Unexpected error checking journal "${journal.name ?? journal.id}"`,
          {
            error: errorMessage,
            journalId: journal.id
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    let changedCount = 0;
    const errors = [];
    for (const { journal, journalId } of journalsToUpdate) {
      try {
        const setFlagResult = await this.journalRepository.setFlag(
          journalId,
          this.config.moduleNamespace,
          this.config.hiddenFlagKey,
          false
        );
        if (!setFlagResult.ok) {
          errors.push({
            journalId,
            error: `Failed to set flag: ${setFlagResult.error.message}`
          });
          this.notifications.warn(
            `Failed to set hidden flag for journal "${journal.name ?? journalId}"`,
            {
              errorCode: setFlagResult.error.code,
              errorMessage: setFlagResult.error.message,
              journalId
            },
            { channels: ["ConsoleChannel"] }
          );
          continue;
        }
        changedCount++;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        errors.push({
          journalId,
          error: errorMessage
        });
        this.notifications.warn(
          `Unexpected error processing journal "${journal.name ?? journalId}"`,
          {
            error: errorMessage,
            journalId
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (changedCount > 0) {
      this.notifications.info(
        `${changedCount} ${changedCount === 1 ? "Journal" : "Journale"} wieder eingeblendet`,
        {
          count: changedCount
        }
      );
    } else {
      this.notifications.info("Keine versteckten Journale gefunden", {});
    }
    if (errors.length > 0) {
      this.notifications.warn(
        `${errors.length} Fehler beim Verarbeiten von Journals`,
        {
          errorCount: errors.length,
          errors: errors.slice(0, 5)
          // Only show first 5 errors
        },
        { channels: ["ConsoleChannel"] }
      );
    }
    if (changedCount > 0) {
      this.scheduler.requestRerender();
    }
    return ok(changedCount);
  }
};
__name(_ShowAllHiddenJournalsUseCase, "ShowAllHiddenJournalsUseCase");
let ShowAllHiddenJournalsUseCase = _ShowAllHiddenJournalsUseCase;
const _DIShowAllHiddenJournalsUseCase = class _DIShowAllHiddenJournalsUseCase extends ShowAllHiddenJournalsUseCase {
  constructor(journalCollection, journalRepository, scheduler, notifications, config2) {
    super(journalCollection, journalRepository, scheduler, notifications, config2);
  }
};
__name(_DIShowAllHiddenJournalsUseCase, "DIShowAllHiddenJournalsUseCase");
_DIShowAllHiddenJournalsUseCase.dependencies = [
  platformJournalCollectionPortToken,
  platformJournalRepositoryToken,
  journalDirectoryRerenderSchedulerToken,
  notificationPublisherPortToken,
  journalVisibilityConfigToken
];
let DIShowAllHiddenJournalsUseCase = _DIShowAllHiddenJournalsUseCase;
const _HideJournalContextMenuHandler = class _HideJournalContextMenuHandler {
  constructor(journalRepository, platformUI, notifications) {
    this.journalRepository = journalRepository;
    this.platformUI = platformUI;
    this.notifications = notifications;
  }
  handle(event2) {
    const journalId = event2.journalId;
    if (!journalId) {
      return;
    }
    const flagResult = this.journalRepository.getFlag(
      journalId,
      MODULE_METADATA.ID,
      DOMAIN_FLAGS.HIDDEN
    );
    if (flagResult.ok && flagResult.value !== true) {
      const eventJournalId = journalId;
      event2.options.push({
        name: "Journal ausblenden",
        icon: '<i class="fas fa-eye-slash"></i>',
        callback: /* @__PURE__ */ __name(async (journalIdParam) => {
          if (journalIdParam !== eventJournalId) {
            this.notifications.error(
              `Journal ID mismatch in context menu callback: expected ${eventJournalId}, got ${journalIdParam}`,
              {
                code: "JOURNAL_ID_MISMATCH",
                message: `Expected journalId ${eventJournalId} but received ${journalIdParam}`,
                details: {
                  expectedJournalId: eventJournalId,
                  receivedJournalId: journalIdParam
                }
              },
              { channels: ["ConsoleChannel"] }
            );
            return;
          }
          const hideResult = await this.journalRepository.setFlag(
            journalIdParam,
            MODULE_METADATA.ID,
            DOMAIN_FLAGS.HIDDEN,
            true
          );
          if (hideResult.ok) {
            const journalEntryResult = this.journalRepository.getById(journalIdParam);
            const journalName = journalEntryResult.ok && journalEntryResult.value ? journalEntryResult.value.name ?? journalIdParam : journalIdParam;
            const notifyResult = this.platformUI.notify(
              `Journal "${journalName}" wurde ausgeblendet`,
              "info"
            );
            if (!notifyResult.ok) {
              this.notifications.warn(
                "Failed to show notification after hiding journal",
                notifyResult.error,
                { channels: ["ConsoleChannel"] }
              );
            }
            this.notifications.debug(
              `Journal ${journalIdParam} (${journalName}) hidden via context menu`,
              { journalId: journalIdParam, journalName },
              { channels: ["ConsoleChannel"] }
            );
          } else {
            this.notifications.error(
              `Failed to hide journal ${journalIdParam}`,
              { code: hideResult.error.code, message: hideResult.error.message },
              {
                channels: ["ConsoleChannel", "UINotificationChannel"]
              }
            );
          }
        }, "callback")
      });
    }
  }
};
__name(_HideJournalContextMenuHandler, "HideJournalContextMenuHandler");
let HideJournalContextMenuHandler = _HideJournalContextMenuHandler;
const _DIHideJournalContextMenuHandler = class _DIHideJournalContextMenuHandler extends HideJournalContextMenuHandler {
  constructor(journalRepository, platformUI, notifications) {
    super(journalRepository, platformUI, notifications);
  }
};
__name(_DIHideJournalContextMenuHandler, "DIHideJournalContextMenuHandler");
_DIHideJournalContextMenuHandler.dependencies = [
  platformJournalRepositoryToken,
  platformUIPortToken,
  notificationPublisherPortToken
];
let DIHideJournalContextMenuHandler = _DIHideJournalContextMenuHandler;
function disposeHooks(hooks) {
  for (const hook of hooks) {
    hook.dispose();
  }
}
__name(disposeHooks, "disposeHooks");
const _ModuleEventRegistrar = class _ModuleEventRegistrar {
  constructor(registry, notifications) {
    this.registry = registry;
    this.notifications = notifications;
    this.eventRegistrars = registry.getAll();
  }
  /**
   * Registers all event listeners.
   *
   * NOTE: Container parameter removed - event listeners receive all dependencies via constructor injection.
   */
  registerAll() {
    const errors = [];
    for (const registrar of this.eventRegistrars) {
      const result = registrar.register();
      if (!result.ok) {
        const error = {
          code: "EVENT_REGISTRATION_FAILED",
          message: result.error.message
        };
        this.notifications.error("Failed to register event listener", error, {
          channels: ["ConsoleChannel"]
        });
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      return err(errors);
    }
    return ok(void 0);
  }
  /**
   * Dispose all event listeners.
   * Called when the module is disabled or reloaded.
   */
  disposeAll() {
    disposeHooks(this.eventRegistrars);
  }
};
__name(_ModuleEventRegistrar, "ModuleEventRegistrar");
let ModuleEventRegistrar = _ModuleEventRegistrar;
const _DIModuleEventRegistrar = class _DIModuleEventRegistrar extends ModuleEventRegistrar {
  constructor(registry, notifications) {
    super(registry, notifications);
  }
};
__name(_DIModuleEventRegistrar, "DIModuleEventRegistrar");
_DIModuleEventRegistrar.dependencies = [eventRegistrarRegistryToken, notificationPublisherPortToken];
let DIModuleEventRegistrar = _DIModuleEventRegistrar;
function debounce(fn, delayMs) {
  let timeoutId = null;
  const debounced = /* @__PURE__ */ __name(function(...args2) {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn(...args2);
      timeoutId = null;
    }, delayMs);
  }, "debounced");
  debounced.cancel = function() {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  return debounced;
}
__name(debounce, "debounce");
const _JournalDirectoryRerenderScheduler = class _JournalDirectoryRerenderScheduler {
  // 100ms debounce delay
  constructor(journalDirectoryUI, notifications) {
    this.journalDirectoryUI = journalDirectoryUI;
    this.notifications = notifications;
    this.delayMs = 100;
    this.debouncedRerender = debounce(() => {
      this.executeRerender();
    }, this.delayMs);
  }
  /**
   * Request a journal directory re-render.
   *
   * Multiple rapid calls will be coalesced into a single re-render
   * after the debounce delay (100ms).
   */
  requestRerender() {
    this.debouncedRerender();
  }
  /**
   * Execute the actual re-render.
   */
  executeRerender() {
    const result = this.journalDirectoryUI.rerenderJournalDirectory();
    if (!result.ok) {
      this.notifications.warn("Failed to re-render journal directory", result.error, {
        channels: ["ConsoleChannel"]
      });
      return;
    }
    if (result.value) {
      this.notifications.debug(
        "Triggered journal directory re-render (debounced)",
        {},
        { channels: ["ConsoleChannel"] }
      );
    }
  }
  /**
   * Cancel any pending re-render.
   *
   * Useful for cleanup or when re-render is no longer needed.
   */
  cancelPending() {
    this.debouncedRerender.cancel();
  }
};
__name(_JournalDirectoryRerenderScheduler, "JournalDirectoryRerenderScheduler");
let JournalDirectoryRerenderScheduler = _JournalDirectoryRerenderScheduler;
const _DIJournalDirectoryRerenderScheduler = class _DIJournalDirectoryRerenderScheduler extends JournalDirectoryRerenderScheduler {
  constructor(journalDirectoryUI, notifications) {
    super(journalDirectoryUI, notifications);
  }
};
__name(_DIJournalDirectoryRerenderScheduler, "DIJournalDirectoryRerenderScheduler");
_DIJournalDirectoryRerenderScheduler.dependencies = [
  platformJournalDirectoryUiPortToken,
  notificationPublisherPortToken
];
let DIJournalDirectoryRerenderScheduler = _DIJournalDirectoryRerenderScheduler;
const _DefaultEventRegistrarRegistry = class _DefaultEventRegistrarRegistry {
  constructor(eventRegistrars) {
    this.eventRegistrars = eventRegistrars;
  }
  getAll() {
    return this.eventRegistrars;
  }
};
__name(_DefaultEventRegistrarRegistry, "DefaultEventRegistrarRegistry");
let DefaultEventRegistrarRegistry = _DefaultEventRegistrarRegistry;
function resolveMultipleServices(container, tokens) {
  const results = [];
  for (const { token, name } of tokens) {
    const result = container.resolveWithError(token);
    if (!result.ok) {
      throw new Error(`Failed to resolve ${name}: ${result.error.message}`);
    }
    results.push(castResolvedService(result.value));
  }
  return results;
}
__name(resolveMultipleServices, "resolveMultipleServices");
function registerEventPorts(container) {
  const eventPortResult = container.registerClass(
    platformJournalEventPortToken,
    DIFoundryJournalEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventPortResult)) {
    return err(`Failed to register PlatformJournalEventPort: ${eventPortResult.error.message}`);
  }
  const uiEventPortResult = container.registerClass(
    platformJournalUiEventPortToken,
    DIFoundryJournalUiEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiEventPortResult)) {
    return err(`Failed to register PlatformJournalUiEventPort: ${uiEventPortResult.error.message}`);
  }
  const cacheInvalidationUseCaseResult = container.registerClass(
    invalidateJournalCacheOnChangeUseCaseToken,
    DIInvalidateJournalCacheOnChangeUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(cacheInvalidationUseCaseResult)) {
    return err(
      `Failed to register InvalidateJournalCacheOnChangeUseCase: ${cacheInvalidationUseCaseResult.error.message}`
    );
  }
  const directoryRenderUseCaseResult = container.registerClass(
    processJournalDirectoryOnRenderUseCaseToken,
    DIProcessJournalDirectoryOnRenderUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(directoryRenderUseCaseResult)) {
    return err(
      `Failed to register ProcessJournalDirectoryOnRenderUseCase: ${directoryRenderUseCaseResult.error.message}`
    );
  }
  const schedulerResult = container.registerClass(
    journalDirectoryRerenderSchedulerToken,
    DIJournalDirectoryRerenderScheduler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(schedulerResult)) {
    return err(
      `Failed to register JournalDirectoryRerenderScheduler: ${schedulerResult.error.message}`
    );
  }
  const reRenderUseCaseResult = container.registerClass(
    triggerJournalDirectoryReRenderUseCaseToken,
    DITriggerJournalDirectoryReRenderUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(reRenderUseCaseResult)) {
    return err(
      `Failed to register TriggerJournalDirectoryReRenderUseCase: ${reRenderUseCaseResult.error.message}`
    );
  }
  const hideJournalHandlerResult = container.registerClass(
    hideJournalContextMenuHandlerToken,
    DIHideJournalContextMenuHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(hideJournalHandlerResult)) {
    return err(
      `Failed to register HideJournalContextMenuHandler: ${hideJournalHandlerResult.error.message}`
    );
  }
  const handlersArrayResult = container.registerFactory(
    journalContextMenuHandlersToken,
    () => {
      return resolveMultipleServices(container, [
        { token: hideJournalContextMenuHandlerToken, name: "HideJournalContextMenuHandler" }
      ]);
    },
    ServiceLifecycle.SINGLETON,
    [hideJournalContextMenuHandlerToken]
  );
  if (isErr(handlersArrayResult)) {
    return err(
      `Failed to register JournalContextMenuHandlers array: ${handlersArrayResult.error.message}`
    );
  }
  const contextMenuUseCaseResult = container.registerClass(
    registerContextMenuUseCaseToken,
    DIRegisterContextMenuUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(contextMenuUseCaseResult)) {
    return err(
      `Failed to register RegisterContextMenuUseCase: ${contextMenuUseCaseResult.error.message}`
    );
  }
  const showAllHiddenJournalsUseCaseResult = container.registerClass(
    showAllHiddenJournalsUseCaseToken,
    DIShowAllHiddenJournalsUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(showAllHiddenJournalsUseCaseResult)) {
    return err(
      `Failed to register ShowAllHiddenJournalsUseCase: ${showAllHiddenJournalsUseCaseResult.error.message}`
    );
  }
  const eventRegistrarRegistryResult = container.registerFactory(
    eventRegistrarRegistryToken,
    () => {
      const eventRegistrars = resolveMultipleServices(container, [
        {
          token: processJournalDirectoryOnRenderUseCaseToken,
          name: "ProcessJournalDirectoryOnRenderUseCase"
        },
        {
          token: invalidateJournalCacheOnChangeUseCaseToken,
          name: "InvalidateJournalCacheOnChangeUseCase"
        },
        {
          token: triggerJournalDirectoryReRenderUseCaseToken,
          name: "TriggerJournalDirectoryReRenderUseCase"
        }
      ]);
      return new DefaultEventRegistrarRegistry(eventRegistrars);
    },
    ServiceLifecycle.SINGLETON,
    [
      processJournalDirectoryOnRenderUseCaseToken,
      invalidateJournalCacheOnChangeUseCaseToken,
      triggerJournalDirectoryReRenderUseCaseToken
    ]
  );
  if (isErr(eventRegistrarRegistryResult)) {
    return err(
      `Failed to register EventRegistrarRegistry: ${eventRegistrarRegistryResult.error.message}`
    );
  }
  const eventRegistrarResult = container.registerClass(
    moduleEventRegistrarToken,
    DIModuleEventRegistrar,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventRegistrarResult)) {
    return err(`Failed to register ModuleEventRegistrar: ${eventRegistrarResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerEventPorts, "registerEventPorts");
registerDependencyStep({
  name: "EventPorts",
  priority: 140,
  execute: registerEventPorts
});
const _JournalMapperRegistry = class _JournalMapperRegistry {
  constructor() {
    this.mappers = [];
  }
  /**
   * Registers a mapper with the registry.
   *
   * Mappers are checked in registration order (first registered = highest priority).
   * The first mapper that returns true for `supports()` will be used.
   *
   * @param mapper - The mapper to register
   * @throws Error if the mapper is already registered
   */
  register(mapper) {
    if (this.mappers.includes(mapper)) {
      throw new Error("Mapper is already registered");
    }
    this.mappers.push(mapper);
  }
  /**
   * Unregisters a mapper from the registry.
   *
   * @param mapper - The mapper to unregister
   */
  unregister(mapper) {
    const index2 = this.mappers.indexOf(mapper);
    if (index2 !== -1) {
      this.mappers.splice(index2, 1);
    }
  }
  /**
   * Returns all registered mappers in priority order.
   *
   * @returns Array of mappers (first = highest priority)
   */
  getAll() {
    return [...this.mappers];
  }
  /**
   * Finds the first mapper that supports the given entity.
   *
   * @param entity - The Foundry entity to find a mapper for
   * @returns The first matching mapper, or undefined if none found
   */
  findMapper(entity) {
    return this.mappers.find((mapper) => mapper.supports(entity));
  }
  /**
   * Maps a Foundry journal entry to a domain journal entry using the first matching mapper.
   *
   * @param entity - The Foundry journal entry to map
   * @returns The domain journal entry
   * @throws Error if no mapper supports the entity
   */
  mapToDomain(entity) {
    const mapper = this.findMapper(entity);
    if (!mapper) {
      throw new Error(`No mapper found for entity: ${JSON.stringify(entity).substring(0, 100)}`);
    }
    if (!mapper.supports(entity)) {
      throw new Error(
        `Mapper supports() returned false after findMapper() returned it: ${mapper.constructor.name}`
      );
    }
    return mapper.toDomain(entity);
  }
  /**
   * Validates that no two mappers have overlapping support.
   *
   * This is useful for detecting configuration errors during development.
   * Note: This is a best-effort check and may not catch all overlaps.
   *
   * @param testEntities - Optional array of test entities to check against
   * @returns Array of conflicts (empty if none)
   */
  validateNoOverlaps(testEntities = []) {
    const conflicts = [];
    for (const entity of testEntities) {
      const matchingMappers = this.mappers.filter((mapper) => mapper.supports(entity));
      if (matchingMappers.length > 1) {
        conflicts.push({
          entity,
          mappers: matchingMappers
        });
      }
    }
    return conflicts;
  }
};
__name(_JournalMapperRegistry, "JournalMapperRegistry");
let JournalMapperRegistry = _JournalMapperRegistry;
const _DefaultJournalMapper = class _DefaultJournalMapper {
  /**
   * Type guard: checks if entity is a Foundry journal entry.
   *
   * Supports any object with an `id` property (basic check).
   * More specific mappers should be registered before this one.
   *
   * @param entity - The entity to check
   * @returns True if entity has id property
   */
  supports(entity) {
    return typeof entity === "object" && entity !== null && "id" in entity && typeof entity.id === "string";
  }
  /**
   * Maps a Foundry journal entry to a domain journal entry.
   *
   * @param entity - The Foundry journal entry
   * @returns The domain journal entry
   */
  toDomain(entity) {
    return {
      id: entity.id,
      name: entity.name ?? null
    };
  }
};
__name(_DefaultJournalMapper, "DefaultJournalMapper");
let DefaultJournalMapper = _DefaultJournalMapper;
const _FilterOperatorRegistry = class _FilterOperatorRegistry {
  constructor() {
    this.operators = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a filter operator.
   *
   * @param operator - The operator to register
   * @throws Error if an operator with the same name is already registered
   */
  register(operator) {
    if (this.operators.has(operator.name)) {
      throw new Error(
        `Filter operator "${operator.name}" is already registered. Use unregister() first to replace an existing operator.`
      );
    }
    this.operators.set(operator.name, operator);
  }
  /**
   * Unregisters a filter operator.
   *
   * @param name - The name of the operator to unregister
   * @returns true if the operator was unregistered, false if it wasn't registered
   */
  unregister(name) {
    return this.operators.delete(name);
  }
  /**
   * Gets a filter operator by name.
   *
   * @param name - The name of the operator
   * @returns The operator if found, undefined otherwise
   */
  get(name) {
    return this.operators.get(name);
  }
  /**
   * Checks if an operator is registered.
   *
   * @param name - The name of the operator
   * @returns true if registered, false otherwise
   */
  has(name) {
    return this.operators.has(name);
  }
  /**
   * Gets all registered operator names.
   *
   * @returns Array of operator names
   */
  getOperatorNames() {
    return Array.from(this.operators.keys());
  }
};
__name(_FilterOperatorRegistry, "FilterOperatorRegistry");
let FilterOperatorRegistry = _FilterOperatorRegistry;
const _EqualsOperator = class _EqualsOperator {
  constructor() {
    this.name = "equals";
  }
  matches(fieldValue, filterValue) {
    return fieldValue === filterValue;
  }
};
__name(_EqualsOperator, "EqualsOperator");
let EqualsOperator = _EqualsOperator;
const _NotEqualsOperator = class _NotEqualsOperator {
  constructor() {
    this.name = "notEquals";
  }
  matches(fieldValue, filterValue) {
    return fieldValue !== filterValue;
  }
};
__name(_NotEqualsOperator, "NotEqualsOperator");
let NotEqualsOperator = _NotEqualsOperator;
const _ContainsOperator = class _ContainsOperator {
  constructor() {
    this.name = "contains";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().includes(String(filterValue).toLowerCase());
  }
};
__name(_ContainsOperator, "ContainsOperator");
let ContainsOperator = _ContainsOperator;
const _StartsWithOperator = class _StartsWithOperator {
  constructor() {
    this.name = "startsWith";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().startsWith(String(filterValue).toLowerCase());
  }
};
__name(_StartsWithOperator, "StartsWithOperator");
let StartsWithOperator = _StartsWithOperator;
const _EndsWithOperator = class _EndsWithOperator {
  constructor() {
    this.name = "endsWith";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().endsWith(String(filterValue).toLowerCase());
  }
};
__name(_EndsWithOperator, "EndsWithOperator");
let EndsWithOperator = _EndsWithOperator;
const _InOperator = class _InOperator {
  constructor() {
    this.name = "in";
  }
  matches(fieldValue, filterValue) {
    if (!Array.isArray(filterValue)) {
      return false;
    }
    const filterArray = filterValue;
    return filterArray.includes(fieldValue);
  }
};
__name(_InOperator, "InOperator");
let InOperator = _InOperator;
const _NotInOperator = class _NotInOperator {
  constructor() {
    this.name = "notIn";
  }
  matches(fieldValue, filterValue) {
    if (!Array.isArray(filterValue)) {
      return false;
    }
    const filterArray = filterValue;
    return !filterArray.includes(fieldValue);
  }
};
__name(_NotInOperator, "NotInOperator");
let NotInOperator = _NotInOperator;
const _GreaterThanOperator = class _GreaterThanOperator {
  constructor() {
    this.name = "greaterThan";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) > Number(filterValue);
  }
};
__name(_GreaterThanOperator, "GreaterThanOperator");
let GreaterThanOperator = _GreaterThanOperator;
const _LessThanOperator = class _LessThanOperator {
  constructor() {
    this.name = "lessThan";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) < Number(filterValue);
  }
};
__name(_LessThanOperator, "LessThanOperator");
let LessThanOperator = _LessThanOperator;
const _GreaterThanOrEqualOperator = class _GreaterThanOrEqualOperator {
  constructor() {
    this.name = "greaterThanOrEqual";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) >= Number(filterValue);
  }
};
__name(_GreaterThanOrEqualOperator, "GreaterThanOrEqualOperator");
let GreaterThanOrEqualOperator = _GreaterThanOrEqualOperator;
const _LessThanOrEqualOperator = class _LessThanOrEqualOperator {
  constructor() {
    this.name = "lessThanOrEqual";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) <= Number(filterValue);
  }
};
__name(_LessThanOrEqualOperator, "LessThanOrEqualOperator");
let LessThanOrEqualOperator = _LessThanOrEqualOperator;
function createDefaultFilterOperators() {
  const registry = new FilterOperatorRegistry();
  registry.register(new EqualsOperator());
  registry.register(new NotEqualsOperator());
  registry.register(new ContainsOperator());
  registry.register(new StartsWithOperator());
  registry.register(new EndsWithOperator());
  registry.register(new InOperator());
  registry.register(new NotInOperator());
  registry.register(new GreaterThanOperator());
  registry.register(new LessThanOperator());
  registry.register(new GreaterThanOrEqualOperator());
  registry.register(new LessThanOrEqualOperator());
  return registry;
}
__name(createDefaultFilterOperators, "createDefaultFilterOperators");
const _FoundryJournalCollectionAdapter = class _FoundryJournalCollectionAdapter {
  constructor(foundryGame, mapperRegistry, operatorRegistry = createDefaultFilterOperators()) {
    this.foundryGame = foundryGame;
    this.mapperRegistry = mapperRegistry;
    this.operatorRegistry = operatorRegistry;
  }
  getAll() {
    const result = this.foundryGame.getJournalEntries();
    if (!result.ok) {
      return {
        ok: false,
        error: {
          code: "COLLECTION_NOT_AVAILABLE",
          message: `Failed to get journals from Foundry: ${result.error.message}`,
          details: result.error
        }
      };
    }
    const entries2 = [];
    for (const foundryEntry of result.value) {
      try {
        entries2.push(this.mapperRegistry.mapToDomain(foundryEntry));
      } catch (error) {
        return err({
          code: "PLATFORM_ERROR",
          message: `Failed to map journal entry to domain: ${error instanceof Error ? error.message : String(error)}`,
          details: error
        });
      }
    }
    return ok(entries2);
  }
  getById(id) {
    const result = this.foundryGame.getJournalEntryById(id);
    if (!result.ok) {
      return {
        ok: false,
        error: {
          code: "PLATFORM_ERROR",
          message: `Failed to get journal ${id} from Foundry: ${result.error.message}`,
          details: result.error
        }
      };
    }
    if (!result.value) {
      return ok(null);
    }
    try {
      const entry = this.mapperRegistry.mapToDomain(result.value);
      return ok(entry);
    } catch (error) {
      return err({
        code: "PLATFORM_ERROR",
        message: `Failed to map journal entry to domain: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  getByIds(ids) {
    const results = [];
    const errors = [];
    for (const id of ids) {
      const result = this.getById(id);
      if (!result.ok) {
        errors.push(result.error);
      } else if (result.value) {
        results.push(result.value);
      }
    }
    if (errors.length > 0) {
      const firstError = errors[0];
      return err(firstError);
    }
    return ok(results);
  }
  exists(id) {
    const result = this.getById(id);
    if (!result.ok) {
      return result;
    }
    return ok(result.value !== null);
  }
  count() {
    const result = this.getAll();
    if (!result.ok) {
      return {
        ok: false,
        error: result.error
      };
    }
    return ok(result.value.length);
  }
  search(query) {
    const allResult = this.getAll();
    if (!allResult.ok) {
      return allResult;
    }
    let results = allResult.value;
    if (query.filters && query.filters.length > 0) {
      const filters = query.filters;
      results = results.filter((entity) => {
        return filters.every((filter) => {
          const fieldValue = entity[filter.field];
          return this.matchesFilter(fieldValue, filter.operator, filter.value);
        });
      });
    }
    if (query.filterGroups && query.filterGroups.length > 0) {
      const filterGroups = query.filterGroups;
      results = results.filter((entity) => {
        return filterGroups.every((group) => {
          if (group.filters.length === 0) return true;
          if (group.logic === "OR") {
            return group.filters.some((filter) => {
              const fieldValue = entity[filter.field];
              return this.matchesFilter(fieldValue, filter.operator, filter.value);
            });
          } else {
            return group.filters.every((filter) => {
              const fieldValue = entity[filter.field];
              return this.matchesFilter(fieldValue, filter.operator, filter.value);
            });
          }
        });
      });
    }
    if (query.sortBy) {
      const sortBy = query.sortBy;
      results.sort((a, b) => {
        const aValue = a[sortBy];
        const bValue = b[sortBy];
        if (aValue === bValue) return 0;
        if (aValue === null || aValue === void 0) return 1;
        if (bValue === null || bValue === void 0) return -1;
        const comparison = aValue < bValue ? -1 : 1;
        return query.sortOrder === "desc" ? -comparison : comparison;
      });
    }
    if (query.offset) {
      results = results.slice(query.offset);
    }
    if (query.limit) {
      results = results.slice(0, query.limit);
    }
    return ok(results);
  }
  query() {
    return new FoundryJournalQueryBuilder(this);
  }
  /**
   * Checks if a field value matches a filter using the registered operator.
   *
   * Uses FilterOperatorRegistry (Strategy Pattern) for OCP-compliant extensibility.
   * New operators can be added without modifying this method.
   *
   * @param fieldValue - The value from the entity field
   * @param operator - The operator name (e.g., "equals", "contains")
   * @param filterValue - The value from the filter
   * @returns true if the field value matches the filter, false otherwise
   */
  matchesFilter(fieldValue, operator, filterValue) {
    const op = this.operatorRegistry.get(operator);
    if (!op) {
      return false;
    }
    return op.matches(fieldValue, filterValue);
  }
};
__name(_FoundryJournalCollectionAdapter, "FoundryJournalCollectionAdapter");
let FoundryJournalCollectionAdapter = _FoundryJournalCollectionAdapter;
const _FoundryJournalQueryBuilder = class _FoundryJournalQueryBuilder {
  constructor(adapter) {
    this.adapter = adapter;
    this.query = {};
    this.currentOrGroup = null;
  }
  where(field, operator, value2) {
    if (this.currentOrGroup !== null) {
      this.currentOrGroup.push({ field, operator, value: value2 });
      return this;
    }
    this.closeOrGroup();
    if (!this.query.filters) {
      this.query.filters = [];
    }
    this.query.filters.push({ field, operator, value: value2 });
    return this;
  }
  orWhere(field, operator, value2) {
    if (this.currentOrGroup === null) {
      this.currentOrGroup = [];
      if (this.query.filters && this.query.filters.length > 0) {
        const lastFilter = this.query.filters.pop();
        this.currentOrGroup.push({
          field: lastFilter.field,
          operator: lastFilter.operator,
          value: lastFilter.value
        });
      }
    }
    this.currentOrGroup.push({ field, operator, value: value2 });
    return this;
  }
  or(callback) {
    this.closeOrGroup();
    const orGroup = [];
    if (this.query.filters && this.query.filters.length > 0) {
      const lastFilter = this.query.filters.pop();
      orGroup.push({
        field: lastFilter.field,
        operator: lastFilter.operator,
        value: lastFilter.value
      });
    }
    const originalOrGroup = this.currentOrGroup;
    this.currentOrGroup = orGroup;
    callback(this);
    this.currentOrGroup = originalOrGroup;
    if (orGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "OR",
        filters: orGroup.map((f) => ({ field: f.field, operator: f.operator, value: f.value }))
      });
    }
    return this;
  }
  and(callback) {
    this.closeOrGroup();
    const andGroup = [];
    const originalFilters = this.query.filters;
    this.query.filters = andGroup;
    callback(this);
    if (originalFilters !== void 0) {
      this.query.filters = originalFilters;
    } else {
      delete this.query.filters;
    }
    if (andGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "AND",
        filters: andGroup.map((f) => ({ field: f.field, operator: f.operator, value: f.value }))
      });
    }
    return this;
  }
  limit(count) {
    this.closeOrGroup();
    this.query.limit = count;
    return this;
  }
  offset(count) {
    this.closeOrGroup();
    this.query.offset = count;
    return this;
  }
  sortBy(field, order) {
    this.closeOrGroup();
    this.query.sortBy = field;
    this.query.sortOrder = order;
    return this;
  }
  execute() {
    this.closeOrGroup();
    return this.adapter.search(this.query);
  }
  /**
   * Closes the current OR group and adds it to filterGroups.
   * Called automatically before where(), limit(), offset(), sortBy(), execute().
   */
  closeOrGroup() {
    if (this.currentOrGroup && this.currentOrGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "OR",
        filters: this.currentOrGroup.map((f) => ({
          field: f.field,
          operator: f.operator,
          value: f.value
        }))
      });
      this.currentOrGroup = null;
    }
  }
};
__name(_FoundryJournalQueryBuilder, "FoundryJournalQueryBuilder");
let FoundryJournalQueryBuilder = _FoundryJournalQueryBuilder;
const _DIFoundryJournalCollectionAdapter = class _DIFoundryJournalCollectionAdapter extends FoundryJournalCollectionAdapter {
  // foundryGameToken → FoundryGamePort (version-agnostisch)
  constructor(foundryGame) {
    const mapperRegistry = new JournalMapperRegistry();
    mapperRegistry.register(new DefaultJournalMapper());
    super(foundryGame, mapperRegistry);
  }
};
__name(_DIFoundryJournalCollectionAdapter, "DIFoundryJournalCollectionAdapter");
_DIFoundryJournalCollectionAdapter.dependencies = [foundryGameToken];
let DIFoundryJournalCollectionAdapter = _DIFoundryJournalCollectionAdapter;
const _FoundryJournalRepositoryAdapter = class _FoundryJournalRepositoryAdapter {
  constructor(collection, foundryGame, foundryDocument, mapperRegistry) {
    this.collection = collection;
    this.foundryGame = foundryGame;
    this.foundryDocument = foundryDocument;
    this.mapperRegistry = mapperRegistry;
  }
  // ===== Collection Methods (delegate to collection adapter) =====
  getAll() {
    return this.collection.getAll();
  }
  getById(id) {
    return this.collection.getById(id);
  }
  getByIds(ids) {
    return this.collection.getByIds(ids);
  }
  exists(id) {
    return this.collection.exists(id);
  }
  count() {
    return this.collection.count();
  }
  search(query) {
    return this.collection.search(query);
  }
  query() {
    return this.collection.query();
  }
  // ===== CREATE Operations =====
  async create(data) {
    const journalEntryClassResult = castFoundryJournalEntryClass();
    if (!journalEntryClassResult.ok) {
      return err({
        code: "PLATFORM_ERROR",
        message: `Foundry JournalEntry class not available: ${journalEntryClassResult.error.message}`,
        details: journalEntryClassResult.error
      });
    }
    const JournalEntryClass = journalEntryClassResult.value;
    try {
      const createResult = await this.foundryDocument.create(JournalEntryClass, data);
      if (!createResult.ok) {
        return err({
          code: "OPERATION_FAILED",
          message: `Failed to create journal: ${createResult.error.message}`,
          details: createResult.error
        });
      }
      const foundryEntry = castCreatedJournalEntry(createResult.value);
      try {
        const createdEntry = this.mapperRegistry.mapToDomain(foundryEntry);
        return ok(createdEntry);
      } catch (error) {
        return err({
          code: "OPERATION_FAILED",
          message: `Failed to map journal to domain: ${error instanceof Error ? error.message : String(error)}`,
          details: error
        });
      }
    } catch (error) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create journal: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  async createMany(data) {
    const results = [];
    const errors = [];
    for (const item of data) {
      const result = await this.create(item);
      if (result.ok) {
        results.push(result.value);
      } else {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = errors[0];
      return err(firstError);
    }
    return ok(results);
  }
  // ===== UPDATE Operations =====
  async update(id, changes) {
    const currentResult = this.getById(id);
    if (!currentResult.ok) {
      return {
        ok: false,
        error: {
          code: "ENTITY_NOT_FOUND",
          message: `Journal ${id} not found`,
          details: currentResult.error
        }
      };
    }
    if (!currentResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found`
      });
    }
    const foundryResult = this.foundryGame.getJournalEntryById(id);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found in Foundry`
      });
    }
    const foundryEntry = foundryResult.value;
    const updateData = {};
    if (changes.name !== void 0) {
      if (changes.name === null) {
        updateData["name.-="] = null;
      } else {
        updateData.name = changes.name;
      }
    }
    const docWithUpdateResult = castFoundryDocumentWithUpdate(
      foundryEntry
    );
    if (!docWithUpdateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support update: ${docWithUpdateResult.error.message}`,
        details: docWithUpdateResult.error
      });
    }
    const updateResult = await this.foundryDocument.update(docWithUpdateResult.value, updateData);
    if (!updateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to update journal ${id}: ${updateResult.error.message}`,
        details: updateResult.error
      });
    }
    const updatedResult = this.getById(id);
    if (!updatedResult.ok || !updatedResult.value) {
      return err({
        code: "OPERATION_FAILED",
        message: "Failed to retrieve updated journal"
      });
    }
    return ok(updatedResult.value);
  }
  async updateMany(updates) {
    const results = [];
    const errors = [];
    for (const update2 of updates) {
      const result = await this.update(update2.id, update2.changes);
      if (result.ok) {
        results.push(result.value);
      } else {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = errors[0];
      return err(firstError);
    }
    return ok(results);
  }
  async patch(id, partial2) {
    return this.update(id, partial2);
  }
  async upsert(id, data) {
    const existsResult = this.exists(id);
    if (!existsResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to check if journal ${id} exists`,
        details: existsResult.error
      });
    }
    if (existsResult.value) {
      return this.update(id, data);
    } else {
      return this.create({ ...data, id });
    }
  }
  // ===== DELETE Operations =====
  async delete(id) {
    const foundryResult = this.foundryGame.getJournalEntryById(id);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found`
      });
    }
    const deleteResult = await this.foundryDocument.delete(foundryResult.value);
    if (!deleteResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to delete journal ${id}: ${deleteResult.error.message}`,
        details: deleteResult.error
      });
    }
    return ok(void 0);
  }
  async deleteMany(ids) {
    const errors = [];
    for (const id of ids) {
      const result = await this.delete(id);
      if (!result.ok) {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = errors[0];
      return err(firstError);
    }
    return ok(void 0);
  }
  // ===== Flag Convenience Methods =====
  getFlag(id, scope, key2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = this.foundryDocument.getFlag(documentResult.value, scope, key2, /* @__PURE__ */ unknown());
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to get flag ${scope}.${key2}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(flagResult.value);
  }
  async setFlag(id, scope, key2, value2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = await this.foundryDocument.setFlag(documentResult.value, scope, key2, value2);
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to set flag ${scope}.${key2}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(void 0);
  }
  async unsetFlag(id, scope, key2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const unsetResult = await this.foundryDocument.unsetFlag(documentResult.value, scope, key2);
    if (!unsetResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to unset flag ${scope}.${key2}: ${unsetResult.error.message}`,
        details: unsetResult.error
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryJournalRepositoryAdapter, "FoundryJournalRepositoryAdapter");
let FoundryJournalRepositoryAdapter = _FoundryJournalRepositoryAdapter;
const _DIFoundryJournalRepositoryAdapter = class _DIFoundryJournalRepositoryAdapter extends FoundryJournalRepositoryAdapter {
  constructor(foundryGame, foundryDocument) {
    const mapperRegistry = new JournalMapperRegistry();
    mapperRegistry.register(new DefaultJournalMapper());
    const collection = new FoundryJournalCollectionAdapter(foundryGame, mapperRegistry);
    super(collection, foundryGame, foundryDocument, mapperRegistry);
  }
};
__name(_DIFoundryJournalRepositoryAdapter, "DIFoundryJournalRepositoryAdapter");
_DIFoundryJournalRepositoryAdapter.dependencies = [foundryGameToken, foundryDocumentToken];
let DIFoundryJournalRepositoryAdapter = _DIFoundryJournalRepositoryAdapter;
function registerEntityPorts(container) {
  const collectionResult = container.registerClass(
    platformJournalCollectionPortToken,
    DIFoundryJournalCollectionAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(collectionResult)) {
    return err(
      `Failed to register PlatformJournalCollectionPort: ${collectionResult.error.message}`
    );
  }
  const repositoryResult = container.registerClass(
    platformJournalRepositoryToken,
    DIFoundryJournalRepositoryAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(repositoryResult)) {
    return err(`Failed to register PlatformJournalRepository: ${repositoryResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerEntityPorts, "registerEntityPorts");
registerDependencyStep({
  name: "EntityPorts",
  priority: 100,
  execute: registerEntityPorts
});
const settingTypeMapperToken = createInjectionToken("SettingTypeMapper");
const settingsErrorMapperToken = createInjectionToken("SettingsErrorMapper");
function mapDomainErrorToSettingsError(error) {
  let code;
  switch (error.code) {
    case "SETTING_REGISTRATION_FAILED":
      code = "SETTING_REGISTRATION_FAILED";
      break;
    case "SETTING_NOT_FOUND":
      code = "SETTING_NOT_REGISTERED";
      break;
    case "INVALID_SETTING_VALUE":
      code = "SETTING_VALIDATION_FAILED";
      break;
    case "SETTING_READ_FAILED":
    case "SETTING_WRITE_FAILED":
      if (error.message.toLowerCase().includes("not found") || error.message.toLowerCase().includes("not registered")) {
        code = "SETTING_NOT_REGISTERED";
      } else {
        code = "SETTING_VALIDATION_FAILED";
      }
      break;
    case "PLATFORM_NOT_AVAILABLE":
      code = "PLATFORM_NOT_AVAILABLE";
      break;
    default:
      code = "SETTING_REGISTRATION_FAILED";
  }
  return {
    code,
    message: error.message,
    details: error.details
  };
}
__name(mapDomainErrorToSettingsError, "mapDomainErrorToSettingsError");
const _FoundrySettingsAdapter = class _FoundrySettingsAdapter {
  constructor(foundrySettings, typeMapper, errorMapper) {
    this.foundrySettings = foundrySettings;
    this.typeMapper = typeMapper;
    this.errorMapper = errorMapper;
  }
  /**
   * Register a setting in Foundry.
   *
   * Maps platform config → Foundry config.
   */
  register(namespace, key2, config2) {
    const typeResult = this.typeMapper.map(config2.type);
    if (!typeResult.ok) {
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(typeResult.error)
      };
    }
    const foundryConfig = {
      name: config2.name,
      ...config2.hint !== void 0 && { hint: config2.hint },
      scope: config2.scope,
      config: config2.config,
      type: typeResult.value,
      ...config2.choices !== void 0 && { choices: config2.choices },
      default: config2.default,
      ...config2.onChange !== void 0 && { onChange: config2.onChange }
    };
    const result = this.foundrySettings.register(namespace, key2, foundryConfig);
    if (!result.ok) {
      const domainError = this.errorMapper.map(result.error, {
        operation: "register",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    return { ok: true, value: void 0 };
  }
  /**
   * Get setting value from Foundry with validation.
   *
   * Uses a permissive valibot schema (v.unknown()) to retrieve the raw value,
   * then validates it using the provided ValidationSchema. This allows any
   * ValidationSchema implementation to be used, not just ValibotValidationSchema.
   */
  get(namespace, key2, schema) {
    const rawResult = this.foundrySettings.get(namespace, key2, /* @__PURE__ */ unknown());
    if (!rawResult.ok) {
      const domainError = this.errorMapper.map(rawResult.error, {
        operation: "get",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    const validationResult = schema.validate(rawResult.value);
    if (!validationResult.ok) {
      return validationResult;
    }
    return validationResult;
  }
  /**
   * Set setting value in Foundry.
   *
   * Persists to Foundry's database and triggers onChange.
   */
  async set(namespace, key2, value2) {
    const result = await this.foundrySettings.set(namespace, key2, value2);
    if (!result.ok) {
      const domainError = this.errorMapper.map(result.error, {
        operation: "set",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    return { ok: true, value: void 0 };
  }
};
__name(_FoundrySettingsAdapter, "FoundrySettingsAdapter");
let FoundrySettingsAdapter = _FoundrySettingsAdapter;
const _DIFoundrySettingsAdapter = class _DIFoundrySettingsAdapter extends FoundrySettingsAdapter {
  constructor(foundrySettings, typeMapper, errorMapper) {
    super(foundrySettings, typeMapper, errorMapper);
  }
};
__name(_DIFoundrySettingsAdapter, "DIFoundrySettingsAdapter");
_DIFoundrySettingsAdapter.dependencies = [
  foundrySettingsToken,
  settingTypeMapperToken,
  settingsErrorMapperToken
];
let DIFoundrySettingsAdapter = _DIFoundrySettingsAdapter;
const _FoundrySettingTypeMapper = class _FoundrySettingTypeMapper {
  /**
   * Maps a platform-agnostic SettingType to Foundry-specific type constructor.
   *
   * @param type - The setting type to map
   * @returns Result containing the Foundry type constructor or a SettingsError
   */
  map(type) {
    if (type === "String" || type === String) {
      return { ok: true, value: String };
    }
    if (type === "Number" || type === Number) {
      return { ok: true, value: Number };
    }
    if (type === "Boolean" || type === Boolean) {
      return { ok: true, value: Boolean };
    }
    return {
      ok: false,
      error: {
        code: "SETTING_REGISTRATION_FAILED",
        message: `Unknown setting type: ${type}. Supported types are: String, Number, Boolean`,
        details: { type }
      }
    };
  }
};
__name(_FoundrySettingTypeMapper, "FoundrySettingTypeMapper");
let FoundrySettingTypeMapper = _FoundrySettingTypeMapper;
const _FoundrySettingsErrorMapper = class _FoundrySettingsErrorMapper {
  /**
   * Maps a FoundryError to a platform-agnostic SettingsError.
   *
   * @param foundryError - The Foundry-specific error to map
   * @param context - Context information about the operation and setting
   * @returns Platform-agnostic SettingsError
   */
  map(foundryError, context) {
    let code;
    switch (foundryError.code) {
      case "API_NOT_AVAILABLE":
        code = "PLATFORM_NOT_AVAILABLE";
        break;
      case "VALIDATION_FAILED":
        code = "INVALID_SETTING_VALUE";
        break;
      case "OPERATION_FAILED":
        if (context.operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else {
          const message2 = foundryError.message.toLowerCase();
          if (message2.includes("not registered") || message2.includes("not found")) {
            code = "SETTING_NOT_FOUND";
          } else if (context.operation === "get") {
            code = "SETTING_READ_FAILED";
          } else {
            code = "SETTING_WRITE_FAILED";
          }
        }
        break;
      default:
        if (context.operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else if (context.operation === "get") {
          code = "SETTING_READ_FAILED";
        } else {
          code = "SETTING_WRITE_FAILED";
        }
    }
    return {
      code,
      message: `Failed to ${context.operation} setting "${context.namespace}.${context.key}": ${foundryError.message}`,
      details: foundryError
    };
  }
};
__name(_FoundrySettingsErrorMapper, "FoundrySettingsErrorMapper");
let FoundrySettingsErrorMapper = _FoundrySettingsErrorMapper;
function registerSettingsPorts(container) {
  const typeMapperResult = container.registerClass(
    settingTypeMapperToken,
    FoundrySettingTypeMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(typeMapperResult)) {
    return err(`Failed to register SettingTypeMapper: ${typeMapperResult.error.message}`);
  }
  const errorMapperResult = container.registerClass(
    settingsErrorMapperToken,
    FoundrySettingsErrorMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(errorMapperResult)) {
    return err(`Failed to register SettingsErrorMapper: ${errorMapperResult.error.message}`);
  }
  const settingsPortResult = container.registerClass(
    platformSettingsPortToken,
    DIFoundrySettingsAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsPortResult)) {
    return err(`Failed to register PlatformSettingsPort: ${settingsPortResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerSettingsPorts, "registerSettingsPorts");
registerDependencyStep({
  name: "SettingsPorts",
  priority: 90,
  execute: registerSettingsPorts
});
const KEY_SEPARATOR = ":";
function normalizeSegment(segment) {
  return segment.trim().replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "").toLowerCase();
}
__name(normalizeSegment, "normalizeSegment");
function createCacheKey(parts, moduleId) {
  const { namespace, resource, identifier } = parts;
  const payload = [moduleId, namespace, resource];
  if (identifier !== null && identifier !== void 0) {
    payload.push(String(identifier));
  }
  return assertCacheKey(payload.map(normalizeSegment).join(KEY_SEPARATOR));
}
__name(createCacheKey, "createCacheKey");
function createCacheNamespace(namespace, moduleId) {
  const normalizedNamespace = normalizeSegment(namespace);
  return (resource, identifier) => identifier === void 0 ? createCacheKey({ namespace: normalizedNamespace, resource }, moduleId) : createCacheKey({ namespace: normalizedNamespace, resource, identifier }, moduleId);
}
__name(createCacheNamespace, "createCacheNamespace");
function registerJournalVisibilityConfig(container) {
  const buildCacheKey = createCacheNamespace("journal-visibility", MODULE_METADATA.ID);
  const cacheKeyFactory = /* @__PURE__ */ __name((resource) => {
    return buildCacheKey(resource);
  }, "cacheKeyFactory");
  const config2 = {
    moduleNamespace: MODULE_METADATA.ID,
    hiddenFlagKey: DOMAIN_FLAGS.HIDDEN,
    unknownName: APP_DEFAULTS.UNKNOWN_NAME,
    cacheKeyFactory
  };
  const configResult = container.registerValue(journalVisibilityConfigToken, config2);
  if (isErr(configResult)) {
    return err(`Failed to register JournalVisibilityConfig: ${configResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerJournalVisibilityConfig, "registerJournalVisibilityConfig");
registerDependencyStep({
  name: "JournalVisibilityConfig",
  priority: 110,
  execute: registerJournalVisibilityConfig
});
const _WindowRegistry = class _WindowRegistry {
  constructor() {
    this.definitions = /* @__PURE__ */ new Map();
    this.instances = /* @__PURE__ */ new Map();
  }
  registerDefinition(definition) {
    if (this.definitions.has(definition.definitionId)) {
      return err({
        code: "DefinitionAlreadyExists",
        message: `Definition ${definition.definitionId} already exists`
      });
    }
    this.definitions.set(definition.definitionId, definition);
    return ok(void 0);
  }
  getDefinition(definitionId) {
    const definition = this.definitions.get(definitionId);
    if (!definition) {
      return err({
        code: "DefinitionNotFound",
        message: `Definition ${definitionId} not found`
      });
    }
    return ok(definition);
  }
  registerInstance(instance2) {
    if (this.instances.has(instance2.instanceId)) {
      return err({
        code: "InstanceAlreadyExists",
        message: `Instance ${instance2.instanceId} already exists`
      });
    }
    this.instances.set(instance2.instanceId, instance2);
    return ok(void 0);
  }
  getInstance(instanceId) {
    const instance2 = this.instances.get(instanceId);
    if (!instance2) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    return ok(instance2);
  }
  unregisterInstance(instanceId) {
    if (!this.instances.has(instanceId)) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    this.instances.delete(instanceId);
    return ok(void 0);
  }
  listInstances() {
    return Array.from(this.instances.values());
  }
  listInstancesByDefinition(definitionId) {
    return Array.from(this.instances.values()).filter(
      (instance2) => instance2.definitionId === definitionId
    );
  }
};
__name(_WindowRegistry, "WindowRegistry");
let WindowRegistry = _WindowRegistry;
const _EventBus = class _EventBus {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  emit(event2, payload) {
    const eventListeners = this.listeners.get(event2);
    if (!eventListeners) return;
    for (const listener of eventListeners) {
      listener(payload);
    }
  }
  on(event2, handler) {
    if (!this.listeners.has(event2)) {
      this.listeners.set(event2, /* @__PURE__ */ new Set());
    }
    const eventListeners = this.listeners.get(event2);
    eventListeners.add(handler);
    return () => {
      eventListeners.delete(handler);
      if (eventListeners.size === 0) {
        this.listeners.delete(event2);
      }
    };
  }
  off(event2, handler) {
    const eventListeners = this.listeners.get(event2);
    if (!eventListeners) return;
    eventListeners.delete(handler);
    if (eventListeners.size === 0) {
      this.listeners.delete(event2);
    }
  }
  once(event2, handler) {
    const onceHandler = /* @__PURE__ */ __name((payload) => {
      handler(payload);
      this.off(event2, onceHandler);
    }, "onceHandler");
    this.on(event2, onceHandler);
  }
};
__name(_EventBus, "EventBus");
let EventBus = _EventBus;
const _StateStore = class _StateStore {
  constructor() {
    this.state = /* @__PURE__ */ new Map();
  }
  set(instanceId, key2, value2) {
    if (!this.state.has(instanceId)) {
      this.state.set(instanceId, /* @__PURE__ */ new Map());
    }
    const instanceState = this.state.get(instanceId);
    instanceState.set(key2, value2);
    return ok(void 0);
  }
  get(instanceId, key2) {
    const instanceState = this.state.get(instanceId);
    if (!instanceState) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    if (!instanceState.has(key2)) {
      return err({
        code: "KeyNotFound",
        message: `Key ${key2} not found for instance ${instanceId}`
      });
    }
    return ok(instanceState.get(key2));
  }
  getAll(instanceId) {
    const instanceState = this.state.get(instanceId);
    if (!instanceState) {
      return ok({});
    }
    const result = {};
    for (const [key2, value2] of instanceState.entries()) {
      result[key2] = value2;
    }
    return ok(result);
  }
  clear(instanceId) {
    this.state.delete(instanceId);
    return ok(void 0);
  }
};
__name(_StateStore, "StateStore");
let StateStore = _StateStore;
const _ActionDispatcher = class _ActionDispatcher {
  constructor(registry) {
    this.registry = registry;
  }
  async dispatch(actionId, context) {
    const instanceResult = this.registry.getInstance(context.windowInstanceId);
    if (!instanceResult.ok) {
      return err(instanceResult.error);
    }
    const definitionResult = this.registry.getDefinition(instanceResult.value.definitionId);
    if (!definitionResult.ok) {
      return err(definitionResult.error);
    }
    const definition = definitionResult.value;
    const action2 = definition.actions?.find((a) => a.id === actionId);
    if (!action2) {
      return err({
        code: "ActionNotFound",
        message: `Action ${actionId} not found`
      });
    }
    const permissionResult = this.checkPermissions(action2, context);
    if (!permissionResult.ok) {
      return err({
        code: "PermissionDenied",
        message: permissionResult.error.message
      });
    }
    const validationResult = this.validateAction(action2, context);
    if (!validationResult.ok) {
      return err({
        code: "ValidationFailed",
        message: validationResult.error.message
      });
    }
    if (action2.confirm) {
      const confirmed = await this.requestConfirmation(action2.confirm);
      if (!confirmed) {
        return err({
          code: "ActionCancelled",
          message: "Action was cancelled by user"
        });
      }
    }
    const result = await action2.handler(context);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(void 0);
  }
  /**
   * Checks if the user has permission to execute the action
   */
  checkPermissions(action2, context) {
    if (!action2.permissions || action2.permissions.length === 0) {
      return ok(void 0);
    }
    for (const permission of action2.permissions) {
      const checkResult = this.checkPermission(permission, context);
      if (!checkResult.ok) {
        return err(checkResult.error);
      }
    }
    return ok(void 0);
  }
  /**
   * Checks a single permission
   */
  checkPermission(permission, context) {
    switch (permission.type) {
      case "user":
        if (typeof game === "undefined" || !game.user?.id) {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        return ok(void 0);
      case "gm":
        if (typeof game === "undefined") {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        const user = game.user;
        if (!user) {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        const isGM = user.isGM === true || user.role >= 4;
        if (!isGM) {
          return err({
            code: "InsufficientPermissions",
            message: "This action requires Game Master permissions"
          });
        }
        return ok(void 0);
      case "custom":
        if (!permission.check) {
          return err({
            code: "InvalidPermission",
            message: "Custom permission check function is not defined"
          });
        }
        const hasPermission = permission.check(context);
        if (!hasPermission) {
          return err({
            code: "InsufficientPermissions",
            message: "Custom permission check failed"
          });
        }
        return ok(void 0);
      default:
        return err({
          code: "UnknownPermissionType",
          message: `Unknown permission type: ${permission.type}`
        });
    }
  }
  /**
   * Validates the action context against validation rules
   */
  validateAction(action2, context) {
    if (!action2.validation || action2.validation.length === 0) {
      return ok(void 0);
    }
    for (const rule of action2.validation) {
      const isValid = rule.validate(context);
      if (!isValid) {
        return err({
          code: "ValidationFailed",
          message: rule.message || "Action validation failed"
        });
      }
    }
    return ok(void 0);
  }
  /**
   * Requests user confirmation before executing the action
   */
  async requestConfirmation(confirm) {
    if (typeof foundry === "undefined" || !foundry.applications?.api?.DialogV2) {
      console.warn("Foundry DialogV2 not available, action confirmation cancelled");
      return false;
    }
    const result = await foundry.applications.api.DialogV2.confirm({
      content: confirm.message,
      rejectClose: false,
      modal: true
    });
    return result === true;
  }
};
__name(_ActionDispatcher, "ActionDispatcher");
_ActionDispatcher.dependencies = [windowRegistryToken];
let ActionDispatcher = _ActionDispatcher;
const _RendererRegistry = class _RendererRegistry {
  constructor() {
    this.renderers = /* @__PURE__ */ new Map();
  }
  register(type, renderer) {
    this.renderers.set(type, renderer);
  }
  get(type) {
    const renderer = this.renderers.get(type);
    if (!renderer) {
      return err({
        code: "RendererNotFound",
        message: `Renderer for type ${type} not found`
      });
    }
    return ok(renderer);
  }
};
__name(_RendererRegistry, "RendererRegistry");
let RendererRegistry = _RendererRegistry;
const _BindingEngine = class _BindingEngine {
  constructor(stateStore, persistAdapter, remoteSyncGate) {
    this.stateStore = stateStore;
    this.persistAdapter = persistAdapter;
    this.remoteSyncGate = remoteSyncGate;
    this.bindings = /* @__PURE__ */ new Map();
    this.debounceTimers = /* @__PURE__ */ new Map();
  }
  initialize(definition, instanceId) {
    const normalized = this.getNormalizedBindings(definition);
    if (!this.bindings.has(instanceId)) {
      this.bindings.set(instanceId, /* @__PURE__ */ new Map());
    }
    const instanceBindings = this.bindings.get(instanceId);
    for (const binding of normalized) {
      instanceBindings.set(binding.id || `${binding.source.key}-binding`, binding);
      this.loadBindingValue(binding.source, instanceId).then((valueResult) => {
        if (valueResult.ok && valueResult.value !== void 0) {
          this.stateStore.set(instanceId, binding.target.stateKey, valueResult.value);
        }
      });
    }
    return ok(void 0);
  }
  async sync(instanceId, policy = "immediate") {
    if (policy === "none") return ok(void 0);
    const instanceBindings = this.bindings.get(instanceId);
    if (!instanceBindings) return ok(void 0);
    for (const binding of instanceBindings.values()) {
      const bindingSyncPolicy = binding.syncPolicy === "manual" ? "none" : binding.syncPolicy;
      const bindingPolicy = bindingSyncPolicy ?? policy;
      if (bindingPolicy === "none") continue;
      if (binding.twoWay) {
        const stateResult = this.stateStore.get(instanceId, binding.target.stateKey);
        if (!stateResult.ok) continue;
        if (bindingPolicy === "debounced") {
          this.scheduleDebouncedSync(
            binding.id || `${binding.source.key}-binding`,
            instanceId,
            binding.source,
            stateResult.value
          );
        } else {
          const saveResult = await this.saveBindingValue(
            binding.source,
            instanceId,
            stateResult.value
          );
          if (!saveResult.ok) return err(saveResult.error);
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Phase 2: Schedules a debounced sync for a binding
   */
  scheduleDebouncedSync(bindingId, instanceId, source2, value2) {
    const timerKey = `${instanceId}:${bindingId}`;
    const existingTimer = this.debounceTimers.get(timerKey);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const instanceBindings = this.bindings.get(instanceId);
    const binding = instanceBindings?.get(bindingId);
    const debounceMs = binding?.debounceMs ?? 300;
    const timer = setTimeout(async () => {
      this.debounceTimers.delete(timerKey);
      const saveResult = await this.saveBindingValue(source2, instanceId, value2);
      if (!saveResult.ok) {
        console.error(`Failed to save debounced binding ${bindingId}:`, saveResult.error);
      }
    }, debounceMs);
    this.debounceTimers.set(timerKey, timer);
  }
  getNormalizedBindings(definition) {
    const normalized = [];
    for (const control of definition.controls || []) {
      if (control.binding) {
        normalized.push({
          ...control.binding,
          id: control.binding.id || `${control.id}-binding`,
          isLocal: true
        });
      }
    }
    for (const binding of definition.bindings || []) {
      normalized.push({
        ...binding,
        isLocal: false
      });
    }
    return normalized;
  }
  /**
   * Phase 2: Loads a binding value from the source
   */
  async loadBindingValue(source2, instanceId) {
    switch (source2.type) {
      case "state":
        return this.stateStore.get(instanceId, source2.key);
      case "setting":
      case "flag":
        if (!this.persistAdapter) {
          return ok(void 0);
        }
        const persistConfig = this.bindingSourceToPersistConfig(source2);
        if (!persistConfig.ok) {
          return err(persistConfig.error);
        }
        const loadResult = await this.persistAdapter.load(persistConfig.value);
        if (!loadResult.ok) {
          return err({
            code: "BindingLoadFailed",
            message: `Failed to load ${source2.type} binding: ${loadResult.error.message}`
          });
        }
        const data = loadResult.value;
        if (source2.key.includes(".")) {
          const keys = source2.key.split(".");
          let current = data;
          for (const key2 of keys) {
            if (current && typeof current === "object" && key2 in current) {
              current = current[key2];
            } else {
              return ok(void 0);
            }
          }
          return ok(current);
        }
        return ok(data[source2.key] ?? data);
      case "journal":
        return ok(void 0);
      default:
        return ok(void 0);
    }
  }
  /**
   * Phase 2: Saves a binding value to the source
   */
  async saveBindingValue(source2, instanceId, value2) {
    switch (source2.type) {
      case "state":
        this.stateStore.set(instanceId, source2.key, value2);
        return ok(void 0);
      case "setting":
      case "flag":
        if (!this.persistAdapter) {
          return ok(void 0);
        }
        const persistConfig = this.bindingSourceToPersistConfig(source2);
        if (!persistConfig.ok) {
          return err(persistConfig.error);
        }
        let data;
        if (source2.key.includes(".")) {
          const keys = source2.key.split(".");
          const nested = {};
          let current = nested;
          for (let i = 0; i < keys.length - 1; i++) {
            const key2 = keys[i];
            if (key2) {
              current[key2] = {};
              current = current[key2];
            }
          }
          const lastKey = keys[keys.length - 1];
          if (lastKey) {
            current[lastKey] = value2;
          }
          data = nested;
        } else {
          data = { [source2.key]: value2 };
        }
        const meta = this.remoteSyncGate?.makePersistMeta(instanceId);
        const saveResult = await this.persistAdapter.save(persistConfig.value, data, meta);
        if (!saveResult.ok) {
          return err({
            code: "BindingSaveFailed",
            message: `Failed to save ${source2.type} binding: ${saveResult.error.message}`
          });
        }
        return ok(void 0);
      case "journal":
        return ok(void 0);
      default:
        return ok(void 0);
    }
  }
  /**
   * Phase 2: Converts BindingSource to PersistConfig
   */
  bindingSourceToPersistConfig(source2) {
    if (source2.type === "setting") {
      if (!source2.namespace) {
        return err({
          code: "InvalidBindingSource",
          message: "Setting binding requires namespace"
        });
      }
      return ok({
        type: "setting",
        key: source2.key,
        namespace: source2.namespace
      });
    }
    if (source2.type === "flag") {
      if (!source2.namespace || !source2.documentId) {
        return err({
          code: "InvalidBindingSource",
          message: "Flag binding requires namespace and documentId"
        });
      }
      return ok({
        type: "flag",
        key: source2.key,
        namespace: source2.namespace,
        documentId: source2.documentId
      });
    }
    return err({
      code: "InvalidBindingSource",
      message: `Cannot convert ${source2.type} to PersistConfig`
    });
  }
};
__name(_BindingEngine, "BindingEngine");
_BindingEngine.dependencies = [stateStoreToken, persistAdapterToken, remoteSyncGateToken];
let BindingEngine = _BindingEngine;
const _RemoteSyncGate = class _RemoteSyncGate {
  constructor() {
    this.OPT_KEY = "windowFrameworkOrigin";
    this.clientId = typeof game !== "undefined" && game.userId ? game.userId : `client-${Date.now()}`;
  }
  makePersistMeta(instanceId) {
    return {
      originClientId: this.clientId,
      originWindowInstanceId: instanceId,
      render: false
      // Kein Foundry-window rerender
    };
  }
  isFromWindow(options, instanceId) {
    if (!options) return false;
    const meta = options[this.OPT_KEY];
    return meta?.originWindowInstanceId === instanceId;
  }
  getClientId() {
    return this.clientId;
  }
};
__name(_RemoteSyncGate, "RemoteSyncGate");
let RemoteSyncGate = _RemoteSyncGate;
const _ViewModelBuilder = class _ViewModelBuilder {
  build(definition, state2, actions) {
    const computed = {};
    return {
      state: state2,
      // StatePort (kann reaktiv sein, z.B. RuneState)
      computed,
      actions
      // i18n und logger werden optional über DI injiziert (später)
    };
  }
};
__name(_ViewModelBuilder, "ViewModelBuilder");
let ViewModelBuilder = _ViewModelBuilder;
const _FoundryApplicationWrapper2 = class _FoundryApplicationWrapper2 {
  static build(definition, controller, instanceId) {
    var _a2;
    const controllerMap = /* @__PURE__ */ new WeakMap();
    const mountedMap = /* @__PURE__ */ new WeakMap();
    const foundryApi = foundry;
    const applicationBase = foundryApi.applications.api.ApplicationV2 ?? class {
    };
    const handlebarsMixin = foundryApi.applications.api.HandlebarsApplicationMixin ?? ((cls) => cls);
    const appClass = (_a2 = class extends handlebarsMixin(applicationBase) {
      constructor(options) {
        super(options);
        const appInstance = this;
        controllerMap.set(appInstance, controller);
        mountedMap.set(appInstance, false);
        if (typeof process !== "undefined" && false) {
          _FoundryApplicationWrapper._testControllerMaps.set(appInstance, controllerMap);
          _FoundryApplicationWrapper._testMountedMaps.set(appInstance, mountedMap);
        }
      }
      // Verwendet _onRender lifecycle method (Best Practice für ApplicationV2)
      // Wird nach dem Rendering aufgerufen, wenn das HTML bereits im DOM ist
      async _onRender(context, options) {
        await super._onRender(
          context,
          options
        );
        const ctrl = controllerMap.get(this);
        const isMounted = mountedMap.get(this) ?? false;
        const element2 = this.element;
        if (ctrl && element2) {
          if (!isMounted) {
            await ctrl.onFoundryRender(element2);
            mountedMap.set(this, true);
          } else {
            await ctrl.onFoundryUpdate(element2);
          }
        }
      }
      async close(options) {
        const ctrl = controllerMap.get(this);
        if (ctrl) {
          await ctrl.onFoundryClose();
        }
        mountedMap.set(this, false);
        await super.close(options);
        return this;
      }
    }, __name(_a2, "appClass"), _a2.DEFAULT_OPTIONS = {
      id: instanceId,
      // WICHTIG: instanceId, nicht definitionId!
      title: definition.title,
      classes: definition.classes || [],
      window: {
        resizable: definition.features?.resizable ?? true,
        minimizable: definition.features?.minimizable ?? true,
        draggable: definition.features?.draggable ?? true
      },
      ...definition.position && {
        position: {
          ...definition.position.top !== void 0 && { top: definition.position.top },
          ...definition.position.left !== void 0 && { left: definition.position.left },
          ...definition.position.width !== void 0 && { width: definition.position.width },
          ...definition.position.height !== void 0 && { height: definition.position.height }
        }
      }
    }, _a2.template = '<div id="svelte-mount-point"></div>', _a2);
    return appClass;
  }
};
__name(_FoundryApplicationWrapper2, "FoundryApplicationWrapper");
_FoundryApplicationWrapper2._testControllerMaps = /* @__PURE__ */ new Map();
_FoundryApplicationWrapper2._testMountedMaps = /* @__PURE__ */ new Map();
let FoundryApplicationWrapper = _FoundryApplicationWrapper2;
const _FoundryWindowAdapter = class _FoundryWindowAdapter {
  buildApplicationWrapper(definition, controller, instanceId) {
    try {
      const appClass = FoundryApplicationWrapper.build(definition, controller, instanceId);
      return ok(appClass);
    } catch (error) {
      return err({
        code: "BuildApplicationFailed",
        message: `Failed to build application wrapper: ${String(error)}`,
        cause: error
      });
    }
  }
  async renderWindow(instance2, force) {
    if (!instance2.foundryApp) {
      return err({
        code: "NoFoundryApp",
        message: "FoundryApp not set on instance"
      });
    }
    try {
      await instance2.foundryApp.render({ force: force ?? false });
      return ok(void 0);
    } catch (error) {
      return err({
        code: "RenderFailed",
        message: `Failed to render window: ${String(error)}`,
        cause: error
      });
    }
  }
  async closeWindow(instance2) {
    if (!instance2.foundryApp) {
      return err({
        code: "NoFoundryApp",
        message: "FoundryApp not set on instance"
      });
    }
    try {
      await instance2.foundryApp.close();
      return ok(void 0);
    } catch (error) {
      return err({
        code: "CloseFailed",
        message: `Failed to close window: ${String(error)}`,
        cause: error
      });
    }
  }
};
__name(_FoundryWindowAdapter, "FoundryWindowAdapter");
let FoundryWindowAdapter = _FoundryWindowAdapter;
const _RuneState = class _RuneState {
  constructor(initial) {
    const $stateResult = castSvelteStateRune();
    if (!$stateResult.ok) {
      throw new Error(`Svelte 5 $state rune not available: ${$stateResult.error.message}`);
    }
    this.runeState = $stateResult.value(initial);
  }
  get() {
    return this.runeState;
  }
  patch(updates) {
    for (const [key2, value2] of Object.entries(updates)) {
      const currentValue = this.runeState[key2];
      if (currentValue !== value2) {
        this.runeState[key2] = value2;
      }
    }
  }
  subscribe(_fn) {
    return () => {
    };
  }
  snapshot() {
    return { ...this.runeState };
  }
};
__name(_RuneState, "RuneState");
let RuneState = _RuneState;
const _RuneStateFactory = class _RuneStateFactory {
  create(instanceId, initial) {
    return new RuneState(initial);
  }
};
__name(_RuneStateFactory, "RuneStateFactory");
let RuneStateFactory = _RuneStateFactory;
const _GlobalDocumentCache = class _GlobalDocumentCache {
  constructor() {
    this.actorsById = (() => {
      const $stateResult = castSvelteStateRune();
      if ($stateResult.ok) {
        return $stateResult.value(/* @__PURE__ */ new Map());
      }
      return /* @__PURE__ */ new Map();
    })();
    this.itemsById = (() => {
      const $stateResult = castSvelteStateRune();
      if ($stateResult.ok) {
        return $stateResult.value(/* @__PURE__ */ new Map());
      }
      return /* @__PURE__ */ new Map();
    })();
    this.itemsByActorId = (() => {
      const $stateResult = castSvelteStateRune();
      if ($stateResult.ok) {
        return $stateResult.value(/* @__PURE__ */ new Map());
      }
      return /* @__PURE__ */ new Map();
    })();
  }
  static getInstance() {
    if (!_GlobalDocumentCache.instance) {
      _GlobalDocumentCache.instance = new _GlobalDocumentCache();
    }
    return _GlobalDocumentCache.instance;
  }
  // Idempotent Patch: nur ändern wenn value differs
  patchActor(actorId, updates) {
    const actor = this.actorsById.get(actorId);
    if (!actor) {
      this.actorsById.set(actorId, { ...updates, id: actorId });
      return;
    }
    let hasChanges = false;
    for (const [key2, value2] of Object.entries(updates)) {
      const typedKey = key2;
      if (actor[typedKey] !== value2) {
        actor[key2] = value2;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      this.actorsById.set(actorId, actor);
    }
  }
  patchItem(itemId, updates) {
    const item = this.itemsById.get(itemId);
    if (!item) {
      this.itemsById.set(itemId, { ...updates, id: itemId });
      if (updates.actorId) {
        const actorItems = this.itemsByActorId.get(updates.actorId) || [];
        if (!actorItems.includes(itemId)) {
          this.itemsByActorId.set(updates.actorId, [...actorItems, itemId]);
        }
      }
      return;
    }
    const oldActorId = item.actorId;
    let hasChanges = false;
    for (const [key2, value2] of Object.entries(updates)) {
      const typedKey = key2;
      if (item[typedKey] !== value2) {
        item[key2] = value2;
        hasChanges = true;
      }
    }
    if (updates.actorId && updates.actorId !== oldActorId) {
      if (oldActorId) {
        const oldActorItems = this.itemsByActorId.get(oldActorId) || [];
        this.itemsByActorId.set(
          oldActorId,
          oldActorItems.filter((id) => id !== itemId)
        );
      }
      const newActorItems = this.itemsByActorId.get(updates.actorId) || [];
      if (!newActorItems.includes(itemId)) {
        this.itemsByActorId.set(updates.actorId, [...newActorItems, itemId]);
      }
    }
    if (hasChanges) {
      this.itemsById.set(itemId, item);
    }
  }
  getActor(actorId) {
    return this.actorsById.get(actorId);
  }
  getItem(itemId) {
    return this.itemsById.get(itemId);
  }
  getItemsByActorId(actorId) {
    return this.itemsByActorId.get(actorId) || [];
  }
};
__name(_GlobalDocumentCache, "GlobalDocumentCache");
_GlobalDocumentCache.instance = null;
let GlobalDocumentCache = _GlobalDocumentCache;
var BROWSER = true;
var DEV = false;
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
__name(is_function, "is_function");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
function is_promise(value2) {
  return typeof value2?.then === "function";
}
__name(is_promise, "is_promise");
function run$2(fn) {
  return fn();
}
__name(run$2, "run$2");
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
__name(run_all, "run_all");
function deferred() {
  var resolve;
  var reject;
  var promise2 = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise: promise2, resolve, reject };
}
__name(deferred, "deferred");
function fallback(value2, fallback2, lazy2 = false) {
  return value2 === void 0 ? lazy2 ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value2;
}
__name(fallback, "fallback");
function to_array(value2, n) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (n === void 0 || !(Symbol.iterator in value2)) {
    return Array.from(value2);
  }
  const array2 = [];
  for (const element2 of value2) {
    array2.push(element2);
    if (array2.length === n) break;
  }
  return array2;
}
__name(to_array, "to_array");
const DERIVED = 1 << 1;
const EFFECT = 1 << 2;
const RENDER_EFFECT = 1 << 3;
const MANAGED_EFFECT = 1 << 24;
const BLOCK_EFFECT = 1 << 4;
const BRANCH_EFFECT = 1 << 5;
const ROOT_EFFECT = 1 << 6;
const BOUNDARY_EFFECT = 1 << 7;
const CONNECTED = 1 << 9;
const CLEAN = 1 << 10;
const DIRTY = 1 << 11;
const MAYBE_DIRTY = 1 << 12;
const INERT = 1 << 13;
const DESTROYED = 1 << 14;
const EFFECT_RAN = 1 << 15;
const EFFECT_TRANSPARENT = 1 << 16;
const EAGER_EFFECT = 1 << 17;
const HEAD_EFFECT = 1 << 18;
const EFFECT_PRESERVED = 1 << 19;
const USER_EFFECT = 1 << 20;
const EFFECT_OFFSCREEN = 1 << 25;
const WAS_MARKED = 1 << 15;
const REACTION_IS_UPDATING = 1 << 21;
const ASYNC = 1 << 22;
const ERROR_VALUE = 1 << 23;
const STATE_SYMBOL = /* @__PURE__ */ Symbol("$state");
const LEGACY_PROPS = /* @__PURE__ */ Symbol("legacy props");
const LOADING_ATTR_SYMBOL = /* @__PURE__ */ Symbol("");
const PROXY_PATH_SYMBOL = /* @__PURE__ */ Symbol("proxy path");
const STALE_REACTION = new (_b = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}, __name(_b, "StaleReactionError"), _b)();
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const DOCUMENT_FRAGMENT_NODE = 11;
function experimental_async_required(name) {
  if (DEV) {
    const error = new Error(`experimental_async_required
Cannot use \`${name}(...)\` unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/experimental_async_required`);
  }
}
__name(experimental_async_required, "experimental_async_required");
function invalid_default_snippet() {
  if (DEV) {
    const error = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
__name(invalid_default_snippet, "invalid_default_snippet");
function invalid_snippet_arguments() {
  if (DEV) {
    const error = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
__name(invalid_snippet_arguments, "invalid_snippet_arguments");
function lifecycle_outside_component(name) {
  if (DEV) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
__name(lifecycle_outside_component, "lifecycle_outside_component");
function missing_context() {
  if (DEV) {
    const error = new Error(`missing_context
Context was not set in a parent component
https://svelte.dev/e/missing_context`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/missing_context`);
  }
}
__name(missing_context, "missing_context");
function snippet_without_render_tag() {
  if (DEV) {
    const error = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
__name(snippet_without_render_tag, "snippet_without_render_tag");
function store_invalid_shape(name) {
  if (DEV) {
    const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
__name(store_invalid_shape, "store_invalid_shape");
function svelte_element_invalid_this_value() {
  if (DEV) {
    const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}
__name(svelte_element_invalid_this_value, "svelte_element_invalid_this_value");
function async_derived_orphan() {
  if (DEV) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
__name(async_derived_orphan, "async_derived_orphan");
function bind_invalid_checkbox_value() {
  if (DEV) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
__name(bind_invalid_checkbox_value, "bind_invalid_checkbox_value");
function bind_invalid_export(component2, key2, name) {
  if (DEV) {
    const error = new Error(`bind_invalid_export
Component ${component2} has an export named \`${key2}\` that a consumer component is trying to access using \`bind:${key2}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${name} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${key2}\`)
https://svelte.dev/e/bind_invalid_export`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_export`);
  }
}
__name(bind_invalid_export, "bind_invalid_export");
function bind_not_bindable(key2, component2, name) {
  if (DEV) {
    const error = new Error(`bind_not_bindable
A component is attempting to bind to a non-bindable property \`${key2}\` belonging to ${component2} (i.e. \`<${name} bind:${key2}={...}>\`). To mark a property as bindable: \`let { ${key2} = $bindable() } = $props()\`
https://svelte.dev/e/bind_not_bindable`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_not_bindable`);
  }
}
__name(bind_not_bindable, "bind_not_bindable");
function component_api_changed(method, component2) {
  if (DEV) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component2}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
__name(component_api_changed, "component_api_changed");
function component_api_invalid_new(component2, name) {
  if (DEV) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
__name(component_api_invalid_new, "component_api_invalid_new");
function derived_references_self() {
  if (DEV) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
__name(derived_references_self, "derived_references_self");
function each_key_duplicate(a, b, value2) {
  if (DEV) {
    const error = new Error(`each_key_duplicate
${value2 ? `Keyed each block has duplicate key \`${value2}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
__name(each_key_duplicate, "each_key_duplicate");
function effect_in_teardown(rune) {
  if (DEV) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
__name(effect_in_teardown, "effect_in_teardown");
function effect_in_unowned_derived() {
  if (DEV) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
__name(effect_in_unowned_derived, "effect_in_unowned_derived");
function effect_orphan(rune) {
  if (DEV) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
__name(effect_orphan, "effect_orphan");
function effect_pending_outside_reaction() {
  if (DEV) {
    const error = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
__name(effect_pending_outside_reaction, "effect_pending_outside_reaction");
function effect_update_depth_exceeded() {
  if (DEV) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function flush_sync_in_effect() {
  if (DEV) {
    const error = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
__name(flush_sync_in_effect, "flush_sync_in_effect");
function fork_discarded() {
  if (DEV) {
    const error = new Error(`fork_discarded
Cannot commit a fork that was already discarded
https://svelte.dev/e/fork_discarded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/fork_discarded`);
  }
}
__name(fork_discarded, "fork_discarded");
function fork_timing() {
  if (DEV) {
    const error = new Error(`fork_timing
Cannot create a fork inside an effect or when state changes are pending
https://svelte.dev/e/fork_timing`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/fork_timing`);
  }
}
__name(fork_timing, "fork_timing");
function get_abort_signal_outside_reaction() {
  if (DEV) {
    const error = new Error(`get_abort_signal_outside_reaction
\`getAbortSignal()\` can only be called inside an effect or derived
https://svelte.dev/e/get_abort_signal_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/get_abort_signal_outside_reaction`);
  }
}
__name(get_abort_signal_outside_reaction, "get_abort_signal_outside_reaction");
function hydratable_missing_but_required(key2) {
  if (DEV) {
    const error = new Error(`hydratable_missing_but_required
Expected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydratable_missing_but_required`);
  }
}
__name(hydratable_missing_but_required, "hydratable_missing_but_required");
function hydration_failed() {
  if (DEV) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
__name(hydration_failed, "hydration_failed");
function invalid_snippet() {
  if (DEV) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
__name(invalid_snippet, "invalid_snippet");
function lifecycle_legacy_only(name) {
  if (DEV) {
    const error = new Error(`lifecycle_legacy_only
\`${name}(...)\` cannot be used in runes mode
https://svelte.dev/e/lifecycle_legacy_only`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`);
  }
}
__name(lifecycle_legacy_only, "lifecycle_legacy_only");
function props_invalid_value(key2) {
  if (DEV) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
__name(props_invalid_value, "props_invalid_value");
function props_rest_readonly(property) {
  if (DEV) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
__name(props_rest_readonly, "props_rest_readonly");
function rune_outside_svelte(rune) {
  if (DEV) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
__name(rune_outside_svelte, "rune_outside_svelte");
function set_context_after_init() {
  if (DEV) {
    const error = new Error(`set_context_after_init
\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression
https://svelte.dev/e/set_context_after_init`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/set_context_after_init`);
  }
}
__name(set_context_after_init, "set_context_after_init");
function state_descriptors_fixed() {
  if (DEV) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
__name(state_descriptors_fixed, "state_descriptors_fixed");
function state_prototype_fixed() {
  if (DEV) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
__name(state_prototype_fixed, "state_prototype_fixed");
function state_unsafe_mutation() {
  if (DEV) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
function svelte_boundary_reset_onerror() {
  if (DEV) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
__name(svelte_boundary_reset_onerror, "svelte_boundary_reset_onerror");
const EACH_ITEM_REACTIVE = 1;
const EACH_INDEX_REACTIVE = 1 << 1;
const EACH_IS_CONTROLLED = 1 << 2;
const EACH_IS_ANIMATED = 1 << 3;
const EACH_ITEM_IMMUTABLE = 1 << 4;
const PROPS_IS_IMMUTABLE = 1;
const PROPS_IS_RUNES = 1 << 1;
const PROPS_IS_UPDATED = 1 << 2;
const PROPS_IS_BINDABLE = 1 << 3;
const PROPS_IS_LAZY_INITIAL = 1 << 4;
const TRANSITION_IN = 1;
const TRANSITION_OUT = 1 << 1;
const TRANSITION_GLOBAL = 1 << 2;
const TEMPLATE_FRAGMENT = 1;
const TEMPLATE_USE_IMPORT_NODE = 1 << 1;
const TEMPLATE_USE_SVG = 1 << 2;
const TEMPLATE_USE_MATHML = 1 << 3;
const HYDRATION_START = "[";
const HYDRATION_START_ELSE = "[!";
const HYDRATION_END = "]";
const HYDRATION_ERROR = {};
const ELEMENT_IS_NAMESPACED = 1;
const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
const ELEMENT_IS_INPUT = 1 << 2;
const UNINITIALIZED = /* @__PURE__ */ Symbol();
const FILENAME = /* @__PURE__ */ Symbol("filename");
const HMR = /* @__PURE__ */ Symbol("hmr");
const NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
const NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
const IGNORABLE_RUNTIME_WARNINGS = (
  /** @type {const} */
  [
    "await_waterfall",
    "await_reactivity_loss",
    "state_snapshot_uncloneable",
    "binding_property_non_reactive",
    "hydration_attribute_changed",
    "hydration_html_changed",
    "ownership_invalid_binding",
    "ownership_invalid_mutation"
  ]
);
const ELEMENTS_WITHOUT_TEXT = ["audio", "datalist", "dl", "optgroup", "select", "video"];
const ATTACHMENT_KEY = "@attach";
var bold$1 = "font-weight: bold";
var normal$1 = "font-weight: normal";
function assignment_value_stale(property, location) {
  if (DEV) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
__name(assignment_value_stale, "assignment_value_stale");
function await_reactivity_loss(name) {
  if (DEV) {
    console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
__name(await_reactivity_loss, "await_reactivity_loss");
function await_waterfall(name, location) {
  if (DEV) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
__name(await_waterfall, "await_waterfall");
function binding_property_non_reactive(binding, location) {
  if (DEV) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
__name(binding_property_non_reactive, "binding_property_non_reactive");
function console_log_state(method) {
  if (DEV) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
__name(console_log_state, "console_log_state");
function event_handler_invalid(handler, suggestion) {
  if (DEV) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
__name(event_handler_invalid, "event_handler_invalid");
function hydratable_missing_but_expected(key2) {
  if (DEV) {
    console.warn(`%c[svelte] hydratable_missing_but_expected
%cExpected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_expected`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/hydratable_missing_but_expected`);
  }
}
__name(hydratable_missing_but_expected, "hydratable_missing_but_expected");
function hydration_attribute_changed(attribute, html2, value2) {
  if (DEV) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value2}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
__name(hydration_attribute_changed, "hydration_attribute_changed");
function hydration_html_changed(location) {
  if (DEV) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
__name(hydration_html_changed, "hydration_html_changed");
function hydration_mismatch(location) {
  if (DEV) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
__name(hydration_mismatch, "hydration_mismatch");
function invalid_raw_snippet_render() {
  if (DEV) {
    console.warn(`%c[svelte] invalid_raw_snippet_render
%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element
https://svelte.dev/e/invalid_raw_snippet_render`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`);
  }
}
__name(invalid_raw_snippet_render, "invalid_raw_snippet_render");
function legacy_recursive_reactive_block(filename) {
  if (DEV) {
    console.warn(`%c[svelte] legacy_recursive_reactive_block
%cDetected a migrated \`$:\` reactive block in \`${filename}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.
https://svelte.dev/e/legacy_recursive_reactive_block`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`);
  }
}
__name(legacy_recursive_reactive_block, "legacy_recursive_reactive_block");
function lifecycle_double_unmount() {
  if (DEV) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
__name(lifecycle_double_unmount, "lifecycle_double_unmount");
function ownership_invalid_binding(parent, prop2, child2, owner) {
  if (DEV) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
__name(ownership_invalid_binding, "ownership_invalid_binding");
function ownership_invalid_mutation(name, location, prop2, parent) {
  if (DEV) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
__name(ownership_invalid_mutation, "ownership_invalid_mutation");
function select_multiple_invalid_value() {
  if (DEV) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
__name(select_multiple_invalid_value, "select_multiple_invalid_value");
function state_proxy_equality_mismatch(operator) {
  if (DEV) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
__name(state_proxy_equality_mismatch, "state_proxy_equality_mismatch");
function state_proxy_unmount() {
  if (DEV) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
__name(state_proxy_unmount, "state_proxy_unmount");
function svelte_boundary_reset_noop() {
  if (DEV) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
__name(svelte_boundary_reset_noop, "svelte_boundary_reset_noop");
function transition_slide_display(value2) {
  if (DEV) {
    console.warn(`%c[svelte] transition_slide_display
%cThe \`slide\` transition does not work correctly for elements with \`display: ${value2}\`
https://svelte.dev/e/transition_slide_display`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/transition_slide_display`);
  }
}
__name(transition_slide_display, "transition_slide_display");
let hydrating = false;
function set_hydrating(value2) {
  hydrating = value2;
}
__name(set_hydrating, "set_hydrating");
let hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(/* @__PURE__ */ get_next_sibling(hydrate_node));
}
__name(hydrate_next, "hydrate_next");
function reset(node) {
  if (!hydrating) return;
  if (/* @__PURE__ */ get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
__name(reset, "reset");
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
__name(hydrate_template, "hydrate_template");
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
__name(next, "next");
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
__name(skip_nodes, "skip_nodes");
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}
__name(read_hydration_instruction, "read_hydration_instruction");
function equals$1(value2) {
  return value2 === this.v;
}
__name(equals$1, "equals$1");
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
__name(safe_not_equal, "safe_not_equal");
function not_equal(a, b) {
  return a !== b;
}
__name(not_equal, "not_equal");
function safe_equals(value2) {
  return !safe_not_equal(value2, this.v);
}
__name(safe_equals, "safe_equals");
let async_mode_flag = false;
let legacy_mode_flag = false;
let tracing_mode_flag = false;
function enable_async_mode_flag() {
  async_mode_flag = true;
}
__name(enable_async_mode_flag, "enable_async_mode_flag");
function disable_async_mode_flag() {
  async_mode_flag = false;
}
__name(disable_async_mode_flag, "disable_async_mode_flag");
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}
__name(enable_legacy_mode_flag, "enable_legacy_mode_flag");
function enable_tracing_mode_flag() {
  tracing_mode_flag = true;
}
__name(enable_tracing_mode_flag, "enable_tracing_mode_flag");
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function dynamic_void_element_content(tag2) {
  if (DEV) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element — it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
__name(dynamic_void_element_content, "dynamic_void_element_content");
function state_snapshot_uncloneable(properties) {
  if (DEV) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` — the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}
__name(state_snapshot_uncloneable, "state_snapshot_uncloneable");
const empty = [];
function snapshot(value2, skip_warning = false, no_tojson = false) {
  if (DEV && !skip_warning) {
    const paths = [];
    const copy = clone(value2, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value2, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
__name(snapshot, "snapshot");
function clone(value2, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value2 === "object" && value2 !== null) {
    var unwrapped = cloned.get(value2);
    if (unwrapped !== void 0) return unwrapped;
    if (value2 instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value2)
    );
    if (value2 instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value2)
    );
    if (is_array(value2)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value2.length)
      );
      cloned.set(value2, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value2.length; i += 1) {
        var element2 = value2[i];
        if (i in value2) {
          copy[i] = clone(element2, cloned, DEV ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value2) === object_prototype) {
      copy = {};
      cloned.set(value2, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key2 in value2) {
        copy[key2] = clone(
          // @ts-expect-error
          value2[key2],
          cloned,
          DEV ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value2 instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value2)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value2.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value2.toJSON(),
        cloned,
        DEV ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value2
      );
    }
  }
  if (value2 instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value2
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value2)
    );
  } catch (e) {
    if (DEV) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value2
    );
  }
}
__name(clone, "clone");
let tracing_expressions = null;
function log_entry(signal, entry) {
  const value2 = signal.v;
  if (value2 === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style,
    dirty ? "font-weight: normal" : style,
    typeof value2 === "object" && value2 !== null && STATE_SYMBOL in value2 ? snapshot(value2, true) : value2
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      if (updated.error) {
        console.log(updated.error);
      }
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
__name(log_entry, "log_entry");
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
__name(get_type, "get_type");
function trace(label2, fn) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value2 = fn();
    var time = (performance.now() - start).toFixed(2);
    var prefix = untrack(label2);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time}ms)`, "color: grey");
      var entries2 = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries2) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value2;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
__name(trace, "trace");
function tag(source2, label2) {
  source2.label = label2;
  tag_proxy(source2.v, label2);
  return source2;
}
__name(tag, "tag");
function tag_proxy(value2, label2) {
  value2?.[PROXY_PATH_SYMBOL]?.(label2);
  return value2;
}
__name(tag_proxy, "tag_proxy");
function label(value2) {
  if (typeof value2 === "symbol") return `Symbol(${value2.description})`;
  if (typeof value2 === "function") return "<function>";
  if (typeof value2 === "object" && value2) return "<object>";
  return String(value2);
}
__name(label, "label");
function get_error(label2) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label2
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
__name(get_error, "get_error");
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}
__name(get_stack, "get_stack");
let component_context = null;
function set_component_context(context) {
  component_context = context;
}
__name(set_component_context, "set_component_context");
let dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
__name(set_dev_stack, "set_dev_stack");
function add_svelte_meta(callback, type, component2, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component2[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
__name(add_svelte_meta, "add_svelte_meta");
let dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
__name(set_dev_current_component_function, "set_dev_current_component_function");
function createContext() {
  const key2 = {};
  return [
    () => {
      if (!hasContext(key2)) {
        missing_context();
      }
      return getContext(key2);
    },
    (context) => setContext(key2, context)
  ];
}
__name(createContext, "createContext");
function getContext(key2) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
__name(getContext, "getContext");
function setContext(key2, context) {
  const context_map = get_or_init_context_map("setContext");
  if (async_mode_flag) {
    var flags2 = (
      /** @type {Effect} */
      active_effect.f
    );
    var valid = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && // pop() runs synchronously, so this indicates we're setting context after an await
    !/** @type {ComponentContext} */
    component_context.i;
    if (!valid) {
      set_context_after_init();
    }
  }
  context_map.set(key2, context);
  return context;
}
__name(setContext, "setContext");
function hasContext(key2) {
  const context_map = get_or_init_context_map("hasContext");
  return context_map.has(key2);
}
__name(hasContext, "hasContext");
function getAllContexts() {
  const context_map = get_or_init_context_map("getAllContexts");
  return (
    /** @type {T} */
    context_map
  );
}
__name(getAllContexts, "getAllContexts");
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (DEV) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
__name(push, "push");
function pop(component2) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  context.i = true;
  component_context = context.p;
  if (DEV) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
__name(pop, "pop");
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
__name(is_runes, "is_runes");
function get_or_init_context_map(name) {
  if (component_context === null) {
    lifecycle_outside_component(name);
  }
  return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
__name(get_or_init_context_map, "get_or_init_context_map");
function get_parent_context(component_context2) {
  let parent = component_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
__name(get_parent_context, "get_parent_context");
let micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
__name(run_micro_tasks, "run_micro_tasks");
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
__name(queue_micro_task, "queue_micro_task");
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
__name(flush_tasks, "flush_tasks");
const adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (DEV && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (DEV && !effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
__name(handle_error, "handle_error");
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (DEV && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
__name(invoke_error_boundary, "invoke_error_boundary");
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
__name(get_adjustments, "get_adjustments");
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}
__name(apply_adjustments, "apply_adjustments");
const batches = /* @__PURE__ */ new Set();
let current_batch = null;
let previous_batch = null;
let batch_values = null;
let queued_root_effects = [];
let last_scheduled_effect = null;
let is_flushing = false;
let is_flushing_sync = false;
const _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    __publicField(this, "committed", false);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __publicField(this, "previous", /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _commit_callbacks, /* @__PURE__ */ new Set());
    /**
     * If a fork is discarded, we need to destroy any effects that are no longer needed
     * @type {Set<(batch: Batch) => void>}
     */
    __privateAdd(this, _discard_callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * The number of async effects that are currently in flight, _not_ inside a pending boundary
     */
    __privateAdd(this, _blocking_pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _dirty_effects, /* @__PURE__ */ new Set());
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _maybe_dirty_effects, /* @__PURE__ */ new Set());
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed — we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
    __publicField(this, "is_fork", false);
  }
  is_deferred() {
    return this.is_fork || __privateGet(this, _blocking_pending) > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const root2 of root_effects) {
      __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root2, target);
    }
    if (!this.is_fork) {
      __privateMethod(this, _Batch_instances, resolve_fn).call(this);
    }
    if (this.is_deferred()) {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
    } else {
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      previous_batch = null;
      __privateGet(this, _deferred)?.resolve();
    }
    batch_values = null;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value2) {
    if (!this.previous.has(source2)) {
      this.previous.set(source2, value2);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values?.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch !== this) return;
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (__privateGet(this, _pending) === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn of __privateGet(this, _discard_callbacks)) fn(this);
    __privateGet(this, _discard_callbacks).clear();
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) + 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) - 1);
    this.revive();
  }
  revive() {
    for (const e of __privateGet(this, _dirty_effects)) {
      __privateGet(this, _maybe_dirty_effects).delete(e);
      set_signal_status(e, DIRTY);
      schedule_effect(e);
    }
    for (const e of __privateGet(this, _maybe_dirty_effects)) {
      set_signal_status(e, MAYBE_DIRTY);
      schedule_effect(e);
    }
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(fn) {
    __privateGet(this, _commit_callbacks).add(fn);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(fn) {
    __privateGet(this, _discard_callbacks).add(fn);
  }
  settled() {
    return (__privateGet(this, _deferred) ?? __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
    batch_values = new Map(this.current);
    for (const batch of batches) {
      if (batch === this) continue;
      for (const [source2, previous] of batch.previous) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
};
_commit_callbacks = new WeakMap();
_discard_callbacks = new WeakMap();
_pending = new WeakMap();
_blocking_pending = new WeakMap();
_deferred = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_Batch_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 * @param {EffectTarget} target
 */
traverse_effect_tree_fn = /* @__PURE__ */ __name(function(root2, target) {
  root2.f ^= CLEAN;
  var effect2 = root2.first;
  while (effect2 !== null) {
    var flags2 = effect2.f;
    var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
    if ((effect2.f & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending()) {
      target = {
        parent: target,
        effect: effect2,
        effects: [],
        render_effects: []
      };
    }
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags2 & EFFECT) !== 0) {
        target.effects.push(effect2);
      } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
        target.render_effects.push(effect2);
      } else if (is_dirty(effect2)) {
        if ((effect2.f & BLOCK_EFFECT) !== 0) __privateGet(this, _dirty_effects).add(effect2);
        update_effect(effect2);
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent !== null) {
      if (parent === target.effect) {
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
        target = /** @type {EffectTarget} */
        target.parent;
      }
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
}, "#traverse_effect_tree");
/**
 * @param {Effect[]} effects
 */
defer_effects_fn = /* @__PURE__ */ __name(function(effects) {
  for (const e of effects) {
    if ((e.f & DIRTY) !== 0) {
      __privateGet(this, _dirty_effects).add(e);
    } else if ((e.f & MAYBE_DIRTY) !== 0) {
      __privateGet(this, _maybe_dirty_effects).add(e);
    }
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(this, e.deps);
    set_signal_status(e, CLEAN);
  }
}, "#defer_effects");
/**
 * @param {Value[] | null} deps
 */
clear_marked_fn = /* @__PURE__ */ __name(function(deps) {
  if (deps === null) return;
  for (const dep of deps) {
    if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
      continue;
    }
    dep.f ^= WAS_MARKED;
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(
      this,
      /** @type {Derived} */
      dep.deps
    );
  }
}, "#clear_marked");
resolve_fn = /* @__PURE__ */ __name(function() {
  if (__privateGet(this, _blocking_pending) === 0) {
    for (const fn of __privateGet(this, _commit_callbacks)) fn();
    __privateGet(this, _commit_callbacks).clear();
  }
  if (__privateGet(this, _pending) === 0) {
    __privateMethod(this, _Batch_instances, commit_fn).call(this);
  }
}, "#resolve");
commit_fn = /* @__PURE__ */ __name(function() {
  var _a2;
  if (batches.size > 1) {
    this.previous.clear();
    var previous_batch_values = batch_values;
    var is_earlier = true;
    var dummy_target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const batch of batches) {
      if (batch === this) {
        is_earlier = false;
        continue;
      }
      const sources = [];
      for (const [source2, value2] of this.current) {
        if (batch.current.has(source2)) {
          if (is_earlier && value2 !== batch.current.get(source2)) {
            batch.current.set(source2, value2);
          } else {
            continue;
          }
        }
        sources.push(source2);
      }
      if (sources.length === 0) {
        continue;
      }
      const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
      if (others.length > 0) {
        var prev_queued_root_effects = queued_root_effects;
        queued_root_effects = [];
        const marked = /* @__PURE__ */ new Set();
        const checked = /* @__PURE__ */ new Map();
        for (const source2 of sources) {
          mark_effects(source2, others, marked, checked);
        }
        if (queued_root_effects.length > 0) {
          current_batch = batch;
          batch.apply();
          for (const root2 of queued_root_effects) {
            __privateMethod(_a2 = batch, _Batch_instances, traverse_effect_tree_fn).call(_a2, root2, dummy_target);
          }
          batch.deactivate();
        }
        queued_root_effects = prev_queued_root_effects;
      }
    }
    current_batch = null;
    batch_values = previous_batch_values;
  }
  this.committed = true;
  batches.delete(this);
}, "#commit");
__name(_Batch, "Batch");
let Batch = _Batch;
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
__name(flushSync, "flushSync");
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = DEV ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (DEV) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (DEV) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (DEV) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
__name(flush_effects, "flush_effects");
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (DEV) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
__name(infinite_loop_guard, "infinite_loop_guard");
let eager_block_effects = null;
function flush_queued_effects(effects) {
  var length2 = effects.length;
  if (length2 === 0) return;
  var i = 0;
  while (i < length2) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
__name(flush_queued_effects, "flush_queued_effects");
function mark_effects(value2, sources, marked, checked) {
  if (marked.has(value2)) return;
  marked.add(value2);
  if (value2.reactions !== null) {
    for (const reaction of value2.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_effects, "mark_effects");
function mark_eager_effects(value2, effects) {
  if (value2.reactions === null) return;
  for (const reaction of value2.reactions) {
    const flags2 = reaction.f;
    if ((flags2 & DERIVED) !== 0) {
      mark_eager_effects(
        /** @type {Derived} */
        reaction,
        effects
      );
    } else if ((flags2 & EAGER_EFFECT) !== 0) {
      set_signal_status(reaction, DIRTY);
      effects.add(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_eager_effects, "mark_eager_effects");
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
__name(depends_on, "depends_on");
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
__name(schedule_effect, "schedule_effect");
let eager_versions = [];
function eager_flush() {
  try {
    flushSync(() => {
      for (const version of eager_versions) {
        update(version);
      }
    });
  } finally {
    eager_versions = [];
  }
}
__name(eager_flush, "eager_flush");
function eager(fn) {
  var version = source(0);
  var initial = true;
  var value2 = (
    /** @type {T} */
    void 0
  );
  get$1(version);
  eager_effect(() => {
    if (initial) {
      var previous_batch_values = batch_values;
      try {
        batch_values = null;
        value2 = fn();
      } finally {
        batch_values = previous_batch_values;
      }
      return;
    }
    if (eager_versions.length === 0) {
      queue_micro_task(eager_flush);
    }
    eager_versions.push(version);
  });
  initial = false;
  return value2;
}
__name(eager, "eager");
function fork(fn) {
  if (!async_mode_flag) {
    experimental_async_required("fork");
  }
  if (current_batch !== null) {
    fork_timing();
  }
  var batch = Batch.ensure();
  batch.is_fork = true;
  batch_values = /* @__PURE__ */ new Map();
  var committed = false;
  var settled2 = batch.settled();
  flushSync(fn);
  batch_values = null;
  for (var [source2, value2] of batch.previous) {
    source2.v = value2;
  }
  return {
    commit: /* @__PURE__ */ __name(async () => {
      if (committed) {
        await settled2;
        return;
      }
      if (!batches.has(batch)) {
        fork_discarded();
      }
      committed = true;
      batch.is_fork = false;
      for (var [source3, value3] of batch.current) {
        source3.v = value3;
      }
      flushSync(() => {
        var eager_effects2 = /* @__PURE__ */ new Set();
        for (var source4 of batch.current.keys()) {
          mark_eager_effects(source4, eager_effects2);
        }
        set_eager_effects(eager_effects2);
        flush_eager_effects();
      });
      batch.revive();
      await settled2;
    }, "commit"),
    discard: /* @__PURE__ */ __name(() => {
      if (!committed && batches.has(batch)) {
        batches.delete(batch);
        batch.discard();
      }
    }, "discard")
  };
}
__name(fork, "fork");
function clear() {
  batches.clear();
}
__name(clear, "clear");
function createSubscriber(start) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (DEV) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get$1(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}
__name(createSubscriber, "createSubscriber");
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
__name(boundary, "boundary");
const _Boundary = class _Boundary {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    __privateAdd(this, _Boundary_instances);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    __privateAdd(this, _pending2, false);
    /** @type {TemplateNode} */
    __privateAdd(this, _anchor);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _hydrate_open, hydrating ? hydrate_node : null);
    /** @type {BoundaryProps} */
    __privateAdd(this, _props);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _children);
    /** @type {Effect} */
    __privateAdd(this, _effect);
    /** @type {Effect | null} */
    __privateAdd(this, _main_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _pending_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _failed_effect, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _offscreen_fragment, null);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _pending_anchor, null);
    __privateAdd(this, _local_pending_count, 0);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _local_pending_count)));
      if (DEV) {
        tag(__privateGet(this, _effect_pending), "$effect.pending()");
      }
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children);
    this.parent = /** @type {Effect} */
    active_effect.b;
    __privateSet(this, _pending2, !!__privateGet(this, _props).pending);
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment2 = __privateGet(this, _hydrate_open);
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment2.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          __privateMethod(this, _Boundary_instances, hydrate_pending_content_fn).call(this);
        } else {
          __privateMethod(this, _Boundary_instances, hydrate_resolved_content_fn).call(this);
        }
      } else {
        var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
        try {
          __privateSet(this, _main_effect, branch(() => children(anchor)));
        } catch (error) {
          this.error(error);
        }
        if (__privateGet(this, _pending_count) > 0) {
          __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
        } else {
          __privateSet(this, _pending2, false);
        }
      }
      return () => {
        __privateGet(this, _pending_anchor)?.remove();
      };
    }, flags));
    if (hydrating) {
      __privateSet(this, _anchor, hydrate_node);
    }
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return __privateGet(this, _pending2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    __privateMethod(this, _Boundary_instances, update_pending_count_fn).call(this, d);
    __privateSet(this, _local_pending_count, __privateGet(this, _local_pending_count) + d);
    if (__privateGet(this, _effect_pending)) {
      internal_set(__privateGet(this, _effect_pending), __privateGet(this, _local_pending_count));
    }
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get$1(
      /** @type {Source<number>} */
      __privateGet(this, _effect_pending)
    );
  }
  /** @param {unknown} error */
  error(error) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) {
      throw error;
    }
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        __privateGet(this, _hydrate_open)
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = /* @__PURE__ */ __name(() => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      __privateSet(this, _local_pending_count, 0);
      if (__privateGet(this, _failed_effect) !== null) {
        pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
      }
      __privateSet(this, _pending2, this.has_pending_snippet());
      __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        __privateSet(this, _is_creating_fallback, false);
        return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
      }));
      if (__privateGet(this, _pending_count) > 0) {
        __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
      } else {
        __privateSet(this, _pending2, false);
      }
    }, "reset");
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error, reset2);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        __privateSet(this, _failed_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
          Batch.ensure();
          __privateSet(this, _is_creating_fallback, true);
          try {
            return branch(() => {
              failed(
                __privateGet(this, _anchor),
                () => error,
                () => reset2
              );
            });
          } catch (error2) {
            invoke_error_boundary(
              error2,
              /** @type {Effect} */
              __privateGet(this, _effect).parent
            );
            return null;
          } finally {
            __privateSet(this, _is_creating_fallback, false);
          }
        }));
      });
    }
  }
};
_pending2 = new WeakMap();
_anchor = new WeakMap();
_hydrate_open = new WeakMap();
_props = new WeakMap();
_children = new WeakMap();
_effect = new WeakMap();
_main_effect = new WeakMap();
_pending_effect = new WeakMap();
_failed_effect = new WeakMap();
_offscreen_fragment = new WeakMap();
_pending_anchor = new WeakMap();
_local_pending_count = new WeakMap();
_pending_count = new WeakMap();
_is_creating_fallback = new WeakMap();
_effect_pending = new WeakMap();
_effect_pending_subscriber = new WeakMap();
_Boundary_instances = new WeakSet();
hydrate_resolved_content_fn = /* @__PURE__ */ __name(function() {
  try {
    __privateSet(this, _main_effect, branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor))));
  } catch (error) {
    this.error(error);
  }
  __privateSet(this, _pending2, false);
}, "#hydrate_resolved_content");
hydrate_pending_content_fn = /* @__PURE__ */ __name(function() {
  const pending2 = __privateGet(this, _props).pending;
  if (!pending2) {
    return;
  }
  __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  Batch.enqueue(() => {
    var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
    __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
      Batch.ensure();
      return branch(() => __privateGet(this, _children).call(this, anchor));
    }));
    if (__privateGet(this, _pending_count) > 0) {
      __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
    } else {
      pause_effect(
        /** @type {Effect} */
        __privateGet(this, _pending_effect),
        () => {
          __privateSet(this, _pending_effect, null);
        }
      );
      __privateSet(this, _pending2, false);
    }
  });
}, "#hydrate_pending_content");
get_anchor_fn = /* @__PURE__ */ __name(function() {
  var anchor = __privateGet(this, _anchor);
  if (__privateGet(this, _pending2)) {
    __privateSet(this, _pending_anchor, create_text());
    __privateGet(this, _anchor).before(__privateGet(this, _pending_anchor));
    anchor = __privateGet(this, _pending_anchor);
  }
  return anchor;
}, "#get_anchor");
/**
 * @param {() => Effect | null} fn
 */
run_fn = /* @__PURE__ */ __name(function(fn) {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn();
  } catch (e2) {
    handle_error(e2);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
}, "#run");
show_pending_snippet_fn = /* @__PURE__ */ __name(function() {
  const pending2 = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _props).pending
  );
  if (__privateGet(this, _main_effect) !== null) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    __privateGet(this, _offscreen_fragment).append(
      /** @type {TemplateNode} */
      __privateGet(this, _pending_anchor)
    );
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (__privateGet(this, _pending_effect) === null) {
    __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  }
}, "#show_pending_snippet");
/**
 * Updates the pending count associated with the currently visible pending snippet,
 * if any, such that we can replace the snippet with content once work is done
 * @param {1 | -1} d
 */
update_pending_count_fn = /* @__PURE__ */ __name(function(d) {
  var _a2;
  if (!this.has_pending_snippet()) {
    if (this.parent) {
      __privateMethod(_a2 = this.parent, _Boundary_instances, update_pending_count_fn).call(_a2, d);
    }
    return;
  }
  __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d);
  if (__privateGet(this, _pending_count) === 0) {
    __privateSet(this, _pending2, false);
    if (__privateGet(this, _pending_effect)) {
      pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
    }
    if (__privateGet(this, _offscreen_fragment)) {
      __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
      __privateSet(this, _offscreen_fragment, null);
    }
  }
}, "#update_pending_count");
__name(_Boundary, "Boundary");
let Boundary = _Boundary;
function get_boundary() {
  return (
    /** @type {Boundary} */
    /** @type {Effect} */
    active_effect.b
  );
}
__name(get_boundary, "get_boundary");
function pending$1() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}
__name(pending$1, "pending$1");
function flatten(blockers, sync, async2, fn) {
  const d = is_runes() ? derived$1 : derived_safe_equal;
  if (async2.length === 0 && blockers.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  function run2() {
    Promise.all(async2.map((expression) => /* @__PURE__ */ async_derived(expression))).then((result) => {
      restore();
      try {
        fn([...sync.map(d), ...result]);
      } catch (error) {
        if ((parent.f & DESTROYED) === 0) {
          invoke_error_boundary(error, parent);
        }
      }
      batch?.deactivate();
      unset_context();
    }).catch((error) => {
      invoke_error_boundary(error, parent);
    });
  }
  __name(run2, "run");
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run2();
      } finally {
        batch?.deactivate();
        unset_context();
      }
    });
  } else {
    run2();
  }
}
__name(flatten, "flatten");
function run_after_blockers(blockers, fn) {
  flatten(blockers, [], [], fn);
}
__name(run_after_blockers, "run_after_blockers");
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (DEV) {
    var previous_dev_stack = dev_stack;
  }
  return /* @__PURE__ */ __name(function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) previous_batch2?.activate();
    if (DEV) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  }, "restore");
}
__name(capture, "capture");
async function save(promise2) {
  var restore = capture();
  var value2 = await promise2;
  return () => {
    restore();
    return value2;
  };
}
__name(save, "save");
async function track_reactivity_loss(promise2) {
  var previous_async_effect = current_async_effect;
  var value2 = await promise2;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value2;
  };
}
__name(track_reactivity_loss, "track_reactivity_loss");
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value: value2 } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value2;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
__name(for_await_track_reactivity_loss, "for_await_track_reactivity_loss");
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (DEV) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}
__name(unset_context, "unset_context");
async function async_body(anchor, fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var was_hydrating = hydrating;
  var next_hydrate_node = void 0;
  if (was_hydrating) {
    hydrate_next();
    next_hydrate_node = skip_nodes(false);
  }
  try {
    var promise2 = fn(anchor);
  } finally {
    if (next_hydrate_node) {
      set_hydrate_node(next_hydrate_node);
      hydrate_next();
    }
  }
  try {
    await promise2;
  } catch (error) {
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  } finally {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
    unset_context();
  }
}
__name(async_body, "async_body");
function run$1(thunks) {
  const restore = capture();
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var errored = null;
  const handle_error2 = /* @__PURE__ */ __name((error) => {
    errored = { error };
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  }, "handle_error");
  var promise2 = Promise.resolve(thunks[0]()).catch(handle_error2);
  var promises = [promise2];
  for (const fn of thunks.slice(1)) {
    promise2 = promise2.then(() => {
      if (errored) {
        throw errored.error;
      }
      if (aborted(active)) {
        throw STALE_REACTION;
      }
      try {
        restore();
        return fn();
      } finally {
        unset_context();
      }
    }).catch(handle_error2).finally(() => {
      unset_context();
    });
    promises.push(promise2);
  }
  promise2.then(() => Promise.resolve()).finally(() => {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
  });
  return promises;
}
__name(run$1, "run$1");
let current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
__name(set_from_async_derived, "set_from_async_derived");
const recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived$1(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals: equals$1,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (DEV && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
__name(derived$1, "derived$1");
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise2 = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    if (DEV) current_async_effect = active_effect;
    var d = deferred();
    promise2 = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (DEV) current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      deferreds.get(batch)?.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d);
    }
    const handler = /* @__PURE__ */ __name((value2, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value2);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (DEV && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    }, "handler");
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (DEV) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise2) {
          fulfil(signal);
        } else {
          next2(promise2);
        }
      }
      __name(go, "go");
      p.then(go, go);
    }
    __name(next2, "next");
    next2(promise2);
  });
}
__name(async_derived, "async_derived");
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived$1(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
__name(user_derived, "user_derived");
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived$1(fn);
  signal.equals = safe_equals;
  return signal;
}
__name(derived_safe_equal, "derived_safe_equal");
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
__name(destroy_derived_effects, "destroy_derived_effects");
let stack = [];
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
__name(get_derived_parent_effect, "get_derived_parent_effect");
function execute_derived(derived2) {
  var value2;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (DEV) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value2 = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value2 = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value2;
}
__name(execute_derived, "execute_derived");
function update_derived(derived2) {
  var value2 = execute_derived(derived2);
  if (!derived2.equals(value2)) {
    if (!current_batch?.is_fork) {
      derived2.v = value2;
    }
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived2, value2);
    }
  } else {
    var status = (derived2.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
__name(update_derived, "update_derived");
let eager_effects = /* @__PURE__ */ new Set();
const old_values = /* @__PURE__ */ new Map();
function set_eager_effects(v) {
  eager_effects = v;
}
__name(set_eager_effects, "set_eager_effects");
let eager_effects_deferred = false;
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
__name(set_eager_effects_deferred, "set_eager_effects_deferred");
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals: equals$1,
    rv: 0,
    wv: 0
  };
  if (DEV && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
__name(source, "source");
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
__name(state, "state");
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a2;
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_a2 = component_context.l).s ?? (_a2.s = [])).push(s);
  }
  return s;
}
__name(mutable_source, "mutable_source");
function mutate(source2, value2) {
  set(
    source2,
    untrack(() => get$1(source2))
  );
  return value2;
}
__name(mutate, "mutate");
function set(source2, value2, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value2) : value2;
  if (DEV) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
__name(set, "set");
function internal_set(source2, value2) {
  if (!source2.equals(value2)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value2);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value2;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (DEV) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ?? (source2.updated = /* @__PURE__ */ new Map());
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value2;
}
__name(internal_set, "internal_set");
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
__name(flush_eager_effects, "flush_eager_effects");
function update(source2, d = 1) {
  var value2 = get$1(source2);
  var result = d === 1 ? value2++ : value2--;
  set(source2, value2);
  return result;
}
__name(update, "update");
function update_pre(source2, d = 1) {
  var value2 = get$1(source2);
  return set(source2, d === 1 ? ++value2 : --value2);
}
__name(update_pre, "update_pre");
function increment(source2) {
  set(source2, source2.v + 1);
}
__name(increment, "increment");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length2 = reactions.length;
  for (var i = 0; i < length2; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (DEV && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived2 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived2);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived2, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_reactions, "mark_reactions");
const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value2) {
  if (typeof value2 !== "object" || value2 === null || STATE_SYMBOL in value2) {
    return value2;
  }
  const prototype = get_prototype_of(value2);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value2;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value2);
  var version = /* @__PURE__ */ state(0);
  var stack2 = DEV && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = /* @__PURE__ */ __name((fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  }, "with_parent");
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value2.length,
      stack2
    ));
    if (DEV) {
      value2 = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value2
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  __name(update_path, "update_path");
  return new Proxy(
    /** @type {any} */
    value2,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = /* @__PURE__ */ state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (DEV && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (DEV) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value2;
        }
        if (DEV && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = /* @__PURE__ */ state(p, stack2);
            if (DEV) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get$1(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get$1(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value3 = source2?.v;
          if (source2 !== void 0 && value3 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value3,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = /* @__PURE__ */ state(p, stack2);
              if (DEV) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value3 = get$1(s);
          if (value3 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value3, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value3; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (DEV) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => /* @__PURE__ */ state(void 0, stack2));
            if (DEV) {
              tag(s, get_label(path, prop2));
            }
            set(s, proxy(value3));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value3));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value3);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get$1(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
__name(proxy, "proxy");
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
__name(get_label, "get_label");
function get_proxied_value(value2) {
  try {
    if (value2 !== null && typeof value2 === "object" && STATE_SYMBOL in value2) {
      return value2[STATE_SYMBOL];
    }
  } catch {
  }
  return value2;
}
__name(get_proxied_value, "get_proxied_value");
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
__name(is, "is");
const ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array2) {
  return new Proxy(array2, {
    get(target, prop2, receiver) {
      var value2 = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value2;
      }
      return function(...args2) {
        set_eager_effects_deferred();
        var result = value2.apply(this, args2);
        flush_eager_effects();
        return result;
      };
    }
  });
}
__name(inspectable_array, "inspectable_array");
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes: includes2 } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes2.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes2;
  };
}
__name(init_array_prototype_warnings, "init_array_prototype_warnings");
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
__name(strict_equals, "strict_equals");
function equals(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}
__name(equals, "equals");
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (DEV) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
__name(init_operations, "init_operations");
function create_text(value2 = "") {
  return document.createTextNode(value2);
}
__name(create_text, "create_text");
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return (
    /** @type {TemplateNode | null} */
    first_child_getter.call(node)
  );
}
__name(get_first_child, "get_first_child");
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return (
    /** @type {TemplateNode | null} */
    next_sibling_getter.call(node)
  );
}
__name(get_next_sibling, "get_next_sibling");
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = /* @__PURE__ */ get_first_child(hydrate_node);
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
__name(child, "child");
function first_child(node, is_text = false) {
  if (!hydrating) {
    var first = /* @__PURE__ */ get_first_child(node);
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    hydrate_node?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
__name(first_child, "first_child");
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}
__name(sibling, "sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}
__name(should_defer_append, "should_defer_append");
function create_element(tag2, namespace, is2) {
  let options = is2 ? { is: is2 } : void 0;
  if (namespace) {
    return document.createElementNS(namespace, tag2, options);
  }
  return document.createElement(tag2, options);
}
__name(create_element, "create_element");
function create_fragment() {
  return document.createDocumentFragment();
}
__name(create_fragment, "create_fragment");
function create_comment(data = "") {
  return document.createComment(data);
}
__name(create_comment, "create_comment");
function set_attribute$1(element2, key2, value2 = "") {
  if (key2.startsWith("xlink:")) {
    element2.setAttributeNS("http://www.w3.org/1999/xlink", key2, value2);
    return;
  }
  return element2.setAttribute(key2, value2);
}
__name(set_attribute$1, "set_attribute$1");
function autofocus(dom, value2) {
  if (value2) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
__name(autofocus, "autofocus");
function remove_textarea_child(dom) {
  if (hydrating && /* @__PURE__ */ get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
__name(remove_textarea_child, "remove_textarea_child");
let listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}
__name(add_form_reset_listener, "add_form_reset_listener");
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
__name(listen, "listen");
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(without_reactive_context, "without_reactive_context");
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}
__name(listen_to_event_and_reset_event, "listen_to_event_and_reset_event");
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
__name(validate_effect, "validate_effect");
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn, sync) {
  var parent = active_effect;
  if (DEV) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (DEV) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e3) {
      destroy_effect(effect2);
      throw e3;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e2 = effect2;
  if (sync && e2.deps === null && e2.teardown === null && e2.nodes === null && e2.first === e2.last && // either `null`, or a singular child
  (e2.f & EFFECT_PRESERVED) === 0) {
    e2 = e2.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e2 !== null) {
      e2.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e2 !== null) {
    e2.parent = parent;
    if (parent !== null) {
      push_effect(e2, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.effects ?? (derived2.effects = [])).push(e2);
    }
  }
  return effect2;
}
__name(create_effect, "create_effect");
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
__name(effect_tracking, "effect_tracking");
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
__name(teardown, "teardown");
function user_effect(fn) {
  validate_effect("$effect");
  if (DEV) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    (context.e ?? (context.e = [])).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
__name(user_effect, "user_effect");
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
__name(create_user_effect, "create_user_effect");
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (DEV) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
__name(user_pre_effect, "user_pre_effect");
function eager_effect(fn) {
  return create_effect(EAGER_EFFECT, fn, true);
}
__name(eager_effect, "eager_effect");
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
__name(effect_root, "effect_root");
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
__name(component_root, "component_root");
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
__name(effect, "effect");
function legacy_pre_effect(deps, fn) {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn);
  });
}
__name(legacy_pre_effect, "legacy_pre_effect");
function legacy_pre_effect_reset() {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
__name(legacy_pre_effect_reset, "legacy_pre_effect_reset");
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
__name(async_effect, "async_effect");
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
__name(render_effect, "render_effect");
function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values2) => {
    create_effect(RENDER_EFFECT, () => fn(...values2.map(get$1)), true);
  });
}
__name(template_effect, "template_effect");
function deferred_template_effect(fn, sync = [], async2 = [], blockers = []) {
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var is_async = async2.length > 0 || blockers.length > 0;
  if (is_async) batch.increment(true);
  flatten(blockers, sync, async2, (values2) => {
    create_effect(EFFECT, () => fn(...values2.map(get$1)), false);
    if (is_async) batch.decrement(true);
  });
}
__name(deferred_template_effect, "deferred_template_effect");
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (DEV) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
__name(block, "block");
function managed(fn, flags2 = 0) {
  var effect2 = create_effect(MANAGED_EFFECT | flags2, fn, true);
  if (DEV) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
__name(managed, "managed");
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
__name(branch, "branch");
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes !== null && effect2.nodes.end !== null) {
    remove_effect_dom(
      effect2.nodes.start,
      /** @type {TemplateNode} */
      effect2.nodes.end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (DEV) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}
__name(destroy_effect, "destroy_effect");
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
__name(remove_effect_dom, "remove_effect_dom");
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
__name(unlink_effect, "unlink_effect");
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn = /* @__PURE__ */ __name(() => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  }, "fn");
  var remaining = transitions.length;
  if (remaining > 0) {
    var check2 = /* @__PURE__ */ __name(() => --remaining || fn(), "check");
    for (var transition2 of transitions) {
      transition2.out(check2);
    }
  } else {
    fn();
  }
}
__name(pause_effect, "pause_effect");
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
__name(pause_children, "pause_children");
function resume_effect(effect2) {
  resume_children(effect2, true);
}
__name(resume_effect, "resume_effect");
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
__name(resume_children, "resume_children");
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}
__name(aborted, "aborted");
function move_effect(effect2, fragment) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  while (node !== null) {
    var next2 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}
__name(move_effect, "move_effect");
let captured_signals = null;
function capture_signals(fn) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
__name(capture_signals, "capture_signals");
function invalidate_inner_signals(fn) {
  for (var signal of capture_signals(fn)) {
    internal_set(signal, signal.v);
  }
}
__name(invalidate_inner_signals, "invalidate_inner_signals");
let is_updating_effect = false;
function set_is_updating_effect(value2) {
  is_updating_effect = value2;
}
__name(set_is_updating_effect, "set_is_updating_effect");
let is_destroying_effect = false;
function set_is_destroying_effect(value2) {
  is_destroying_effect = value2;
}
__name(set_is_destroying_effect, "set_is_destroying_effect");
let active_reaction = null;
let untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
let active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
__name(set_active_effect, "set_active_effect");
let current_sources = null;
function push_reaction_value(value2) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value2];
    } else {
      current_sources.push(value2);
    }
  }
}
__name(push_reaction_value, "push_reaction_value");
let new_deps = null;
let skipped_deps = 0;
let untracked_writes = null;
function set_untracked_writes(value2) {
  untracked_writes = value2;
}
__name(set_untracked_writes, "set_untracked_writes");
let write_version = 1;
let read_version = 0;
let update_version = read_version;
function set_update_version(value2) {
  update_version = value2;
}
__name(set_update_version, "set_update_version");
function increment_write_version() {
  return ++write_version;
}
__name(increment_write_version, "increment_write_version");
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length2 = dependencies.length;
      for (var i = 0; i < length2; i++) {
        var dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(is_dirty, "is_dirty");
function schedule_possible_effect_self_invalidation(signal, effect2, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(schedule_possible_effect_self_invalidation, "schedule_possible_effect_self_invalidation");
function update_reaction(reaction) {
  var _a2;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          ((_a2 = deps[i]).reactions ?? (_a2.reactions = [])).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (DEV) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (DEV && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (DEV) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
__name(update_effect, "update_effect");
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
__name(tick, "tick");
function settled() {
  return Batch.ensure().settled();
}
__name(settled, "settled");
function get$1(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ?? (active_reaction.deps = [])).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (DEV) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived2 = (
        /** @type {Derived} */
        signal
      );
      var value2 = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value2 = execute_derived(derived2);
      }
      old_values.set(derived2, value2);
      return value2;
    }
  } else if (is_derived && (!batch_values?.has(signal) || current_batch?.is_fork && !effect_tracking())) {
    derived2 = /** @type {Derived} */
    signal;
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
    if (is_updating_effect && effect_tracking() && (derived2.f & CONNECTED) === 0) {
      reconnect(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
__name(get$1, "get$1");
function reconnect(derived2) {
  if (derived2.deps === null) return;
  derived2.f ^= CONNECTED;
  for (const dep of derived2.deps) {
    (dep.reactions ?? (dep.reactions = [])).push(derived2);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
__name(reconnect, "reconnect");
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
__name(depends_on_old_values, "depends_on_old_values");
function safe_get(signal) {
  return signal && get$1(signal);
}
__name(safe_get, "safe_get");
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
__name(untrack, "untrack");
const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  for (var symbol2 of Object.getOwnPropertySymbols(obj)) {
    if (Object.propertyIsEnumerable.call(obj, symbol2) && !keys.includes(symbol2)) {
      result[symbol2] = obj[symbol2];
    }
  }
  return result;
}
__name(exclude_from_object, "exclude_from_object");
function deep_read_state(value2) {
  if (typeof value2 !== "object" || !value2 || value2 instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value2) {
    deep_read(value2);
  } else if (!Array.isArray(value2)) {
    for (let key2 in value2) {
      const prop2 = value2[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
__name(deep_read_state, "deep_read_state");
function deep_read(value2, visited = /* @__PURE__ */ new Set()) {
  if (typeof value2 === "object" && value2 !== null && // We don't want to traverse DOM elements
  !(value2 instanceof EventTarget) && !visited.has(value2)) {
    visited.add(value2);
    if (value2 instanceof Date) {
      value2.getTime();
    }
    for (let key2 in value2) {
      try {
        deep_read(value2[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value2);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get2 = descriptors[key2].get;
        if (get2) {
          try {
            get2.call(value2);
          } catch (e) {
          }
        }
      }
    }
  }
}
__name(deep_read, "deep_read");
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}
__name(createAttachmentKey, "createAttachmentKey");
function fromAction(action2, fn = (
  /** @type {() => T} */
  noop
)) {
  return (element2) => {
    const { update: update2, destroy } = untrack(() => action2(element2, fn()) ?? {});
    if (update2) {
      var ran = false;
      render_effect(() => {
        const arg = fn();
        if (ran) update2(arg);
      });
      ran = true;
    }
    if (destroy) {
      teardown(destroy);
    }
  };
}
__name(fromAction, "fromAction");
const regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
__name(hash, "hash");
const VOID_ELEMENT_NAMES = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
__name(is_void, "is_void");
const RESERVED_WORDS = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
function is_reserved(word) {
  return RESERVED_WORDS.includes(word);
}
__name(is_reserved, "is_reserved");
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
__name(is_capture_event, "is_capture_event");
const DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
__name(can_delegate_event, "can_delegate_event");
const DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
__name(is_boolean_attribute, "is_boolean_attribute");
const ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
__name(normalize_attribute, "normalize_attribute");
const DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
function is_dom_property(name) {
  return DOM_PROPERTIES.includes(name);
}
__name(is_dom_property, "is_dom_property");
const NON_STATIC_PROPERTIES = ["autofocus", "muted", "defaultValue", "defaultChecked"];
function cannot_be_set_statically(name) {
  return NON_STATIC_PROPERTIES.includes(name);
}
__name(cannot_be_set_statically, "cannot_be_set_statically");
const PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
__name(is_passive_event, "is_passive_event");
const CONTENT_EDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_content_editable_binding(name) {
  return CONTENT_EDITABLE_BINDINGS.includes(name);
}
__name(is_content_editable_binding, "is_content_editable_binding");
const LOAD_ERROR_ELEMENTS = [
  "body",
  "embed",
  "iframe",
  "img",
  "link",
  "object",
  "script",
  "style",
  "track"
];
function is_load_error_element(name) {
  return LOAD_ERROR_ELEMENTS.includes(name);
}
__name(is_load_error_element, "is_load_error_element");
const SVG_ELEMENTS = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg(name) {
  return SVG_ELEMENTS.includes(name);
}
__name(is_svg, "is_svg");
const MATHML_ELEMENTS = [
  "annotation",
  "annotation-xml",
  "maction",
  "math",
  "merror",
  "mfrac",
  "mi",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mprescripts",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
];
function is_mathml(name) {
  return MATHML_ELEMENTS.includes(name);
}
__name(is_mathml, "is_mathml");
const STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
const RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.eager",
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
function is_rune(name) {
  return RUNES.includes(
    /** @type {RuneName} */
    name
  );
}
__name(is_rune, "is_rune");
function is_state_creation_rune(name) {
  return STATE_CREATION_RUNES.includes(
    /** @type {StateCreationRuneName} */
    name
  );
}
__name(is_state_creation_rune, "is_state_creation_rune");
const RAW_TEXT_ELEMENTS = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
__name(is_raw_text_element, "is_raw_text_element");
function sanitize_location(location) {
  return (
    /** @type {T} */
    location?.replace(/\//g, "/​")
  );
}
__name(sanitize_location, "sanitize_location");
function compare(a, b, property, location) {
  if (a !== b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location)
    );
  }
  return a;
}
__name(compare, "compare");
function assign(object2, property, value2, location) {
  return compare(
    object2[property] = value2,
    untrack(() => object2[property]),
    property,
    location
  );
}
__name(assign, "assign");
function assign_and(object2, property, value2, location) {
  return compare(
    object2[property] && (object2[property] = value2),
    untrack(() => object2[property]),
    property,
    location
  );
}
__name(assign_and, "assign_and");
function assign_or(object2, property, value2, location) {
  return compare(
    object2[property] || (object2[property] = value2),
    untrack(() => object2[property]),
    property,
    location
  );
}
__name(assign_or, "assign_or");
function assign_nullish(object2, property, value2, location) {
  return compare(
    object2[property] ?? (object2[property] = value2),
    untrack(() => object2[property]),
    property,
    location
  );
}
__name(assign_nullish, "assign_nullish");
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}
__name(register_style, "register_style");
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style of styles) {
    style.remove();
  }
  all_styles.delete(hash2);
}
__name(cleanup_styles, "cleanup_styles");
function add_locations(fn, filename, locations) {
  return (...args2) => {
    const dom = fn(...args2);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
__name(add_locations, "add_locations");
function assign_location(element2, filename, location) {
  element2.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element2.firstChild, filename, location[2]);
  }
}
__name(assign_location, "assign_location");
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}
__name(assign_locations, "assign_locations");
const all_registered_events = /* @__PURE__ */ new Set();
const root_event_handles = /* @__PURE__ */ new Set();
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
__name(replay_events, "replay_events");
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event2);
      });
    }
  }
  __name(target_handler, "target_handler");
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
__name(create_event, "create_event");
function on(element2, type, handler, options = {}) {
  var target_handler = create_event(type, element2, handler, options);
  return () => {
    element2.removeEventListener(type, target_handler, options);
  };
}
__name(on, "on");
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
__name(event, "event");
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
__name(delegate, "delegate");
let last_propagated_event = null;
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function apply(thunk, element2, args2, component2, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error;
  try {
    handler = thunk();
  } catch (e) {
    error = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
    const filename = component2?.[FILENAME];
    const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args2[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args2[0]?.type + phase;
    const description2 = `\`${event_name}\` handler${location}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description2, suggestion);
    if (error) {
      throw error;
    }
  }
  handler?.apply(element2, args2);
}
__name(apply, "apply");
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "<!---->");
  return elem.content;
}
__name(create_fragment_from_html, "create_fragment_from_html");
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes === null) {
    effect2.nodes = { start, end, a: null, t: null };
  }
}
__name(assign_nodes, "assign_nodes");
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
__name(from_html, "from_html");
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root2 = (
        /** @type {Element} */
        /* @__PURE__ */ get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (/* @__PURE__ */ get_first_child(root2)) {
          node.appendChild(
            /** @type {TemplateNode} */
            /* @__PURE__ */ get_first_child(root2)
          );
        }
      } else {
        node = /** @type {Element} */
        /* @__PURE__ */ get_first_child(root2);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
__name(from_namespace, "from_namespace");
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
__name(from_svg, "from_svg");
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
__name(from_mathml, "from_mathml");
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element2 = create_element(name, namespace, attributes?.is);
    for (var key2 in attributes) {
      set_attribute$1(element2, key2, attributes[key2]);
    }
    if (children.length > 0) {
      var target = element2.tagName === "TEMPLATE" ? (
        /** @type {HTMLTemplateElement} */
        element2.content
      ) : element2;
      target.append(
        fragment_from_tree(children, element2.tagName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element2);
  }
  return fragment;
}
__name(fragment_from_tree, "fragment_from_tree");
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
__name(from_tree, "from_tree");
function with_script(fn) {
  return () => run_scripts(fn());
}
__name(with_script, "with_script");
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  for (const script of scripts) {
    const clone2 = document.createElement("script");
    for (var attribute of script.attributes) {
      clone2.setAttribute(attribute.name, attribute.value);
    }
    clone2.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes.start = clone2;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes.end = clone2;
    }
    script.replaceWith(clone2);
  }
  return node;
}
__name(run_scripts, "run_scripts");
function text(value2 = "") {
  if (!hydrating) {
    var t = create_text(value2 + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
__name(text, "text");
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
__name(comment, "comment");
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect & { nodes: EffectNodes }} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes.end === null) {
      effect2.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
__name(append, "append");
function props_id() {
  var _a2;
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
    const id = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id;
  }
  (_a2 = window.__svelte ?? (window.__svelte = {})).uid ?? (_a2.uid = 1);
  return `c${window.__svelte.uid++}`;
}
__name(props_id, "props_id");
let should_intro = true;
function set_should_intro(value2) {
  should_intro = value2;
}
__name(set_should_intro, "set_should_intro");
function set_text(text2, value2) {
  var str = value2 == null ? "" : typeof value2 === "object" ? value2 + "" : value2;
  if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
__name(set_text, "set_text");
function mount(component2, options) {
  return _mount(component2, options);
}
__name(mount, "mount");
function hydrate(component2, options) {
  init_operations();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = /* @__PURE__ */ get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /* @__PURE__ */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance2 = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance2
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
const document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: /* @__PURE__ */ __name(() => {
        }, "pending")
      },
      (anchor_node2) => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes.end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
__name(_mount, "_mount");
let mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (DEV) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
__name(unmount, "unmount");
function hmr(original, get_source) {
  function wrapper(anchor, props) {
    let instance2 = {};
    let effect2;
    let ran = false;
    block(() => {
      const source2 = get_source();
      const component2 = get$1(source2);
      if (effect2) {
        for (var k in instance2) delete instance2[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance2,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component2(anchor, props) : component2(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance2;
  }
  __name(wrapper, "wrapper");
  wrapper[FILENAME] = original[FILENAME];
  wrapper[HMR] = {
    // When we accept an update, we set the original source to the new component
    original,
    // The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
    // function we always replace it with `previous[HMR].source`, which in practice
    // means we only ever update the original
    source: source(original)
  };
  return wrapper;
}
__name(hmr, "hmr");
function create_ownership_validator(props) {
  const component2 = component_context?.function;
  const parent = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: /* @__PURE__ */ __name((prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent) {
        return result;
      }
      let value2 = props;
      for (let i = 0; i < path.length - 1; i++) {
        value2 = value2[path[i]];
        if (!value2?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location = sanitize_location(`${component2[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location, prop2, parent[FILENAME]);
      return result;
    }, "mutation"),
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: /* @__PURE__ */ __name((key2, child_component, value2) => {
      if (!is_bound_or_unset(props, key2) && parent && value2()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component2[FILENAME],
          key2,
          child_component[FILENAME],
          parent[FILENAME]
        );
      }
    }, "binding")
  };
}
__name(create_ownership_validator, "create_ownership_validator");
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}
__name(is_bound_or_unset, "is_bound_or_unset");
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
__name(check_target, "check_target");
function legacy_api() {
  const component2 = component_context?.function;
  function error(method) {
    component_api_changed(method, component2[FILENAME]);
  }
  __name(error, "error");
  return {
    $destroy: /* @__PURE__ */ __name(() => error("$destroy()"), "$destroy"),
    $on: /* @__PURE__ */ __name(() => error("$on(...)"), "$on"),
    $set: /* @__PURE__ */ __name(() => error("$set(...)"), "$set")
  };
}
__name(legacy_api, "legacy_api");
function inspect(get_value, inspector, show_stack = false) {
  validate_effect("$inspect");
  let initial = true;
  let error = (
    /** @type {any} */
    UNINITIALIZED
  );
  eager_effect(() => {
    try {
      var value2 = get_value();
    } catch (e) {
      error = e;
      return;
    }
    var snap = snapshot(value2, true, true);
    untrack(() => {
      if (show_stack) {
        inspector(...snap);
        if (!initial) {
          const stack2 = get_error("$inspect(...)");
          if (stack2) {
            console.groupCollapsed("stack trace");
            console.log(stack2);
            console.groupEnd();
          }
        }
      } else {
        inspector(initial ? "init" : "update", ...snap);
      }
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error !== UNINITIALIZED) {
      console.error(error);
      error = UNINITIALIZED;
    }
  });
}
__name(inspect, "inspect");
function async(node, blockers = [], expressions = [], fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var was_hydrating = hydrating;
  if (was_hydrating) {
    hydrate_next();
    var previous_hydrate_node = hydrate_node;
    var end = skip_nodes(false);
    set_hydrate_node(end);
  }
  flatten(blockers, [], expressions, (values2) => {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    try {
      for (const d of values2) get$1(d);
      fn(node, ...values2);
    } finally {
      if (was_hydrating) {
        set_hydrating(false);
      }
      boundary2.update_pending_count(-1);
      batch.decrement(blocking);
    }
  });
}
__name(async, "async");
function validate_snippet_args(anchor, ...args2) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args2) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}
__name(validate_snippet_args, "validate_snippet_args");
const _BranchManager = class _BranchManager {
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(anchor, transition2 = true) {
    /** @type {TemplateNode} */
    __publicField(this, "anchor");
    /** @type {Map<Batch, Key>} */
    __privateAdd(this, _batches, /* @__PURE__ */ new Map());
    /**
     * Map of keys to effects that are currently rendered in the DOM.
     * These effects are visible and actively part of the document tree.
     * Example:
     * ```
     * {#if condition}
     * 	foo
     * {:else}
     * 	bar
     * {/if}
     * ```
     * Can result in the entries `true->Effect` and `false->Effect`
     * @type {Map<Key, Effect>}
     */
    __privateAdd(this, _onscreen, /* @__PURE__ */ new Map());
    /**
     * Similar to #onscreen with respect to the keys, but contains branches that are not yet
     * in the DOM, because their insertion is deferred.
     * @type {Map<Key, Branch>}
     */
    __privateAdd(this, _offscreen, /* @__PURE__ */ new Map());
    /**
     * Keys of effects that are currently outroing
     * @type {Set<Key>}
     */
    __privateAdd(this, _outroing, /* @__PURE__ */ new Set());
    /**
     * Whether to pause (i.e. outro) on change, or destroy immediately.
     * This is necessary for `<svelte:element>`
     */
    __privateAdd(this, _transition, true);
    __privateAdd(this, _commit, /* @__PURE__ */ __name(() => {
      var batch = (
        /** @type {Batch} */
        current_batch
      );
      if (!__privateGet(this, _batches).has(batch)) return;
      var key2 = (
        /** @type {Key} */
        __privateGet(this, _batches).get(batch)
      );
      var onscreen = __privateGet(this, _onscreen).get(key2);
      if (onscreen) {
        resume_effect(onscreen);
        __privateGet(this, _outroing).delete(key2);
      } else {
        var offscreen = __privateGet(this, _offscreen).get(key2);
        if (offscreen) {
          __privateGet(this, _onscreen).set(key2, offscreen.effect);
          __privateGet(this, _offscreen).delete(key2);
          offscreen.fragment.lastChild.remove();
          this.anchor.before(offscreen.fragment);
          onscreen = offscreen.effect;
        }
      }
      for (const [b, k] of __privateGet(this, _batches)) {
        __privateGet(this, _batches).delete(b);
        if (b === batch) {
          break;
        }
        const offscreen2 = __privateGet(this, _offscreen).get(k);
        if (offscreen2) {
          destroy_effect(offscreen2.effect);
          __privateGet(this, _offscreen).delete(k);
        }
      }
      for (const [k, effect2] of __privateGet(this, _onscreen)) {
        if (k === key2 || __privateGet(this, _outroing).has(k)) continue;
        const on_destroy = /* @__PURE__ */ __name(() => {
          const keys = Array.from(__privateGet(this, _batches).values());
          if (keys.includes(k)) {
            var fragment = document.createDocumentFragment();
            move_effect(effect2, fragment);
            fragment.append(create_text());
            __privateGet(this, _offscreen).set(k, { effect: effect2, fragment });
          } else {
            destroy_effect(effect2);
          }
          __privateGet(this, _outroing).delete(k);
          __privateGet(this, _onscreen).delete(k);
        }, "on_destroy");
        if (__privateGet(this, _transition) || !onscreen) {
          __privateGet(this, _outroing).add(k);
          pause_effect(effect2, on_destroy, false);
        } else {
          on_destroy();
        }
      }
    }, "#commit"));
    /**
     * @param {Batch} batch
     */
    __privateAdd(this, _discard, /* @__PURE__ */ __name((batch) => {
      __privateGet(this, _batches).delete(batch);
      const keys = Array.from(__privateGet(this, _batches).values());
      for (const [k, branch2] of __privateGet(this, _offscreen)) {
        if (!keys.includes(k)) {
          destroy_effect(branch2.effect);
          __privateGet(this, _offscreen).delete(k);
        }
      }
    }, "#discard"));
    this.anchor = anchor;
    __privateSet(this, _transition, transition2);
  }
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(key2, fn) {
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    if (fn && !__privateGet(this, _onscreen).has(key2) && !__privateGet(this, _offscreen).has(key2)) {
      if (defer) {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        __privateGet(this, _offscreen).set(key2, {
          effect: branch(() => fn(target)),
          fragment
        });
      } else {
        __privateGet(this, _onscreen).set(
          key2,
          branch(() => fn(this.anchor))
        );
      }
    }
    __privateGet(this, _batches).set(batch, key2);
    if (defer) {
      for (const [k, effect2] of __privateGet(this, _onscreen)) {
        if (k === key2) {
          batch.skipped_effects.delete(effect2);
        } else {
          batch.skipped_effects.add(effect2);
        }
      }
      for (const [k, branch2] of __privateGet(this, _offscreen)) {
        if (k === key2) {
          batch.skipped_effects.delete(branch2.effect);
        } else {
          batch.skipped_effects.add(branch2.effect);
        }
      }
      batch.oncommit(__privateGet(this, _commit));
      batch.ondiscard(__privateGet(this, _discard));
    } else {
      if (hydrating) {
        this.anchor = hydrate_node;
      }
      __privateGet(this, _commit).call(this);
    }
  }
};
_batches = new WeakMap();
_onscreen = new WeakMap();
_offscreen = new WeakMap();
_outroing = new WeakMap();
_transition = new WeakMap();
_commit = new WeakMap();
_discard = new WeakMap();
__name(_BranchManager, "BranchManager");
let BranchManager = _BranchManager;
const PENDING = 0;
const THEN = 1;
const CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var runes = is_runes();
  var v = (
    /** @type {V} */
    UNINITIALIZED
  );
  var value2 = runes ? source(v) : /* @__PURE__ */ mutable_source(v, false, false);
  var error = runes ? source(v) : /* @__PURE__ */ mutable_source(v, false, false);
  var branches = new BranchManager(node);
  block(() => {
    var input = get_input();
    var destroyed = false;
    let mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);
    if (mismatch) {
      set_hydrate_node(skip_nodes());
      set_hydrating(false);
    }
    if (is_promise(input)) {
      var restore = capture();
      var resolved = false;
      const resolve = /* @__PURE__ */ __name((fn) => {
        if (destroyed) return;
        resolved = true;
        restore(false);
        Batch.ensure();
        if (hydrating) {
          set_hydrating(false);
        }
        try {
          fn();
        } finally {
          unset_context();
          if (!is_flushing_sync) flushSync();
        }
      }, "resolve");
      input.then(
        (v2) => {
          resolve(() => {
            internal_set(value2, v2);
            branches.ensure(THEN, then_fn && ((target) => then_fn(target, value2)));
          });
        },
        (e) => {
          resolve(() => {
            internal_set(error, e);
            branches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error)));
            if (!catch_fn) {
              throw error.v;
            }
          });
        }
      );
      if (hydrating) {
        branches.ensure(PENDING, pending_fn);
      } else {
        queue_micro_task(() => {
          if (!resolved) {
            resolve(() => {
              branches.ensure(PENDING, pending_fn);
            });
          }
        });
      }
    } else {
      internal_set(value2, input);
      branches.ensure(THEN, then_fn && ((target) => then_fn(target, value2)));
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => {
      destroyed = true;
    };
  });
}
__name(await_block, "await_block");
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(condition, fn2) {
    if (hydrating) {
      const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;
      if (condition === is_else) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(condition, fn2);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(condition, fn2);
  }
  __name(update_branch, "update_branch");
  block(() => {
    var has_branch = false;
    fn((fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}
__name(if_block, "if_block");
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var legacy = !is_runes();
  block(() => {
    var key2 = get_key();
    if (legacy && key2 !== null && typeof key2 === "object") {
      key2 = /** @type {V} */
      {};
    }
    branches.ensure(key2, render_fn);
  });
}
__name(key, "key");
function css_props(element2, get_styles) {
  if (hydrating) {
    set_hydrate_node(/* @__PURE__ */ get_first_child(element2));
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value2 = styles[key2];
      if (value2) {
        element2.style.setProperty(key2, value2);
      } else {
        element2.style.removeProperty(key2);
      }
    }
  });
}
__name(css_props, "css_props");
function index(_, i) {
  return i;
}
__name(index, "index");
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length2 = to_destroy.length;
  var group;
  var remaining = to_destroy.length;
  for (var i = 0; i < length2; i++) {
    let effect2 = to_destroy[i];
    pause_effect(
      effect2,
      () => {
        if (group) {
          group.pending.delete(effect2);
          group.done.add(effect2);
          if (group.pending.size === 0) {
            var groups = (
              /** @type {Set<EachOutroGroup>} */
              state2.outrogroups
            );
            destroy_effects(array_from(group.done));
            groups.delete(group);
            if (groups.size === 0) {
              state2.outrogroups = null;
            }
          }
        } else {
          remaining -= 1;
        }
      },
      false
    );
  }
  if (remaining === 0) {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group = {
      pending: new Set(to_destroy),
      done: /* @__PURE__ */ new Set()
    };
    (state2.outrogroups ?? (state2.outrogroups = /* @__PURE__ */ new Set())).add(group);
  }
}
__name(pause_effects, "pause_effects");
function destroy_effects(to_destroy, remove_dom = true) {
  for (var i = 0; i < to_destroy.length; i++) {
    destroy_effect(to_destroy[i], remove_dom);
  }
}
__name(destroy_effects, "destroy_effects");
var offscreen_anchor;
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(/* @__PURE__ */ get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var each_array = /* @__PURE__ */ derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array2;
  var first_run = true;
  function commit() {
    state2.fallback = fallback2;
    reconcile(state2, array2, anchor, flags2, get_key);
    if (fallback2 !== null) {
      if (array2.length === 0) {
        if ((fallback2.f & EFFECT_OFFSCREEN) === 0) {
          resume_effect(fallback2);
        } else {
          fallback2.f ^= EFFECT_OFFSCREEN;
          move(fallback2, null, anchor);
        }
      } else {
        pause_effect(fallback2, () => {
          fallback2 = null;
        });
      }
    }
  }
  __name(commit, "commit");
  var effect2 = block(() => {
    array2 = /** @type {V[]} */
    get$1(each_array);
    var length2 = array2.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length2 === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    for (var index2 = 0; index2 < length2; index2 += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value2 = array2[index2];
      var key2 = get_key(value2, index2);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (item.v) internal_set(item.v, value2);
        if (item.i) internal_set(item.i, index2);
        if (defer) {
          batch.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(
          items,
          first_run ? anchor : offscreen_anchor ?? (offscreen_anchor = create_text()),
          value2,
          key2,
          index2,
          render_fn,
          flags2,
          get_collection
        );
        if (!first_run) {
          item.e.f |= EFFECT_OFFSCREEN;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length2 === 0 && fallback_fn && !fallback2) {
      if (first_run) {
        fallback2 = branch(() => fallback_fn(anchor));
      } else {
        fallback2 = branch(() => fallback_fn(offscreen_anchor ?? (offscreen_anchor = create_text())));
        fallback2.f |= EFFECT_OFFSCREEN;
      }
    }
    if (hydrating && length2 > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get$1(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, outrogroups: null, fallback: fallback2 };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
__name(each, "each");
function reconcile(state2, array2, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length2 = array2.length;
  var items = state2.items;
  var current = state2.effect.first;
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value2;
  var key2;
  var effect2;
  var i;
  if (is_animated) {
    for (i = 0; i < length2; i += 1) {
      value2 = array2[i];
      key2 = get_key(value2, i);
      effect2 = /** @type {EachItem} */
      items.get(key2).e;
      if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
        effect2.nodes?.a?.measure();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(effect2);
      }
    }
  }
  for (i = 0; i < length2; i += 1) {
    value2 = array2[i];
    key2 = get_key(value2, i);
    effect2 = /** @type {EachItem} */
    items.get(key2).e;
    if (state2.outrogroups !== null) {
      for (const group of state2.outrogroups) {
        group.pending.delete(effect2);
        group.done.delete(effect2);
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) !== 0) {
      effect2.f ^= EFFECT_OFFSCREEN;
      if (effect2 === current) {
        move(effect2, null, anchor);
      } else {
        var next2 = prev ? prev.next : current;
        if (effect2 === state2.effect.last) {
          state2.effect.last = effect2.prev;
        }
        if (effect2.prev) effect2.prev.next = effect2.next;
        if (effect2.next) effect2.next.prev = effect2.prev;
        link(state2, prev, effect2);
        link(state2, effect2, next2);
        move(effect2, next2, anchor);
        prev = effect2;
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
    }
    if ((effect2.f & INERT) !== 0) {
      resume_effect(effect2);
      if (is_animated) {
        effect2.nodes?.a?.unfix();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(effect2);
      }
    }
    if (effect2 !== current) {
      if (seen !== void 0 && seen.has(effect2)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(effect2);
          move(effect2, current, anchor);
          link(state2, effect2.prev, effect2.next);
          link(state2, effect2, prev === null ? state2.effect.first : prev.next);
          link(state2, prev, effect2);
          prev = effect2;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current !== effect2) {
        (seen ?? (seen = /* @__PURE__ */ new Set())).add(current);
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
      matched.push(effect2);
    }
    prev = effect2;
    current = effect2.next;
  }
  if (state2.outrogroups !== null) {
    for (const group of state2.outrogroups) {
      if (group.pending.size === 0) {
        destroy_effects(array_from(group.done));
        state2.outrogroups?.delete(group);
      }
    }
    if (state2.outrogroups.size === 0) {
      state2.outrogroups = null;
    }
  }
  if (current !== null || seen !== void 0) {
    var to_destroy = [];
    if (seen !== void 0) {
      for (effect2 of seen) {
        if ((effect2.f & INERT) === 0) {
          to_destroy.push(effect2);
        }
      }
    }
    while (current !== null) {
      if ((current.f & INERT) === 0 && current !== state2.fallback) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length2 === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (effect2 of to_animate) {
        effect2.nodes?.a?.apply();
      }
    });
  }
}
__name(reconcile, "reconcile");
function create_item(items, anchor, value2, key2, index2, render_fn, flags2, get_collection) {
  var v = (flags2 & EACH_ITEM_REACTIVE) !== 0 ? (flags2 & EACH_ITEM_IMMUTABLE) === 0 ? /* @__PURE__ */ mutable_source(value2, false, false) : source(value2) : null;
  var i = (flags2 & EACH_INDEX_REACTIVE) !== 0 ? source(index2) : null;
  if (DEV && v) {
    v.trace = () => {
      get_collection()[i?.v ?? index2];
    };
  }
  return {
    v,
    i,
    e: branch(() => {
      render_fn(anchor, v ?? value2, i ?? index2, get_collection);
      return () => {
        items.delete(key2);
      };
    })
  };
}
__name(create_item, "create_item");
function move(effect2, next2, anchor) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  var dest = next2 && (next2.f & EFFECT_OFFSCREEN) === 0 ? (
    /** @type {EffectNodes} */
    next2.nodes.start
  ) : anchor;
  while (node !== null) {
    var next_node = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    dest.before(node);
    if (node === end) {
      return;
    }
    node = next_node;
  }
}
__name(move, "move");
function link(state2, prev, next2) {
  if (prev === null) {
    state2.effect.first = next2;
  } else {
    prev.next = next2;
  }
  if (next2 === null) {
    state2.effect.last = prev;
  } else {
    next2.prev = prev;
  }
}
__name(link, "link");
function check_hash(element2, server_hash, value2) {
  if (!server_hash || server_hash === hash(String(value2 ?? ""))) return;
  let location;
  const loc = element2.__svelte_meta?.loc;
  if (loc) {
    location = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location));
}
__name(check_hash, "check_hash");
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value2 = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value2 === (value2 = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes !== null) {
      remove_effect_dom(
        effect2.nodes.start,
        /** @type {TemplateNode} */
        effect2.nodes.end
      );
      effect2.nodes = null;
    }
    if (value2 === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last = next2;
        next2 = /* @__PURE__ */ get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (DEV && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value2
        );
      }
      assign_nodes(hydrate_node, last);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html2 = value2 + "";
    if (svg) html2 = `<svg>${html2}</svg>`;
    else if (mathml) html2 = `<math>${html2}</math>`;
    var node2 = create_fragment_from_html(html2);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      /* @__PURE__ */ get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (/* @__PURE__ */ get_first_child(node2)) {
        anchor.before(
          /** @type {TemplateNode} */
          /* @__PURE__ */ get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}
__name(html, "html");
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
__name(slot, "slot");
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}
__name(sanitize_slots, "sanitize_slots");
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
__name(validate_void_dynamic_element, "validate_void_dynamic_element");
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
__name(validate_dynamic_element_tag, "validate_dynamic_element_tag");
function validate_store(store2, name) {
  if (store2 != null && typeof store2.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
__name(validate_store, "validate_store");
function prevent_snippet_stringification(fn) {
  fn.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn;
}
__name(prevent_snippet_stringification, "prevent_snippet_stringification");
function snippet(node, get_snippet, ...args2) {
  var branches = new BranchManager(node);
  block(() => {
    const snippet2 = get_snippet() ?? null;
    if (DEV && snippet2 == null) {
      invalid_snippet();
    }
    branches.ensure(snippet2, snippet2 && ((anchor) => snippet2(anchor, ...args2)));
  }, EFFECT_TRANSPARENT);
}
__name(snippet, "snippet");
function wrap_snippet(component2, fn) {
  const snippet2 = /* @__PURE__ */ __name((node, ...args2) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component2);
    try {
      return fn(node, ...args2);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  }, "snippet");
  prevent_snippet_stringification(snippet2);
  return snippet2;
}
__name(wrap_snippet, "wrap_snippet");
function createRawSnippet(fn) {
  return (anchor, ...params) => {
    var snippet2 = fn(...params);
    var element2;
    if (hydrating) {
      element2 = /** @type {Element} */
      hydrate_node;
      hydrate_next();
    } else {
      var html2 = snippet2.render().trim();
      var fragment = create_fragment_from_html(html2);
      element2 = /** @type {Element} */
      /* @__PURE__ */ get_first_child(fragment);
      if (DEV && (/* @__PURE__ */ get_next_sibling(element2) !== null || element2.nodeType !== ELEMENT_NODE)) {
        invalid_raw_snippet_render();
      }
      anchor.before(element2);
    }
    const result = snippet2.setup?.(element2);
    assign_nodes(element2, element2);
    if (typeof result === "function") {
      teardown(result);
    }
  };
}
__name(createRawSnippet, "createRawSnippet");
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  block(() => {
    var component2 = get_component() ?? null;
    branches.ensure(component2, component2 && ((target) => render_fn(target, component2)));
  }, EFFECT_TRANSPARENT);
}
__name(component, "component");
const now = BROWSER ? () => performance.now() : () => Date.now();
const raf = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    /* @__PURE__ */ __name((_) => (BROWSER ? requestAnimationFrame : noop)(_), "tick")
  ),
  now: /* @__PURE__ */ __name(() => now(), "now"),
  tasks: /* @__PURE__ */ new Set()
};
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
__name(run_tasks, "run_tasks");
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}
__name(loop, "loop");
function dispatch_event(element2, type) {
  without_reactive_context(() => {
    element2.dispatchEvent(new CustomEvent(type));
  });
}
__name(dispatch_event, "dispatch_event");
function css_property_to_camelcase(style) {
  if (style === "float") return "cssFloat";
  if (style === "offset") return "cssOffset";
  if (style.startsWith("--")) return style;
  const parts = style.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
__name(css_property_to_camelcase, "css_property_to_camelcase");
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value2] = part.split(":");
    if (!property || value2 === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value2.trim();
  }
  return keyframe;
}
__name(css_to_keyframe, "css_to_keyframe");
const linear = /* @__PURE__ */ __name((t) => t, "linear");
let animation_effect_override = null;
function set_animation_effect_override(v) {
  animation_effect_override = v;
}
__name(set_animation_effect_override, "set_animation_effect_override");
function animation(element2, get_fn, get_params) {
  var effect2 = animation_effect_override ?? /** @type {Effect} */
  active_effect;
  var nodes = (
    /** @type {EffectNodes} */
    effect2.nodes
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  nodes.a ?? (nodes.a = {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params?.());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2?.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element2.getAnimations().length) return;
      var { position, width, height } = getComputedStyle(element2);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform2 = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform2}` : transform2;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  });
  nodes.a.element = element2;
}
__name(animation, "animation");
function transition(flags2, element2, get_fn, get_params) {
  var _a2;
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var overflow = element2.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ?? (current_options = get_fn()(element2, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      }));
    });
  }
  __name(get_options, "get_options");
  var transition2 = {
    is_global,
    in() {
      element2.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      dispatch_event(element2, "introstart");
      intro = animate(element2, get_options(), outro, 1, () => {
        dispatch_event(element2, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element2.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn?.();
        current_options = void 0;
        return;
      }
      element2.inert = true;
      dispatch_event(element2, "outrostart");
      outro = animate(element2, get_options(), intro, 0, () => {
        dispatch_event(element2, "outroend");
        fn?.();
      });
    },
    stop: /* @__PURE__ */ __name(() => {
      intro?.abort();
      outro?.abort();
    }, "stop")
  };
  var e = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  ((_a2 = e.nodes).t ?? (_a2.t = [])).push(transition2);
  if (is_intro && should_intro) {
    var run2 = is_global;
    if (!run2) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run2) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
__name(transition, "transition");
function animate(element2, options, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options({ direction: is_intro ? "in" : "out" });
      a = animate(element2, o, counterpart, t2, on_finish);
    });
    return {
      abort: /* @__PURE__ */ __name(() => {
        aborted2 = true;
        a?.abort();
      }, "abort"),
      deactivate: /* @__PURE__ */ __name(() => a.deactivate(), "deactivate"),
      reset: /* @__PURE__ */ __name(() => a.reset(), "reset"),
      t: /* @__PURE__ */ __name(() => a.t(), "t")
    };
  }
  counterpart?.deactivate();
  if (!options?.duration) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: /* @__PURE__ */ __name(() => t2, "t")
    };
  }
  const { delay = 0, css, tick: tick2, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick2) {
      tick2(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = /* @__PURE__ */ __name(() => 1 - t2, "get_t");
  var animation2 = element2.animate(keyframes, { duration: delay, fill: "forwards" });
  animation2.onfinish = () => {
    animation2.cancel();
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden || (needs_overflow_hidden = styles2.overflow === "hidden");
        }
      }
      if (needs_overflow_hidden) {
        element2.style.overflow = "hidden";
      }
      get_t = /* @__PURE__ */ __name(() => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      }, "get_t");
      if (tick2) {
        loop(() => {
          if (animation2.playState !== "running") return false;
          var t3 = get_t();
          tick2(t3, 1 - t3);
          return true;
        });
      }
    }
    animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = /* @__PURE__ */ __name(() => t2, "get_t");
      tick2?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: /* @__PURE__ */ __name(() => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    }, "abort"),
    deactivate: /* @__PURE__ */ __name(() => {
      on_finish = noop;
    }, "deactivate"),
    reset: /* @__PURE__ */ __name(() => {
      if (t2 === 0) {
        tick2?.(1, 0);
      }
    }, "reset"),
    t: /* @__PURE__ */ __name(() => get_t(), "t")
  };
}
__name(animate, "animate");
function element(node, get_tag, is_svg2, render_fn, get_namespace, location) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = DEV && location && component_context?.function[FILENAME];
  var element2 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element2 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  var branches = new BranchManager(anchor, false);
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg2 || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === null) {
      branches.ensure(null, null);
      set_should_intro(true);
      return;
    }
    branches.ensure(next_tag, (anchor2) => {
      if (next_tag) {
        element2 = hydrating ? (
          /** @type {Element} */
          element2
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (DEV && location) {
          element2.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element2, element2);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element2.append(document.createComment(""));
          }
          var child_anchor = hydrating ? /* @__PURE__ */ get_first_child(element2) : element2.appendChild(create_text());
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          set_animation_effect_override(parent_effect);
          render_fn(element2, child_anchor);
          set_animation_effect_override(null);
        }
        active_effect.nodes.end = element2;
        anchor2.before(element2);
      }
      if (hydrating) {
        set_hydrate_node(anchor2);
      }
    });
    set_should_intro(true);
    return () => {
      if (next_tag) {
        set_should_intro(false);
      }
    };
  }, EFFECT_TRANSPARENT);
  teardown(() => {
    set_should_intro(true);
  });
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}
__name(element, "element");
function head(hash2, render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    var head_anchor = /* @__PURE__ */ get_first_child(document.head);
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== hash2)) {
      head_anchor = /* @__PURE__ */ get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_next_sibling(head_anchor)
      );
      head_anchor.remove();
      set_hydrate_node(start);
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}
__name(head, "head");
function append_styles$1(anchor, css) {
  effect(() => {
    var root2 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root2.host ? (
        /** @type {ShadowRoot} */
        root2
      ) : (
        /** @type {Document} */
        root2.head ?? /** @type {Document} */
        root2.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (DEV) {
        register_style(css.hash, style);
      }
    }
  });
}
__name(append_styles$1, "append_styles$1");
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value2 = get_value();
        deep_read_state(value2);
        if (inited && safe_not_equal(prev, value2)) {
          prev = value2;
          payload.update(value2);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}
__name(action, "action");
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  managed(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}
__name(attach, "attach");
const ATTR_REGEX = /[&"<]/g;
const CONTENT_REGEX = /[&<]/g;
function escape_html(value2, is_attr) {
  const str = String(value2 ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str.substring(last);
}
__name(escape_html, "escape_html");
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
__name(r, "r");
function clsx$1() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
__name(clsx$1, "clsx$1");
const replacements = {
  translate: /* @__PURE__ */ new Map([
    [true, "yes"],
    [false, "no"]
  ])
};
function attr(name, value2, is_boolean = false) {
  if (name === "hidden" && value2 !== "until-found") {
    is_boolean = true;
  }
  if (value2 == null || !value2 && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value2) || value2;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
__name(attr, "attr");
function clsx(value2) {
  if (typeof value2 === "object") {
    return clsx$1(value2);
  } else {
    return value2 ?? "";
  }
}
__name(clsx, "clsx");
const whitespace = [..." 	\n\r\f \v\uFEFF"];
function to_class(value2, hash2, directives) {
  var classname = value2 == null ? "" : "" + value2;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
__name(to_class, "to_class");
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value2 = styles[key2];
    if (value2 != null && value2 !== "") {
      css += " " + key2 + ": " + value2 + separator;
    }
  }
  return css;
}
__name(append_styles, "append_styles");
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
__name(to_css_name, "to_css_name");
function to_style(value2, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value2) {
      value2 = String(value2).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value2.length;
      for (var i = 0; i < len; i++) {
        var c = value2[i];
        if (in_comment) {
          if (c === "/" && value2[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value2[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value2.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value2.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value2 == null ? null : String(value2);
}
__name(to_style, "to_style");
function set_class(dom, is_html, value2, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value2 || prev === void 0) {
    var next_class_name = to_class(value2, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value2;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}
__name(set_class, "set_class");
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value2 = next2[key2];
    if (prev[key2] !== value2) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value2, priority);
      }
    }
  }
}
__name(update_styles, "update_styles");
function set_style(dom, value2, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value2) {
    var next_style_attr = to_style(value2, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value2;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}
__name(set_style, "set_style");
function select_option(select, value2, mounting = false) {
  if (select.multiple) {
    if (value2 == void 0) {
      return;
    }
    if (!is_array(value2)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value2.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value2)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
__name(select_option, "select_option");
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
__name(init_select, "init_select");
function bind_select_value(select, get2, set2 = get2) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value2;
    if (select.multiple) {
      value2 = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value2 = selected_option && get_option_value(selected_option);
    }
    set2(value2);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var value2 = get2();
    if (select === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    select_option(select, value2, mounting);
    if (mounting && value2 === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value2 = get_option_value(selected_option);
        set2(value2);
      }
    }
    select.__value = value2;
    mounting = false;
  });
  init_select(select);
}
__name(bind_select_value, "bind_select_value");
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
__name(get_option_value, "get_option_value");
const CLASS = /* @__PURE__ */ Symbol("class");
const STYLE = /* @__PURE__ */ Symbol("style");
const IS_CUSTOM_ELEMENT = /* @__PURE__ */ Symbol("is custom element");
const IS_HTML = /* @__PURE__ */ Symbol("is html");
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = /* @__PURE__ */ __name(() => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value2 = input.value;
      set_attribute(input, "value", null);
      input.value = value2;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute(input, "checked", null);
      input.checked = checked;
    }
  }, "remove_defaults");
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
__name(remove_input_defaults, "remove_input_defaults");
function set_value(element2, value2) {
  var attributes = get_attributes(element2);
  if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
  value2 ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element2.value === value2 && (value2 !== 0 || element2.nodeName !== "PROGRESS")) {
    return;
  }
  element2.value = value2 ?? "";
}
__name(set_value, "set_value");
function set_checked(element2, checked) {
  var attributes = get_attributes(element2);
  if (attributes.checked === (attributes.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element2.checked = checked;
}
__name(set_checked, "set_checked");
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
__name(set_selected, "set_selected");
function set_default_checked(element2, checked) {
  const existing_value = element2.checked;
  element2.defaultChecked = checked;
  element2.checked = existing_value;
}
__name(set_default_checked, "set_default_checked");
function set_default_value(element2, value2) {
  const existing_value = element2.value;
  element2.defaultValue = value2;
  element2.value = existing_value;
}
__name(set_default_value, "set_default_value");
function set_attribute(element2, attribute, value2, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value2 ?? "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value2)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value2;
  }
  if (value2 == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value2 !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value2;
  } else {
    element2.setAttribute(attribute, value2);
  }
}
__name(set_attribute, "set_attribute");
function set_xlink_attribute(dom, attribute, value2) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value2);
}
__name(set_xlink_attribute, "set_xlink_attribute");
function set_custom_element_data(node, prop2, value2) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.tagName.toLowerCase()) ? get_setters(node).includes(prop2) : value2 && typeof value2 === "object")
    ) {
      node[prop2] = value2;
    } else {
      set_attribute(node, prop2, value2 == null ? value2 : String(value2));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
__name(set_custom_element_data, "set_custom_element_data");
function set_attributes(element2, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  if (hydrating && should_remove_defaults && element2.tagName === "INPUT") {
    var input = (
      /** @type {HTMLInputElement} */
      element2
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes = get_attributes(element2);
  var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element2.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ?? (next2.style = null);
  }
  var setters = get_setters(element2);
  for (const key3 in next2) {
    let value2 = next2[key3];
    if (is_option_element && key3 === "value" && value2 == null) {
      element2.value = element2.__value = "";
      current[key3] = value2;
      continue;
    }
    if (key3 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value2, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value2;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element2, value2, prev?.[STYLE], next2[STYLE]);
      current[key3] = value2;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value2 === prev_value && !(value2 === void 0 && element2.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value2;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = can_delegate_event(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value2 != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value2 != null) {
        if (!delegated) {
          let handle2 = function(evt) {
            current[key3].call(this, evt);
          };
          var handle = handle2;
          __name(handle2, "handle");
          current[event_handle_key] = create_event(event_name, element2, handle2, opts);
        } else {
          element2[`__${event_name}`] = value2;
          delegate([event_name]);
        }
      } else if (delegated) {
        element2[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute(element2, key3, value2);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value2)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value2 != null)) {
      element2.value = element2.__value = value2;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value2
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value2 == null && !is_custom_element && !is_default) {
        attributes[key3] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value2 !== "string")) {
        element2[name] = value2;
        if (name in attributes) attributes[name] = UNINITIALIZED;
      } else if (typeof value2 !== "function") {
        set_attribute(element2, name, value2, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
__name(set_attributes, "set_attributes");
function attribute_effect(element2, fn, sync = [], async2 = [], blockers = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(blockers, sync, async2, (values2) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === "SELECT";
    var inited = false;
    managed(() => {
      var next2 = fn(...values2.map(get$1));
      var current = set_attributes(
        element2,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next2.value
        );
      }
      for (let symbol2 of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol2]) destroy_effect(effects[symbol2]);
      }
      for (let symbol2 of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol2];
        if (symbol2.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol2])) {
          if (effects[symbol2]) destroy_effect(effects[symbol2]);
          effects[symbol2] = branch(() => attach(element2, () => n));
        }
        current[symbol2] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
__name(attribute_effect, "attribute_effect");
function get_attributes(element2) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element2.__attributes ?? (element2.__attributes = {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    })
  );
}
__name(get_attributes, "get_attributes");
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
__name(get_setters, "get_setters");
function check_src_in_dev_hydration(element2, attribute, value2) {
  if (!DEV) return;
  if (attribute === "srcset" && srcset_url_equal(element2, value2)) return;
  if (src_url_equal(element2.getAttribute(attribute) ?? "", value2)) return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value2)
  );
}
__name(check_src_in_dev_hydration, "check_src_in_dev_hydration");
function src_url_equal(element_src, url2) {
  if (element_src === url2) return true;
  return new URL(element_src, document.baseURI).href === new URL(url2, document.baseURI).href;
}
__name(src_url_equal, "src_url_equal");
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
__name(split_srcset, "split_srcset");
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url2, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url2) || src_url_equal(url2, element_urls[i][0]))
  );
}
__name(srcset_url_equal, "srcset_url_equal");
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event2) => {
    if (event2 && event2.type === "focusout" && /** @type {FocusEvent} */
    event2.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}
__name(bind_active_element, "bind_active_element");
function bind_value(input, get2, set2 = get2) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value2 = is_reset ? input.defaultValue : input.value;
    value2 = is_numberlike_input(input) ? to_number(value2) : value2;
    set2(value2);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value2 !== (value2 = get2())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      var length2 = input.value.length;
      input.value = value2 ?? "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start === end && end === length2 && new_length > length2) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get2) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value2 = get2();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value2 === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value2 && !input.value) {
      return;
    }
    if (value2 !== input.value) {
      input.value = value2 ?? "";
    }
  });
}
__name(bind_value, "bind_value");
const pending = /* @__PURE__ */ new Set();
function bind_group(inputs, group_index, input, get2, set2 = get2) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ?? (binding_group[index2] = []);
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value2 = input.__value;
      if (is_checkbox) {
        value2 = get_binding_group_value(binding_group, value2, input.checked);
      }
      set2(value2);
    },
    // TODO better default value handling
    () => set2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value2 = get2();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value2 = value2 || [];
      input.checked = value2.includes(input.__value);
    } else {
      input.checked = is(input.__value, value2);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending.has(binding_group)) {
    pending.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value2;
      if (is_checkbox) {
        value2 = get_binding_group_value(binding_group, value2, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value2 = hydration_input?.__value;
      }
      set2(value2);
    }
  });
}
__name(bind_group, "bind_group");
function bind_checked(input, get2, set2 = get2) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value2 = is_reset ? input.defaultChecked : input.checked;
    set2(value2);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get2) == null
  ) {
    set2(input.checked);
  }
  render_effect(() => {
    var value2 = get2();
    input.checked = Boolean(value2);
  });
}
__name(bind_checked, "bind_checked");
function get_binding_group_value(group, __value, checked) {
  var value2 = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value2.add(group[i].__value);
    }
  }
  if (!checked) {
    value2.delete(__value);
  }
  return Array.from(value2);
}
__name(get_binding_group_value, "get_binding_group_value");
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
__name(is_numberlike_input, "is_numberlike_input");
function to_number(value2) {
  return value2 === "" ? null : +value2;
}
__name(to_number, "to_number");
function bind_files(input, get2, set2 = get2) {
  listen_to_event_and_reset_event(input, "change", () => {
    set2(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set2(input.files);
  }
  render_effect(() => {
    input.files = get2();
  });
}
__name(bind_files, "bind_files");
function time_ranges_to_array(ranges) {
  var array2 = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array2.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array2;
}
__name(time_ranges_to_array, "time_ranges_to_array");
function bind_current_time(media, get2, set2 = get2) {
  var raf_id;
  var value2;
  var callback = /* @__PURE__ */ __name(() => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value2 !== next_value) {
      set2(value2 = next_value);
    }
  }, "callback");
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get2());
    if (value2 !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value2 = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
__name(bind_current_time, "bind_current_time");
function bind_buffered(media, set2) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set2(current);
    }
  });
}
__name(bind_buffered, "bind_buffered");
function bind_seekable(media, set2) {
  listen(media, ["loadedmetadata"], () => set2(time_ranges_to_array(media.seekable)));
}
__name(bind_seekable, "bind_seekable");
function bind_played(media, set2) {
  listen(media, ["timeupdate"], () => set2(time_ranges_to_array(media.played)));
}
__name(bind_played, "bind_played");
function bind_seeking(media, set2) {
  listen(media, ["seeking", "seeked"], () => set2(media.seeking));
}
__name(bind_seeking, "bind_seeking");
function bind_ended(media, set2) {
  listen(media, ["timeupdate", "ended"], () => set2(media.ended));
}
__name(bind_ended, "bind_ended");
function bind_ready_state(media, set2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set2(media.readyState)
  );
}
__name(bind_ready_state, "bind_ready_state");
function bind_playback_rate(media, get2, set2 = get2) {
  effect(() => {
    var value2 = Number(get2());
    if (value2 !== media.playbackRate && !isNaN(value2)) {
      media.playbackRate = value2;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set2(media.playbackRate);
    });
  });
}
__name(bind_playback_rate, "bind_playback_rate");
function bind_paused(media, get2, set2 = get2) {
  var paused = get2();
  var update2 = /* @__PURE__ */ __name(() => {
    if (paused !== media.paused) {
      set2(paused = media.paused);
    }
  }, "update");
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get2()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch(() => {
          set2(paused = true);
        });
      }
    }
  });
}
__name(bind_paused, "bind_paused");
function bind_volume(media, get2, set2 = get2) {
  var callback = /* @__PURE__ */ __name(() => {
    set2(media.volume);
  }, "callback");
  if (get2() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value2 = Number(get2());
    if (value2 !== media.volume && !isNaN(value2)) {
      media.volume = value2;
    }
  });
}
__name(bind_volume, "bind_volume");
function bind_muted(media, get2, set2 = get2) {
  var callback = /* @__PURE__ */ __name(() => {
    set2(media.muted);
  }, "callback");
  if (get2() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value2 = !!get2();
    if (media.muted !== value2) media.muted = value2;
  });
}
__name(bind_muted, "bind_muted");
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}
__name(bind_online, "bind_online");
function bind_prop(props, prop2, value2) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value2;
    teardown(() => {
      props[prop2] = null;
    });
  }
}
__name(bind_prop, "bind_prop");
const _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _ResizeObserverSingleton_instances);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _ResizeObserverSingleton_instances, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_ResizeObserverSingleton_instances = new WeakSet();
getObserver_fn = /* @__PURE__ */ __name(function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries2) => {
      for (var entry of entries2) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
}, "#getObserver");
__name(_ResizeObserverSingleton, "ResizeObserverSingleton");
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
let ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(element2, type, set2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element2,
    /** @param {any} entry */
    (entry) => set2(entry[type])
  );
  teardown(unsub);
}
__name(bind_resize_observer, "bind_resize_observer");
function bind_element_size(element2, type, set2) {
  var unsub = resize_observer_border_box.observe(element2, () => set2(element2[type]));
  effect(() => {
    untrack(() => set2(element2[type]));
    return unsub;
  });
}
__name(bind_element_size, "bind_element_size");
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
__name(is_bound_this, "is_bound_this");
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}
__name(bind_this, "bind_this");
function bind_content_editable(property, element2, get2, set2 = get2) {
  element2.addEventListener("input", () => {
    set2(element2[property]);
  });
  render_effect(() => {
    var value2 = get2();
    if (element2[property] !== value2) {
      if (value2 == null) {
        var non_null_value = element2[property];
        set2(non_null_value);
      } else {
        element2[property] = value2 + "";
      }
    }
  });
}
__name(bind_content_editable, "bind_content_editable");
function bind_property(property, event_name, element2, set2, get2) {
  var handler = /* @__PURE__ */ __name(() => {
    set2(element2[property]);
  }, "handler");
  element2.addEventListener(event_name, handler);
  if (get2) {
    render_effect(() => {
      element2[property] = get2();
    });
  } else {
    handler();
  }
  if (element2 === document.body || element2 === window || element2 === document) {
    teardown(() => {
      element2.removeEventListener(event_name, handler);
    });
  }
}
__name(bind_property, "bind_property");
function bind_focused(element2, set2) {
  listen(element2, ["focus", "blur"], () => {
    set2(element2 === document.activeElement);
  });
}
__name(bind_focused, "bind_focused");
function bind_window_scroll(type, get2, set2 = get2) {
  var is_scrolling_x = type === "x";
  var target_handler = /* @__PURE__ */ __name(() => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear2, 100);
    set2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  }), "target_handler");
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear2 = /* @__PURE__ */ __name(() => {
    scrolling = false;
  }, "clear");
  var first = true;
  render_effect(() => {
    var latest_value = get2();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear2, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
__name(bind_window_scroll, "bind_window_scroll");
function bind_window_size(type, set2) {
  listen(window, ["resize"], () => without_reactive_context(() => set2(window[type])));
}
__name(bind_window_size, "bind_window_size");
function trusted(fn) {
  return function(...args2) {
    var event2 = (
      /** @type {Event} */
      args2[0]
    );
    if (event2.isTrusted) {
      fn?.apply(this, args2);
    }
  };
}
__name(trusted, "trusted");
function self(fn) {
  return function(...args2) {
    var event2 = (
      /** @type {Event} */
      args2[0]
    );
    if (event2.target === this) {
      fn?.apply(this, args2);
    }
  };
}
__name(self, "self");
function stopPropagation(fn) {
  return function(...args2) {
    var event2 = (
      /** @type {Event} */
      args2[0]
    );
    event2.stopPropagation();
    return fn?.apply(this, args2);
  };
}
__name(stopPropagation, "stopPropagation");
function once(fn) {
  var ran = false;
  return function(...args2) {
    if (ran) return;
    ran = true;
    return fn?.apply(this, args2);
  };
}
__name(once, "once");
function stopImmediatePropagation(fn) {
  return function(...args2) {
    var event2 = (
      /** @type {Event} */
      args2[0]
    );
    event2.stopImmediatePropagation();
    return fn?.apply(this, args2);
  };
}
__name(stopImmediatePropagation, "stopImmediatePropagation");
function preventDefault(fn) {
  return function(...args2) {
    var event2 = (
      /** @type {Event} */
      args2[0]
    );
    event2.preventDefault();
    return fn?.apply(this, args2);
  };
}
__name(preventDefault, "preventDefault");
function passive(node, [event2, handler]) {
  user_pre_effect(() => {
    return on(node, event2, handler() ?? noop, {
      passive: true
    });
  });
}
__name(passive, "passive");
function nonpassive(node, [event2, handler]) {
  user_pre_effect(() => {
    return on(node, event2, handler() ?? noop, {
      passive: false
    });
  });
}
__name(nonpassive, "nonpassive");
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = /* @__PURE__ */ __name(() => deep_read_state(context.s), "props");
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = /* @__PURE__ */ derived$1(() => {
      let changed = false;
      const props2 = context.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = /* @__PURE__ */ __name(() => get$1(d), "props");
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run$2));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
__name(init, "init");
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get$1(signal);
  }
  props();
}
__name(observe_all, "observe_all");
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get$1(s) + 1);
      return arguments[0];
    } else {
      get$1(s);
      return fn();
    }
  };
}
__name(reactive_import, "reactive_import");
function bubble_event($$props, event2) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
__name(bubble_event, "bubble_event");
function add_legacy_event_listener($$props, event_name, event_callback) {
  var _a2;
  $$props.$$events || ($$props.$$events = {});
  (_a2 = $$props.$$events)[event_name] || (_a2[event_name] = []);
  $$props.$$events[event_name].push(event_callback);
}
__name(add_legacy_event_listener, "add_legacy_event_listener");
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}
__name(update_legacy_props, "update_legacy_props");
function subscribe_to_store(store2, run2, invalidate) {
  if (store2 == null) {
    run2(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store2.subscribe(
      run2,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
__name(subscribe_to_store, "subscribe_to_store");
const subscriber_queue = [];
function readable(value2, start) {
  return {
    subscribe: writable(value2, start).subscribe
  };
}
__name(readable, "readable");
function writable(value2, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set2, "set");
  function update2(fn) {
    set2(fn(
      /** @type {T} */
      value2
    ));
  }
  __name(update2, "update");
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update2) || noop;
    }
    run2(
      /** @type {T} */
      value2
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set2, update: update2, subscribe };
}
__name(writable, "writable");
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values2 = [];
    let pending2 = 0;
    let cleanup = noop;
    const sync = /* @__PURE__ */ __name(() => {
      if (pending2) {
        return;
      }
      cleanup();
      const result = fn(single ? values2[0] : values2, set2, update2);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    }, "sync");
    const unsubscribers = stores_array.map(
      (store2, i) => subscribe_to_store(
        store2,
        (value2) => {
          values2[i] = value2;
          pending2 &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending2 |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return /* @__PURE__ */ __name(function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    }, "stop");
  });
}
__name(derived, "derived");
function readonly(store2) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store2.subscribe.bind(store2)
  };
}
__name(readonly, "readonly");
function get(store2) {
  let value2;
  subscribe_to_store(store2, (_) => value2 = _)();
  return value2;
}
__name(get, "get");
let is_store_binding = false;
let IS_UNMOUNTED = /* @__PURE__ */ Symbol();
function store_get(store2, store_name, stores) {
  const entry = stores[store_name] ?? (stores[store_name] = {
    store: null,
    source: /* @__PURE__ */ mutable_source(void 0),
    unsubscribe: noop
  });
  if (DEV) {
    entry.source.label = store_name;
  }
  if (entry.store !== store2 && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store2 ?? null;
    if (store2 == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store2, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store2 && IS_UNMOUNTED in stores) {
    return get(store2);
  }
  return get$1(entry.source);
}
__name(store_get, "store_get");
function store_unsub(store2, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store2) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store2;
}
__name(store_unsub, "store_unsub");
function store_set(store2, value2) {
  store2.set(value2);
  return value2;
}
__name(store_set, "store_set");
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
__name(invalidate_store, "invalidate_store");
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  __name(cleanup, "cleanup");
  return [stores, cleanup];
}
__name(setup_stores, "setup_stores");
function store_mutate(store2, expression, new_value) {
  store2.set(new_value);
  return expression;
}
__name(store_mutate, "store_mutate");
function update_store(store2, store_value, d = 1) {
  store2.set(store_value + d);
  return store_value;
}
__name(update_store, "update_store");
function update_pre_store(store2, store_value, d = 1) {
  const value2 = store_value + d;
  store2.set(value2);
  return value2;
}
__name(update_pre_store, "update_pre_store");
function mark_store_binding() {
  is_store_binding = true;
}
__name(mark_store_binding, "mark_store_binding");
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}
__name(capture_store_binding, "capture_store_binding");
function update_prop(fn, d = 1) {
  const value2 = fn();
  fn(value2 + d);
  return value2;
}
__name(update_prop, "update_prop");
function update_pre_prop(fn, d = 1) {
  const value2 = fn() + d;
  fn(value2);
  return value2;
}
__name(update_pre_prop, "update_pre_prop");
const rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    return target.props[key2];
  },
  set(target, key2) {
    if (DEV) {
      props_rest_readonly(`${target.name}.${String(key2)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    DEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
__name(rest_props, "rest_props");
const legacy_rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    get$1(target.version);
    return key2 in target.special ? target.special[key2]() : target.props[key2];
  },
  set(target, key2, value2) {
    if (!(key2 in target.special)) {
      var previous_effect = active_effect;
      try {
        set_active_effect(target.parent_effect);
        target.special[key2] = prop(
          {
            get [key2]() {
              return target.props[key2];
            }
          },
          /** @type {string} */
          key2,
          PROPS_IS_UPDATED
        );
      } finally {
        set_active_effect(previous_effect);
      }
    }
    target.special[key2](value2);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  deleteProperty(target, key2) {
    if (target.exclude.includes(key2)) return true;
    target.exclude.push(key2);
    update(target.version);
    return true;
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
__name(legacy_rest_props, "legacy_rest_props");
const spread_props_handler = {
  get(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) return p[key2];
    }
  },
  set(target, key2, value2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      const desc = get_descriptor(p, key2);
      if (desc && desc.set) {
        desc.set(value2);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) {
        const descriptor = get_descriptor(p, key2);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key2) {
    if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (p != null && key2 in p) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (!p) continue;
      for (const key2 in p) {
        if (!keys.includes(key2)) keys.push(key2);
      }
      for (const key2 of Object.getOwnPropertySymbols(p)) {
        if (!keys.includes(key2)) keys.push(key2);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
__name(spread_props, "spread_props");
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy2 = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = /* @__PURE__ */ __name(() => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy2 ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  }, "get_fallback");
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = /* @__PURE__ */ __name(() => {
      var value2 = (
        /** @type {V} */
        props[key2]
      );
      if (value2 === void 0) return get_fallback();
      fallback_dirty = true;
      return value2;
    }, "getter");
  } else {
    getter = /* @__PURE__ */ __name(() => {
      var value2 = (
        /** @type {V} */
        props[key2]
      );
      if (value2 !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value2 === void 0 ? fallback_value : value2;
    }, "getter");
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value2, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value2);
          }
          return value2;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived$1 : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (DEV) {
    d.label = key2;
  }
  if (bindable) get$1(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value2, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get$1(d) : runes && bindable ? proxy(value2) : value2;
        set(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value2;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get$1(d);
    })
  );
}
__name(prop, "prop");
function validate_each_keys(collection, key_fn) {
  render_effect(() => {
    const keys = /* @__PURE__ */ new Map();
    const maybe_array = collection();
    const array2 = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
    const length2 = array2.length;
    for (let i = 0; i < length2; i++) {
      const key2 = key_fn(array2[i], i);
      if (keys.has(key2)) {
        const a = String(keys.get(key2));
        const b = String(i);
        let k = String(key2);
        if (k.startsWith("[object ")) k = null;
        each_key_duplicate(a, b, k);
      }
      keys.set(key2, i);
    }
  });
}
__name(validate_each_keys, "validate_each_keys");
function validate_binding(binding, blockers, get_object, get_property, line, column) {
  run_after_blockers(blockers, () => {
    var warned = false;
    var filename = dev_current_component_function?.[FILENAME];
    render_effect(() => {
      if (warned) return;
      var [object2, is_store_sub] = capture_store_binding(get_object);
      if (is_store_sub) return;
      var property = get_property();
      var ran = false;
      var effect2 = render_effect(() => {
        if (ran) return;
        object2[property];
      });
      ran = true;
      if (effect2.deps === null) {
        var location = `${filename}:${line}:${column}`;
        binding_property_non_reactive(binding, location);
        warned = true;
      }
    });
  });
}
__name(validate_binding, "validate_binding");
function createClassComponent(options) {
  return new Svelte4Component(options);
}
__name(createClassComponent, "createClassComponent");
function asClassComponent(component2) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component: component2,
        ...options
      });
    }
  };
}
__name(asClassComponent, "asClassComponent");
const _Svelte4Component = class _Svelte4Component {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance);
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value2) => {
      var s = /* @__PURE__ */ mutable_source(value2, false, false);
      sources.set(key2, s);
      return s;
    }, "add_source");
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          return get$1(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          if (prop2 === LEGACY_PROPS) return true;
          get$1(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value2) {
          set(sources.get(prop2) ?? add_source(prop2, value2), value2);
          return Reflect.set(target, prop2, value2);
        }
      }
    );
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: options.intro ?? false,
      recover: options.recover
    }));
    if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
      flushSync();
    }
    __privateSet(this, _events, props.$$events);
    for (const key2 of Object.keys(__privateGet(this, _instance))) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return __privateGet(this, _instance)[key2];
        },
        /** @param {any} value */
        set(value2) {
          __privateGet(this, _instance)[key2] = value2;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = /* @__PURE__ */ __name((...args2) => callback.call(this, ...args2), "cb");
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();
__name(_Svelte4Component, "Svelte4Component");
let Svelte4Component = _Svelte4Component;
function run(fn) {
  user_pre_effect(() => {
    fn();
    var effect2 = (
      /** @type {import('#client').Effect} */
      active_effect
    );
    if ((effect2.f & DIRTY) !== 0) {
      let filename = "a file (we can't know which one)";
      if (DEV) {
        filename = dev_current_component_function?.[FILENAME] ?? filename;
      }
      legacy_recursive_reactive_block(filename);
      set_signal_status(effect2, MAYBE_DIRTY);
    }
  });
}
__name(run, "run");
function handlers(...handlers2) {
  return function(event2) {
    const { stopImmediatePropagation: stopImmediatePropagation2 } = event2;
    let stopped = false;
    event2.stopImmediatePropagation = () => {
      stopped = true;
      stopImmediatePropagation2.call(event2);
    };
    const errors = [];
    for (const handler of handlers2) {
      try {
        handler?.call(this, event2);
      } catch (e) {
        errors.push(e);
      }
      if (stopped) {
        break;
      }
    }
    for (let error of errors) {
      queueMicrotask(() => {
        throw error;
      });
    }
  };
}
__name(handlers, "handlers");
function createBubbler() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createBubbler");
  }
  return (type) => (event2) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {any} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      for (const fn of callbacks) {
        fn.call(active_component_context.x, event2);
      }
      return !event2.defaultPrevented;
    }
    return true;
  };
}
__name(createBubbler, "createBubbler");
let SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = (_c = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        var create_slot = create_slot2;
        __name(create_slot2, "create_slot");
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot2(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot2(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key2 in this.$$p_d) {
          if (!(key2 in this.$$d) && this[key2] !== void 0) {
            this.$$d[key2] = this[key2];
            delete this[key2];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key2 of object_keys(this.$$c)) {
              if (!this.$$p_d[key2]?.reflect) continue;
              this.$$d[key2] = this.$$c[key2];
              const attribute_value = get_custom_element_value(
                key2,
                this.$$d[key2],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key2].attribute || key2);
              } else {
                this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  }, __name(_c, "SvelteElement"), _c);
}
function get_custom_element_value(prop2, value2, props_definition, transform2) {
  const type = props_definition[prop2]?.type;
  value2 = type === "Boolean" && typeof value2 !== "boolean" ? value2 != null : value2;
  if (!transform2 || !props_definition[prop2]) {
    return value2;
  } else if (transform2 === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value2 == null ? null : JSON.stringify(value2);
      case "Boolean":
        return value2 ? "" : null;
      case "Number":
        return value2 == null ? null : value2;
      default:
        return value2;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value2 && JSON.parse(value2);
      case "Boolean":
        return value2;
      // conversion already handled above
      case "Number":
        return value2 != null ? +value2 : value2;
      default:
        return value2;
    }
  }
}
__name(get_custom_element_value, "get_custom_element_value");
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
__name(get_custom_elements_slots, "get_custom_elements_slots");
function create_custom_element(Component, props_definition, slots, exports, use_shadow_dom, extend) {
  var _a2;
  let Class = (_a2 = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  }, __name(_a2, "Class"), _a2);
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value2) {
        value2 = get_custom_element_value(prop2, value2, props_definition);
        this.$$d[prop2] = value2;
        var component2 = this.$$c;
        if (component2) {
          var setter = get_descriptor(component2, prop2)?.get;
          if (setter) {
            component2[prop2] = value2;
          } else {
            component2.$set({ [prop2]: value2 });
          }
        }
      }
    });
  });
  exports.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}
__name(create_custom_element, "create_custom_element");
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}
__name(log_if_contains_state, "log_if_contains_state");
function hydratable(key2, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  if (hydrating) {
    const store2 = window.__svelte?.h;
    if (store2?.has(key2)) {
      return (
        /** @type {T} */
        store2.get(key2)
      );
    }
    if (DEV) {
      hydratable_missing_but_required(key2);
    } else {
      hydratable_missing_but_expected(key2);
    }
  }
  return fn();
}
__name(hydratable, "hydratable");
if (DEV) {
  let throw_rune_error = /* @__PURE__ */ __name(function(rune) {
    if (!(rune in globalThis)) {
      let value2;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: /* @__PURE__ */ __name(() => {
          if (value2 !== void 0) {
            return value2;
          }
          rune_outside_svelte(rune);
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          value2 = v;
        }, "set")
      });
    }
  }, "throw_rune_error");
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
function getAbortSignal() {
  if (active_reaction === null) {
    get_abort_signal_outside_reaction();
  }
  return (active_reaction.ac ?? (active_reaction.ac = new AbortController())).signal;
}
__name(getAbortSignal, "getAbortSignal");
function onMount(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onMount");
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn);
      if (typeof cleanup === "function") return (
        /** @type {() => void} */
        cleanup
      );
    });
  }
}
__name(onMount, "onMount");
function onDestroy(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onDestroy");
  }
  onMount(() => () => untrack(fn));
}
__name(onDestroy, "onDestroy");
function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
__name(create_custom_event, "create_custom_event");
function createEventDispatcher() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createEventDispatcher");
  }
  return (type, detail, options) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {string} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      const event2 = create_custom_event(
        /** @type {string} */
        type,
        detail,
        options
      );
      for (const fn of callbacks) {
        fn.call(active_component_context.x, event2);
      }
      return !event2.defaultPrevented;
    }
    return true;
  };
}
__name(createEventDispatcher, "createEventDispatcher");
function beforeUpdate(fn) {
  if (component_context === null) {
    lifecycle_outside_component("beforeUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("beforeUpdate");
  }
  init_update_callbacks(component_context).b.push(fn);
}
__name(beforeUpdate, "beforeUpdate");
function afterUpdate(fn) {
  if (component_context === null) {
    lifecycle_outside_component("afterUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("afterUpdate");
  }
  init_update_callbacks(component_context).a.push(fn);
}
__name(afterUpdate, "afterUpdate");
function init_update_callbacks(context) {
  var l = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return l.u ?? (l.u = { a: [], b: [], m: [] });
}
__name(init_update_callbacks, "init_update_callbacks");
const _SvelteRenderer = class _SvelteRenderer {
  mount(descriptor, target, viewModel) {
    if (descriptor.type !== "svelte") {
      return err({
        code: "InvalidType",
        message: `SvelteRenderer can only mount svelte components`
      });
    }
    try {
      const component2 = descriptor.component;
      const mounted = mount(component2, {
        target,
        props: {
          ...descriptor.props,
          viewModel
          // ViewModel als Prop
        }
      });
      return ok({
        id: `svelte-${Date.now()}-${Math.random()}`,
        type: "svelte",
        element: target,
        props: { ...descriptor.props, viewModel },
        instance: mounted
        // Svelte-spezifisch: mount() Rückgabe
      });
    } catch (error) {
      return err({
        code: "MountFailed",
        message: `Failed to mount svelte component: ${String(error)}`,
        cause: error
      });
    }
  }
  unmount(instance2) {
    try {
      if (instance2.instance) {
        unmount(instance2.instance);
      }
      return ok(void 0);
    } catch (error) {
      return err({
        code: "UnmountFailed",
        message: `Failed to unmount component: ${String(error)}`,
        cause: error
      });
    }
  }
  update(_instance2, _viewModel) {
    try {
      return ok(void 0);
    } catch (error) {
      return err({
        code: "UpdateFailed",
        message: `Failed to update component: ${String(error)}`,
        cause: error
      });
    }
  }
};
__name(_SvelteRenderer, "SvelteRenderer");
let SvelteRenderer = _SvelteRenderer;
const _FlagsPersistAdapter = class _FlagsPersistAdapter {
  async save(config2, data, meta) {
    if (config2.type !== "flag") {
      return err({ code: "InvalidType", message: "Not a flag persist config" });
    }
    if (!config2.documentId || !config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Flag config requires documentId, namespace, and key"
      });
    }
    try {
      if (typeof game === "undefined") {
        return err({ code: "GameNotAvailable", message: "Foundry game object not available" });
      }
      const documentType = config2.documentId.split(".")[0];
      if (!documentType) {
        return err({ code: "InvalidConfig", message: "Invalid document ID format" });
      }
      const collectionResult = castFoundryDocumentCollection(game.collections, documentType);
      if (!collectionResult.ok) {
        return err({
          code: "DocumentNotFound",
          message: `Document collection not found: ${collectionResult.error.message}`
        });
      }
      const collection = collectionResult.value;
      const doc = collection.get(config2.documentId);
      if (!doc) {
        return err({
          code: "DocumentNotFound",
          message: `Document ${config2.documentId} not found`
        });
      }
      const documentWithUpdate = doc;
      const changes = {
        [`flags.${config2.namespace}.${config2.key}`]: data
      };
      const options = {
        render: meta?.render ?? false,
        // Kein Rerender (in options, nicht in changes!)
        windowFrameworkOrigin: meta
        // Origin-Meta für Hook-Bridge
      };
      await documentWithUpdate.update(changes, options);
      return ok(void 0);
    } catch (error) {
      return err({
        code: "SaveFailed",
        message: `Failed to save flag: ${String(error)}`,
        cause: error
      });
    }
  }
  async load(config2) {
    if (config2.type !== "flag") {
      return err({ code: "InvalidType", message: "Not a flag persist config" });
    }
    if (!config2.documentId || !config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Flag config requires documentId, namespace, and key"
      });
    }
    try {
      if (typeof game === "undefined") {
        return err({ code: "GameNotAvailable", message: "Foundry game object not available" });
      }
      const documentType = config2.documentId.split(".")[0];
      if (!documentType) {
        return err({ code: "InvalidConfig", message: "Invalid document ID format" });
      }
      const collectionResult = castFoundryDocumentCollection(game.collections, documentType);
      if (!collectionResult.ok) {
        return err({
          code: "DocumentNotFound",
          message: `Document collection not found: ${collectionResult.error.message}`
        });
      }
      const collection = collectionResult.value;
      const doc = collection.get(config2.documentId);
      if (!doc) {
        return err({
          code: "DocumentNotFound",
          message: `Document ${config2.documentId} not found`
        });
      }
      const documentWithFlags = doc;
      let flags2;
      if (typeof documentWithFlags.getFlag === "function") {
        try {
          flags2 = documentWithFlags.getFlag(config2.namespace, config2.key);
        } catch {
          flags2 = void 0;
        }
      }
      if (!flags2) {
        const docFlags = documentWithFlags.flags?.[config2.namespace];
        flags2 = docFlags?.[config2.key];
      }
      return ok(flags2 || {});
    } catch (error) {
      return err({
        code: "LoadFailed",
        message: `Failed to load flag: ${String(error)}`,
        cause: error
      });
    }
  }
};
__name(_FlagsPersistAdapter, "FlagsPersistAdapter");
let FlagsPersistAdapter = _FlagsPersistAdapter;
const recordSchema = {
  validate(value2) {
    if (value2 && typeof value2 === "object" && !Array.isArray(value2)) {
      return ok(value2);
    }
    return err({
      code: "SETTING_VALIDATION_FAILED",
      message: "Value is not a valid object"
    });
  }
};
const _SettingsPersistAdapter = class _SettingsPersistAdapter {
  constructor(settingsPort) {
    this.settingsPort = settingsPort;
  }
  async save(config2, data, _meta) {
    if (config2.type !== "setting") {
      return err({ code: "InvalidType", message: "Not a setting persist config" });
    }
    if (!config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Setting config requires namespace and key"
      });
    }
    const result = await this.settingsPort.set(config2.namespace, config2.key, data);
    if (!result.ok) {
      return err({
        code: "SaveFailed",
        message: result.error.message,
        cause: result.error
      });
    }
    return ok(void 0);
  }
  async load(config2) {
    if (config2.type !== "setting") {
      return err({ code: "InvalidType", message: "Not a setting persist config" });
    }
    if (!config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Setting config requires namespace and key"
      });
    }
    const result = this.settingsPort.get(config2.namespace, config2.key, recordSchema);
    if (!result.ok) {
      return err({
        code: "LoadFailed",
        message: result.error.message,
        cause: result.error
      });
    }
    return ok(result.value || {});
  }
};
__name(_SettingsPersistAdapter, "SettingsPersistAdapter");
let SettingsPersistAdapter = _SettingsPersistAdapter;
const _CompositePersistAdapter = class _CompositePersistAdapter {
  constructor(settingsPort) {
    this.flagsAdapter = new FlagsPersistAdapter();
    this.settingsAdapter = new SettingsPersistAdapter(settingsPort);
  }
  async save(config2, data, meta) {
    const adapter = this.getAdapter(config2.type);
    return adapter.save(config2, data, meta);
  }
  async load(config2) {
    const adapter = this.getAdapter(config2.type);
    return adapter.load(config2);
  }
  getAdapter(type) {
    switch (type) {
      case "flag":
        return this.flagsAdapter;
      case "setting":
        return this.settingsAdapter;
      default:
        return this.flagsAdapter;
    }
  }
};
__name(_CompositePersistAdapter, "CompositePersistAdapter");
_CompositePersistAdapter.dependencies = [platformSettingsPortToken];
let CompositePersistAdapter = _CompositePersistAdapter;
const _WindowController = class _WindowController {
  constructor(instanceId, definitionId, definition, registry, stateStore, statePortFactory, actionDispatcher, rendererRegistry, bindingEngine, viewModelBuilder, eventBus, remoteSyncGate, persistAdapter) {
    this.registry = registry;
    this.stateStore = stateStore;
    this.statePortFactory = statePortFactory;
    this.actionDispatcher = actionDispatcher;
    this.rendererRegistry = rendererRegistry;
    this.bindingEngine = bindingEngine;
    this.viewModelBuilder = viewModelBuilder;
    this.eventBus = eventBus;
    this.remoteSyncGate = remoteSyncGate;
    this.persistAdapter = persistAdapter;
    this.componentInstance = null;
    this.isMounted = false;
    this.instanceId = instanceId;
    this.definitionId = definitionId;
    this.definition = definition;
    this.statePort = this.createStatePort();
  }
  get state() {
    const result = this.stateStore.getAll(this.instanceId);
    return result.ok ? result.value : {};
  }
  async onFoundryRender(element2) {
    if (this.isMounted) {
      return ok(void 0);
    }
    this.element = element2;
    const bindResult = this.bindingEngine.initialize(this.definition, this.instanceId);
    if (!bindResult.ok) return err(bindResult.error);
    const viewModel = this.viewModelBuilder.build(
      this.definition,
      this.statePort,
      // StatePort statt Plain Object
      this.createActions()
    );
    this.cachedViewModel = viewModel;
    const rendererResult = this.rendererRegistry.get(this.definition.component.type);
    if (!rendererResult.ok) return err(rendererResult.error);
    const mountPoint = element2.querySelector("#svelte-mount-point");
    if (!mountPoint) {
      return err({
        code: "MountPointNotFound",
        message: "Mount point #svelte-mount-point not found"
      });
    }
    const mountResult = rendererResult.value.mount(
      this.definition.component,
      mountPoint,
      viewModel
    );
    if (!mountResult.ok) return err(mountResult.error);
    this.componentInstance = mountResult.value;
    this.isMounted = true;
    this.registerEventListeners();
    this.eventBus.emit("window:rendered", { instanceId: this.instanceId });
    return ok(void 0);
  }
  async onFoundryUpdate(_element) {
    return ok(void 0);
  }
  async onFoundryClose() {
    if (this.componentInstance !== null) {
      const rendererResult = this.rendererRegistry.get(this.definition.component.type);
      if (rendererResult.ok) {
        if (this.componentInstance !== null) {
          rendererResult.value.unmount(this.componentInstance);
        }
      }
      this.componentInstance = null;
    }
    this.isMounted = false;
    if (this.definition.persist) {
      const meta = this.remoteSyncGate.makePersistMeta(this.instanceId);
      await this.persist(meta);
    }
    this.eventBus.emit("window:closed", { instanceId: this.instanceId });
    return ok(void 0);
  }
  async updateStateLocal(updates, options) {
    const { persist = false, sync = "none" } = options ?? {};
    this.statePort.patch(updates);
    if (persist && this.definition.persist) {
      const meta = this.remoteSyncGate.makePersistMeta(this.instanceId);
      const persistResult = await this.persist(meta);
      if (!persistResult.ok) return err(persistResult.error);
    }
    if (sync !== "none") {
      const syncResult = await this.bindingEngine.sync(this.instanceId, sync);
      if (!syncResult.ok) return err(syncResult.error);
    }
    for (const [key2, value2] of Object.entries(updates)) {
      this.eventBus.emit("state:updated", { instanceId: this.instanceId, key: key2, value: value2 });
    }
    return ok(void 0);
  }
  async applyRemotePatch(updates) {
    this.statePort.patch(updates);
    for (const [key2, value2] of Object.entries(updates)) {
      this.eventBus.emit("state:updated", { instanceId: this.instanceId, key: key2, value: value2 });
    }
    return ok(void 0);
  }
  async dispatchAction(actionId, controlId, event2) {
    const context = {
      windowInstanceId: this.instanceId,
      ...controlId !== void 0 && { controlId },
      state: this.state,
      ...event2 !== void 0 && { event: event2 }
    };
    const result = await this.actionDispatcher.dispatch(actionId, context);
    if (!result.ok) return err(result.error);
    return ok(void 0);
  }
  async persist(meta) {
    if (!this.definition.persist) {
      return err({
        code: "NoPersistConfig",
        message: "No persist configuration found"
      });
    }
    if (!this.persistAdapter) {
      return err({
        code: "NoPersistAdapter",
        message: "No persist adapter available"
      });
    }
    const state2 = this.statePort.get();
    const persistMeta = meta ?? this.remoteSyncGate.makePersistMeta(this.instanceId);
    const result = await this.persistAdapter.save(this.definition.persist, state2, persistMeta);
    if (!result.ok) return err(result.error);
    return ok(void 0);
  }
  async restore() {
    if (!this.definition.persist?.restoreOnOpen) {
      return ok(void 0);
    }
    if (!this.persistAdapter) {
      return err({
        code: "NoPersistAdapter",
        message: "No persist adapter available"
      });
    }
    const result = await this.persistAdapter.load(this.definition.persist);
    if (!result.ok) return err(result.error);
    await this.applyRemotePatch(result.value);
    return ok(void 0);
  }
  getViewModel() {
    if (this.cachedViewModel) {
      return this.cachedViewModel;
    }
    return this.viewModelBuilder.build(this.definition, this.statePort, this.createActions());
  }
  createStatePort() {
    const initialStateResult = this.stateStore.getAll(this.instanceId);
    const initialState = initialStateResult.ok ? initialStateResult.value : {};
    return this.statePortFactory.create(this.instanceId, initialState);
  }
  createActions() {
    const actions = {};
    for (const actionDef of this.definition.actions || []) {
      actions[actionDef.id] = () => {
        this.dispatchAction(actionDef.id);
      };
    }
    return actions;
  }
  registerEventListeners() {
    this.eventBus.on("control:action", (payload) => {
      if (payload.instanceId === this.instanceId) {
        this.dispatchAction(payload.actionId, payload.controlId, payload.event);
      }
    });
  }
};
__name(_WindowController, "WindowController");
let WindowController = _WindowController;
const _WindowFactory = class _WindowFactory {
  constructor(registry, foundryWindowAdapter, container) {
    this.registry = registry;
    this.foundryWindowAdapter = foundryWindowAdapter;
    this.container = container;
  }
  async createWindow(definitionId, instanceKey, overrides) {
    const definitionResult = this.registry.getDefinition(definitionId);
    if (!definitionResult.ok) return err(definitionResult.error);
    let definition = definitionResult.value;
    if (overrides) {
      definition = { ...definition, ...overrides };
    }
    const instanceId = instanceKey ? `${definitionId}:${instanceKey}` : `${definitionId}:${Date.now()}-${Math.random()}`;
    const controller = this.createController(instanceId, definitionId, definition);
    const appClassResult = this.foundryWindowAdapter.buildApplicationWrapper(
      definition,
      controller,
      instanceId
    );
    if (!appClassResult.ok) return err(appClassResult.error);
    const appClass = appClassResult.value;
    const app = new appClass();
    const instance2 = {
      instanceId,
      definitionId,
      foundryApp: app,
      controller
      // Für Hook-Bridge Zugriff
    };
    const registerResult = this.registry.registerInstance(instance2);
    if (!registerResult.ok) return err(registerResult.error);
    const registry = this.registry;
    const handle = {
      instanceId,
      definitionId,
      controller,
      definition,
      async show() {
        await app.render();
        return ok(void 0);
      },
      async hide() {
        await app.render({ force: false });
        return ok(void 0);
      },
      async close() {
        await app.close();
        const unregisterResult = registry.unregisterInstance(instanceId);
        return unregisterResult;
      },
      async update(state2) {
        return controller.updateStateLocal(state2);
      },
      async persist() {
        return controller.persist();
      },
      async restore() {
        return controller.restore();
      }
    };
    return ok(handle);
  }
  createController(instanceId, definitionId, definition) {
    const registry = this.container.resolve(windowRegistryToken);
    const stateStore = this.container.resolve(
      stateStoreToken
    );
    const statePortFactory = this.container.resolve(
      statePortFactoryToken
    );
    const actionDispatcher = this.container.resolve(
      actionDispatcherToken
    );
    const rendererRegistry = this.container.resolve(
      rendererRegistryToken
    );
    const bindingEngine = this.container.resolve(
      bindingEngineToken
    );
    const viewModelBuilder = this.container.resolve(
      viewModelBuilderToken
    );
    const eventBus = this.container.resolve(
      eventBusToken
    );
    const remoteSyncGate = this.container.resolve(
      remoteSyncGateToken
    );
    const persistAdapter = this.container.resolve(persistAdapterToken);
    return new WindowController(
      instanceId,
      definitionId,
      definition,
      registry,
      stateStore,
      statePortFactory,
      actionDispatcher,
      rendererRegistry,
      bindingEngine,
      viewModelBuilder,
      eventBus,
      remoteSyncGate,
      persistAdapter
    );
  }
};
__name(_WindowFactory, "WindowFactory");
let WindowFactory = _WindowFactory;
const _WindowHooksBridge = class _WindowHooksBridge {
  constructor(registry, remoteSyncGate, sharedDocumentCache) {
    this.registry = registry;
    this.remoteSyncGate = remoteSyncGate;
    this.sharedDocumentCache = sharedDocumentCache;
  }
  register() {
    if (typeof Hooks !== "undefined") {
      const hooksApi = Hooks;
      hooksApi.on("updateDocument", (...args2) => {
        const [document2, _update, options] = args2;
        this.handleDocumentUpdate(document2, _update, options);
      });
      hooksApi.on("settingChange", (...args2) => {
        const [namespace, key2, value2, options] = args2;
        this.handleSettingChange(
          // type-coverage:ignore-next-line
          namespace,
          // type-coverage:ignore-next-line
          key2,
          value2,
          options
        );
      });
    }
  }
  handleDocumentUpdate(document2, update2, options) {
    const optionsRecord = options;
    const instances = this.registry.listInstances();
    for (const instance2 of instances) {
      if (this.remoteSyncGate.isFromWindow(optionsRecord, instance2.instanceId)) {
        continue;
      }
      const instanceResult = this.registry.getInstance(instance2.instanceId);
      if (!instanceResult.ok) continue;
      const definitionResult = this.registry.getDefinition(instance2.definitionId);
      if (!definitionResult.ok) continue;
      const definition = definitionResult.value;
      if (this.isRelevant(definition, document2, update2)) {
        const controller = instanceResult.value.controller;
        if (controller) {
          const patch = this.extractPatch(document2, update2);
          controller.applyRemotePatch(patch);
        }
      }
    }
    this.updateSharedCache(document2, update2);
  }
  handleSettingChange(namespace, key2, value2, options) {
    const instances = this.registry.listInstances();
    const optionsRecord = options;
    for (const instance2 of instances) {
      if (this.remoteSyncGate.isFromWindow(optionsRecord, instance2.instanceId)) {
        continue;
      }
      const definitionResult = this.registry.getDefinition(instance2.definitionId);
      if (!definitionResult.ok) continue;
      const definition = definitionResult.value;
      if (this.isRelevantForSetting(definition, namespace, key2)) {
      }
    }
  }
  isRelevantForSetting(definition, namespace, key2) {
    if (definition.persist?.type === "setting" && definition.persist.namespace === namespace && definition.persist.key === key2) {
      return true;
    }
    if (definition.dependencies) {
      for (const dep of definition.dependencies) {
        if (dep.type === "setting" && dep.namespace === namespace && dep.key === key2) {
          return true;
        }
      }
    }
    return false;
  }
  isRelevant(definition, document2, _update) {
    if (definition.persist) {
      if (definition.persist.type === "flag" && definition.persist.documentId === document2.id) {
        return true;
      }
      if (definition.persist.type === "journal" && definition.persist.documentId === document2.id) {
        return true;
      }
    }
    if (definition.dependencies) {
      for (const dep of definition.dependencies) {
        if (dep.type === "document" && dep.documentId === document2.id) {
          return true;
        }
        if (dep.type === "document" && dep.documentType) {
          const docType = document2.constructor?.name;
          if (docType === dep.documentType) {
            return true;
          }
        }
      }
    }
    return false;
  }
  extractPatch(document2, update2) {
    const updateRecord = update2;
    return updateRecord || {};
  }
  updateSharedCache(document2, update2) {
    const documentType = document2.constructor?.name || "";
    const updateRecord = update2 || {};
    const docRecord = document2;
    if (documentType === "Actor" || document2.id.startsWith("Actor.")) {
      const actorSnapshot = {
        id: document2.id,
        // type-coverage:ignore-next-line
        name: docRecord.name || "",
        system: (
          // type-coverage:ignore-next-line
          updateRecord.system || // type-coverage:ignore-next-line
          docRecord.system || {}
        ),
        flags: (
          // type-coverage:ignore-next-line
          updateRecord.flags || // type-coverage:ignore-next-line
          docRecord.flags || {}
        )
      };
      this.sharedDocumentCache.patchActor(document2.id, actorSnapshot);
    } else if (documentType === "Item" || document2.id.startsWith("Item.")) {
      const itemSnapshot = {
        id: document2.id,
        // type-coverage:ignore-next-line
        name: docRecord.name || "",
        system: (
          // type-coverage:ignore-next-line
          updateRecord.system || // type-coverage:ignore-next-line
          docRecord.system || {}
        ),
        flags: (
          // type-coverage:ignore-next-line
          updateRecord.flags || // type-coverage:ignore-next-line
          docRecord.flags || {}
        ),
        // type-coverage:ignore-next-line
        actorId: updateRecord.actorId || docRecord.actorId
      };
      this.sharedDocumentCache.patchItem(document2.id, itemSnapshot);
    }
  }
};
__name(_WindowHooksBridge, "WindowHooksBridge");
let WindowHooksBridge = _WindowHooksBridge;
const _WindowHooksService = class _WindowHooksService {
  constructor(registry, remoteSyncGate, sharedDocumentCache) {
    this.registry = registry;
    this.remoteSyncGate = remoteSyncGate;
    this.sharedDocumentCache = sharedDocumentCache;
    this.bridge = null;
  }
  /**
   * Registriert die WindowHooksBridge.
   * Muss nach erfolgreichem Bootstrap aufgerufen werden.
   */
  register() {
    if (this.bridge) {
      return;
    }
    this.bridge = new WindowHooksBridge(
      this.registry,
      this.remoteSyncGate,
      this.sharedDocumentCache
    );
    this.bridge.register();
  }
  /**
   * Entfernt die Hook-Registrierungen.
   * Sollte bei Shutdown aufgerufen werden.
   */
  unregister() {
    this.bridge = null;
  }
};
__name(_WindowHooksService, "WindowHooksService");
_WindowHooksService.dependencies = [
  windowRegistryToken,
  remoteSyncGateToken,
  sharedDocumentCacheToken
];
let WindowHooksService = _WindowHooksService;
const _WindowPositionManager = class _WindowPositionManager {
  constructor() {
    this.STORAGE_KEY_PREFIX = "windowPosition:";
  }
  loadPosition(instanceId) {
    try {
      const key2 = this.getStorageKey(instanceId);
      const stored = localStorage.getItem(key2);
      if (!stored) {
        return ok(void 0);
      }
      const position = JSON.parse(stored);
      return ok(position);
    } catch (error) {
      return err({
        code: "PositionLoadFailed",
        message: `Failed to load position for ${instanceId}: ${String(error)}`
      });
    }
  }
  savePosition(instanceId, position) {
    try {
      const key2 = this.getStorageKey(instanceId);
      localStorage.setItem(key2, JSON.stringify(position));
      return ok(void 0);
    } catch (error) {
      return err({
        code: "PositionSaveFailed",
        message: `Failed to save position for ${instanceId}: ${String(error)}`
      });
    }
  }
  getEffectivePosition(instanceId, initialPosition) {
    const savedResult = this.loadPosition(instanceId);
    if (!savedResult.ok) {
      return err(savedResult.error);
    }
    const saved = savedResult.value;
    if (!saved && !initialPosition) {
      return ok(void 0);
    }
    if (!saved) {
      return ok(initialPosition);
    }
    if (!initialPosition) {
      return ok(saved);
    }
    return ok({
      ...initialPosition,
      ...saved
    });
  }
  getStorageKey(instanceId) {
    return `${this.STORAGE_KEY_PREFIX}${instanceId}`;
  }
};
__name(_WindowPositionManager, "WindowPositionManager");
let WindowPositionManager = _WindowPositionManager;
function registerWindowServices(container) {
  const eventBusResult = container.registerClass(
    eventBusToken,
    EventBus,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventBusResult)) {
    return err(`Failed to register EventBus: ${eventBusResult.error.message}`);
  }
  const stateStoreResult = container.registerClass(
    stateStoreToken,
    StateStore,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(stateStoreResult)) {
    return err(`Failed to register StateStore: ${stateStoreResult.error.message}`);
  }
  const windowRegistryResult = container.registerClass(
    windowRegistryToken,
    WindowRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowRegistryResult)) {
    return err(`Failed to register WindowRegistry: ${windowRegistryResult.error.message}`);
  }
  const remoteSyncGateResult = container.registerClass(
    remoteSyncGateToken,
    RemoteSyncGate,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(remoteSyncGateResult)) {
    return err(`Failed to register RemoteSyncGate: ${remoteSyncGateResult.error.message}`);
  }
  const rendererRegistryResult = container.registerClass(
    rendererRegistryToken,
    RendererRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(rendererRegistryResult)) {
    return err(`Failed to register RendererRegistry: ${rendererRegistryResult.error.message}`);
  }
  const statePortFactoryResult = container.registerClass(
    statePortFactoryToken,
    RuneStateFactory,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(statePortFactoryResult)) {
    return err(`Failed to register StatePortFactory: ${statePortFactoryResult.error.message}`);
  }
  const sharedCache = GlobalDocumentCache.getInstance();
  const sharedCacheResult = container.registerValue(sharedDocumentCacheToken, sharedCache);
  if (isErr(sharedCacheResult)) {
    return err(`Failed to register SharedDocumentCache: ${sharedCacheResult.error.message}`);
  }
  const persistAdapterResult = container.registerClass(
    persistAdapterToken,
    CompositePersistAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(persistAdapterResult)) {
    return err(`Failed to register PersistAdapter: ${persistAdapterResult.error.message}`);
  }
  const foundryAdapterResult = container.registerClass(
    foundryWindowAdapterToken,
    FoundryWindowAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryAdapterResult)) {
    return err(`Failed to register FoundryWindowAdapter: ${foundryAdapterResult.error.message}`);
  }
  const actionDispatcherResult = container.registerClass(
    actionDispatcherToken,
    ActionDispatcher,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(actionDispatcherResult)) {
    return err(`Failed to register ActionDispatcher: ${actionDispatcherResult.error.message}`);
  }
  const bindingEngineResult = container.registerClass(
    bindingEngineToken,
    BindingEngine,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(bindingEngineResult)) {
    return err(`Failed to register BindingEngine: ${bindingEngineResult.error.message}`);
  }
  const viewModelBuilderResult = container.registerClass(
    viewModelBuilderToken,
    ViewModelBuilder,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(viewModelBuilderResult)) {
    return err(`Failed to register ViewModelBuilder: ${viewModelBuilderResult.error.message}`);
  }
  const windowFactoryFactoryResult = container.registerFactory(
    windowFactoryToken,
    () => {
      const registry = container.resolve(
        windowRegistryToken
      );
      const foundryAdapter = container.resolve(
        foundryWindowAdapterToken
      );
      const containerPort = container.resolve(
        platformContainerPortToken
      );
      return new WindowFactory(registry, foundryAdapter, containerPort);
    },
    ServiceLifecycle.SINGLETON,
    [windowRegistryToken, foundryWindowAdapterToken, platformContainerPortToken]
  );
  if (isErr(windowFactoryFactoryResult)) {
    return err(`Failed to register WindowFactory: ${windowFactoryFactoryResult.error.message}`);
  }
  const windowPositionManagerResult = container.registerClass(
    windowPositionManagerToken,
    WindowPositionManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowPositionManagerResult)) {
    return err(
      `Failed to register WindowPositionManager: ${windowPositionManagerResult.error.message}`
    );
  }
  const windowHooksServiceResult = container.registerClass(
    windowHooksServiceToken,
    WindowHooksService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowHooksServiceResult)) {
    return err(`Failed to register WindowHooksService: ${windowHooksServiceResult.error.message}`);
  }
  const rendererRegistryResolvedResult = container.resolveWithError(rendererRegistryToken);
  if (rendererRegistryResolvedResult.ok) {
    const rendererRegistryResolved = castResolvedService(rendererRegistryResolvedResult.value);
    const svelteRenderer = new SvelteRenderer();
    rendererRegistryResolved.register("svelte", svelteRenderer);
  }
  return ok(void 0);
}
__name(registerWindowServices, "registerWindowServices");
dependencyRegistry.register({
  name: "WindowServices",
  priority: 150,
  // After core services (140), before validation (170)
  execute: registerWindowServices
});
let internalStepsRegistered = false;
function createDependencyRegistrationRegistry() {
  if (!internalStepsRegistered) {
    dependencyRegistry.register({
      name: "StaticValues",
      priority: 10,
      execute: registerStaticValues
    });
    dependencyRegistry.register({
      name: "SubcontainerValues",
      priority: 70,
      execute: registerSubcontainerValues
    });
    dependencyRegistry.register({
      name: "LoopPreventionServices",
      priority: 160,
      execute: registerLoopPreventionServices
    });
    dependencyRegistry.register({ name: "Validation", priority: 170, execute: validateContainer });
    dependencyRegistry.register({
      name: "LoopPreventionInit",
      priority: 180,
      execute: initializeLoopPreventionValues
    });
    dependencyRegistry.register({
      name: "CacheConfigSyncInit",
      priority: 190,
      execute: initializeCacheConfigSync
    });
    internalStepsRegistered = true;
  }
  return dependencyRegistry;
}
__name(createDependencyRegistrationRegistry, "createDependencyRegistrationRegistry");
function resetDependencyRegistry() {
  dependencyRegistry.reset();
  internalStepsRegistered = false;
}
__name(resetDependencyRegistry, "resetDependencyRegistry");
function registerEnvironmentConfig(container) {
  const envResult = container.registerValue(environmentConfigToken, ENV);
  if (isErr(envResult)) {
    return err(`Failed to register EnvironmentConfig: ${envResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerEnvironmentConfig, "registerEnvironmentConfig");
function registerRuntimeConfig(container) {
  const runtimeConfigAdapter = createRuntimeConfigAdapter(ENV);
  const runtimeConfigResult = container.registerValue(runtimeConfigToken, runtimeConfigAdapter);
  if (isErr(runtimeConfigResult)) {
    return err(`Failed to register RuntimeConfigAdapter: ${runtimeConfigResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerRuntimeConfig, "registerRuntimeConfig");
function registerServiceContainer(container) {
  const containerResult = container.registerValue(serviceContainerToken, container);
  if (isErr(containerResult)) {
    return err(`Failed to register ServiceContainer: ${containerResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerServiceContainer, "registerServiceContainer");
function registerPlatformContainerPortAlias(container) {
  const aliasResult = container.registerAlias(
    platformContainerPortToken,
    castContainerTokenToPlatformContainerPortToken(serviceContainerToken)
  );
  if (isErr(aliasResult)) {
    return err(`Failed to register PlatformContainerPort alias: ${aliasResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerPlatformContainerPortAlias, "registerPlatformContainerPortAlias");
function registerModuleId(container) {
  const moduleIdResult = container.registerValue(moduleIdToken, MODULE_METADATA.ID);
  if (isErr(moduleIdResult)) {
    return err(`Failed to register ModuleId: ${moduleIdResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerModuleId, "registerModuleId");
function registerStaticValues(container) {
  const results = [
    registerEnvironmentConfig(container),
    registerRuntimeConfig(container),
    registerServiceContainer(container),
    registerPlatformContainerPortAlias(container),
    registerModuleId(container)
  ];
  for (const result of results) {
    if (isErr(result)) return result;
  }
  return ok(void 0);
}
__name(registerStaticValues, "registerStaticValues");
function registerSubcontainerValues(container) {
  return registerPortRegistries(container);
}
__name(registerSubcontainerValues, "registerSubcontainerValues");
function registerLoopPreventionServices(container) {
  const containerCheckResult = container.registerClass(
    containerHealthCheckToken,
    getDIContainerHealthCheckClass(),
    ServiceLifecycle.SINGLETON
  );
  if (isErr(containerCheckResult)) {
    return err(`Failed to register ContainerHealthCheck: ${containerCheckResult.error.message}`);
  }
  const metricsCheckResult = container.registerClass(
    metricsHealthCheckToken,
    getDIMetricsHealthCheckClass(),
    ServiceLifecycle.SINGLETON
  );
  if (isErr(metricsCheckResult)) {
    return err(`Failed to register MetricsHealthCheck: ${metricsCheckResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerLoopPreventionServices, "registerLoopPreventionServices");
function initializeLoopPreventionValues(container) {
  const registryRes = container.resolveWithError(healthCheckRegistryToken);
  const metricsRes = container.resolveWithError(metricsCollectorToken);
  if (!registryRes.ok) {
    return err(`Failed to resolve HealthCheckRegistry: ${registryRes.error.message}`);
  }
  if (!metricsRes.ok) {
    return err(`Failed to resolve MetricsCollector: ${metricsRes.error.message}`);
  }
  const containerCheckResult = container.resolveWithError(containerHealthCheckToken);
  if (!containerCheckResult.ok) {
    return err(`Failed to resolve ContainerHealthCheck: ${containerCheckResult.error.message}`);
  }
  const metricsCheckResult = container.resolveWithError(metricsHealthCheckToken);
  if (!metricsCheckResult.ok) {
    return err(`Failed to resolve MetricsHealthCheck: ${metricsCheckResult.error.message}`);
  }
  return ok(void 0);
}
__name(initializeLoopPreventionValues, "initializeLoopPreventionValues");
function validateContainer(container) {
  const validateResult = container.validate();
  if (isErr(validateResult)) {
    const errorMessages = validateResult.error.map((e) => e.message).join(", ");
    return err(`Validation failed: ${errorMessages}`);
  }
  return ok(void 0);
}
__name(validateContainer, "validateContainer");
function configureDependencies(container) {
  const registry = createDependencyRegistrationRegistry();
  return registry.configure(container);
}
__name(configureDependencies, "configureDependencies");
const _DependencyConfigurator = class _DependencyConfigurator {
  /**
   * Configures all dependencies in the given container.
   *
   * @param container - The service container to configure
   * @returns Result indicating success or configuration errors
   */
  configure(container) {
    return configureDependencies(container);
  }
};
__name(_DependencyConfigurator, "DependencyConfigurator");
let DependencyConfigurator = _DependencyConfigurator;
const _CompositionRoot = class _CompositionRoot {
  /**
   * Creates a new CompositionRoot instance.
   *
   * @param containerFactory - Factory for creating containers (defaults to ContainerFactory)
   * @param dependencyConfigurator - Configurator for setting up dependencies (defaults to DependencyConfigurator)
   * @param performanceTracker - Optional performance tracker (created internally if not provided)
   * @param errorHandler - Optional error handler (defaults to BootstrapErrorHandler)
   */
  constructor(containerFactory, dependencyConfigurator, performanceTracker, errorHandler) {
    this.container = null;
    this.containerFactory = containerFactory ?? new ContainerFactory();
    this.dependencyConfigurator = dependencyConfigurator ?? new DependencyConfigurator();
    this.performanceTracker = performanceTracker ?? new BootstrapPerformanceTracker(new RuntimeConfigAdapter(ENV), null);
    this.errorHandler = errorHandler ?? BootstrapErrorHandler;
  }
  /**
   * Attempts to log bootstrap completion message.
   * Extracted to separate method for better testability.
   *
   * @param container - The service container to resolve logger from
   * @param duration - The bootstrap duration in milliseconds
   * @internal For testing purposes - public to allow direct testing
   */
  tryLogBootstrapCompletion(container, duration) {
    const loggerResult = container.resolveWithError(loggerToken);
    if (loggerResult.ok) {
      const logger = castResolvedService(loggerResult.value);
      logger.debug(`Bootstrap completed in ${duration.toFixed(2)}ms`);
    } else {
    }
  }
  /**
   * Erstellt den ServiceContainer und führt Basis-Registrierungen aus.
   * Misst Performance für Diagnose-Zwecke.
   *
   * **Coordination Flow:**
   * 1. ContainerFactory creates container
   * 2. BootstrapPerformanceTracker tracks performance
   * 3. DependencyConfigurator configures dependencies
   * 4. BootstrapErrorHandler handles errors if needed
   *
   * **Performance Tracking:**
   * Uses BootstrapPerformanceTracker with ENV (direct import) and null MetricsCollector.
   * MetricsCollector is not yet available during bootstrap phase.
   *
   * @returns Result mit initialisiertem Container oder Fehlermeldung
   */
  bootstrap() {
    const container = this.containerFactory.createRoot(ENV);
    const configured = this.performanceTracker.track(
      () => this.dependencyConfigurator.configure(container),
      (duration) => {
        this.tryLogBootstrapCompletion(container, duration);
      }
    );
    if (configured.ok) {
      this.container = container;
      return { ok: true, value: container };
    }
    this.errorHandler.logError(configured.error, {
      phase: "bootstrap",
      component: "CompositionRoot",
      metadata: { error: configured.error }
    });
    return { ok: false, error: configured.error };
  }
  /**
   * Liefert den initialisierten Container als Result.
   * @returns Result mit Container oder Fehlermeldung
   */
  getContainer() {
    if (!this.container) {
      return { ok: false, error: `${LOG_PREFIX} Container not initialized` };
    }
    return { ok: true, value: this.container };
  }
};
__name(_CompositionRoot, "CompositionRoot");
let CompositionRoot = _CompositionRoot;
function initializeFoundryModule() {
  const containerResult = root.getContainer();
  if (!containerResult.ok) {
    console.error(`${LOG_PREFIX} ${containerResult.error}`);
    return;
  }
  const loggerResult = containerResult.value.resolveWithError(loggerToken);
  if (!loggerResult.ok) {
    console.error(`${LOG_PREFIX} Failed to resolve logger: ${loggerResult.error.message}`);
    return;
  }
  const logger = castResolvedService(loggerResult.value);
  const initHookServiceResult = containerResult.value.resolveWithError(
    bootstrapInitHookServiceToken
  );
  if (!initHookServiceResult.ok) {
    logger.error(
      `Failed to resolve BootstrapInitHookService: ${initHookServiceResult.error.message}`
    );
    return;
  }
  const initHookService = castResolvedService(
    initHookServiceResult.value
  );
  initHookService.register();
  const readyHookServiceResult = containerResult.value.resolveWithError(
    bootstrapReadyHookServiceToken
  );
  if (!readyHookServiceResult.ok) {
    logger.error(
      `Failed to resolve BootstrapReadyHookService: ${readyHookServiceResult.error.message}`
    );
    return;
  }
  const readyHookService = castResolvedService(
    readyHookServiceResult.value
  );
  readyHookService.register();
}
__name(initializeFoundryModule, "initializeFoundryModule");
const root = new CompositionRoot();
const bootstrapResult = root.bootstrap();
const bootstrapOk = isOk(bootstrapResult);
function getRootContainer() {
  return root.getContainer();
}
__name(getRootContainer, "getRootContainer");
if (!bootstrapOk) {
  const foundryVersion = tryGetFoundryVersion();
  BootstrapErrorHandler.logError(bootstrapResult.error, {
    phase: "bootstrap",
    component: "CompositionRoot",
    metadata: {
      foundryVersion
    }
  });
  let isOldFoundryVersion = false;
  if (typeof bootstrapResult.error === "string" && bootstrapResult.error.includes("PORT_SELECTION_FAILED")) {
    if (foundryVersion !== void 0 && foundryVersion < 13) {
      isOldFoundryVersion = true;
      if (typeof ui !== "undefined" && ui?.notifications) {
        ui.notifications.error(
          `${MODULE_METADATA.NAME} benötigt mindestens Foundry VTT Version 13. Ihre Version: ${foundryVersion}. Bitte aktualisieren Sie Foundry VTT.`,
          { permanent: true }
        );
      }
    }
  }
  if (!isOldFoundryVersion && typeof ui !== "undefined" && ui?.notifications) {
    ui.notifications?.error(
      `${MODULE_METADATA.NAME} failed to initialize. Check console for details.`,
      { permanent: true }
    );
  }
} else {
  initializeFoundryModule();
}
//# sourceMappingURL=fvtt_relationship_app_module.js.map
