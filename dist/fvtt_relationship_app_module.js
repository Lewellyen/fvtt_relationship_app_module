var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __reflectGet = Reflect.get;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var __publicField = (obj, key2, value2) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __superGet = (cls, obj, key2) => __reflectGet(__getProtoOf(cls), key2, obj);
var _a, _disposed, _disposed2, _disposed3, _disposed4, _disposed5, _disposed6, _b, _commit_callbacks, _discard_callbacks, _pending, _blocking_pending, _deferred, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, clear_marked_fn, resolve_fn, commit_fn, _pending2, _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _pending_anchor, _local_pending_count, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_subscriber, _Boundary_instances, hydrate_resolved_content_fn, hydrate_pending_content_fn, get_anchor_fn, run_fn, show_pending_snippet_fn, update_pending_count_fn, _batches, _onscreen, _offscreen, _outroing, _transition, _commit, _discard, _listeners, _observer, _options, _ResizeObserverSingleton_instances, getObserver_fn, _events, _instance, _c, _d, _runeState, _actorsById, _itemsById, _itemsByActorId;
const MODULE_METADATA = {
  ID: "fvtt_relationship_app_module",
  NAME: "Beziehungsnetzwerke für Foundry",
  AUTHOR: "Andreas Rothe",
  AUTHOR_EMAIL: "forenadmin.tir@gmail.com",
  AUTHOR_DISCORD: "lewellyen"
};
const SETTING_KEYS = {
  LOG_LEVEL: "logLevel",
  CACHE_ENABLED: "cacheEnabled",
  CACHE_TTL_MS: "cacheTtlMs",
  CACHE_MAX_ENTRIES: "cacheMaxEntries",
  PERFORMANCE_TRACKING_ENABLED: "performanceTrackingEnabled",
  PERFORMANCE_SAMPLING_RATE: "performanceSamplingRate",
  METRICS_PERSISTENCE_ENABLED: "metricsPersistenceEnabled",
  METRICS_PERSISTENCE_KEY: "metricsPersistenceKey",
  NOTIFICATION_QUEUE_MAX_SIZE: "notificationQueueMaxSize",
  JOURNAL_DIRECTORY_BUTTONS_PLAYER: "journalDirectoryButtonsPlayer",
  JOURNAL_DIRECTORY_BUTTONS_TRUSTED: "journalDirectoryButtonsTrusted",
  JOURNAL_DIRECTORY_BUTTONS_ASSISTANT: "journalDirectoryButtonsAssistant",
  JOURNAL_DIRECTORY_BUTTONS_GAMEMASTER: "journalDirectoryButtonsGamemaster"
};
const APP_DEFAULTS = {
  UNKNOWN_NAME: "Unknown",
  NO_VERSION_SELECTED: -1,
  CACHE_NOT_INITIALIZED: -1,
  CACHE_TTL_MS: 5e3
};
const PUBLIC_API_VERSION = "1.0.0";
const LOG_PREFIX = "Relationship App |";
const JOURNAL_PAGE_SHEET_TYPE = {
  RELATIONSHIP_NODE: "fvtt_relationship_app_module.relationship_app_node",
  RELATIONSHIP_GRAPH: "fvtt_relationship_app_module.relationship_app_graph"
};
Object.freeze(MODULE_METADATA);
Object.freeze(SETTING_KEYS);
Object.freeze(APP_DEFAULTS);
Object.freeze(JOURNAL_PAGE_SHEET_TYPE);
function ok(value2) {
  return { ok: true, value: value2 };
}
__name(ok, "ok");
function err(error3) {
  return { ok: false, error: error3 };
}
__name(err, "err");
function isOk(result) {
  return result.ok;
}
__name(isOk, "isOk");
function isErr(result) {
  return !result.ok;
}
__name(isErr, "isErr");
function map$1(result, transform7) {
  return result.ok ? ok(transform7(result.value)) : result;
}
__name(map$1, "map$1");
function mapError(result, transform7) {
  return result.ok ? result : err(transform7(result.error));
}
__name(mapError, "mapError");
function andThen(result, next2) {
  return result.ok ? next2(result.value) : result;
}
__name(andThen, "andThen");
function unwrapOr(result, fallbackValue) {
  return result.ok ? result.value : fallbackValue;
}
__name(unwrapOr, "unwrapOr");
function unwrapOrElse(result, getFallback2) {
  return result.ok ? result.value : getFallback2(result.error);
}
__name(unwrapOrElse, "unwrapOrElse");
function getOrThrow(result, toError) {
  if (result.ok) return result.value;
  const e = toError ? toError(result.error) : new Error(String(result.error));
  throw e;
}
__name(getOrThrow, "getOrThrow");
function all(results) {
  const out = [];
  for (const r2 of results) {
    if (!r2.ok) return r2;
    out.push(r2.value);
  }
  return ok(out);
}
__name(all, "all");
function match$1(result, handlers2) {
  return result.ok ? handlers2.onOk(result.value) : handlers2.onErr(result.error);
}
__name(match$1, "match$1");
function tryCatch(fn3, mapUnknownError) {
  try {
    return ok(fn3());
  } catch (unknownError) {
    return err(mapUnknownError(unknownError));
  }
}
__name(tryCatch, "tryCatch");
function lift(fn3, mapUnknownError) {
  return (param) => tryCatch(() => fn3(param), mapUnknownError);
}
__name(lift, "lift");
async function asyncMap(asyncResult, transform7) {
  const result = await asyncResult;
  return result.ok ? ok(await transform7(result.value)) : result;
}
__name(asyncMap, "asyncMap");
async function asyncAndThen(asyncResult, next2) {
  const result = await asyncResult;
  return result.ok ? next2(result.value) : result;
}
__name(asyncAndThen, "asyncAndThen");
async function fromPromise(promise4, mapUnknownError) {
  try {
    return ok(await promise4);
  } catch (unknownError) {
    return err(mapUnknownError(unknownError));
  }
}
__name(fromPromise, "fromPromise");
async function asyncAll(asyncResults) {
  const results = await Promise.all(asyncResults);
  return all(results);
}
__name(asyncAll, "asyncAll");
function createInjectionToken(description2) {
  return Symbol(description2);
}
__name(createInjectionToken, "createInjectionToken");
const loggerToken = createInjectionToken("Logger");
const bootstrapInitHookServiceToken = createInjectionToken(
  "BootstrapInitHookService"
);
const bootstrapReadyHookServiceToken = createInjectionToken(
  "BootstrapReadyHookService"
);
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
const __vite_import_meta_env__ = { "BASE_URL": "/", "DEV": false, "MODE": "development", "PROD": true, "SSR": false, "VITE_ENABLE_PERF_TRACKING": "true" };
function parseSamplingRate(envValue, fallback2) {
  const raw = parseFloat(envValue ?? String(fallback2));
  return Number.isFinite(raw) ? Math.min(1, Math.max(0, raw)) : fallback2;
}
__name(parseSamplingRate, "parseSamplingRate");
function parseNonNegativeNumber(envValue, fallback2) {
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed)) {
    return fallback2;
  }
  return parsed < 0 ? fallback2 : parsed;
}
__name(parseNonNegativeNumber, "parseNonNegativeNumber");
function parseOptionalPositiveInteger(envValue) {
  if (!envValue) {
    return void 0;
  }
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return void 0;
  }
  return Math.floor(parsed);
}
__name(parseOptionalPositiveInteger, "parseOptionalPositiveInteger");
function parsePositiveInteger(envValue, fallback2) {
  const parsed = Number(envValue);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback2;
  }
  return Math.floor(parsed);
}
__name(parsePositiveInteger, "parsePositiveInteger");
function getEnvVar(key2, parser2) {
  const value2 = __vite_import_meta_env__[key2];
  return parser2(value2);
}
__name(getEnvVar, "getEnvVar");
const parsedCacheMaxEntries = getEnvVar("VITE_CACHE_MAX_ENTRIES", parseOptionalPositiveInteger);
const ENV = {
  isDevelopment: true,
  isProduction: false,
  logLevel: true ? LogLevel.DEBUG : LogLevel.INFO,
  enablePerformanceTracking: true,
  enableMetricsPersistence: getEnvVar("VITE_ENABLE_METRICS_PERSISTENCE", (val) => val === "true"),
  metricsPersistenceKey: getEnvVar(
    "VITE_METRICS_PERSISTENCE_KEY",
    (val) => val ?? "fvtt_relationship_app_module.metrics"
  ),
  // 1% sampling in production, 100% in development
  performanceSamplingRate: false ? parseSamplingRate(void 0, 0.01) : 1,
  enableCacheService: getEnvVar(
    "VITE_CACHE_ENABLED",
    (val) => val === void 0 ? true : val === "true"
  ),
  cacheDefaultTtlMs: getEnvVar(
    "VITE_CACHE_TTL_MS",
    (val) => parseNonNegativeNumber(val, APP_DEFAULTS.CACHE_TTL_MS)
  ),
  ...parsedCacheMaxEntries !== void 0 ? { cacheMaxEntries: parsedCacheMaxEntries } : {},
  notificationQueueMinSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_MIN_SIZE",
    (val) => parsePositiveInteger(val, 10)
  ),
  notificationQueueMaxSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_MAX_SIZE",
    (val) => parsePositiveInteger(val, 1e3)
  ),
  notificationQueueDefaultSize: getEnvVar(
    "VITE_NOTIFICATION_QUEUE_DEFAULT_SIZE",
    (val) => parsePositiveInteger(val, 50)
  )
};
const _PerformanceTrackerImpl = class _PerformanceTrackerImpl {
  /**
   * Creates a performance tracker implementation.
   *
   * @param env - Environment configuration for tracking settings
   * @param sampler - Optional metrics sampler for sampling decisions (null during early bootstrap)
   */
  constructor(config2, sampler) {
    this.config = config2;
    this.sampler = sampler;
  }
  /**
   * Tracks synchronous operation execution time.
   *
   * Only measures when:
   * 1. Performance tracking is enabled (env.enablePerformanceTracking)
   * 2. MetricsCollector is available
   * 3. Sampling check passes (metricsCollector.shouldSample())
   *
   * @template T - Return type of the operation
   * @param operation - Function to execute and measure
   * @param onComplete - Optional callback invoked with duration and result
   * @returns Result of the operation
   */
  track(operation, onComplete) {
    if (!this.config.get("enablePerformanceTracking") || !this.sampler?.shouldSample()) {
      return operation();
    }
    const startTime = performance.now();
    const result = operation();
    const duration = performance.now() - startTime;
    if (onComplete) {
      onComplete(duration, result);
    }
    return result;
  }
  /**
   * Tracks asynchronous operation execution time.
   *
   * Only measures when:
   * 1. Performance tracking is enabled (env.enablePerformanceTracking)
   * 2. MetricsCollector is available
   * 3. Sampling check passes (metricsCollector.shouldSample())
   *
   * @template T - Return type of the async operation
   * @param operation - Async function to execute and measure
   * @param onComplete - Optional callback invoked with duration and result
   * @returns Promise resolving to the operation result
   */
  async trackAsync(operation, onComplete) {
    if (!this.config.get("enablePerformanceTracking") || !this.sampler?.shouldSample()) {
      return operation();
    }
    const startTime = performance.now();
    const result = await operation();
    const duration = performance.now() - startTime;
    if (onComplete) {
      onComplete(duration, result);
    }
    return result;
  }
};
__name(_PerformanceTrackerImpl, "PerformanceTrackerImpl");
let PerformanceTrackerImpl = _PerformanceTrackerImpl;
const _BootstrapPerformanceTracker = class _BootstrapPerformanceTracker extends PerformanceTrackerImpl {
  /**
   * Creates a bootstrap performance tracker.
   *
   * @param config - Runtime configuration port
   * @param sampler - Optional metrics sampler for sampling decisions (null during early bootstrap)
   */
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_BootstrapPerformanceTracker, "BootstrapPerformanceTracker");
let BootstrapPerformanceTracker = _BootstrapPerformanceTracker;
const _BootstrapErrorHandler = class _BootstrapErrorHandler {
  /**
   * Logs an error with structured context in the browser console.
   *
   * Creates a collapsible group with timestamp, phase, component,
   * error details, and metadata for easy debugging and screenshotting.
   *
   * @param error - The error that occurred (Error object, string, or unknown)
   * @param context - Context information about the error
   */
  static logError(error3, context) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    console.group(`[${timestamp}] ${LOG_PREFIX} Error in ${context.phase}`);
    if (context.component) {
      console.error("Component:", context.component);
    }
    console.error("Error:", error3);
    if (context.metadata && Object.keys(context.metadata).length > 0) {
      console.error("Metadata:", context.metadata);
    }
    console.groupEnd();
  }
};
__name(_BootstrapErrorHandler, "BootstrapErrorHandler");
let BootstrapErrorHandler = _BootstrapErrorHandler;
const _RuntimeConfigService = class _RuntimeConfigService {
  constructor(store2, emitter3) {
    this.store = store2;
    this.emitter = emitter3;
  }
  /**
   * Returns the current value for the given configuration key.
   */
  get(key2) {
    return this.store.get(key2);
  }
  /**
   * Updates the configuration value based on platform settings and notifies listeners
   * only if the value actually changed.
   *
   * Implements PlatformRuntimeConfigPort interface.
   */
  setFromPlatform(key2, value2) {
    const changed = this.store.set(key2, value2);
    if (changed) {
      this.emitter.notify(key2, value2);
    }
  }
  /**
   * Registers a listener for the given key. Returns an unsubscribe function.
   */
  onChange(key2, listener) {
    return this.emitter.onChange(key2, listener);
  }
};
__name(_RuntimeConfigService, "RuntimeConfigService");
let RuntimeConfigService = _RuntimeConfigService;
const _RuntimeConfigStore = class _RuntimeConfigStore {
  constructor(env) {
    this.values = {
      isDevelopment: env.isDevelopment,
      isProduction: env.isProduction,
      logLevel: env.logLevel,
      enablePerformanceTracking: env.enablePerformanceTracking,
      performanceSamplingRate: env.performanceSamplingRate,
      enableMetricsPersistence: env.enableMetricsPersistence,
      metricsPersistenceKey: env.metricsPersistenceKey,
      enableCacheService: env.enableCacheService,
      cacheDefaultTtlMs: env.cacheDefaultTtlMs,
      cacheMaxEntries: env.cacheMaxEntries,
      notificationQueueMaxSize: env.notificationQueueDefaultSize
    };
  }
  /**
   * Returns the current value for the given configuration key.
   */
  get(key2) {
    return this.values[key2];
  }
  /**
   * Updates the configuration value.
   * Returns true if the value actually changed, false otherwise.
   */
  set(key2, value2) {
    const current = this.values[key2];
    if (Object.is(current, value2)) {
      return false;
    }
    this.values[key2] = value2;
    return true;
  }
  /**
   * Gets all current values (for testing/debugging purposes).
   */
  getAll() {
    return { ...this.values };
  }
};
__name(_RuntimeConfigStore, "RuntimeConfigStore");
let RuntimeConfigStore = _RuntimeConfigStore;
const _RuntimeConfigEventEmitter = class _RuntimeConfigEventEmitter {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a listener for the given key. Returns an unsubscribe function.
   */
  onChange(key2, listener) {
    const existing = this.getListenersForKey(key2);
    const listeners = existing ?? /* @__PURE__ */ new Set();
    listeners.add(listener);
    this.setListenersForKey(key2, listeners);
    return () => {
      const activeListeners = this.getListenersForKey(key2);
      activeListeners?.delete(listener);
      if (!activeListeners || activeListeners.size === 0) {
        this.listeners.delete(key2);
      }
    };
  }
  /**
   * Notifies all listeners for the given key with the new value.
   */
  notify(key2, value2) {
    const listeners = this.listeners.get(key2);
    if (!listeners || listeners.size === 0) {
      return;
    }
    for (const listener of listeners) {
      listener(value2);
    }
  }
  /**
   * Type-safe helper to get listeners for a specific key.
   * @ts-expect-error - Type coverage exclusion for generic Set cast
   */
  getListenersForKey(key2) {
    return this.listeners.get(key2);
  }
  /**
   * Type-safe helper to set listeners for a specific key.
   */
  setListenersForKey(key2, listeners) {
    this.listeners.set(key2, listeners);
  }
};
__name(_RuntimeConfigEventEmitter, "RuntimeConfigEventEmitter");
let RuntimeConfigEventEmitter = _RuntimeConfigEventEmitter;
function createRuntimeConfig(env, store2, emitter3) {
  return new RuntimeConfigService(
    store2 ?? new RuntimeConfigStore(env),
    emitter3 ?? new RuntimeConfigEventEmitter()
  );
}
__name(createRuntimeConfig, "createRuntimeConfig");
const _RuntimeConfigAdapter = class _RuntimeConfigAdapter {
  constructor(env) {
    this.service = createRuntimeConfig(env);
  }
  get(key2) {
    return this.service.get(key2);
  }
  setFromPlatform(key2, value2) {
    this.service.setFromPlatform(key2, value2);
  }
  onChange(key2, listener) {
    return this.service.onChange(key2, listener);
  }
};
__name(_RuntimeConfigAdapter, "RuntimeConfigAdapter");
let RuntimeConfigAdapter = _RuntimeConfigAdapter;
function createRuntimeConfigAdapter(env) {
  return new RuntimeConfigAdapter(env);
}
__name(createRuntimeConfigAdapter, "createRuntimeConfigAdapter");
function castCachedServiceInstance(instance2) {
  return instance2;
}
__name(castCachedServiceInstance, "castCachedServiceInstance");
function castCachedServiceInstanceForResult(instance2) {
  if (instance2 === void 0) {
    return err({
      code: "TokenNotRegistered",
      message: "castCachedServiceInstanceForResult: instance must not be undefined. Use castCachedServiceInstance() for optional instances.",
      details: {}
    });
  }
  return ok(instance2);
}
__name(castCachedServiceInstanceForResult, "castCachedServiceInstanceForResult");
function castServiceRegistrationEntry(token, registration) {
  return [token, registration];
}
__name(castServiceRegistrationEntry, "castServiceRegistrationEntry");
function* iterateServiceRegistrationEntries(entries2) {
  for (const [token, registration] of entries2) {
    yield castServiceRegistrationEntry(token, registration);
  }
}
__name(iterateServiceRegistrationEntries, "iterateServiceRegistrationEntries");
function getRegistrationStatus(result) {
  return result.ok ? result.value : false;
}
__name(getRegistrationStatus, "getRegistrationStatus");
function castToFoundryHookCallback(callback) {
  return callback;
}
__name(castToFoundryHookCallback, "castToFoundryHookCallback");
function castResolvedService$1(value2) {
  return value2;
}
__name(castResolvedService$1, "castResolvedService$1");
function castContainerErrorCode(code) {
  return code;
}
__name(castContainerErrorCode, "castContainerErrorCode");
function castContainerTokenToPlatformContainerPortToken(token) {
  return token;
}
__name(castContainerTokenToPlatformContainerPortToken, "castContainerTokenToPlatformContainerPortToken");
const apiSafeTokens = /* @__PURE__ */ new Set();
function markAsApiSafe(token) {
  apiSafeTokens.add(token);
  return token;
}
__name(markAsApiSafe, "markAsApiSafe");
function isApiSafeTokenRuntime(token) {
  return apiSafeTokens.has(token);
}
__name(isApiSafeTokenRuntime, "isApiSafeTokenRuntime");
var ServiceLifecycle = /* @__PURE__ */ ((ServiceLifecycle2) => {
  ServiceLifecycle2["SINGLETON"] = "singleton";
  ServiceLifecycle2["TRANSIENT"] = "transient";
  ServiceLifecycle2["SCOPED"] = "scoped";
  return ServiceLifecycle2;
})(ServiceLifecycle || {});
const _ServiceRegistration = class _ServiceRegistration {
  /**
   * Private constructor - use static factory methods instead.
   * This prevents direct construction with invalid parameters
   * and ensures Result-based error handling.
   */
  constructor(lifecycle, dependencies, providerType, serviceClass, factory, value2, aliasTarget) {
    this.lifecycle = lifecycle;
    this.dependencies = dependencies;
    this.providerType = providerType;
    this.serviceClass = serviceClass;
    this.factory = factory;
    this.value = value2;
    this.aliasTarget = aliasTarget;
  }
  /**
   * Creates a class-based registration.
   * @template Tunknown - The concrete service type
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of dependency tokens
   * @param serviceClass - The class to instantiate
   * @returns Result with registration or validation error
   */
  static createClass(lifecycle, dependencies, serviceClass) {
    return ok(
      new _ServiceRegistration(
        lifecycle,
        dependencies,
        "class",
        serviceClass,
        void 0,
        void 0,
        void 0
      )
    );
  }
  /**
   * Creates a factory-based registration.
   * @template Tunknown - The concrete service type
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of dependency tokens
   * @param factory - Factory function that creates instances
   * @returns Result with registration or validation error
   */
  static createFactory(lifecycle, dependencies, factory) {
    if (!factory) {
      return err({
        code: "InvalidOperation",
        message: "factory is required for factory registration"
      });
    }
    return ok(
      new _ServiceRegistration(
        lifecycle,
        dependencies,
        "factory",
        void 0,
        factory,
        void 0,
        void 0
      )
    );
  }
  /**
   * Creates a value-based registration (always SINGLETON).
   * @template Tunknown - The concrete service type
   * @param value - The value to register
   * @returns Result with registration or validation error
   */
  static createValue(value2) {
    if (value2 === void 0) {
      return err({
        code: "InvalidOperation",
        message: "value cannot be undefined for value registration"
      });
    }
    if (typeof value2 === "function") {
      return err({
        code: "InvalidOperation",
        message: "registerValue() only accepts plain values, not functions or classes. Use registerClass() or registerFactory() instead."
      });
    }
    return ok(
      new _ServiceRegistration(ServiceLifecycle.SINGLETON, [], "value", void 0, void 0, value2, void 0)
    );
  }
  /**
   * Creates an alias registration (always SINGLETON).
   * @template Tunknown - The concrete service type
   * @param targetToken - The token to resolve instead
   * @returns Result with registration or validation error
   */
  static createAlias(targetToken) {
    if (!targetToken) {
      return err({
        code: "InvalidOperation",
        message: "targetToken is required for alias registration"
      });
    }
    return ok(
      new _ServiceRegistration(
        ServiceLifecycle.SINGLETON,
        [targetToken],
        "alias",
        void 0,
        void 0,
        void 0,
        targetToken
      )
    );
  }
  /**
   * Creates a clone of this registration.
   * Used when child containers inherit registrations from parent.
   *
   * @returns A new ServiceRegistration instance with cloned dependencies array
   */
  clone() {
    return new _ServiceRegistration(
      this.lifecycle,
      [...this.dependencies],
      // Clone array to prevent shared mutations
      this.providerType,
      this.serviceClass,
      this.factory,
      this.value,
      this.aliasTarget
    );
  }
};
__name(_ServiceRegistration, "ServiceRegistration");
let ServiceRegistration = _ServiceRegistration;
const _TypeSafeRegistrationMap = class _TypeSafeRegistrationMap {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Stores a service registration.
   *
   * @template T - The concrete service type
   * @param token - The injection token identifying the service
   * @param registration - The service registration metadata
   */
  set(token, registration) {
    this.map.set(token, registration);
  }
  /**
   * Retrieves a service registration.
   *
   * Type-safe by design: The token's generic parameter guarantees that the
   * returned registration matches the expected service type.
   *
   * @template T - The concrete service type
   * @param token - The injection token identifying the service
   * @returns The service registration or undefined if not found
   */
  get(token) {
    return this.map.get(token);
  }
  /**
   * Checks if a service is registered.
   *
   * @param token - The injection token to check
   * @returns True if the service is registered
   */
  has(token) {
    return this.map.has(token);
  }
  /**
   * Removes a service registration.
   *
   * @param token - The injection token identifying the service
   * @returns True if the service was found and removed
   */
  delete(token) {
    return this.map.delete(token);
  }
  /**
   * Gets the number of registered services.
   *
   * @returns The count of registrations
   */
  get size() {
    return this.map.size;
  }
  /**
   * Removes all service registrations.
   */
  clear() {
    this.map.clear();
  }
  /**
   * Returns an iterator of all registration entries.
   *
   * @returns Iterator of [token, registration] pairs
   */
  entries() {
    return this.map.entries();
  }
  /**
   * Creates a shallow clone of this map.
   * Used when child containers inherit registrations from parent.
   *
   * @returns A new TypeSafeRegistrationMap with cloned entries
   */
  clone() {
    const cloned = new _TypeSafeRegistrationMap();
    this.map.forEach((value2, key2) => {
      cloned.map.set(key2, value2);
    });
    return cloned;
  }
};
__name(_TypeSafeRegistrationMap, "TypeSafeRegistrationMap");
let TypeSafeRegistrationMap = _TypeSafeRegistrationMap;
function hasDependencies(cls) {
  return "dependencies" in cls;
}
__name(hasDependencies, "hasDependencies");
const _ServiceRegistry = class _ServiceRegistry {
  constructor() {
    this.MAX_REGISTRATIONS = 1e4;
    this.registrations = new TypeSafeRegistrationMap();
    this.lifecycleIndex = /* @__PURE__ */ new Map();
  }
  /**
   * Updates the lifecycle index when a service is registered.
   *
   * @param token - The injection token
   * @param lifecycle - The service lifecycle
   */
  updateLifecycleIndex(token, lifecycle) {
    let tokenSet = this.lifecycleIndex.get(lifecycle);
    if (!tokenSet) {
      tokenSet = /* @__PURE__ */ new Set();
      this.lifecycleIndex.set(lifecycle, tokenSet);
    }
    tokenSet.add(token);
  }
  /**
   * Registers a service class with automatic dependency injection.
   *
   * @template Tunknown - The type of service to register
   * @param token - The injection token identifying this service
   * @param serviceClass - The class to instantiate
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @returns Result indicating success or error
   */
  registerClass(token, serviceClass, lifecycle) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    if (!serviceClass) {
      return err({
        code: "InvalidOperation",
        message: "serviceClass is required for class registration"
      });
    }
    const dependencies = hasDependencies(serviceClass) ? serviceClass.dependencies ?? [] : [];
    const registrationResult = ServiceRegistration.createClass(
      lifecycle,
      dependencies,
      serviceClass
    );
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, lifecycle);
    return ok(void 0);
  }
  /**
   * Registers a factory function for creating service instances.
   *
   * @template Tunknown - The type of service this factory creates
   * @param token - The injection token identifying this service
   * @param factory - Factory function that creates instances
   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)
   * @param dependencies - Array of tokens this factory depends on
   * @returns Result indicating success or error
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    const registrationResult = ServiceRegistration.createFactory(
      lifecycle,
      dependencies,
      factory
    );
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, lifecycle);
    return ok(void 0);
  }
  /**
   * Registers a constant value (always SINGLETON lifecycle).
   *
   * @template Tunknown - The type of value to register
   * @param token - The injection token identifying this value
   * @param value - The value to register
   * @returns Result indicating success or error
   */
  registerValue(token, value2) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(token)
      });
    }
    if (this.registrations.has(token)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(token)} already registered`,
        tokenDescription: String(token)
      });
    }
    const registrationResult = ServiceRegistration.createValue(value2);
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(token, registrationResult.value);
    this.updateLifecycleIndex(token, ServiceLifecycle.SINGLETON);
    return ok(void 0);
  }
  /**
   * Registers an alias that points to another token.
   *
   * @template Tunknown - The type of service
   * @param aliasToken - The alias token
   * @param targetToken - The token to resolve instead
   * @returns Result indicating success or error
   */
  registerAlias(aliasToken, targetToken) {
    if (this.registrations.size >= this.MAX_REGISTRATIONS) {
      return err({
        code: "MaxRegistrationsExceeded",
        message: `Cannot register more than ${this.MAX_REGISTRATIONS} services`,
        tokenDescription: String(aliasToken)
      });
    }
    if (this.registrations.has(aliasToken)) {
      return err({
        code: "DuplicateRegistration",
        message: `Service ${String(aliasToken)} already registered`,
        tokenDescription: String(aliasToken)
      });
    }
    const registrationResult = ServiceRegistration.createAlias(targetToken);
    if (isErr(registrationResult)) {
      return registrationResult;
    }
    this.registrations.set(aliasToken, registrationResult.value);
    return ok(void 0);
  }
  /**
   * Retrieves a service registration.
   *
   * @template Tunknown - The type of service
   * @param token - The injection token identifying the service
   * @returns The registration or undefined if not found
   */
  getRegistration(token) {
    return this.registrations.get(token);
  }
  /**
   * Returns all registrations.
   * Used by ContainerValidator for dependency validation.
   *
   * @returns Map of all registrations
   */
  getAllRegistrations() {
    return new Map(iterateServiceRegistrationEntries(this.registrations.entries()));
  }
  /**
   * Returns all registrations for a specific lifecycle.
   * More efficient than filtering getAllRegistrations() when only one lifecycle is needed.
   *
   * @param lifecycle - The lifecycle to query
   * @returns Array of registrations with the specified lifecycle
   */
  getRegistrationsByLifecycle(lifecycle) {
    const tokens2 = this.lifecycleIndex.get(lifecycle) ?? /* @__PURE__ */ new Set();
    return Array.from(tokens2).map((token) => this.registrations.get(token)).filter((reg) => reg !== void 0);
  }
  /**
   * Checks if a service is registered.
   *
   * @template Tunknown - The type of service
   * @param token - The injection token to check
   * @returns True if registered, false otherwise
   */
  has(token) {
    return this.registrations.has(token);
  }
  /**
   * Clears all registrations.
   * Warning: This removes all configured services.
   */
  clear() {
    this.registrations.clear();
    this.lifecycleIndex.clear();
  }
  /**
   * Creates a deep clone of this registry for child containers.
   *
   * Important: Creates a new Map instance with cloned ServiceRegistration objects
   * to prevent child containers from mutating parent registrations.
   *
   * @returns A new ServiceRegistry with cloned registrations
   */
  clone() {
    const clonedRegistry = new _ServiceRegistry();
    for (const [token, registration] of iterateServiceRegistrationEntries(
      this.registrations.entries()
    )) {
      clonedRegistry.registrations.set(token, registration.clone());
    }
    for (const [lifecycle, tokens2] of this.lifecycleIndex.entries()) {
      clonedRegistry.lifecycleIndex.set(lifecycle, new Set(tokens2));
    }
    return clonedRegistry;
  }
};
__name(_ServiceRegistry, "ServiceRegistry");
let ServiceRegistry = _ServiceRegistry;
const _ContainerValidator = class _ContainerValidator {
  constructor() {
    this.validatedSubgraphs = /* @__PURE__ */ new Set();
  }
  /**
   * Validates all registrations in the registry.
   *
   * Performs three checks:
   * 1. All dependencies are registered
   * 2. All alias targets exist
   * 3. No circular dependencies
   *
   * @param registry - The service registry to validate
   * @returns Result with void on success, or array of errors
   */
  validate(registry) {
    this.validatedSubgraphs = /* @__PURE__ */ new Set();
    const errors = [
      ...this.validateDependencies(registry),
      ...this.validateAliasTargets(registry),
      ...this.detectCircularDependencies(registry)
    ];
    return errors.length > 0 ? err(errors) : ok(void 0);
  }
  /**
   * Checks that all declared dependencies are registered.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for missing dependencies
   */
  validateDependencies(registry) {
    const errors = [];
    const registrations = registry.getAllRegistrations();
    for (const [token, registration] of registrations.entries()) {
      for (const dep of registration.dependencies) {
        if (!registry.has(dep)) {
          errors.push({
            code: "TokenNotRegistered",
            message: `${String(token)} depends on ${String(dep)} which is not registered`,
            tokenDescription: String(dep)
          });
        }
      }
    }
    return errors;
  }
  /**
   * Checks that all alias targets are registered.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for missing alias targets
   */
  validateAliasTargets(registry) {
    const errors = [];
    const registrations = registry.getAllRegistrations();
    for (const [token, registration] of registrations.entries()) {
      if (registration.providerType === "alias" && registration.aliasTarget) {
        if (!registry.has(registration.aliasTarget)) {
          errors.push({
            code: "AliasTargetNotFound",
            message: `Alias ${String(token)} points to ${String(registration.aliasTarget)} which is not registered`,
            tokenDescription: String(registration.aliasTarget)
          });
        }
      }
    }
    return errors;
  }
  /**
   * Detects circular dependencies using depth-first search.
   *
   * @param registry - The service registry to check
   * @returns Array of errors for detected cycles
   */
  detectCircularDependencies(registry) {
    const errors = [];
    const visited = /* @__PURE__ */ new Set();
    const registrations = registry.getAllRegistrations();
    for (const token of registrations.keys()) {
      const visiting = /* @__PURE__ */ new Set();
      const path = [];
      const error3 = this.checkCycleForToken(registry, token, visiting, visited, path);
      if (error3) {
        errors.push(error3);
      }
    }
    return errors;
  }
  /**
   * Recursively checks for cycles starting from a specific token.
   *
   * **Algorithm: Depth-First Search (DFS) with Three-Color Marking**
   *
   * Three states for each node (token):
   * - WHITE (unvisited): Not in `visiting` or `visited` sets
   * - GRAY (visiting): In `visiting` set (currently in DFS recursion stack)
   * - BLACK (visited): In `visited` set (fully processed, all descendants checked)
   *
   * Cycle Detection:
   * - If we encounter a GRAY node during traversal, we've found a back edge → cycle
   * - GRAY nodes represent the current path from root to current node
   * - Encountering a GRAY node means we're trying to visit an ancestor → circular dependency
   *
   * Performance Optimization:
   * - `validatedSubgraphs` cache prevents redundant traversals of already-validated subtrees
   * - Crucial for large dependency graphs (>500 services)
   * - BLACK nodes can be safely skipped (all their descendants are cycle-free)
   *
   * Time Complexity: O(V + E) where V = number of services, E = number of dependencies
   * Space Complexity: O(V) for visiting/visited sets + O(D) for recursion depth D
   *
   * @param registry - The service registry
   * @param token - Current token being checked (current node in DFS)
   * @param visiting - GRAY nodes: tokens currently in the DFS recursion stack
   * @param visited - BLACK nodes: tokens fully processed in this validation run
   * @param path - Current dependency path for error reporting (stack trace)
   * @returns ContainerError if cycle detected, null otherwise
   *
   * @example
   * Cycle A → B → C → A will be detected when:
   * 1. Start at A (mark GRAY)
   * 2. Visit B (mark GRAY)
   * 3. Visit C (mark GRAY)
   * 4. Try to visit A → A is GRAY → Back edge detected → Cycle!
   */
  checkCycleForToken(registry, token, visiting, visited, path) {
    if (visiting.has(token)) {
      const cyclePath = [...path, token].map(String).join(" → ");
      return {
        code: "CircularDependency",
        message: `Circular dependency: ${cyclePath}`,
        tokenDescription: String(token)
      };
    }
    if (this.validatedSubgraphs.has(token)) {
      return null;
    }
    if (visited.has(token)) {
      return null;
    }
    visiting.add(token);
    path.push(token);
    const registration = registry.getRegistration(token);
    if (registration) {
      for (const dep of registration.dependencies) {
        const error3 = this.checkCycleForToken(registry, dep, visiting, visited, path);
        if (error3) return error3;
      }
    }
    visiting.delete(token);
    path.pop();
    visited.add(token);
    this.validatedSubgraphs.add(token);
    return null;
  }
};
__name(_ContainerValidator, "ContainerValidator");
let ContainerValidator = _ContainerValidator;
const _InstanceCache = class _InstanceCache {
  constructor() {
    this.instances = /* @__PURE__ */ new Map();
    this.metricsCollector = null;
  }
  /**
   * Injects the MetricsCollector for cache hit/miss tracking.
   * Called after container validation to enable observability.
   *
   * @param collector - The metrics collector instance
   */
  setMetricsCollector(collector) {
    this.metricsCollector = collector;
  }
  /**
   * Retrieves a cached service instance.
   *
   * @template Tunknown - The type of service to retrieve
   * @param token - The injection token identifying the service
   * @returns The cached instance or undefined if not found
   */
  get(token) {
    const hasInstance = this.instances.has(token);
    this.metricsCollector?.recordCacheAccess(hasInstance);
    return castCachedServiceInstance(this.instances.get(token));
  }
  /**
   * Stores a service instance in the cache.
   *
   * @template Tunknown - The type of service to store
   * @param token - The injection token identifying the service
   * @param instance - The service instance to cache
   */
  set(token, instance2) {
    this.instances.set(token, instance2);
  }
  /**
   * Checks if a service instance is cached.
   *
   * @template Tunknown - The type of service to check
   * @param token - The injection token identifying the service
   * @returns True if the instance is cached, false otherwise
   */
  has(token) {
    const hasInstance = this.instances.has(token);
    this.metricsCollector?.recordCacheAccess(hasInstance);
    return hasInstance;
  }
  /**
   * Clears all cached instances.
   * Note: Does not dispose instances - call getAllInstances() first if disposal is needed.
   */
  clear() {
    this.instances.clear();
  }
  /**
   * Returns all cached instances for disposal purposes.
   * Used by ScopeManager to dispose Disposable services.
   *
   * @returns A map of all cached instances
   */
  getAllInstances() {
    return new Map(this.instances);
  }
};
__name(_InstanceCache, "InstanceCache");
let InstanceCache = _InstanceCache;
const _SingletonResolutionStrategy = class _SingletonResolutionStrategy {
  resolve(token, registration, dependencyResolver, instantiator, cache3, parentResolver, _scopeName) {
    if (parentResolver !== null) {
      const parentResult = parentResolver.resolve(token);
      if (parentResult.ok) {
        return parentResult;
      }
      if (parentResult.error.code === "CircularDependency") {
        return parentResult;
      }
    }
    if (!cache3.has(token)) {
      const instanceResult2 = instantiator.instantiate(token, registration);
      if (!instanceResult2.ok) {
        return instanceResult2;
      }
      cache3.set(token, instanceResult2.value);
    }
    const instanceResult = castCachedServiceInstanceForResult(cache3.get(token));
    if (!instanceResult.ok) {
      return instanceResult;
    }
    return ok(instanceResult.value);
  }
};
__name(_SingletonResolutionStrategy, "SingletonResolutionStrategy");
let SingletonResolutionStrategy = _SingletonResolutionStrategy;
const _TransientResolutionStrategy = class _TransientResolutionStrategy {
  resolve(token, registration, _dependencyResolver, instantiator, _cache, _parentResolver, _scopeName) {
    return instantiator.instantiate(token, registration);
  }
};
__name(_TransientResolutionStrategy, "TransientResolutionStrategy");
let TransientResolutionStrategy = _TransientResolutionStrategy;
const _ScopedResolutionStrategy = class _ScopedResolutionStrategy {
  resolve(token, registration, _dependencyResolver, instantiator, cache3, parentResolver, _scopeName) {
    if (parentResolver === null) {
      return err({
        code: "ScopeRequired",
        message: `Scoped service ${String(token)} requires a scope container. Use createScope() to create a child container first.`,
        tokenDescription: String(token)
      });
    }
    if (!cache3.has(token)) {
      const instanceResult2 = instantiator.instantiate(token, registration);
      if (!instanceResult2.ok) {
        return instanceResult2;
      }
      cache3.set(token, instanceResult2.value);
    }
    const instanceResult = castCachedServiceInstanceForResult(cache3.get(token));
    if (!instanceResult.ok) {
      return instanceResult;
    }
    return ok(instanceResult.value);
  }
};
__name(_ScopedResolutionStrategy, "ScopedResolutionStrategy");
let ScopedResolutionStrategy = _ScopedResolutionStrategy;
const _LifecycleResolver = class _LifecycleResolver {
  constructor(cache3, parentResolver, scopeName) {
    this.cache = cache3;
    this.parentResolver = parentResolver;
    this.scopeName = scopeName;
    this.strategies = /* @__PURE__ */ new Map();
    this.strategies.set(ServiceLifecycle.SINGLETON, new SingletonResolutionStrategy());
    this.strategies.set(ServiceLifecycle.TRANSIENT, new TransientResolutionStrategy());
    this.strategies.set(ServiceLifecycle.SCOPED, new ScopedResolutionStrategy());
  }
  /**
   * Resolves a service based on its lifecycle.
   *
   * @template T - The type of service to resolve
   * @param token - The injection token identifying the service
   * @param registration - The service registration metadata
   * @param dependencyResolver - The DependencyResolver for dependency resolution
   * @param instantiator - The ServiceInstantiator for service instantiation
   * @returns Result with service instance or error
   */
  resolve(token, registration, dependencyResolver, instantiator) {
    const strategy = this.strategies.get(registration.lifecycle);
    if (!strategy) {
      return err({
        code: "InvalidLifecycle",
        message: `Invalid service lifecycle: ${String(registration.lifecycle)}`,
        tokenDescription: String(token)
      });
    }
    return strategy.resolve(
      token,
      registration,
      dependencyResolver,
      instantiator,
      this.cache,
      this.parentResolver,
      this.scopeName
    );
  }
};
__name(_LifecycleResolver, "LifecycleResolver");
let LifecycleResolver = _LifecycleResolver;
const _ServiceInstantiatorImpl = class _ServiceInstantiatorImpl {
  constructor(dependencyResolver) {
    this.dependencyResolver = dependencyResolver;
  }
  /**
   * Instantiates a service based on registration type.
   *
   * CRITICAL: Returns Result to preserve error context and avoid breaking Result-Contract.
   * Handles dependency resolution for classes, direct factory calls, and value returns.
   *
   * @template T - The type of service to instantiate
   * @param token - The injection token (used for error messages)
   * @param registration - The service registration metadata
   * @returns Result with instance or detailed error (DependencyResolveFailed, FactoryFailed, etc.)
   */
  instantiate(token, registration) {
    if (registration.serviceClass) {
      const resolvedDeps = [];
      for (const dep of registration.dependencies) {
        const depResult = this.dependencyResolver.resolve(dep);
        if (!depResult.ok) {
          return err({
            code: "DependencyResolveFailed",
            message: `Cannot resolve dependency ${String(dep)} for ${String(token)}`,
            tokenDescription: String(dep),
            cause: depResult.error
          });
        }
        resolvedDeps.push(depResult.value);
      }
      try {
        return ok(new registration.serviceClass(...resolvedDeps));
      } catch (constructorError) {
        return err({
          code: "FactoryFailed",
          message: `Constructor failed for ${String(token)}: ${String(constructorError)}`,
          tokenDescription: String(token),
          cause: constructorError
        });
      }
    } else if (registration.factory) {
      try {
        return ok(registration.factory());
      } catch (factoryError) {
        return err({
          code: "FactoryFailed",
          message: `Factory failed for ${String(token)}: ${String(factoryError)}`,
          tokenDescription: String(token),
          cause: factoryError
        });
      }
    } else if (registration.value !== void 0) {
      return ok(registration.value);
    } else {
      return err({
        code: "InvalidOperation",
        message: `Invalid registration for ${String(token)} - no class, factory, or value`,
        tokenDescription: String(token)
      });
    }
  }
};
__name(_ServiceInstantiatorImpl, "ServiceInstantiatorImpl");
let ServiceInstantiatorImpl = _ServiceInstantiatorImpl;
const _ServiceResolver = class _ServiceResolver {
  constructor(registry, cache3, parentResolver, scopeName, performanceTracker) {
    this.registry = registry;
    this.cache = cache3;
    this.parentResolver = parentResolver;
    this.scopeName = scopeName;
    this.performanceTracker = performanceTracker;
    this.metricsCollector = null;
    this.lifecycleResolver = new LifecycleResolver(cache3, parentResolver, scopeName);
    this.instantiator = new ServiceInstantiatorImpl(this);
  }
  /**
   * Sets the MetricsCollector for metrics recording.
   * Called by ServiceContainer after validation.
   *
   * @param collector - The metrics collector instance
   */
  setMetricsCollector(collector) {
    this.metricsCollector = collector;
  }
  /**
   * Resolves a service by token.
   *
   * Handles:
   * - Alias resolution (recursive)
   * - Lifecycle-specific resolution (delegated to LifecycleResolver)
   * - Performance tracking
   * - Metrics recording
   *
   * Performance tracking is handled by the injected PerformanceTracker.
   *
   * @template T - The type of service to resolve
   * @param token - The injection token identifying the service
   * @returns Result with service instance or error
   */
  resolve(token) {
    return this.performanceTracker.track(
      () => {
        const registration = this.registry.getRegistration(token);
        if (!registration) {
          const stack2 = new Error().stack;
          const error3 = {
            code: "TokenNotRegistered",
            message: `Service ${String(token)} not registered`,
            tokenDescription: String(token),
            ...stack2 !== void 0 && { stack: stack2 },
            // Only include stack if defined
            timestamp: Date.now(),
            containerScope: this.scopeName
          };
          return err(error3);
        }
        if (registration.providerType === "alias" && registration.aliasTarget) {
          return this.resolve(registration.aliasTarget);
        }
        return this.lifecycleResolver.resolve(token, registration, this, this);
      },
      (duration, result) => {
        this.metricsCollector?.recordResolution(token, duration, result.ok);
      }
    );
  }
  /**
   * Instantiates a service based on registration type.
   *
   * CRITICAL: Returns Result to preserve error context and avoid breaking Result-Contract.
   * Delegates to ServiceInstantiatorImpl for actual instantiation logic.
   *
   * This method implements the ServiceInstantiator interface, allowing lifecycle
   * strategies to instantiate services without depending on ServiceResolver directly.
   *
   * @template T - The type of service to instantiate
   * @param token - The injection token (used for error messages)
   * @param registration - The service registration metadata
   * @returns Result with instance or detailed error (DependencyResolveFailed, FactoryFailed, etc.)
   */
  instantiate(token, registration) {
    return this.instantiator.instantiate(token, registration);
  }
};
__name(_ServiceResolver, "ServiceResolver");
let ServiceResolver = _ServiceResolver;
function generateScopeId() {
  try {
    return crypto.randomUUID();
  } catch {
    return Date.now() + "-" + Math.random();
  }
}
__name(generateScopeId, "generateScopeId");
const _ScopeManager = class _ScopeManager {
  // Unique correlation ID for tracing
  constructor(scopeName, parent4, cache3, depth = 0) {
    this.scopeName = scopeName;
    this.parent = parent4;
    this.cache = cache3;
    this.MAX_SCOPE_DEPTH = 10;
    this.children = /* @__PURE__ */ new Set();
    this.disposed = false;
    this.depth = depth;
    this.scopeId = `${scopeName}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }
  /**
   * Creates a child scope manager.
   *
   * Note: Returns data (scopeName, cache, childManager) instead of full container
   * to avoid circular dependency with ServiceResolver.
   *
   * @param name - Optional custom name for the scope
   * @returns Result with child scope data or error if disposed or max depth exceeded
   */
  createChild(name) {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Cannot create child scope from disposed scope: ${this.scopeName}`
      });
    }
    if (this.depth >= this.MAX_SCOPE_DEPTH) {
      return err({
        code: "MaxScopeDepthExceeded",
        message: `Maximum scope depth of ${this.MAX_SCOPE_DEPTH} exceeded. Current depth: ${this.depth}`
      });
    }
    const uniqueId = name ?? `scope-${generateScopeId()}`;
    const childScopeName = `${this.scopeName}.${uniqueId}`;
    const childCache = new InstanceCache();
    const childManager = new _ScopeManager(childScopeName, this, childCache, this.depth + 1);
    this.children.add(childManager);
    return ok({
      scopeName: childScopeName,
      cache: childCache,
      manager: childManager
    });
  }
  /**
   * Disposes this scope and all child scopes.
   *
   * Disposal order (critical):
   * 1. Recursively dispose all children
   * 2. Dispose instances in this scope (if Disposable)
   * 3. Clear instance cache
   * 4. Remove from parent's children set
   *
   * @returns Result indicating success or disposal error
   */
  dispose() {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Scope already disposed: ${this.scopeName}`
      });
    }
    this.disposed = true;
    const childDisposalErrors = [];
    for (const child2 of this.children) {
      const childResult = child2.dispose();
      if (isErr(childResult)) {
        childDisposalErrors.push({
          scopeName: child2.scopeName,
          error: childResult.error
        });
      }
    }
    const disposeResult = this.disposeInstances();
    if (!disposeResult.ok) {
      return disposeResult;
    }
    this.cache.clear();
    if (this.parent !== null) {
      this.parent.children.delete(this);
    }
    if (childDisposalErrors.length > 0) {
      return err({
        code: "PartialDisposal",
        message: `Failed to dispose ${childDisposalErrors.length} child scope(s)`,
        details: childDisposalErrors
      });
    }
    return ok(void 0);
  }
  /**
   * Asynchronously disposes this scope and all child scopes.
   *
   * Preferred method for cleanup as it properly handles async dispose operations.
   * Falls back to sync dispose() for services that only implement Disposable.
   *
   * Disposal order (critical):
   * 1. Recursively dispose all children (async)
   * 2. Dispose instances in this scope (async or sync)
   * 3. Clear instance cache
   * 4. Remove from parent's children set
   *
   * @returns Promise with Result indicating success or disposal error
   */
  async disposeAsync() {
    if (this.disposed) {
      return err({
        code: "Disposed",
        message: `Scope already disposed: ${this.scopeName}`
      });
    }
    this.disposed = true;
    const childDisposalErrors = [];
    for (const child2 of this.children) {
      const childResult = await child2.disposeAsync();
      if (isErr(childResult)) {
        childDisposalErrors.push({
          scopeName: child2.scopeName,
          error: childResult.error
        });
      }
    }
    const disposeResult = await this.disposeInstancesAsync();
    if (!disposeResult.ok) {
      return disposeResult;
    }
    this.cache.clear();
    if (this.parent !== null) {
      this.parent.children.delete(this);
    }
    if (childDisposalErrors.length > 0) {
      return err({
        code: "PartialDisposal",
        message: `Failed to dispose ${childDisposalErrors.length} child scope(s)`,
        details: childDisposalErrors
      });
    }
    return ok(void 0);
  }
  /**
   * Disposes all instances in the cache that implement Disposable (sync).
   *
   * @returns Result indicating success or disposal error
   */
  disposeInstances() {
    const instances = this.cache.getAllInstances();
    for (const [token, instance2] of instances.entries()) {
      if (this.isDisposable(instance2)) {
        const result = tryCatch(
          () => instance2.dispose(),
          (error3) => ({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error3)}`,
            tokenDescription: String(token),
            cause: error3
          })
        );
        if (isErr(result)) {
          return result;
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Disposes all instances in the cache that implement Disposable or AsyncDisposable (async).
   * Prefers async disposal when available, falls back to sync.
   *
   * @returns Promise with Result indicating success or disposal error
   */
  async disposeInstancesAsync() {
    const instances = this.cache.getAllInstances();
    for (const [token, instance2] of instances.entries()) {
      if (this.isAsyncDisposable(instance2)) {
        try {
          await instance2.disposeAsync();
        } catch (error3) {
          return err({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error3)}`,
            tokenDescription: String(token),
            cause: error3
          });
        }
      } else if (this.isDisposable(instance2)) {
        const disposableInstance = instance2;
        const result = tryCatch(
          () => disposableInstance.dispose(),
          (error3) => ({
            code: "DisposalFailed",
            message: `Error disposing service ${String(token)}: ${String(error3)}`,
            tokenDescription: String(token),
            cause: error3
          })
        );
        if (isErr(result)) {
          return result;
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Type guard to check if an instance implements the Disposable pattern.
   *
   * @param instance - The service instance to check
   * @returns True if instance has dispose() method
   */
  isDisposable(instance2) {
    return instance2 !== null && typeof instance2 === "object" && "dispose" in instance2 && // Type-safe check: instance has 'dispose' property (checked above)
    typeof instance2.dispose === "function";
  }
  /**
   * Type guard to check if an instance implements the AsyncDisposable pattern.
   *
   * @param instance - The service instance to check
   * @returns True if instance has disposeAsync() method
   */
  isAsyncDisposable(instance2) {
    return instance2 !== null && typeof instance2 === "object" && "disposeAsync" in instance2 && // Type-safe check: instance has 'disposeAsync' property (checked above)
    typeof instance2.disposeAsync === "function";
  }
  /**
   * Checks if this scope is disposed.
   *
   * @returns True if disposed, false otherwise
   */
  isDisposed() {
    return this.disposed;
  }
  /**
   * Gets the hierarchical scope name.
   *
   * @returns The scope name (e.g., "root.child1.grandchild")
   */
  getScopeName() {
    return this.scopeName;
  }
  /**
   * Gets the unique correlation ID for this scope.
   *
   * Useful for tracing and logging in distributed/concurrent scenarios.
   * Each scope gets a unique ID combining name, timestamp, and random string.
   *
   * @returns The unique scope ID (e.g., "root-1730761234567-abc123")
   *
   * @example
   * ```typescript
   * const scope = container.createScope("request").value!;
   * logger.info(`[${scope.getScopeId()}] Processing request`);
   * ```
   */
  getScopeId() {
    return this.scopeId;
  }
};
__name(_ScopeManager, "ScopeManager");
let ScopeManager = _ScopeManager;
const _TimeoutError = class _TimeoutError extends Error {
  constructor(timeoutMs) {
    super(`Operation timed out after ${timeoutMs}ms`);
    this.name = "TimeoutError";
  }
};
__name(_TimeoutError, "TimeoutError");
let TimeoutError = _TimeoutError;
function withTimeout(promise4, timeoutMs) {
  let timeoutHandle = null;
  const timeoutPromise = new Promise((_, reject2) => {
    timeoutHandle = setTimeout(() => {
      reject2(new TimeoutError(timeoutMs));
    }, timeoutMs);
  });
  return Promise.race([
    promise4.finally(() => {
      if (timeoutHandle !== null) {
        clearTimeout(timeoutHandle);
      }
    }),
    timeoutPromise
  ]);
}
__name(withTimeout, "withTimeout");
const metricsCollectorToken = createInjectionToken("MetricsCollector");
const _ServiceRegistrationManager = class _ServiceRegistrationManager {
  constructor(registry, isDisposed, getValidationState) {
    this.registry = registry;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  /**
   * Register a service class with automatic dependency injection.
   */
  registerClass(token, serviceClass, lifecycle) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerClass(token, serviceClass, lifecycle);
  }
  /**
   * Register a factory function.
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    if (!factory || typeof factory !== "function") {
      return err({
        code: "InvalidFactory",
        message: "Factory must be a function",
        tokenDescription: String(token)
      });
    }
    return this.registry.registerFactory(token, factory, lifecycle, dependencies);
  }
  /**
   * Register a constant value.
   */
  registerValue(token, value2) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(token)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerValue(token, value2);
  }
  /**
   * Register an alias.
   */
  registerAlias(aliasToken, targetToken) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot register service on disposed container`,
        tokenDescription: String(aliasToken)
      });
    }
    if (this.getValidationState() === "validated") {
      return err({
        code: "InvalidOperation",
        message: "Cannot register after validation"
      });
    }
    return this.registry.registerAlias(aliasToken, targetToken);
  }
  /**
   * Get a registered value without requiring validation.
   * Useful for bootstrap/static values.
   */
  getRegisteredValue(token) {
    const registration = this.registry.getRegistration(token);
    if (!registration) {
      return null;
    }
    if (registration.providerType !== "value") {
      return null;
    }
    const value2 = registration.value;
    if (value2 === void 0) {
      return null;
    }
    return value2;
  }
  /**
   * Check if a service is registered.
   */
  isRegistered(token) {
    return this.registry.has(token);
  }
};
__name(_ServiceRegistrationManager, "ServiceRegistrationManager");
let ServiceRegistrationManager = _ServiceRegistrationManager;
const _ContainerValidationManager = class _ContainerValidationManager {
  constructor(validator, registry, initialState = "registering") {
    this.validator = validator;
    this.registry = registry;
    this.validationPromise = null;
    this.validationState = initialState;
  }
  /**
   * Validate all registrations.
   */
  validate() {
    if (this.validationState === "validated") {
      return ok(void 0);
    }
    if (this.validationState === "validating") {
      return err([
        {
          code: "InvalidOperation",
          message: "Validation already in progress"
        }
      ]);
    }
    this.validationState = "validating";
    const result = this.validator.validate(this.registry);
    if (result.ok) {
      this.validationState = "validated";
    } else {
      this.validationState = "registering";
    }
    return result;
  }
  /**
   * Async-safe validation for concurrent environments with timeout.
   */
  async validateAsync(timeoutMs, withTimeout2, TimeoutErrorClass) {
    if (this.validationState === "validated") {
      return ok(void 0);
    }
    if (this.validationPromise !== null) {
      return this.validationPromise;
    }
    if (this.validationState === "validating") {
      return err([
        {
          code: "InvalidOperation",
          message: "Validation already in progress"
        }
      ]);
    }
    this.validationState = "validating";
    let timedOut = false;
    const validationTask = Promise.resolve().then(() => {
      const result = this.validator.validate(this.registry);
      if (!timedOut) {
        if (result.ok) {
          this.validationState = "validated";
        } else {
          this.validationState = "registering";
        }
      }
      return result;
    });
    try {
      this.validationPromise = withTimeout2(validationTask, timeoutMs);
      const result = await this.validationPromise;
      return result;
    } catch (error3) {
      if (error3 instanceof TimeoutErrorClass) {
        timedOut = true;
        this.validationState = "registering";
        return err([
          {
            code: "InvalidOperation",
            message: `Validation timed out after ${timeoutMs}ms`
          }
        ]);
      }
      throw error3;
    } finally {
      this.validationPromise = null;
    }
  }
  /**
   * Get validation state.
   */
  getValidationState() {
    return this.validationState;
  }
  /**
   * Reset validation state (used after disposal or clear).
   */
  resetValidationState() {
    this.validationState = "registering";
  }
};
__name(_ContainerValidationManager, "ContainerValidationManager");
let ContainerValidationManager = _ContainerValidationManager;
const _ContainerErrorImpl = class _ContainerErrorImpl extends Error {
  constructor(error3) {
    super(error3.message);
    this.name = "ContainerError";
    this.code = error3.code;
    if (error3.cause !== void 0) {
      this.cause = error3.cause;
    }
    if (error3.tokenDescription !== void 0) {
      this.tokenDescription = error3.tokenDescription;
    }
    if (error3.details !== void 0) {
      this.details = error3.details;
    }
    if (error3.stack !== void 0) {
      this.stack = error3.stack;
    }
    if (error3.timestamp !== void 0) {
      this.timestamp = error3.timestamp;
    }
    if (error3.containerScope !== void 0) {
      this.containerScope = error3.containerScope;
    }
  }
};
__name(_ContainerErrorImpl, "ContainerErrorImpl");
let ContainerErrorImpl = _ContainerErrorImpl;
const _ServiceResolutionManager = class _ServiceResolutionManager {
  constructor(resolver3, isDisposed, getValidationState) {
    this.resolver = resolver3;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  resolveWithError(token) {
    if (this.isDisposed()) {
      const error3 = {
        code: "Disposed",
        message: `Cannot resolve from disposed container`,
        tokenDescription: String(token)
      };
      const domainError = {
        code: error3.code,
        message: error3.message,
        cause: error3.cause
      };
      return err(domainError);
    }
    if (this.getValidationState() !== "validated") {
      const error3 = {
        code: "NotValidated",
        message: "Container must be validated before resolving. Call validate() first.",
        tokenDescription: String(token)
      };
      const domainError = {
        code: error3.code,
        message: error3.message,
        cause: error3.cause
      };
      return err(domainError);
    }
    const result = this.resolver.resolve(token);
    if (!result.ok) {
      const domainError = {
        code: result.error.code,
        message: result.error.message,
        cause: result.error.cause
      };
      return err(domainError);
    }
    return result;
  }
  /**
   * Resolves a service instance (throws on failure).
   * FOR EXTERNAL API USE ONLY - uses ApiSafeToken validation.
   */
  resolve(token) {
    const result = this.resolveWithError(token);
    if (isOk(result)) {
      return castResolvedService$1(result.value);
    }
    const containerError = {
      code: castContainerErrorCode(result.error.code),
      message: `Cannot resolve ${String(token)}: ${result.error.message}`,
      tokenDescription: String(token),
      cause: result.error.cause
    };
    throw new ContainerErrorImpl(containerError);
  }
};
__name(_ServiceResolutionManager, "ServiceResolutionManager");
let ServiceResolutionManager = _ServiceResolutionManager;
const _ScopeManagementFacade = class _ScopeManagementFacade {
  constructor(scopeManager, isDisposed, getValidationState) {
    this.scopeManager = scopeManager;
    this.isDisposed = isDisposed;
    this.getValidationState = getValidationState;
  }
  /**
   * Validates that a scope can be created.
   * Returns the scope creation result if valid, or an error if not.
   */
  validateScopeCreation(name) {
    if (this.isDisposed()) {
      return err({
        code: "Disposed",
        message: `Cannot create scope from disposed container`
      });
    }
    if (this.getValidationState() !== "validated") {
      return err({
        code: "NotValidated",
        message: "Parent must be validated before creating scopes. Call validate() first."
      });
    }
    return this.scopeManager.createChild(name);
  }
};
__name(_ScopeManagementFacade, "ScopeManagementFacade");
let ScopeManagementFacade = _ScopeManagementFacade;
const _MetricsInjectionManager = class _MetricsInjectionManager {
  constructor(resolver3, cache3, resolveMetricsCollector) {
    this.resolver = resolver3;
    this.cache = cache3;
    this.resolveMetricsCollector = resolveMetricsCollector;
  }
  /**
   * Injects MetricsCollector into resolver and cache after validation.
   * This enables metrics recording without circular dependencies during bootstrap.
   *
   * Note: EnvironmentConfig is already injected via BootstrapPerformanceTracker
   * during container creation, so only MetricsCollector needs to be injected here.
   */
  injectMetricsCollector() {
    return ok(void 0);
  }
  /**
   * Internal method to perform the actual injection.
   * Called by ServiceContainer after resolving the metrics collector.
   */
  performInjection(collector) {
    this.resolver.setMetricsCollector(collector);
    this.cache.setMetricsCollector(collector);
  }
};
__name(_MetricsInjectionManager, "MetricsInjectionManager");
let MetricsInjectionManager = _MetricsInjectionManager;
const _ApiSecurityManager = class _ApiSecurityManager {
  /**
   * Validates that a token is API-safe.
   * Used by container.resolve() to enforce API boundary.
   *
   * @param token - The token to validate
   * @returns Result indicating if token is API-safe
   */
  validateApiSafeToken(token) {
    if (!isApiSafeTokenRuntime(token)) {
      return err({
        code: "InvalidOperation",
        message: `API Boundary Violation: resolve() called with non-API-safe token: ${String(token)}.
This token was not marked via markAsApiSafe().

Internal code MUST use resolveWithError() instead:
  const result = container.resolveWithError(${String(token)});
  if (result.ok) { /* use result.value */ }

Only the public ModuleApi should expose resolve() for external modules.`,
        tokenDescription: String(token)
      });
    }
    return { ok: true, value: void 0 };
  }
};
__name(_ApiSecurityManager, "ApiSecurityManager");
let ApiSecurityManager = _ApiSecurityManager;
const _ServiceContainer = class _ServiceContainer {
  /**
   * Constructor for ServiceContainer.
   *
   * **Note:** This constructor is public to allow ContainerBootstrapFactory to create instances.
   * External code should use ServiceContainer.createRoot() or ContainerBootstrapFactory.createRoot().
   *
   * @param registry - Service registry
   * @param validator - Container validator (shared for parent/child)
   * @param cache - Instance cache
   * @param resolver - Service resolver
   * @param scopeManager - Scope manager
   * @param validationState - Initial validation state
   * @param env - Environment configuration
   */
  constructor(registry, validator, cache3, resolver3, scopeManager, validationState, env) {
    this.registry = registry;
    this.validator = validator;
    this.cache = cache3;
    this.resolver = resolver3;
    this.scopeManager = scopeManager;
    this.env = env;
    this.validationManager = new ContainerValidationManager(validator, registry, validationState);
    this.registrationManager = new ServiceRegistrationManager(
      registry,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
    this.resolutionManager = new ServiceResolutionManager(
      resolver3,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
    this.metricsInjectionManager = new MetricsInjectionManager(resolver3, cache3, (token) => {
      const result = this.resolutionManager.resolveWithError(token);
      if (!result.ok) {
        const containerError = {
          code: castContainerErrorCode(result.error.code),
          message: result.error.message,
          cause: result.error.cause,
          tokenDescription: String(token)
        };
        return err(containerError);
      }
      const metricsCollector = castResolvedService$1(result.value);
      return ok(metricsCollector);
    });
    this.apiSecurityManager = new ApiSecurityManager();
    this.scopeFacade = new ScopeManagementFacade(
      scopeManager,
      () => this.scopeManager.isDisposed(),
      () => this.validationManager.getValidationState()
    );
  }
  /**
   * Creates a new root container.
   *
   * **Note:** This method creates bootstrap dependencies (RuntimeConfig, PerformanceTracker) inline
   * to avoid circular dependency with ContainerBootstrapFactory.
   * The factory pattern is maintained via ContainerBootstrapFactory for external use (e.g., ContainerFactory).
   *
   * **Architecture:**
   * Creates bootstrap dependencies directly (infrastructure -> infrastructure, no violation).
   * This avoids circular dependency while maintaining the same functionality.
   *
   * @param env - Environment configuration
   * @returns A new root ServiceContainer
   */
  static createRoot(env) {
    const registry = new ServiceRegistry();
    const validator = new ContainerValidator();
    const cache3 = new InstanceCache();
    const scopeManager = new ScopeManager("root", null, cache3);
    const runtimeConfig = new RuntimeConfigAdapter(env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver3 = new ServiceResolver(registry, cache3, null, "root", performanceTracker);
    return new _ServiceContainer(
      registry,
      validator,
      cache3,
      resolver3,
      scopeManager,
      "registering",
      env
    );
  }
  /**
   * Register a service class with automatic dependency injection.
   */
  registerClass(token, serviceClass, lifecycle) {
    return this.registrationManager.registerClass(token, serviceClass, lifecycle);
  }
  /**
   * Register a factory function.
   */
  registerFactory(token, factory, lifecycle, dependencies) {
    return this.registrationManager.registerFactory(token, factory, lifecycle, dependencies);
  }
  /**
   * Register a constant value.
   */
  registerValue(token, value2) {
    return this.registrationManager.registerValue(token, value2);
  }
  /**
   * Register an already created instance.
   * Internally treated the same as a value registration.
   */
  registerInstance(token, instance2) {
    return this.registerValue(token, instance2);
  }
  /**
   * Returns a previously registered constant value without requiring validation.
   * Useful for bootstrap/static values that are needed while the container is still registering services.
   */
  getRegisteredValue(token) {
    return this.registrationManager.getRegisteredValue(token);
  }
  /**
   * Register an alias.
   */
  registerAlias(aliasToken, targetToken) {
    return this.registrationManager.registerAlias(aliasToken, targetToken);
  }
  /**
   * Validate all registrations.
   */
  validate() {
    const result = this.validationManager.validate();
    if (result.ok) {
      this.injectMetricsCollector();
    }
    return result;
  }
  /**
   * Injects MetricsCollector into resolver and cache after validation.
   * This enables metrics recording without circular dependencies during bootstrap.
   *
   * Note: EnvironmentConfig is already injected via BootstrapPerformanceTracker
   * during container creation, so only MetricsCollector needs to be injected here.
   *
   * Static import is safe here because:
   * - tokenindex.ts only uses `import type { ServiceContainer }` (removed at runtime)
   * - No circular runtime dependency exists
   * - Container is already validated when this is called
   */
  injectMetricsCollector() {
    const metricsResult = this.resolutionManager.resolveWithError(metricsCollectorToken);
    if (metricsResult.ok) {
      const metricsCollector = castResolvedService$1(metricsResult.value);
      this.metricsInjectionManager.performInjection(metricsCollector);
    }
  }
  /**
   * Get validation state.
   * Implements both Container.getValidationState and PlatformContainerPort.getValidationState.
   * Both interfaces use compatible types (ContainerValidationState is compatible with DomainContainerValidationState).
   */
  getValidationState() {
    return this.validationManager.getValidationState();
  }
  /**
   * Async-safe validation for concurrent environments with timeout.
   *
   * Prevents race conditions when multiple callers validate simultaneously
   * by ensuring only one validation runs at a time.
   *
   * @param timeoutMs - Timeout in milliseconds (default: 30000 = 30 seconds)
   * @returns Promise resolving to validation result
   *
   * @example
   * ```typescript
   * const container = ServiceContainer.createRoot(ENV);
   * // ... register services
   * await container.validateAsync(); // Safe for concurrent calls
   * await container.validateAsync(5000); // With 5 second timeout
   * ```
   */
  async validateAsync(timeoutMs = 3e4) {
    const result = await this.validationManager.validateAsync(timeoutMs, withTimeout, TimeoutError);
    if (result.ok) {
      this.injectMetricsCollector();
    }
    return result;
  }
  /**
   * Creates a child scope container.
   *
   * Child containers:
   * - Inherit parent registrations (cloned)
   * - Can add their own registrations
   * - Must call validate() before resolving
   * - Share parent's singleton instances
   * - Have isolated scoped instances
   *
   * @param name - Optional custom name for the scope
   * @returns Result with child container or error
   *
   * @example
   * ```typescript
   * const parent = ServiceContainer.createRoot(ENV);
   * parent.registerClass(LoggerToken, Logger, SINGLETON);
   * parent.validate();
   *
   * const child = parent.createScope("request").value!;
   * child.registerClass(RequestToken, RequestContext, SCOPED);
   * child.validate();
   *
   * const logger = child.resolve(LoggerToken);   // From parent (shared)
   * const ctx = child.resolve(RequestToken);      // From child (isolated)
   * ```
   */
  createScope(name) {
    const scopeResult = this.scopeFacade.validateScopeCreation(name);
    if (!scopeResult.ok) {
      return err(scopeResult.error);
    }
    const childRegistry = this.registry.clone();
    const childCache = scopeResult.value.cache;
    const childManager = scopeResult.value.manager;
    const { resolver: childResolver } = this.createBootstrapDependencies(
      childRegistry,
      childCache,
      this.resolver,
      // Parent resolver for singleton delegation
      scopeResult.value.scopeName
    );
    const child2 = new _ServiceContainer(
      childRegistry,
      this.validator,
      // Shared (stateless)
      childCache,
      childResolver,
      childManager,
      "registering",
      // Child starts in registering state
      this.env
      // Inherit ENV from parent
    );
    return ok(child2);
  }
  resolveWithError(token) {
    return this.resolutionManager.resolveWithError(token);
  }
  // Implementation (unified for both overloads)
  resolve(token) {
    const securityResult = this.apiSecurityManager.validateApiSafeToken(token);
    if (!securityResult.ok) {
      throw new ContainerErrorImpl(securityResult.error);
    }
    return this.resolutionManager.resolve(token);
  }
  isRegistered(token) {
    return ok(this.registrationManager.isRegistered(token));
  }
  /**
   * Returns API-safe token metadata for external consumption.
   */
  getApiSafeToken(token) {
    if (!isApiSafeTokenRuntime(token)) {
      return null;
    }
    return {
      description: String(token),
      isRegistered: this.registrationManager.isRegistered(token)
    };
  }
  /**
   * Synchronously dispose container and all children.
   *
   * Use this for scenarios where async disposal is not possible (e.g., browser unload).
   * For normal cleanup, prefer disposeAsync() which handles async disposal properly.
   *
   * @returns Result indicating success or disposal error
   */
  dispose() {
    const result = this.scopeManager.dispose();
    if (result.ok) {
      this.validationManager.resetValidationState();
    }
    return result;
  }
  /**
   * Asynchronously dispose container and all children.
   *
   * This is the preferred disposal method as it properly handles services that
   * implement AsyncDisposable, allowing for proper cleanup of resources like
   * database connections, file handles, or network sockets.
   *
   * Falls back to synchronous disposal for services implementing only Disposable.
   *
   * @returns Promise with Result indicating success or disposal error
   *
   * @example
   * ```typescript
   * // Preferred: async disposal
   * const result = await container.disposeAsync();
   * if (result.ok) {
   *   console.log("Container disposed successfully");
   * }
   *
   * // Browser unload (sync required)
   * window.addEventListener('beforeunload', () => {
   *   container.dispose();  // Sync fallback
   * });
   * ```
   */
  async disposeAsync() {
    const result = await this.scopeManager.disposeAsync();
    if (result.ok) {
      this.validationManager.resetValidationState();
    }
    return result;
  }
  /**
   * Clear all registrations and instances.
   *
   * IMPORTANT: Resets validation state (per review feedback).
   */
  clear() {
    this.registry.clear();
    this.cache.clear();
    this.validationManager.resetValidationState();
    return ok(void 0);
  }
  /**
   * Creates bootstrap dependencies for a scope (RuntimeConfig, PerformanceTracker, Resolver).
   *
   * **Responsibility:** Bootstrap dependency creation (extracted from createScope for SRP).
   * This method encapsulates the creation of bootstrap-specific components to separate
   * concerns from container logic.
   *
   * @private
   * @param registry - Service registry for the scope
   * @param cache - Instance cache for the scope
   * @param parentResolver - Parent resolver for singleton delegation
   * @param scopeName - Name of the scope
   * @returns Object with resolver and performance tracker
   */
  /**
   * Creates bootstrap dependencies for a scope (RuntimeConfig, PerformanceTracker, Resolver).
   *
   * **Responsibility:** Bootstrap dependency creation (extracted from createScope for SRP).
   * This method encapsulates the creation of bootstrap-specific components to separate
   * concerns from container logic.
   *
   * @private
   * @param registry - Service registry for the scope
   * @param cache - Instance cache for the scope
   * @param parentResolver - Parent resolver for singleton delegation
   * @param scopeName - Name of the scope
   * @returns Object with resolver and performance tracker
   */
  createBootstrapDependencies(registry, cache3, parentResolver, scopeName) {
    const runtimeConfig = new RuntimeConfigAdapter(this.env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver3 = new ServiceResolver(
      registry,
      cache3,
      parentResolver,
      scopeName,
      performanceTracker
    );
    return { resolver: resolver3, performanceTracker };
  }
};
__name(_ServiceContainer, "ServiceContainer");
let ServiceContainer = _ServiceContainer;
const _ContainerBootstrapFactory = class _ContainerBootstrapFactory {
  /**
   * Creates a root ServiceContainer with bootstrap dependencies.
   *
   * Creates and wires:
   * - RuntimeConfig from environment
   * - BootstrapPerformanceTracker (no MetricsCollector during bootstrap)
   * - ServiceResolver with performance tracking
   * - ServiceContainer with all dependencies
   *
   * @param env - Environment configuration
   * @returns A new root ServiceContainer
   */
  createRoot(env) {
    const registry = new ServiceRegistry();
    const validator = new ContainerValidator();
    const cache3 = new InstanceCache();
    const scopeManager = new ScopeManager("root", null, cache3);
    const runtimeConfig = new RuntimeConfigAdapter(env);
    const performanceTracker = new BootstrapPerformanceTracker(runtimeConfig, null);
    const resolver3 = new ServiceResolver(registry, cache3, null, "root", performanceTracker);
    return new ServiceContainer(
      registry,
      validator,
      cache3,
      resolver3,
      scopeManager,
      "registering",
      env
    );
  }
  /**
   * Creates a child scope container with bootstrap dependencies.
   *
   * Creates and wires:
   * - RuntimeConfig from parent's environment
   * - BootstrapPerformanceTracker for child scope
   * - ServiceResolver with performance tracking
   * - Child ServiceContainer with all dependencies
   *
   * @param parent - Parent container
   * @param name - Optional custom name for the scope
   * @returns Result with child container or error
   */
  createScope(parent4, name) {
    return parent4.createScope(name);
  }
};
__name(_ContainerBootstrapFactory, "ContainerBootstrapFactory");
let ContainerBootstrapFactory = _ContainerBootstrapFactory;
const _ContainerFactory = class _ContainerFactory {
  /**
   * Creates a new ContainerFactory instance.
   *
   * @param bootstrapFactory - Optional bootstrap factory (defaults to new instance)
   */
  constructor(bootstrapFactory) {
    this.bootstrapFactory = bootstrapFactory ?? new ContainerBootstrapFactory();
  }
  /**
   * Creates a root ServiceContainer with the given environment configuration.
   *
   * Delegates to ContainerBootstrapFactory to maintain SRP (bootstrap logic separated).
   *
   * @param env - Environment configuration
   * @returns A new ServiceContainer instance
   */
  createRoot(env) {
    return this.bootstrapFactory.createRoot(env);
  }
};
__name(_ContainerFactory, "ContainerFactory");
let ContainerFactory = _ContainerFactory;
const environmentConfigToken = createInjectionToken("EnvironmentConfig");
const containerHealthCheckToken = createInjectionToken("ContainerHealthCheck");
const metricsHealthCheckToken = createInjectionToken("MetricsHealthCheck");
const healthCheckRegistryToken = createInjectionToken("PlatformHealthCheckPort");
const serviceContainerToken = createInjectionToken("ServiceContainer");
const runtimeConfigToken = createInjectionToken(
  "PlatformRuntimeConfigPort"
);
const platformNotificationPortToken = createInjectionToken(
  "PlatformNotificationPort"
);
const notificationPublisherPortToken = createInjectionToken(
  "NotificationPublisherPort"
);
const notificationChannelRegistryPortToken = createInjectionToken("NotificationChannelRegistryPort");
const cacheReaderPortToken = createInjectionToken("CacheReaderPort");
const cacheWriterPortToken = createInjectionToken("CacheWriterPort");
const cacheInvalidationPortToken = createInjectionToken("CacheInvalidationPort");
const cacheStatsPortToken = createInjectionToken("CacheStatsPort");
const cacheComputePortToken = createInjectionToken("CacheComputePort");
const platformI18nPortToken = createInjectionToken("PlatformI18nPort");
const platformUIPortToken = createInjectionToken("PlatformUIPort");
const platformJournalDirectoryUiPortToken = createInjectionToken("PlatformJournalDirectoryUiPort");
const platformUINotificationPortToken = createInjectionToken(
  "PlatformUINotificationPort"
);
const platformSettingsPortToken = createInjectionToken("PlatformSettingsPort");
const platformJournalEventPortToken = createInjectionToken(
  "PlatformJournalEventPort"
);
const platformJournalUiEventPortToken = createInjectionToken(
  "PlatformJournalUiEventPort"
);
const platformJournalCollectionPortToken = createInjectionToken("PlatformJournalCollectionPort");
const platformJournalRepositoryToken = createInjectionToken(
  "PlatformJournalRepository"
);
const platformRelationshipPageRepositoryPortToken = createInjectionToken(
  "PlatformRelationshipPageRepositoryPort"
);
const platformPageCreationPortToken = createInjectionToken(
  "PlatformPageCreationPort"
);
const platformJournalPermissionPortToken = createInjectionToken("PlatformJournalPermissionPort");
const platformContextMenuRegistrationPortToken = createInjectionToken("PlatformContextMenuRegistrationPort");
const platformValidationPortToken = createInjectionToken("PlatformValidationPort");
const platformLoggingPortToken = createInjectionToken("PlatformLoggingPort");
const platformMetricsSnapshotPortToken = createInjectionToken(
  "PlatformMetricsSnapshotPort"
);
const platformContainerPortToken = createInjectionToken("PlatformContainerPort");
const platformSettingsRegistrationPortToken = createInjectionToken("PlatformSettingsRegistrationPort");
const platformModuleReadyPortToken = createInjectionToken("PlatformModuleReadyPort");
const platformChannelPortToken = createInjectionToken("PlatformChannelPort");
const platformUINotificationChannelPortToken = createInjectionToken("PlatformUINotificationChannelPort");
const platformConsoleChannelPortToken = createInjectionToken(
  "PlatformConsoleChannelPort"
);
const platformUIAvailabilityPortToken = createInjectionToken(
  "PlatformUIAvailabilityPort"
);
const _ContainerHealthCheck = class _ContainerHealthCheck {
  constructor(container2) {
    this.name = "container";
    this.container = container2;
  }
  check() {
    return this.container.getValidationState() === "validated";
  }
  getDetails() {
    const state2 = this.container.getValidationState();
    if (state2 !== "validated") {
      return `Container state: ${state2}`;
    }
    return null;
  }
  dispose() {
  }
};
__name(_ContainerHealthCheck, "ContainerHealthCheck");
let ContainerHealthCheck = _ContainerHealthCheck;
const _DIContainerHealthCheck = class _DIContainerHealthCheck extends ContainerHealthCheck {
  constructor(container2, registry) {
    super(container2);
    registry.register(this);
  }
};
__name(_DIContainerHealthCheck, "DIContainerHealthCheck");
_DIContainerHealthCheck.dependencies = [platformContainerPortToken, healthCheckRegistryToken];
let DIContainerHealthCheck = _DIContainerHealthCheck;
function getDIContainerHealthCheckClass() {
  return DIContainerHealthCheck;
}
__name(getDIContainerHealthCheckClass, "getDIContainerHealthCheckClass");
const _MetricsHealthCheck = class _MetricsHealthCheck {
  constructor(metricsSnapshotPort) {
    this.name = "metrics";
    this.metricsSnapshotPort = metricsSnapshotPort;
  }
  check() {
    const snapshot2 = this.metricsSnapshotPort.getSnapshot();
    const hasPortFailures = Object.keys(snapshot2.portSelectionFailures).length > 0;
    const hasResolutionErrors = snapshot2.resolutionErrors > 0;
    return !hasPortFailures && !hasResolutionErrors;
  }
  getDetails() {
    const snapshot2 = this.metricsSnapshotPort.getSnapshot();
    const failures = Object.keys(snapshot2.portSelectionFailures);
    if (failures.length > 0) {
      return `Port selection failures: ${failures.join(", ")}`;
    }
    if (snapshot2.resolutionErrors > 0) {
      return `Resolution errors: ${snapshot2.resolutionErrors}`;
    }
    return null;
  }
  dispose() {
  }
};
__name(_MetricsHealthCheck, "MetricsHealthCheck");
let MetricsHealthCheck = _MetricsHealthCheck;
const _DIMetricsHealthCheck = class _DIMetricsHealthCheck extends MetricsHealthCheck {
  constructor(metricsSnapshotPort, registry) {
    super(metricsSnapshotPort);
    registry.register(this);
  }
};
__name(_DIMetricsHealthCheck, "DIMetricsHealthCheck");
_DIMetricsHealthCheck.dependencies = [platformMetricsSnapshotPortToken, healthCheckRegistryToken];
let DIMetricsHealthCheck = _DIMetricsHealthCheck;
function getDIMetricsHealthCheckClass() {
  return DIMetricsHealthCheck;
}
__name(getDIMetricsHealthCheckClass, "getDIMetricsHealthCheckClass");
const moduleIdToken = createInjectionToken("ModuleId");
const _DependencyRegistrationRegistry = class _DependencyRegistrationRegistry {
  constructor() {
    this.steps = [];
  }
  /**
   * Registers a new dependency registration step.
   * Steps are automatically sorted by priority after registration.
   * If a step with the same name already exists, it will be replaced.
   *
   * @param step - The registration step to add
   */
  register(step3) {
    this.steps = this.steps.filter((s) => s.name !== step3.name);
    this.steps.push(step3);
    this.steps.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Resets the registry by clearing all registered steps.
   * This is primarily useful for testing scenarios where a clean state is needed.
   */
  reset() {
    this.steps = [];
  }
  /**
   * Executes all registered steps in priority order.
   * Stops at first error and returns it.
   *
   * @param container - The service container to configure
   * @returns Result indicating success or the first error encountered
   */
  configure(container2) {
    for (const step3 of this.steps) {
      const result = step3.execute(container2);
      if (isErr(result)) {
        return err(`Failed at step '${step3.name}': ${result.error}`);
      }
    }
    return ok(void 0);
  }
};
__name(_DependencyRegistrationRegistry, "DependencyRegistrationRegistry");
let DependencyRegistrationRegistry = _DependencyRegistrationRegistry;
const dependencyRegistry = new DependencyRegistrationRegistry();
function registerDependencyStep(step3) {
  dependencyRegistry.register(step3);
}
__name(registerDependencyStep, "registerDependencyStep");
const portSelectorToken = createInjectionToken("PortSelector");
const foundryGamePortRegistryToken = createInjectionToken("FoundryGamePortRegistry");
const foundryHooksPortRegistryToken = createInjectionToken(
  "FoundryHooksPortRegistry"
);
const foundryDocumentPortRegistryToken = createInjectionToken(
  "FoundryDocumentPortRegistry"
);
const foundryUIPortRegistryToken = createInjectionToken("FoundryUIPortRegistry");
const foundrySettingsPortRegistryToken = createInjectionToken(
  "FoundrySettingsPortRegistry"
);
const foundryI18nPortRegistryToken = createInjectionToken("FoundryI18nPortRegistry");
const foundryModulePortRegistryToken = createInjectionToken(
  "FoundryModulePortRegistry"
);
function createFoundryError(code, message2, details, cause) {
  return { code, message: message2, details, cause };
}
__name(createFoundryError, "createFoundryError");
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null;
}
__name(isErrorLike, "isErrorLike");
function isFoundryError(error3) {
  if (!isErrorLike(error3)) return false;
  return "code" in error3 && "message" in error3 && typeof error3.code === "string" && typeof error3.message === "string";
}
__name(isFoundryError, "isFoundryError");
const portSelectionEventEmitterToken = createInjectionToken(
  "PortSelectionEventEmitter"
);
const foundryVersionDetectorToken = createInjectionToken("FoundryVersionDetector");
const _PortResolutionStrategy = class _PortResolutionStrategy {
  constructor(container2) {
    this.container = container2;
  }
  /**
   * Resolves a port from the DI container using the provided injection token.
   *
   * @template T - The port type
   * @param token - The injection token for the port
   * @returns Result with resolved port or FoundryError
   *
   * @example
   * ```typescript
   * const strategy = new PortResolutionStrategy(container);
   * const portResult = strategy.resolve(foundryV13GamePortToken);
   * if (portResult.ok) {
   *   const port = portResult.value;
   * }
   * ```
   */
  resolve(token) {
    try {
      const resolveResult = this.container.resolveWithError(token);
      if (!resolveResult.ok) {
        return err(
          createFoundryError(
            "PORT_RESOLUTION_FAILED",
            `Failed to resolve port from container`,
            { token: String(token) },
            resolveResult.error
          )
        );
      }
      return ok(castResolvedService$1(resolveResult.value));
    } catch (error3) {
      return err(
        createFoundryError(
          "PORT_RESOLUTION_FAILED",
          `Failed to resolve port from container`,
          { token: String(token) },
          error3 instanceof Error ? error3 : new Error(String(error3))
        )
      );
    }
  }
};
__name(_PortResolutionStrategy, "PortResolutionStrategy");
let PortResolutionStrategy = _PortResolutionStrategy;
const portSelectionObservabilityToken = createInjectionToken(
  "PortSelectionObservability"
);
const portSelectionPerformanceTrackerToken = createInjectionToken("PortSelectionPerformanceTracker");
const portSelectionObserverToken = createInjectionToken("PortSelectionObserver");
function createMatchError(message2, details) {
  return {
    code: "PORT_SELECTION_FAILED",
    message: message2,
    details
  };
}
__name(createMatchError, "createMatchError");
const _GreedyPortMatchStrategy = class _GreedyPortMatchStrategy {
  /**
   * Selects the highest compatible port version.
   *
   * Algorithm:
   * 1. Never select a port with version > current Foundry version
   *    (prevents using APIs that don't exist yet)
   * 2. Select the highest port version that is <= Foundry version
   *    (use the newest compatible implementation)
   *
   * Time Complexity: O(n) where n = number of registered ports
   * Space Complexity: O(1)
   *
   * @param tokens - Map of version numbers to injection tokens
   * @param foundryVersion - The current Foundry version to match against
   * @returns Result with matched port token and version, or error if no match found
   *
   * @example
   * ```typescript
   * const strategy = new GreedyPortMatchStrategy();
   * const tokens = new Map([
   *   [13, foundryV13GamePortToken],
   *   [14, foundryV14GamePortToken]
   * ]);
   * // Foundry v14: selects v14
   * // Foundry v13: selects v13
   * // Foundry v15: selects v14 (fallback to highest available)
   * const result = strategy.select(tokens, 14);
   * ```
   */
  select(tokens2, foundryVersion) {
    let selectedToken;
    let selectedVersion = APP_DEFAULTS.NO_VERSION_SELECTED;
    for (const [portVersion, token] of tokens2.entries()) {
      if (portVersion > foundryVersion) {
        continue;
      }
      if (portVersion > selectedVersion) {
        selectedVersion = portVersion;
        selectedToken = token;
      }
    }
    if (selectedToken === void 0) {
      const availableVersions = Array.from(tokens2.keys()).sort((a, b) => a - b).join(", ");
      return err(
        createMatchError(`No compatible port found for Foundry version ${foundryVersion}`, {
          version: foundryVersion,
          availableVersions: availableVersions || "none"
        })
      );
    }
    return ok({
      token: selectedToken,
      version: selectedVersion
    });
  }
};
__name(_GreedyPortMatchStrategy, "GreedyPortMatchStrategy");
let GreedyPortMatchStrategy = _GreedyPortMatchStrategy;
const _PortSelector = class _PortSelector {
  constructor(versionDetector, eventEmitter, observability, performanceTracker, observer, container2, matchStrategy) {
    this.versionDetector = versionDetector;
    this.eventEmitter = eventEmitter;
    this.observability = observability;
    this.performanceTracker = performanceTracker;
    this.observer = observer;
    this.observability.registerWithObservabilityRegistry(this);
    this.observability.setupObservability(this, this.observer);
    this.resolutionStrategy = new PortResolutionStrategy(container2);
    this.matchStrategy = matchStrategy ?? new GreedyPortMatchStrategy();
  }
  /**
   * Subscribe to port selection events.
   *
   * Allows observers to be notified of port selection success/failure for
   * logging, metrics, and other observability concerns.
   *
   * @param callback - Function to call when port selection events occur
   * @returns Unsubscribe function
   *
   * @example
   * ```typescript
   * const selector = new PortSelector();
   * const unsubscribe = selector.onEvent((event) => {
   *   if (event.type === 'success') {
   *     console.log(`Port v${event.selectedVersion} selected`);
   *   }
   * });
   * ```
   */
  onEvent(callback) {
    return this.eventEmitter.subscribe(callback);
  }
  /**
   * Selects and resolves the appropriate port from injection tokens.
   *
   * CRITICAL: Works with token map to avoid eager instantiation.
   * Only the selected token is resolved from the DI container, preventing crashes from
   * incompatible constructors accessing unavailable APIs.
   *
   * @template T - The port type
   * @param tokens - Map of version numbers to injection tokens
   * @param foundryVersion - Optional version override (uses getFoundryVersion() if not provided)
   * @param adapterName - Optional adapter name for observability
   * @returns Result with resolved port or error
   *
   * @example
   * ```typescript
   * const tokens = new Map([
   *   [13, foundryV13GamePortToken],
   *   [14, foundryV14GamePortToken]
   * ]);
   * const selector = new PortSelector(eventEmitter, observability, container);
   * const result = selector.selectPortFromTokens(tokens);
   * // On Foundry v13: resolves only v13 port from container (v14 token never resolved)
   * // On Foundry v14: resolves v14 port from container
   * ```
   */
  selectPortFromTokens(tokens2, foundryVersion, adapterName) {
    this.performanceTracker.startTracking();
    let version2;
    if (foundryVersion !== void 0) {
      version2 = foundryVersion;
    } else {
      const versionResult = this.versionDetector.getVersion();
      if (!versionResult.ok) {
        this.performanceTracker.endTracking();
        this.observer.handleEvent({
          type: "failure",
          foundryVersion: 0,
          // Unknown version
          availableVersions: Array.from(tokens2.keys()).sort((a, b) => a - b).join(", "),
          ...adapterName !== void 0 ? { adapterName } : {},
          error: createFoundryError(
            "PORT_SELECTION_FAILED",
            "Could not determine Foundry version",
            void 0,
            versionResult.error
          )
        });
        return err(
          createFoundryError(
            "PORT_SELECTION_FAILED",
            "Could not determine Foundry version",
            void 0,
            versionResult.error
          )
        );
      }
      version2 = versionResult.value;
    }
    const tokensForStrategy = tokens2;
    const matchResult = this.matchStrategy.select(tokensForStrategy, version2);
    if (!matchResult.ok) {
      this.performanceTracker.endTracking();
      const errorDetails = matchResult.error.details;
      let availableVersions;
      if (typeof errorDetails === "object" && errorDetails !== null && "availableVersions" in errorDetails && typeof errorDetails.availableVersions === "string") {
        availableVersions = errorDetails.availableVersions;
      } else {
        availableVersions = Array.from(tokens2.keys()).sort((a, b) => a - b).join(", ");
      }
      this.observer.handleEvent({
        type: "failure",
        foundryVersion: version2,
        availableVersions,
        ...adapterName !== void 0 ? { adapterName } : {},
        error: matchResult.error
      });
      return err(matchResult.error);
    }
    const { token: selectedToken, version: selectedVersion } = matchResult.value;
    const typedToken = selectedToken;
    const portResult = this.resolutionStrategy.resolve(typedToken);
    if (!portResult.ok) {
      this.performanceTracker.endTracking();
      this.observer.handleEvent({
        type: "failure",
        foundryVersion: version2,
        availableVersions: Array.from(tokens2.keys()).sort((a, b) => a - b).join(", "),
        ...adapterName !== void 0 ? { adapterName } : {},
        error: portResult.error
      });
      return err(portResult.error);
    }
    const durationMs = this.performanceTracker.endTracking();
    this.observer.handleEvent({
      type: "success",
      selectedVersion,
      foundryVersion: version2,
      ...adapterName !== void 0 ? { adapterName } : {},
      durationMs
    });
    return ok(portResult.value);
  }
};
__name(_PortSelector, "PortSelector");
let PortSelector = _PortSelector;
const _DIPortSelector = class _DIPortSelector extends PortSelector {
  constructor(versionDetector, eventEmitter, observability, performanceTracker, observer, container2) {
    super(versionDetector, eventEmitter, observability, performanceTracker, observer, container2);
  }
};
__name(_DIPortSelector, "DIPortSelector");
_DIPortSelector.dependencies = [
  foundryVersionDetectorToken,
  portSelectionEventEmitterToken,
  portSelectionObservabilityToken,
  portSelectionPerformanceTrackerToken,
  portSelectionObserverToken,
  serviceContainerToken
];
let DIPortSelector = _DIPortSelector;
let cachedVersion = null;
function detectFoundryVersion() {
  if (typeof game === "undefined") {
    return err("Foundry game object is not available or version cannot be determined");
  }
  const versionString = game.version;
  if (!versionString) {
    return err("Foundry version is not available on the game object");
  }
  const versionStr = versionString.match(/^(\d+)/)?.[1];
  if (!versionStr) {
    return err(`Could not parse Foundry version from: ${versionString}`);
  }
  return ok(Number.parseInt(versionStr, 10));
}
__name(detectFoundryVersion, "detectFoundryVersion");
function getFoundryVersionResult() {
  if (cachedVersion === null) {
    cachedVersion = detectFoundryVersion();
  }
  return cachedVersion;
}
__name(getFoundryVersionResult, "getFoundryVersionResult");
function resetVersionCache() {
  cachedVersion = null;
}
__name(resetVersionCache, "resetVersionCache");
function tryGetFoundryVersion() {
  const result = getFoundryVersionResult();
  return result.ok ? result.value : void 0;
}
__name(tryGetFoundryVersion, "tryGetFoundryVersion");
const _FoundryVersionDetector = class _FoundryVersionDetector {
  /**
   * Gets the major version number of the currently running Foundry VTT instance.
   *
   * @returns Result with major version number (e.g., 13 for "13.348") or FoundryError
   *
   * @example
   * ```typescript
   * const detector = new FoundryVersionDetector();
   * const versionResult = detector.getVersion();
   * if (versionResult.ok) {
   *   console.log(`Foundry version: ${versionResult.value}`);
   * }
   * ```
   */
  getVersion() {
    const versionResult = getFoundryVersionResult();
    if (!versionResult.ok) {
      return err(
        createFoundryError(
          "VERSION_DETECTION_FAILED",
          "Could not determine Foundry version",
          void 0,
          versionResult.error
        )
      );
    }
    return ok(versionResult.value);
  }
};
__name(_FoundryVersionDetector, "FoundryVersionDetector");
let FoundryVersionDetector = _FoundryVersionDetector;
const _DIFoundryVersionDetector = class _DIFoundryVersionDetector extends FoundryVersionDetector {
  constructor() {
    super();
  }
};
__name(_DIFoundryVersionDetector, "DIFoundryVersionDetector");
_DIFoundryVersionDetector.dependencies = [];
let DIFoundryVersionDetector = _DIFoundryVersionDetector;
const _PortRegistry = class _PortRegistry {
  constructor() {
    this.tokens = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a port injection token for a specific Foundry version.
   * @param version - The Foundry version this port supports
   * @param token - Injection token for resolving the port from the DI container
   * @returns Result indicating success or duplicate registration error
   */
  register(version2, token) {
    if (this.tokens.has(version2)) {
      return err(
        createFoundryError(
          "PORT_REGISTRY_ERROR",
          `Port for version ${version2} already registered`,
          { version: version2 }
        )
      );
    }
    this.tokens.set(version2, token);
    return ok(void 0);
  }
  /**
   * Gets all registered port versions.
   * @returns Array of registered version numbers, sorted ascending
   */
  getAvailableVersions() {
    return Array.from(this.tokens.keys()).sort((a, b) => a - b);
  }
  /**
   * Gets the token map without resolving ports.
   * Use with PortSelector.selectPortFromTokens() for safe lazy instantiation via DI.
   *
   * @returns Map of version numbers to injection tokens (NOT instances)
   *
   * @example
   * ```typescript
   * const registry = new PortRegistry<FoundryGame>();
   * registry.register(13, foundryV13GamePortToken);
   * registry.register(14, foundryGamePortV14Token);
   *
   * const tokens = registry.getTokens();
   * const selector = new PortSelector(container);
   * const result = selector.selectPortFromTokens(tokens);
   * // Only compatible port is resolved from container
   * ```
   */
  getTokens() {
    return new Map(this.tokens);
  }
  /**
   * Checks if a port is registered for a specific version.
   * @param version - The version to check
   * @returns True if a port is registered for this version
   */
  hasVersion(version2) {
    return this.tokens.has(version2);
  }
  /**
   * Gets the highest registered port version.
   * @returns The highest version number or undefined if no ports are registered
   */
  getHighestVersion() {
    const versions = this.getAvailableVersions();
    return versions.at(-1);
  }
};
__name(_PortRegistry, "PortRegistry");
let PortRegistry = _PortRegistry;
let store$4;
function setGlobalConfig(config$1) {
  store$4 = {
    ...store$4,
    ...config$1
  };
}
__name(setGlobalConfig, "setGlobalConfig");
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config$1) {
  return {
    lang: config$1?.lang ?? store$4?.lang,
    message: config$1?.message,
    abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
    abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
  };
}
__name(getGlobalConfig, "getGlobalConfig");
function deleteGlobalConfig() {
  store$4 = void 0;
}
__name(deleteGlobalConfig, "deleteGlobalConfig");
let store$3;
function setGlobalMessage(message$1, lang) {
  if (!store$3) store$3 = /* @__PURE__ */ new Map();
  store$3.set(lang, message$1);
}
__name(setGlobalMessage, "setGlobalMessage");
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
  return store$3?.get(lang);
}
__name(getGlobalMessage, "getGlobalMessage");
function deleteGlobalMessage(lang) {
  store$3?.delete(lang);
}
__name(deleteGlobalMessage, "deleteGlobalMessage");
let store$2;
function setSchemaMessage(message$1, lang) {
  if (!store$2) store$2 = /* @__PURE__ */ new Map();
  store$2.set(lang, message$1);
}
__name(setSchemaMessage, "setSchemaMessage");
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
  return store$2?.get(lang);
}
__name(getSchemaMessage, "getSchemaMessage");
function deleteSchemaMessage(lang) {
  store$2?.delete(lang);
}
__name(deleteSchemaMessage, "deleteSchemaMessage");
let store$1;
function setSpecificMessage(reference, message$1, lang) {
  if (!store$1) store$1 = /* @__PURE__ */ new Map();
  if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());
  store$1.get(reference).set(lang, message$1);
}
__name(setSpecificMessage, "setSpecificMessage");
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
  return store$1?.get(reference)?.get(lang);
}
__name(getSpecificMessage, "getSpecificMessage");
function deleteSpecificMessage(reference, lang) {
  store$1?.get(reference)?.delete(lang);
}
__name(deleteSpecificMessage, "deleteSpecificMessage");
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
  const type = typeof input;
  if (type === "string") return `"${input}"`;
  if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
  if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  return type;
}
__name(_stringify, "_stringify");
function _addIssue(context, label2, dataset, config$1, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label2}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config$1.lang,
    abortEarly: config$1.abortEarly,
    abortPipeEarly: config$1.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
  if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
  if (isSchema) dataset.typed = false;
  if (dataset.issues) dataset.issues.push(issue);
  else dataset.issues = [issue];
}
__name(_addIssue, "_addIssue");
let textEncoder;
// @__NO_SIDE_EFFECTS__
function _getByteCount(input) {
  if (!textEncoder) textEncoder = new TextEncoder();
  return textEncoder.encode(input).length;
}
__name(_getByteCount, "_getByteCount");
let segmenter;
// @__NO_SIDE_EFFECTS__
function _getGraphemeCount(input) {
  if (!segmenter) segmenter = new Intl.Segmenter();
  const segments = segmenter.segment(input);
  let count = 0;
  for (const _ of segments) count++;
  return count;
}
__name(_getGraphemeCount, "_getGraphemeCount");
// @__NO_SIDE_EFFECTS__
function _getLastMetadata(schema, type) {
  if ("pipe" in schema) {
    const nestedSchemas = [];
    for (let index2 = schema.pipe.length - 1; index2 >= 0; index2--) {
      const item = schema.pipe[index2];
      if (item.kind === "schema" && "pipe" in item) nestedSchemas.push(item);
      else if (item.kind === "metadata" && item.type === type) return item[type];
    }
    for (const nestedSchema of nestedSchemas) {
      const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);
      if (result !== void 0) return result;
    }
  }
}
__name(_getLastMetadata, "_getLastMetadata");
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value$1) {
      return context["~run"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());
    }
  };
}
__name(_getStandardProps, "_getStandardProps");
let store;
// @__NO_SIDE_EFFECTS__
function _getWordCount(locales, input) {
  if (!store) store = /* @__PURE__ */ new Map();
  if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: "word" }));
  const segments = store.get(locales).segment(input);
  let count = 0;
  for (const segment of segments) if (segment.isWordLike) count++;
  return count;
}
__name(_getWordCount, "_getWordCount");
const NON_DIGIT_REGEX = /\D/gu;
// @__NO_SIDE_EFFECTS__
function _isLuhnAlgo(input) {
  const number$12 = input.replace(NON_DIGIT_REGEX, "");
  let length$1 = number$12.length;
  let bit = 1;
  let sum = 0;
  while (length$1) {
    const value$1 = +number$12[--length$1];
    bit ^= 1;
    sum += bit ? [
      0,
      2,
      4,
      6,
      8,
      1,
      3,
      5,
      7,
      9
    ][value$1] : value$1;
  }
  return sum % 10 === 0;
}
__name(_isLuhnAlgo, "_isLuhnAlgo");
// @__NO_SIDE_EFFECTS__
function _isValidObjectKey(object$12, key2) {
  return Object.hasOwn(object$12, key2) && key2 !== "__proto__" && key2 !== "prototype" && key2 !== "constructor";
}
__name(_isValidObjectKey, "_isValidObjectKey");
// @__NO_SIDE_EFFECTS__
function _joinExpects(values$1, separator) {
  const list = [...new Set(values$1)];
  if (list.length > 1) return `(${list.join(` ${separator} `)})`;
  return list[0] ?? "never";
}
__name(_joinExpects, "_joinExpects");
// @__NO_SIDE_EFFECTS__
function entriesFromList(list, schema) {
  const entries$1 = {};
  for (const key2 of list) entries$1[key2] = schema;
  return entries$1;
}
__name(entriesFromList, "entriesFromList");
// @__NO_SIDE_EFFECTS__
function entriesFromObjects(schemas) {
  const entries$1 = {};
  for (const schema of schemas) Object.assign(entries$1, schema.entries);
  return entries$1;
}
__name(entriesFromObjects, "entriesFromObjects");
// @__NO_SIDE_EFFECTS__
function getDotPath(issue) {
  if (issue.path) {
    let key2 = "";
    for (const item of issue.path) if (typeof item.key === "string" || typeof item.key === "number") if (key2) key2 += `.${item.key}`;
    else key2 += item.key;
    else return null;
    return key2;
  }
  return null;
}
__name(getDotPath, "getDotPath");
// @__NO_SIDE_EFFECTS__
function isOfKind(kind, object$12) {
  return object$12.kind === kind;
}
__name(isOfKind, "isOfKind");
// @__NO_SIDE_EFFECTS__
function isOfType(type, object$12) {
  return object$12.type === type;
}
__name(isOfType, "isOfType");
// @__NO_SIDE_EFFECTS__
function isValiError(error3) {
  return error3 instanceof ValiError;
}
__name(isValiError, "isValiError");
var ValiError = (_a = class extends Error {
  /**
  * Creates a Valibot error with useful information.
  *
  * @param issues The error issues.
  */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
}, __name(_a, "ValiError"), _a);
// @__NO_SIDE_EFFECTS__
function args(schema) {
  return {
    kind: "transformation",
    type: "args",
    reference: args,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = (...args_) => {
        const argsDataset = this.schema["~run"]({ value: args_ }, config$1);
        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
        return func(...argsDataset.value);
      };
      return dataset;
    }
  };
}
__name(args, "args");
// @__NO_SIDE_EFFECTS__
function argsAsync(schema) {
  return {
    kind: "transformation",
    type: "args",
    reference: argsAsync,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = async (...args$1) => {
        const argsDataset = await schema["~run"]({ value: args$1 }, config$1);
        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
        return func(...argsDataset.value);
      };
      return dataset;
    }
  };
}
__name(argsAsync, "argsAsync");
// @__NO_SIDE_EFFECTS__
function awaitAsync() {
  return {
    kind: "transformation",
    type: "await",
    reference: awaitAsync,
    async: true,
    async "~run"(dataset) {
      dataset.value = await dataset.value;
      return dataset;
    }
  };
}
__name(awaitAsync, "awaitAsync");
const BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
const BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
const CUID2_REGEX = /^[a-z][\da-z]*$/u;
const DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
const DIGITS_REGEX = /^\d+$/u;
const EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
const EMOJI_REGEX = /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation}))*)+$/u;
const HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
const HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
const IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
const IPV4_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
const IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
const IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
const ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
const ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
const ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
const ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
const ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
const ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
const MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
const MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
const MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
const NANO_ID_REGEX = /^[\w-]+$/u;
const OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
const RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
const ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
const UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
// @__NO_SIDE_EFFECTS__
function base64(message$1) {
  return {
    kind: "validation",
    type: "base64",
    reference: base64,
    async: false,
    expects: null,
    requirement: BASE64_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Base64", dataset, config$1);
      return dataset;
    }
  };
}
__name(base64, "base64");
// @__NO_SIDE_EFFECTS__
function bic(message$1) {
  return {
    kind: "validation",
    type: "bic",
    reference: bic,
    async: false,
    expects: null,
    requirement: BIC_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "BIC", dataset, config$1);
      return dataset;
    }
  };
}
__name(bic, "bic");
// @__NO_SIDE_EFFECTS__
function brand(name) {
  return {
    kind: "transformation",
    type: "brand",
    reference: brand,
    async: false,
    name,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(brand, "brand");
// @__NO_SIDE_EFFECTS__
function bytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "bytes",
    reference: bytes,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 !== this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(bytes, "bytes");
// @__NO_SIDE_EFFECTS__
function check(requirement, message$1) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(check, "check");
// @__NO_SIDE_EFFECTS__
function checkAsync(requirement, message$1) {
  return {
    kind: "validation",
    type: "check",
    reference: checkAsync,
    async: true,
    expects: null,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(checkAsync, "checkAsync");
// @__NO_SIDE_EFFECTS__
function checkItems(requirement, message$1) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItems,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) for (let index2 = 0; index2 < dataset.value.length; index2++) {
        const item = dataset.value[index2];
        if (!this.requirement(item, index2, dataset.value)) _addIssue(this, "item", dataset, config$1, {
          input: item,
          path: [{
            type: "array",
            origin: "value",
            input: dataset.value,
            key: index2,
            value: item
          }]
        });
      }
      return dataset;
    }
  };
}
__name(checkItems, "checkItems");
// @__NO_SIDE_EFFECTS__
function checkItemsAsync(requirement, message$1) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItemsAsync,
    async: true,
    expects: null,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if (dataset.typed) {
        const requirementResults = await Promise.all(dataset.value.map(this.requirement));
        for (let index2 = 0; index2 < dataset.value.length; index2++) if (!requirementResults[index2]) {
          const item = dataset.value[index2];
          _addIssue(this, "item", dataset, config$1, {
            input: item,
            path: [{
              type: "array",
              origin: "value",
              input: dataset.value,
              key: index2,
              value: item
            }]
          });
        }
      }
      return dataset;
    }
  };
}
__name(checkItemsAsync, "checkItemsAsync");
const CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
const SANITIZE_REGEX = /[- ]/gu;
const PROVIDER_REGEX_LIST = [
  /^3[47]\d{13}$/u,
  /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
  /^6(?:011|5\d{2})\d{12,15}$/u,
  /^(?:2131|1800|35\d{3})\d{11}$/u,
  /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
  /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
  /^4\d{12}(?:\d{3,6})?$/u
];
// @__NO_SIDE_EFFECTS__
function creditCard(message$1) {
  return {
    kind: "validation",
    type: "credit_card",
    reference: creditCard,
    async: false,
    expects: null,
    requirement(input) {
      let sanitized;
      return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, "")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "credit card", dataset, config$1);
      return dataset;
    }
  };
}
__name(creditCard, "creditCard");
// @__NO_SIDE_EFFECTS__
function cuid2(message$1) {
  return {
    kind: "validation",
    type: "cuid2",
    reference: cuid2,
    async: false,
    expects: null,
    requirement: CUID2_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Cuid2", dataset, config$1);
      return dataset;
    }
  };
}
__name(cuid2, "cuid2");
// @__NO_SIDE_EFFECTS__
function decimal(message$1) {
  return {
    kind: "validation",
    type: "decimal",
    reference: decimal,
    async: false,
    expects: null,
    requirement: DECIMAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "decimal", dataset, config$1);
      return dataset;
    }
  };
}
__name(decimal, "decimal");
// @__NO_SIDE_EFFECTS__
function description(description_) {
  return {
    kind: "metadata",
    type: "description",
    reference: description,
    description: description_
  };
}
__name(description, "description");
// @__NO_SIDE_EFFECTS__
function digits(message$1) {
  return {
    kind: "validation",
    type: "digits",
    reference: digits,
    async: false,
    expects: null,
    requirement: DIGITS_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "digits", dataset, config$1);
      return dataset;
    }
  };
}
__name(digits, "digits");
// @__NO_SIDE_EFFECTS__
function email(message$1) {
  return {
    kind: "validation",
    type: "email",
    reference: email,
    expects: null,
    async: false,
    requirement: EMAIL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
      return dataset;
    }
  };
}
__name(email, "email");
// @__NO_SIDE_EFFECTS__
function emoji(message$1) {
  return {
    kind: "validation",
    type: "emoji",
    reference: emoji,
    async: false,
    expects: null,
    requirement: EMOJI_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "emoji", dataset, config$1);
      return dataset;
    }
  };
}
__name(emoji, "emoji");
// @__NO_SIDE_EFFECTS__
function empty$1(message$1) {
  return {
    kind: "validation",
    type: "empty",
    reference: empty$1,
    async: false,
    expects: "0",
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length > 0) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(empty$1, "empty$1");
// @__NO_SIDE_EFFECTS__
function endsWith$1(requirement, message$1) {
  return {
    kind: "validation",
    type: "ends_with",
    reference: endsWith$1,
    async: false,
    expects: `"${requirement}"`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, "end", dataset, config$1, { received: `"${dataset.value.slice(-this.requirement.length)}"` });
      return dataset;
    }
  };
}
__name(endsWith$1, "endsWith$1");
// @__NO_SIDE_EFFECTS__
function entries(requirement, message$1) {
  return {
    kind: "validation",
    type: "entries",
    reference: entries,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count !== this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(entries, "entries");
// @__NO_SIDE_EFFECTS__
function everyItem(requirement, message$1) {
  return {
    kind: "validation",
    type: "every_item",
    reference: everyItem,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
      return dataset;
    }
  };
}
__name(everyItem, "everyItem");
// @__NO_SIDE_EFFECTS__
function examples(examples_) {
  return {
    kind: "metadata",
    type: "examples",
    reference: examples,
    examples: examples_
  };
}
__name(examples, "examples");
// @__NO_SIDE_EFFECTS__
function excludes(requirement, message$1) {
  const received = /* @__PURE__ */ _stringify(requirement);
  return {
    kind: "validation",
    type: "excludes",
    reference: excludes,
    async: false,
    expects: `!${received}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received });
      return dataset;
    }
  };
}
__name(excludes, "excludes");
// @__NO_SIDE_EFFECTS__
function filterItems(operation) {
  return {
    kind: "transformation",
    type: "filter_items",
    reference: filterItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.filter(this.operation);
      return dataset;
    }
  };
}
__name(filterItems, "filterItems");
// @__NO_SIDE_EFFECTS__
function findItem(operation) {
  return {
    kind: "transformation",
    type: "find_item",
    reference: findItem,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.find(this.operation);
      return dataset;
    }
  };
}
__name(findItem, "findItem");
// @__NO_SIDE_EFFECTS__
function finite(message$1) {
  return {
    kind: "validation",
    type: "finite",
    reference: finite,
    async: false,
    expects: null,
    requirement: Number.isFinite,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "finite", dataset, config$1);
      return dataset;
    }
  };
}
__name(finite, "finite");
// @__NO_SIDE_EFFECTS__
function flavor(name) {
  return {
    kind: "transformation",
    type: "flavor",
    reference: flavor,
    async: false,
    name,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(flavor, "flavor");
// @__NO_SIDE_EFFECTS__
function graphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "graphemes",
    reference: graphemes,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count !== this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(graphemes, "graphemes");
// @__NO_SIDE_EFFECTS__
function gtValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "gt_value",
    reference: gtValue,
    async: false,
    expects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(gtValue, "gtValue");
const HASH_LENGTHS = {
  md4: 32,
  md5: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8,
  adler32: 8
};
// @__NO_SIDE_EFFECTS__
function hash$1(types, message$1) {
  return {
    kind: "validation",
    type: "hash",
    reference: hash$1,
    expects: null,
    async: false,
    requirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hash", dataset, config$1);
      return dataset;
    }
  };
}
__name(hash$1, "hash$1");
// @__NO_SIDE_EFFECTS__
function hexadecimal(message$1) {
  return {
    kind: "validation",
    type: "hexadecimal",
    reference: hexadecimal,
    async: false,
    expects: null,
    requirement: HEXADECIMAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hexadecimal", dataset, config$1);
      return dataset;
    }
  };
}
__name(hexadecimal, "hexadecimal");
// @__NO_SIDE_EFFECTS__
function hexColor(message$1) {
  return {
    kind: "validation",
    type: "hex_color",
    reference: hexColor,
    async: false,
    expects: null,
    requirement: HEX_COLOR_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hex color", dataset, config$1);
      return dataset;
    }
  };
}
__name(hexColor, "hexColor");
// @__NO_SIDE_EFFECTS__
function imei(message$1) {
  return {
    kind: "validation",
    type: "imei",
    reference: imei,
    async: false,
    expects: null,
    requirement(input) {
      return IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "IMEI", dataset, config$1);
      return dataset;
    }
  };
}
__name(imei, "imei");
// @__NO_SIDE_EFFECTS__
function includes(requirement, message$1) {
  const expects = /* @__PURE__ */ _stringify(requirement);
  return {
    kind: "validation",
    type: "includes",
    reference: includes,
    async: false,
    expects,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received: `!${expects}` });
      return dataset;
    }
  };
}
__name(includes, "includes");
// @__NO_SIDE_EFFECTS__
function integer$1(message$1) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer$1,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
      return dataset;
    }
  };
}
__name(integer$1, "integer$1");
// @__NO_SIDE_EFFECTS__
function ip(message$1) {
  return {
    kind: "validation",
    type: "ip",
    reference: ip,
    async: false,
    expects: null,
    requirement: IP_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IP", dataset, config$1);
      return dataset;
    }
  };
}
__name(ip, "ip");
// @__NO_SIDE_EFFECTS__
function ipv4(message$1) {
  return {
    kind: "validation",
    type: "ipv4",
    reference: ipv4,
    async: false,
    expects: null,
    requirement: IPV4_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv4", dataset, config$1);
      return dataset;
    }
  };
}
__name(ipv4, "ipv4");
// @__NO_SIDE_EFFECTS__
function ipv6(message$1) {
  return {
    kind: "validation",
    type: "ipv6",
    reference: ipv6,
    async: false,
    expects: null,
    requirement: IPV6_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv6", dataset, config$1);
      return dataset;
    }
  };
}
__name(ipv6, "ipv6");
// @__NO_SIDE_EFFECTS__
function isoDate(message$1) {
  return {
    kind: "validation",
    type: "iso_date",
    reference: isoDate,
    async: false,
    expects: null,
    requirement: ISO_DATE_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoDate, "isoDate");
// @__NO_SIDE_EFFECTS__
function isoDateTime(message$1) {
  return {
    kind: "validation",
    type: "iso_date_time",
    reference: isoDateTime,
    async: false,
    expects: null,
    requirement: ISO_DATE_TIME_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date-time", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoDateTime, "isoDateTime");
// @__NO_SIDE_EFFECTS__
function isoTime(message$1) {
  return {
    kind: "validation",
    type: "iso_time",
    reference: isoTime,
    async: false,
    expects: null,
    requirement: ISO_TIME_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTime, "isoTime");
// @__NO_SIDE_EFFECTS__
function isoTimeSecond(message$1) {
  return {
    kind: "validation",
    type: "iso_time_second",
    reference: isoTimeSecond,
    async: false,
    expects: null,
    requirement: ISO_TIME_SECOND_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time-second", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTimeSecond, "isoTimeSecond");
// @__NO_SIDE_EFFECTS__
function isoTimestamp(message$1) {
  return {
    kind: "validation",
    type: "iso_timestamp",
    reference: isoTimestamp,
    async: false,
    expects: null,
    requirement: ISO_TIMESTAMP_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "timestamp", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoTimestamp, "isoTimestamp");
// @__NO_SIDE_EFFECTS__
function isoWeek(message$1) {
  return {
    kind: "validation",
    type: "iso_week",
    reference: isoWeek,
    async: false,
    expects: null,
    requirement: ISO_WEEK_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "week", dataset, config$1);
      return dataset;
    }
  };
}
__name(isoWeek, "isoWeek");
// @__NO_SIDE_EFFECTS__
function length(requirement, message$1) {
  return {
    kind: "validation",
    type: "length",
    reference: length,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(length, "length");
// @__NO_SIDE_EFFECTS__
function ltValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "lt_value",
    reference: ltValue,
    async: false,
    expects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(ltValue, "ltValue");
// @__NO_SIDE_EFFECTS__
function mac(message$1) {
  return {
    kind: "validation",
    type: "mac",
    reference: mac,
    async: false,
    expects: null,
    requirement: MAC_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac, "mac");
// @__NO_SIDE_EFFECTS__
function mac48(message$1) {
  return {
    kind: "validation",
    type: "mac48",
    reference: mac48,
    async: false,
    expects: null,
    requirement: MAC48_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "48-bit MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac48, "mac48");
// @__NO_SIDE_EFFECTS__
function mac64(message$1) {
  return {
    kind: "validation",
    type: "mac64",
    reference: mac64,
    async: false,
    expects: null,
    requirement: MAC64_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "64-bit MAC", dataset, config$1);
      return dataset;
    }
  };
}
__name(mac64, "mac64");
// @__NO_SIDE_EFFECTS__
function mapItems(operation) {
  return {
    kind: "transformation",
    type: "map_items",
    reference: mapItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.map(this.operation);
      return dataset;
    }
  };
}
__name(mapItems, "mapItems");
// @__NO_SIDE_EFFECTS__
function maxBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_bytes",
    reference: maxBytes,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 > this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(maxBytes, "maxBytes");
// @__NO_SIDE_EFFECTS__
function maxEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_entries",
    reference: maxEntries,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count > this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(maxEntries, "maxEntries");
// @__NO_SIDE_EFFECTS__
function maxGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_graphemes",
    reference: maxGraphemes,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count > this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(maxGraphemes, "maxGraphemes");
// @__NO_SIDE_EFFECTS__
function maxLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(maxLength, "maxLength");
// @__NO_SIDE_EFFECTS__
function maxSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_size",
    reference: maxSize,
    async: false,
    expects: `<=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(maxSize, "maxSize");
// @__NO_SIDE_EFFECTS__
function maxValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue,
    async: false,
    expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(maxValue, "maxValue");
// @__NO_SIDE_EFFECTS__
function maxWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "max_words",
    reference: maxWords,
    async: false,
    expects: `<=${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count > this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(maxWords, "maxWords");
// @__NO_SIDE_EFFECTS__
function metadata(metadata_) {
  return {
    kind: "metadata",
    type: "metadata",
    reference: metadata,
    metadata: metadata_
  };
}
__name(metadata, "metadata");
// @__NO_SIDE_EFFECTS__
function mimeType(requirement, message$1) {
  return {
    kind: "validation",
    type: "mime_type",
    reference: mimeType,
    async: false,
    expects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `"${option}"`), "|"),
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, "MIME type", dataset, config$1, { received: `"${dataset.value.type}"` });
      return dataset;
    }
  };
}
__name(mimeType, "mimeType");
// @__NO_SIDE_EFFECTS__
function minBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_bytes",
    reference: minBytes,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 < this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(minBytes, "minBytes");
// @__NO_SIDE_EFFECTS__
function minEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_entries",
    reference: minEntries,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count < this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(minEntries, "minEntries");
// @__NO_SIDE_EFFECTS__
function minGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_graphemes",
    reference: minGraphemes,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count < this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(minGraphemes, "minGraphemes");
// @__NO_SIDE_EFFECTS__
function minLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(minLength, "minLength");
// @__NO_SIDE_EFFECTS__
function minSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_size",
    reference: minSize,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(minSize, "minSize");
// @__NO_SIDE_EFFECTS__
function minValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue,
    async: false,
    expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(minValue, "minValue");
// @__NO_SIDE_EFFECTS__
function minWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "min_words",
    reference: minWords,
    async: false,
    expects: `>=${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count < this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(minWords, "minWords");
// @__NO_SIDE_EFFECTS__
function multipleOf(requirement, message$1) {
  return {
    kind: "validation",
    type: "multiple_of",
    reference: multipleOf,
    async: false,
    expects: `%${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, "multiple", dataset, config$1);
      return dataset;
    }
  };
}
__name(multipleOf, "multipleOf");
// @__NO_SIDE_EFFECTS__
function nanoid(message$1) {
  return {
    kind: "validation",
    type: "nanoid",
    reference: nanoid,
    async: false,
    expects: null,
    requirement: NANO_ID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Nano ID", dataset, config$1);
      return dataset;
    }
  };
}
__name(nanoid, "nanoid");
// @__NO_SIDE_EFFECTS__
function nonEmpty(message$1) {
  return {
    kind: "validation",
    type: "non_empty",
    reference: nonEmpty,
    async: false,
    expects: "!0",
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length === 0) _addIssue(this, "length", dataset, config$1, { received: "0" });
      return dataset;
    }
  };
}
__name(nonEmpty, "nonEmpty");
// @__NO_SIDE_EFFECTS__
function normalize$1(form) {
  return {
    kind: "transformation",
    type: "normalize",
    reference: normalize$1,
    async: false,
    form,
    "~run"(dataset) {
      dataset.value = dataset.value.normalize(this.form);
      return dataset;
    }
  };
}
__name(normalize$1, "normalize$1");
// @__NO_SIDE_EFFECTS__
function notBytes(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_bytes",
    reference: notBytes,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
        if (length$1 === this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
      }
      return dataset;
    }
  };
}
__name(notBytes, "notBytes");
// @__NO_SIDE_EFFECTS__
function notEntries(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_entries",
    reference: notEntries,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (!dataset.typed) return dataset;
      const count = Object.keys(dataset.value).length;
      if (dataset.typed && count === this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
      return dataset;
    }
  };
}
__name(notEntries, "notEntries");
// @__NO_SIDE_EFFECTS__
function notGraphemes(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_graphemes",
    reference: notGraphemes,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
        if (count === this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(notGraphemes, "notGraphemes");
// @__NO_SIDE_EFFECTS__
function notLength(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_length",
    reference: notLength,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
      return dataset;
    }
  };
}
__name(notLength, "notLength");
// @__NO_SIDE_EFFECTS__
function notSize(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_size",
    reference: notSize,
    async: false,
    expects: `!${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(notSize, "notSize");
// @__NO_SIDE_EFFECTS__
function notValue(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_value",
    reference: notValue,
    async: false,
    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(notValue, "notValue");
// @__NO_SIDE_EFFECTS__
function notValues(requirement, message$1) {
  return {
    kind: "validation",
    type: "not_values",
    reference: notValues,
    async: false,
    expects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(notValues, "notValues");
// @__NO_SIDE_EFFECTS__
function notWords(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "not_words",
    reference: notWords,
    async: false,
    expects: `!${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count === this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(notWords, "notWords");
// @__NO_SIDE_EFFECTS__
function octal(message$1) {
  return {
    kind: "validation",
    type: "octal",
    reference: octal,
    async: false,
    expects: null,
    requirement: OCTAL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "octal", dataset, config$1);
      return dataset;
    }
  };
}
__name(octal, "octal");
// @__NO_SIDE_EFFECTS__
function parseJson(config$1, message$1) {
  return {
    kind: "transformation",
    type: "parse_json",
    reference: parseJson,
    config: config$1,
    message: message$1,
    async: false,
    "~run"(dataset, config$2) {
      try {
        dataset.value = JSON.parse(dataset.value, this.config?.reviver);
      } catch (error3) {
        if (error3 instanceof Error) {
          _addIssue(this, "JSON", dataset, config$2, { received: `"${error3.message}"` });
          dataset.typed = false;
        } else throw error3;
      }
      return dataset;
    }
  };
}
__name(parseJson, "parseJson");
// @__NO_SIDE_EFFECTS__
function _isPartiallyTyped(dataset, paths) {
  if (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {
    let typed = false;
    const bound3 = Math.min(path.length, issue.path?.length ?? 0);
    for (let index2 = 0; index2 < bound3; index2++) if (path[index2] !== issue.path[index2].key && (path[index2] !== "$" || issue.path[index2].type !== "array")) {
      typed = true;
      break;
    }
    if (!typed) return false;
  }
  return true;
}
__name(_isPartiallyTyped, "_isPartiallyTyped");
// @__NO_SIDE_EFFECTS__
function partialCheck(paths, requirement, message$1) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheck,
    async: false,
    expects: null,
    paths,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(partialCheck, "partialCheck");
// @__NO_SIDE_EFFECTS__
function partialCheckAsync(paths, requirement, message$1) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheckAsync,
    async: true,
    expects: null,
    paths,
    requirement,
    message: message$1,
    async "~run"(dataset, config$1) {
      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
      return dataset;
    }
  };
}
__name(partialCheckAsync, "partialCheckAsync");
// @__NO_SIDE_EFFECTS__
function rawCheck(action2) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheck,
    async: false,
    expects: null,
    "~run"(dataset, config$1) {
      action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue")
      });
      return dataset;
    }
  };
}
__name(rawCheck, "rawCheck");
// @__NO_SIDE_EFFECTS__
function rawCheckAsync(action2) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheckAsync,
    async: true,
    expects: null,
    async "~run"(dataset, config$1) {
      await action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue")
      });
      return dataset;
    }
  };
}
__name(rawCheckAsync, "rawCheckAsync");
// @__NO_SIDE_EFFECTS__
function rawTransform(action2) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransform,
    async: false,
    "~run"(dataset, config$1) {
      const output2 = action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue"),
        NEVER: null
      });
      if (dataset.issues) dataset.typed = false;
      else dataset.value = output2;
      return dataset;
    }
  };
}
__name(rawTransform, "rawTransform");
// @__NO_SIDE_EFFECTS__
function rawTransformAsync(action2) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransformAsync,
    async: true,
    async "~run"(dataset, config$1) {
      const output2 = await action2({
        dataset,
        config: config$1,
        addIssue: /* @__PURE__ */ __name((info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info), "addIssue"),
        NEVER: null
      });
      if (dataset.issues) dataset.typed = false;
      else dataset.value = output2;
      return dataset;
    }
  };
}
__name(rawTransformAsync, "rawTransformAsync");
// @__NO_SIDE_EFFECTS__
function readonly$1() {
  return {
    kind: "transformation",
    type: "readonly",
    reference: readonly$1,
    async: false,
    "~run"(dataset) {
      return dataset;
    }
  };
}
__name(readonly$1, "readonly$1");
// @__NO_SIDE_EFFECTS__
function reduceItems(operation, initial) {
  return {
    kind: "transformation",
    type: "reduce_items",
    reference: reduceItems,
    async: false,
    operation,
    initial,
    "~run"(dataset) {
      dataset.value = dataset.value.reduce(this.operation, this.initial);
      return dataset;
    }
  };
}
__name(reduceItems, "reduceItems");
// @__NO_SIDE_EFFECTS__
function regex(requirement, message$1) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
      return dataset;
    }
  };
}
__name(regex, "regex");
// @__NO_SIDE_EFFECTS__
function returns(schema) {
  return {
    kind: "transformation",
    type: "returns",
    reference: returns,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = (...args_) => {
        const returnsDataset = this.schema["~run"]({ value: func(...args_) }, config$1);
        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
        return returnsDataset.value;
      };
      return dataset;
    }
  };
}
__name(returns, "returns");
// @__NO_SIDE_EFFECTS__
function returnsAsync(schema) {
  return {
    kind: "transformation",
    type: "returns",
    reference: returnsAsync,
    async: false,
    schema,
    "~run"(dataset, config$1) {
      const func = dataset.value;
      dataset.value = async (...args_) => {
        const returnsDataset = await this.schema["~run"]({ value: await func(...args_) }, config$1);
        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
        return returnsDataset.value;
      };
      return dataset;
    }
  };
}
__name(returnsAsync, "returnsAsync");
// @__NO_SIDE_EFFECTS__
function rfcEmail(message$1) {
  return {
    kind: "validation",
    type: "rfc_email",
    reference: rfcEmail,
    expects: null,
    async: false,
    requirement: RFC_EMAIL_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
      return dataset;
    }
  };
}
__name(rfcEmail, "rfcEmail");
// @__NO_SIDE_EFFECTS__
function safeInteger(message$1) {
  return {
    kind: "validation",
    type: "safe_integer",
    reference: safeInteger,
    async: false,
    expects: null,
    requirement: Number.isSafeInteger,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "safe integer", dataset, config$1);
      return dataset;
    }
  };
}
__name(safeInteger, "safeInteger");
// @__NO_SIDE_EFFECTS__
function size(requirement, message$1) {
  return {
    kind: "validation",
    type: "size",
    reference: size,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
      return dataset;
    }
  };
}
__name(size, "size");
// @__NO_SIDE_EFFECTS__
function slug(message$1) {
  return {
    kind: "validation",
    type: "slug",
    reference: slug,
    async: false,
    expects: null,
    requirement: SLUG_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "slug", dataset, config$1);
      return dataset;
    }
  };
}
__name(slug, "slug");
// @__NO_SIDE_EFFECTS__
function someItem(requirement, message$1) {
  return {
    kind: "validation",
    type: "some_item",
    reference: someItem,
    async: false,
    expects: null,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, "item", dataset, config$1);
      return dataset;
    }
  };
}
__name(someItem, "someItem");
// @__NO_SIDE_EFFECTS__
function sortItems(operation) {
  return {
    kind: "transformation",
    type: "sort_items",
    reference: sortItems,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = dataset.value.sort(this.operation);
      return dataset;
    }
  };
}
__name(sortItems, "sortItems");
// @__NO_SIDE_EFFECTS__
function startsWith(requirement, message$1) {
  return {
    kind: "validation",
    type: "starts_with",
    reference: startsWith,
    async: false,
    expects: `"${requirement}"`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, "start", dataset, config$1, { received: `"${dataset.value.slice(0, this.requirement.length)}"` });
      return dataset;
    }
  };
}
__name(startsWith, "startsWith");
// @__NO_SIDE_EFFECTS__
function stringifyJson(config$1, message$1) {
  return {
    kind: "transformation",
    type: "stringify_json",
    reference: stringifyJson,
    message: message$1,
    config: config$1,
    async: false,
    "~run"(dataset, config$2) {
      try {
        const output2 = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);
        if (output2 === void 0) {
          _addIssue(this, "JSON", dataset, config$2);
          dataset.typed = false;
        }
        dataset.value = output2;
      } catch (error3) {
        if (error3 instanceof Error) {
          _addIssue(this, "JSON", dataset, config$2, { received: `"${error3.message}"` });
          dataset.typed = false;
        } else throw error3;
      }
      return dataset;
    }
  };
}
__name(stringifyJson, "stringifyJson");
// @__NO_SIDE_EFFECTS__
function title(title_) {
  return {
    kind: "metadata",
    type: "title",
    reference: title,
    title: title_
  };
}
__name(title, "title");
// @__NO_SIDE_EFFECTS__
function toBigint(message$1) {
  return {
    kind: "transformation",
    type: "to_bigint",
    reference: toBigint,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = BigInt(dataset.value);
      } catch {
        _addIssue(this, "bigint", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toBigint, "toBigint");
// @__NO_SIDE_EFFECTS__
function toBoolean() {
  return {
    kind: "transformation",
    type: "to_boolean",
    reference: toBoolean,
    async: false,
    "~run"(dataset) {
      dataset.value = Boolean(dataset.value);
      return dataset;
    }
  };
}
__name(toBoolean, "toBoolean");
// @__NO_SIDE_EFFECTS__
function toDate(message$1) {
  return {
    kind: "transformation",
    type: "to_date",
    reference: toDate,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = new Date(dataset.value);
        if (isNaN(dataset.value)) {
          _addIssue(this, "date", dataset, config$1, { received: '"Invalid Date"' });
          dataset.typed = false;
        }
      } catch {
        _addIssue(this, "date", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toDate, "toDate");
// @__NO_SIDE_EFFECTS__
function toLowerCase() {
  return {
    kind: "transformation",
    type: "to_lower_case",
    reference: toLowerCase,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.toLowerCase();
      return dataset;
    }
  };
}
__name(toLowerCase, "toLowerCase");
// @__NO_SIDE_EFFECTS__
function toMaxValue(requirement) {
  return {
    kind: "transformation",
    type: "to_max_value",
    reference: toMaxValue,
    async: false,
    requirement,
    "~run"(dataset) {
      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}
__name(toMaxValue, "toMaxValue");
// @__NO_SIDE_EFFECTS__
function toMinValue(requirement) {
  return {
    kind: "transformation",
    type: "to_min_value",
    reference: toMinValue,
    async: false,
    requirement,
    "~run"(dataset) {
      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}
__name(toMinValue, "toMinValue");
// @__NO_SIDE_EFFECTS__
function toNumber(message$1) {
  return {
    kind: "transformation",
    type: "to_number",
    reference: toNumber,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = Number(dataset.value);
        if (isNaN(dataset.value)) {
          _addIssue(this, "number", dataset, config$1);
          dataset.typed = false;
        }
      } catch {
        _addIssue(this, "number", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toNumber, "toNumber");
// @__NO_SIDE_EFFECTS__
function toString$1(message$1) {
  return {
    kind: "transformation",
    type: "to_string",
    reference: toString$1,
    async: false,
    message: message$1,
    "~run"(dataset, config$1) {
      try {
        dataset.value = String(dataset.value);
      } catch {
        _addIssue(this, "string", dataset, config$1);
        dataset.typed = false;
      }
      return dataset;
    }
  };
}
__name(toString$1, "toString$1");
// @__NO_SIDE_EFFECTS__
function toUpperCase() {
  return {
    kind: "transformation",
    type: "to_upper_case",
    reference: toUpperCase,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.toUpperCase();
      return dataset;
    }
  };
}
__name(toUpperCase, "toUpperCase");
// @__NO_SIDE_EFFECTS__
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    "~run"(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
__name(transform, "transform");
// @__NO_SIDE_EFFECTS__
function transformAsync(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transformAsync,
    async: true,
    operation,
    async "~run"(dataset) {
      dataset.value = await this.operation(dataset.value);
      return dataset;
    }
  };
}
__name(transformAsync, "transformAsync");
// @__NO_SIDE_EFFECTS__
function trim() {
  return {
    kind: "transformation",
    type: "trim",
    reference: trim,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trim();
      return dataset;
    }
  };
}
__name(trim, "trim");
// @__NO_SIDE_EFFECTS__
function trimEnd() {
  return {
    kind: "transformation",
    type: "trim_end",
    reference: trimEnd,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trimEnd();
      return dataset;
    }
  };
}
__name(trimEnd, "trimEnd");
// @__NO_SIDE_EFFECTS__
function trimStart() {
  return {
    kind: "transformation",
    type: "trim_start",
    reference: trimStart,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trimStart();
      return dataset;
    }
  };
}
__name(trimStart, "trimStart");
// @__NO_SIDE_EFFECTS__
function ulid(message$1) {
  return {
    kind: "validation",
    type: "ulid",
    reference: ulid,
    async: false,
    expects: null,
    requirement: ULID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "ULID", dataset, config$1);
      return dataset;
    }
  };
}
__name(ulid, "ulid");
// @__NO_SIDE_EFFECTS__
function url(message$1) {
  return {
    kind: "validation",
    type: "url",
    reference: url,
    async: false,
    expects: null,
    requirement(input) {
      try {
        new URL(input);
        return true;
      } catch {
        return false;
      }
    },
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "URL", dataset, config$1);
      return dataset;
    }
  };
}
__name(url, "url");
// @__NO_SIDE_EFFECTS__
function uuid$1(message$1) {
  return {
    kind: "validation",
    type: "uuid",
    reference: uuid$1,
    async: false,
    expects: null,
    requirement: UUID_REGEX,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
      return dataset;
    }
  };
}
__name(uuid$1, "uuid$1");
// @__NO_SIDE_EFFECTS__
function value(requirement, message$1) {
  return {
    kind: "validation",
    type: "value",
    reference: value,
    async: false,
    expects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(value, "value");
// @__NO_SIDE_EFFECTS__
function values(requirement, message$1) {
  return {
    kind: "validation",
    type: "values",
    reference: values,
    async: false,
    expects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
      return dataset;
    }
  };
}
__name(values, "values");
// @__NO_SIDE_EFFECTS__
function words(locales, requirement, message$1) {
  return {
    kind: "validation",
    type: "words",
    reference: words,
    async: false,
    expects: `${requirement}`,
    locales,
    requirement,
    message: message$1,
    "~run"(dataset, config$1) {
      if (dataset.typed) {
        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
        if (count !== this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
      }
      return dataset;
    }
  };
}
__name(words, "words");
function assert(schema, input) {
  const issues = schema["~run"]({ value: input }, { abortEarly: true }).issues;
  if (issues) throw new ValiError(issues);
}
__name(assert, "assert");
// @__NO_SIDE_EFFECTS__
function config(schema, config$1) {
  return {
    ...schema,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config_) {
      return schema["~run"](dataset, {
        ...config_,
        ...config$1
      });
    }
  };
}
__name(config, "config");
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config$1) {
  return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
}
__name(getFallback, "getFallback");
// @__NO_SIDE_EFFECTS__
function fallback$1(schema, fallback$12) {
  return {
    ...schema,
    fallback: fallback$12,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const outputDataset = schema["~run"](dataset, config$1);
      return outputDataset.issues ? {
        typed: true,
        value: /* @__PURE__ */ getFallback(this, outputDataset, config$1)
      } : outputDataset;
    }
  };
}
__name(fallback$1, "fallback$1");
// @__NO_SIDE_EFFECTS__
function fallbackAsync(schema, fallback$12) {
  return {
    ...schema,
    fallback: fallback$12,
    async: true,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const outputDataset = await schema["~run"](dataset, config$1);
      return outputDataset.issues ? {
        typed: true,
        value: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)
      } : outputDataset;
    }
  };
}
__name(fallbackAsync, "fallbackAsync");
// @__NO_SIDE_EFFECTS__
function flatten$1(issues) {
  const flatErrors = {};
  for (const issue of issues) if (issue.path) {
    const dotPath = /* @__PURE__ */ getDotPath(issue);
    if (dotPath) {
      if (!flatErrors.nested) flatErrors.nested = {};
      if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);
      else flatErrors.nested[dotPath] = [issue.message];
    } else if (flatErrors.other) flatErrors.other.push(issue.message);
    else flatErrors.other = [issue.message];
  } else if (flatErrors.root) flatErrors.root.push(issue.message);
  else flatErrors.root = [issue.message];
  return flatErrors;
}
__name(flatten$1, "flatten$1");
// @__NO_SIDE_EFFECTS__
function forward(action2, path) {
  return {
    ...action2,
    "~run"(dataset, config$1) {
      const prevIssues = dataset.issues && [...dataset.issues];
      dataset = action2["~run"](dataset, config$1);
      if (dataset.issues) {
        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
          let pathInput = dataset.value;
          for (const key2 of path) {
            const pathValue = pathInput[key2];
            const pathItem = {
              type: "unknown",
              origin: "value",
              input: pathInput,
              key: key2,
              value: pathValue
            };
            if (issue.path) issue.path.push(pathItem);
            else issue.path = [pathItem];
            if (!pathValue) break;
            pathInput = pathValue;
          }
        }
      }
      return dataset;
    }
  };
}
__name(forward, "forward");
// @__NO_SIDE_EFFECTS__
function forwardAsync(action2, path) {
  return {
    ...action2,
    async: true,
    async "~run"(dataset, config$1) {
      const prevIssues = dataset.issues && [...dataset.issues];
      dataset = await action2["~run"](dataset, config$1);
      if (dataset.issues) {
        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
          let pathInput = dataset.value;
          for (const key2 of path) {
            const pathValue = pathInput[key2];
            const pathItem = {
              type: "unknown",
              origin: "value",
              input: pathInput,
              key: key2,
              value: pathValue
            };
            if (issue.path) issue.path.push(pathItem);
            else issue.path = [pathItem];
            if (!pathValue) break;
            pathInput = pathValue;
          }
        }
      }
      return dataset;
    }
  };
}
__name(forwardAsync, "forwardAsync");
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config$1) {
  return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
}
__name(getDefault, "getDefault");
// @__NO_SIDE_EFFECTS__
function getDefaults(schema) {
  if ("entries" in schema) {
    const object$12 = {};
    for (const key2 in schema.entries) object$12[key2] = /* @__PURE__ */ getDefaults(schema.entries[key2]);
    return object$12;
  }
  if ("items" in schema) return schema.items.map(getDefaults);
  return /* @__PURE__ */ getDefault(schema);
}
__name(getDefaults, "getDefaults");
// @__NO_SIDE_EFFECTS__
async function getDefaultsAsync(schema) {
  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key2, value$1]) => [key2, await /* @__PURE__ */ getDefaultsAsync(value$1)])));
  if ("items" in schema) return Promise.all(schema.items.map(getDefaultsAsync));
  return /* @__PURE__ */ getDefault(schema);
}
__name(getDefaultsAsync, "getDefaultsAsync");
// @__NO_SIDE_EFFECTS__
function getDescription(schema) {
  return /* @__PURE__ */ _getLastMetadata(schema, "description");
}
__name(getDescription, "getDescription");
// @__NO_SIDE_EFFECTS__
function getExamples(schema) {
  const examples$1 = [];
  function depthFirstCollect(schema$1) {
    if ("pipe" in schema$1) {
      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstCollect(item);
      else if (item.kind === "metadata" && item.type === "examples") examples$1.push(...item.examples);
    }
  }
  __name(depthFirstCollect, "depthFirstCollect");
  depthFirstCollect(schema);
  return examples$1;
}
__name(getExamples, "getExamples");
// @__NO_SIDE_EFFECTS__
function getFallbacks(schema) {
  if ("entries" in schema) {
    const object$12 = {};
    for (const key2 in schema.entries) object$12[key2] = /* @__PURE__ */ getFallbacks(schema.entries[key2]);
    return object$12;
  }
  if ("items" in schema) return schema.items.map(getFallbacks);
  return /* @__PURE__ */ getFallback(schema);
}
__name(getFallbacks, "getFallbacks");
// @__NO_SIDE_EFFECTS__
async function getFallbacksAsync(schema) {
  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key2, value$1]) => [key2, await /* @__PURE__ */ getFallbacksAsync(value$1)])));
  if ("items" in schema) return Promise.all(schema.items.map(getFallbacksAsync));
  return /* @__PURE__ */ getFallback(schema);
}
__name(getFallbacksAsync, "getFallbacksAsync");
// @__NO_SIDE_EFFECTS__
function getMetadata(schema) {
  const result = {};
  function depthFirstMerge(schema$1) {
    if ("pipe" in schema$1) {
      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstMerge(item);
      else if (item.kind === "metadata" && item.type === "metadata") Object.assign(result, item.metadata);
    }
  }
  __name(depthFirstMerge, "depthFirstMerge");
  depthFirstMerge(schema);
  return result;
}
__name(getMetadata, "getMetadata");
// @__NO_SIDE_EFFECTS__
function getTitle(schema) {
  return /* @__PURE__ */ _getLastMetadata(schema, "title");
}
__name(getTitle, "getTitle");
// @__NO_SIDE_EFFECTS__
function is$1(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
__name(is$1, "is$1");
// @__NO_SIDE_EFFECTS__
function any() {
  return {
    kind: "schema",
    type: "any",
    reference: any,
    expects: "any",
    async: false,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
__name(any, "any");
// @__NO_SIDE_EFFECTS__
function array$1(item, message$1) {
  return {
    kind: "schema",
    type: "array",
    reference: array$1,
    expects: "Array",
    async: false,
    item,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < input.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(array$1, "array$1");
// @__NO_SIDE_EFFECTS__
function arrayAsync(item, message$1) {
  return {
    kind: "schema",
    type: "array",
    reference: arrayAsync,
    expects: "Array",
    async: true,
    item,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(input.map((value$1) => this.item["~run"]({ value: value$1 }, config$1)));
        for (let key2 = 0; key2 < itemDatasets.length; key2++) {
          const itemDataset = itemDatasets[key2];
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: input[key2]
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(arrayAsync, "arrayAsync");
// @__NO_SIDE_EFFECTS__
function bigint(message$1) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "bigint") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(bigint, "bigint");
// @__NO_SIDE_EFFECTS__
function blob(message$1) {
  return {
    kind: "schema",
    type: "blob",
    reference: blob,
    expects: "Blob",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Blob) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(blob, "blob");
// @__NO_SIDE_EFFECTS__
function boolean(message$1) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "boolean") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(boolean, "boolean");
// @__NO_SIDE_EFFECTS__
function custom(check$1, message$1) {
  return {
    kind: "schema",
    type: "custom",
    reference: custom,
    expects: "unknown",
    async: false,
    check: check$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.check(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(custom, "custom");
// @__NO_SIDE_EFFECTS__
function customAsync(check$1, message$1) {
  return {
    kind: "schema",
    type: "custom",
    reference: customAsync,
    expects: "unknown",
    async: true,
    check: check$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (await this.check(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(customAsync, "customAsync");
// @__NO_SIDE_EFFECTS__
function date(message$1) {
  return {
    kind: "schema",
    type: "date",
    reference: date,
    expects: "Date",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1, { received: '"Invalid Date"' });
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(date, "date");
// @__NO_SIDE_EFFECTS__
function enum_(enum__, message$1) {
  const options2 = [];
  for (const key2 in enum__) if (`${+key2}` !== key2 || typeof enum__[key2] !== "string" || !Object.is(enum__[enum__[key2]], +key2)) options2.push(enum__[key2]);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: /* @__PURE__ */ _joinExpects(options2.map(_stringify), "|"),
    async: false,
    enum: enum__,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.includes(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(enum_, "enum_");
// @__NO_SIDE_EFFECTS__
function exactOptional(wrapped, default_) {
  return {
    kind: "schema",
    type: "exact_optional",
    reference: exactOptional,
    expects: wrapped.expects,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(exactOptional, "exactOptional");
// @__NO_SIDE_EFFECTS__
function exactOptionalAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "exact_optional",
    reference: exactOptionalAsync,
    expects: wrapped.expects,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(exactOptionalAsync, "exactOptionalAsync");
// @__NO_SIDE_EFFECTS__
function file(message$1) {
  return {
    kind: "schema",
    type: "file",
    reference: file,
    expects: "File",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof File) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(file, "file");
// @__NO_SIDE_EFFECTS__
function function_(message$1) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "function") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(function_, "function_");
// @__NO_SIDE_EFFECTS__
function instance(class_, message$1) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance,
    expects: class_.name,
    async: false,
    class: class_,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof this.class) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(instance, "instance");
// @__NO_SIDE_EFFECTS__
function _merge(value1, value2) {
  if (typeof value1 === typeof value2) {
    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };
    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
      for (const key2 in value2) if (key2 in value1) {
        const dataset = /* @__PURE__ */ _merge(value1[key2], value2[key2]);
        if (dataset.issue) return dataset;
        value1[key2] = dataset.value;
      } else value1[key2] = value2[key2];
      return { value: value1 };
    }
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (value1.length === value2.length) {
        for (let index2 = 0; index2 < value1.length; index2++) {
          const dataset = /* @__PURE__ */ _merge(value1[index2], value2[index2]);
          if (dataset.issue) return dataset;
          value1[index2] = dataset.value;
        }
        return { value: value1 };
      }
    }
  }
  return { issue: true };
}
__name(_merge, "_merge");
// @__NO_SIDE_EFFECTS__
function intersect(options2, message$1) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersect,
    expects: /* @__PURE__ */ _joinExpects(options2.map((option) => option.expects), "&"),
    async: false,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.length) {
        const input = dataset.value;
        let outputs;
        dataset.typed = true;
        for (const schema of this.options) {
          const optionDataset = schema["~run"]({ value: input }, config$1);
          if (optionDataset.issues) {
            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
            else dataset.issues = optionDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!optionDataset.typed) dataset.typed = false;
          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
          else outputs = [optionDataset.value];
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (let index2 = 1; index2 < outputs.length; index2++) {
            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index2]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(intersect, "intersect");
// @__NO_SIDE_EFFECTS__
function intersectAsync(options2, message$1) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersectAsync,
    expects: /* @__PURE__ */ _joinExpects(options2.map((option) => option.expects), "&"),
    async: true,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (this.options.length) {
        const input = dataset.value;
        let outputs;
        dataset.typed = true;
        const optionDatasets = await Promise.all(this.options.map((schema) => schema["~run"]({ value: input }, config$1)));
        for (const optionDataset of optionDatasets) {
          if (optionDataset.issues) {
            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
            else dataset.issues = optionDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!optionDataset.typed) dataset.typed = false;
          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
          else outputs = [optionDataset.value];
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (let index2 = 1; index2 < outputs.length; index2++) {
            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index2]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(intersectAsync, "intersectAsync");
// @__NO_SIDE_EFFECTS__
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return this.getter(dataset.value)["~run"](dataset, config$1);
    }
  };
}
__name(lazy, "lazy");
// @__NO_SIDE_EFFECTS__
function lazyAsync(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazyAsync,
    expects: "unknown",
    async: true,
    getter,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      return (await this.getter(dataset.value))["~run"](dataset, config$1);
    }
  };
}
__name(lazyAsync, "lazyAsync");
// @__NO_SIDE_EFFECTS__
function literal(literal_, message$1) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: /* @__PURE__ */ _stringify(literal_),
    async: false,
    literal: literal_,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === this.literal) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(literal, "literal");
// @__NO_SIDE_EFFECTS__
function looseObject(entries$1, message$1) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) dataset.value[key2] = input[key2];
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseObject, "looseObject");
// @__NO_SIDE_EFFECTS__
function looseObjectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObjectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) dataset.value[key2] = input[key2];
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseObjectAsync, "looseObjectAsync");
// @__NO_SIDE_EFFECTS__
function looseTuple(items, message$1) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) dataset.value.push(input[key2]);
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseTuple, "looseTuple");
// @__NO_SIDE_EFFECTS__
function looseTupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) dataset.value.push(input[key2]);
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(looseTupleAsync, "looseTupleAsync");
// @__NO_SIDE_EFFECTS__
function map(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "map",
    reference: map,
    expects: "Map",
    async: false,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Map();
        for (const [inputKey, inputValue] of input) {
          const keyDataset = this.key["~run"]({ value: inputKey }, config$1);
          if (keyDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "key",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "value",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          dataset.value.set(keyDataset.value, valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(map, "map");
// @__NO_SIDE_EFFECTS__
function mapAsync(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "map",
    reference: mapAsync,
    expects: "Map",
    async: true,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Map();
        const datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([
          inputKey,
          inputValue,
          this.key["~run"]({ value: inputKey }, config$1),
          this.value["~run"]({ value: inputValue }, config$1)
        ])));
        for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {
          if (keyDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "key",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (valueDataset.issues) {
            const pathItem = {
              type: "map",
              origin: "value",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          dataset.value.set(keyDataset.value, valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(mapAsync, "mapAsync");
// @__NO_SIDE_EFFECTS__
function nan(message$1) {
  return {
    kind: "schema",
    type: "nan",
    reference: nan,
    expects: "NaN",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (Number.isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nan, "nan");
// @__NO_SIDE_EFFECTS__
function never(message$1) {
  return {
    kind: "schema",
    type: "never",
    reference: never,
    expects: "never",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(never, "never");
// @__NO_SIDE_EFFECTS__
function nonNullable(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullable,
    expects: "!null",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value !== null) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullable, "nonNullable");
// @__NO_SIDE_EFFECTS__
function nonNullableAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullableAsync,
    expects: "!null",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value !== null) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullableAsync, "nonNullableAsync");
// @__NO_SIDE_EFFECTS__
function nonNullish(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullish,
    expects: "(!null & !undefined)",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullish, "nonNullish");
// @__NO_SIDE_EFFECTS__
function nonNullishAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullishAsync,
    expects: "(!null & !undefined)",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonNullishAsync, "nonNullishAsync");
// @__NO_SIDE_EFFECTS__
function nonOptional(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: false,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value !== void 0) dataset = this.wrapped["~run"](dataset, config$1);
      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonOptional, "nonOptional");
// @__NO_SIDE_EFFECTS__
function nonOptionalAsync(wrapped, message$1) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptionalAsync,
    expects: "!undefined",
    async: true,
    wrapped,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value !== void 0) dataset = await this.wrapped["~run"](dataset, config$1);
      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(nonOptionalAsync, "nonOptionalAsync");
// @__NO_SIDE_EFFECTS__
function null_(message$1) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(null_, "null_");
// @__NO_SIDE_EFFECTS__
function nullable(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `(${wrapped.expects} | null)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullable, "nullable");
// @__NO_SIDE_EFFECTS__
function nullableAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullable",
    reference: nullableAsync,
    expects: `(${wrapped.expects} | null)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === null) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullableAsync, "nullableAsync");
// @__NO_SIDE_EFFECTS__
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullish, "nullish");
// @__NO_SIDE_EFFECTS__
function nullishAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullishAsync,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(nullishAsync, "nullishAsync");
// @__NO_SIDE_EFFECTS__
function number(message$1) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(number, "number");
// @__NO_SIDE_EFFECTS__
function object$1(entries$1, message$1) {
  return {
    kind: "schema",
    type: "object",
    reference: object$1,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(object$1, "object$1");
// @__NO_SIDE_EFFECTS__
function objectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "object",
    reference: objectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectAsync, "objectAsync");
// @__NO_SIDE_EFFECTS__
function objectWithRest(entries$1, rest, message$1) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRest,
    expects: "Object",
    async: false,
    entries: entries$1,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (/* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)) {
            const valueDataset = this.rest["~run"]({ value: input[key2] }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: input[key2]
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectWithRest, "objectWithRest");
// @__NO_SIDE_EFFECTS__
function objectWithRestAsync(entries$1, rest, message$1) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRestAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        })), Promise.all(Object.entries(input).filter(([key2]) => /* @__PURE__ */ _isValidObjectKey(input, key2) && !(key2 in this.entries)).map(async ([key2, value$1]) => [
          key2,
          value$1,
          await this.rest["~run"]({ value: value$1 }, config$1)
        ]))]);
        for (const [key2, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) for (const [key2, value$1, valueDataset] of restDatasets) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(objectWithRestAsync, "objectWithRestAsync");
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(optional, "optional");
// @__NO_SIDE_EFFECTS__
function optionalAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optionalAsync,
    expects: `(${wrapped.expects} | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(optionalAsync, "optionalAsync");
// @__NO_SIDE_EFFECTS__
function picklist(options2, message$1) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: /* @__PURE__ */ _joinExpects(options2.map(_stringify), "|"),
    async: false,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (this.options.includes(dataset.value)) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(picklist, "picklist");
// @__NO_SIDE_EFFECTS__
function promise$1(message$1) {
  return {
    kind: "schema",
    type: "promise",
    reference: promise$1,
    expects: "Promise",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value instanceof Promise) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(promise$1, "promise$1");
// @__NO_SIDE_EFFECTS__
function record(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {
          const entryValue = input[entryKey];
          const keyDataset = this.key["~run"]({ value: entryKey }, config$1);
          if (keyDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "key",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of keyDataset.issues) {
              issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          const valueDataset = this.value["~run"]({ value: entryValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(record, "record");
// @__NO_SIDE_EFFECTS__
function recordAsync(key2, value$1, message$1) {
  return {
    kind: "schema",
    type: "record",
    reference: recordAsync,
    expects: "Object",
    async: true,
    key: key2,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([
          entryKey,
          entryValue,
          this.key["~run"]({ value: entryKey }, config$1),
          this.value["~run"]({ value: entryValue }, config$1)
        ])));
        for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {
          if (keyDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "key",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of keyDataset.issues) {
              issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = keyDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: entryKey,
              value: entryValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(recordAsync, "recordAsync");
// @__NO_SIDE_EFFECTS__
function set$2(value$1, message$1) {
  return {
    kind: "schema",
    type: "set",
    reference: set$2,
    expects: "Set",
    async: false,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Set();
        for (const inputValue of input) {
          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
          if (valueDataset.issues) {
            const pathItem = {
              type: "set",
              origin: "value",
              input,
              key: null,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value.add(valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(set$2, "set$2");
// @__NO_SIDE_EFFECTS__
function setAsync(value$1, message$1) {
  return {
    kind: "schema",
    type: "set",
    reference: setAsync,
    expects: "Set",
    async: true,
    value: value$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */ new Set();
        const valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value["~run"]({ value: inputValue }, config$1)]));
        for (const [inputValue, valueDataset] of valueDatasets) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "set",
              origin: "value",
              input,
              key: null,
              value: inputValue
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value.add(valueDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(setAsync, "setAsync");
// @__NO_SIDE_EFFECTS__
function strictObject(entries$1, message$1) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObject,
    expects: "Object",
    async: false,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const valueSchema = this.entries[key2];
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: key2,
                value: value$1
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) issue.path.unshift(pathItem);
                else issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) dataset.issues = valueDataset.issues;
              if (config$1.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) dataset.typed = false;
            dataset.value[key2] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) dataset.value[key2] = /* @__PURE__ */ getFallback(valueSchema);
          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config$1, {
              input: void 0,
              expected: `"${key2}"`,
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            if (config$1.abortEarly) break;
          }
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (!(key2 in this.entries)) {
            _addIssue(this, "key", dataset, config$1, {
              input: key2,
              expected: "never",
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictObject, "strictObject");
// @__NO_SIDE_EFFECTS__
function strictObjectAsync(entries$1, message$1) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObjectAsync,
    expects: "Object",
    async: true,
    entries: entries$1,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key2, valueSchema]) => {
          if (key2 in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
            const value$1 = key2 in input ? input[key2] : await /* @__PURE__ */ getDefault(valueSchema);
            return [
              key2,
              value$1,
              valueSchema,
              await valueSchema["~run"]({ value: value$1 }, config$1)
            ];
          }
          return [
            key2,
            input[key2],
            valueSchema,
            null
          ];
        }));
        for (const [key2, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = valueDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) dataset.typed = false;
          dataset.value[key2] = valueDataset.value;
        } else if (valueSchema.fallback !== void 0) dataset.value[key2] = await /* @__PURE__ */ getFallback(valueSchema);
        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
          _addIssue(this, "key", dataset, config$1, {
            input: void 0,
            expected: `"${key2}"`,
            path: [{
              type: "object",
              origin: "key",
              input,
              key: key2,
              value: value$1
            }]
          });
          if (config$1.abortEarly) break;
        }
        if (!dataset.issues || !config$1.abortEarly) {
          for (const key2 in input) if (!(key2 in this.entries)) {
            _addIssue(this, "key", dataset, config$1, {
              input: key2,
              expected: "never",
              path: [{
                type: "object",
                origin: "key",
                input,
                key: key2,
                value: input[key2]
              }]
            });
            break;
          }
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictObjectAsync, "strictObjectAsync");
// @__NO_SIDE_EFFECTS__
function strictTuple(items, message$1) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
          input: input[this.items.length],
          expected: "never",
          path: [{
            type: "array",
            origin: "value",
            input,
            key: this.items.length,
            value: input[this.items.length]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictTuple, "strictTuple");
// @__NO_SIDE_EFFECTS__
function strictTupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
          input: input[this.items.length],
          expected: "never",
          path: [{
            type: "array",
            origin: "value",
            input,
            key: this.items.length,
            value: input[this.items.length]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(strictTupleAsync, "strictTupleAsync");
// @__NO_SIDE_EFFECTS__
function string$1(message$1) {
  return {
    kind: "schema",
    type: "string",
    reference: string$1,
    expects: "string",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "string") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(string$1, "string$1");
// @__NO_SIDE_EFFECTS__
function symbol(message$1) {
  return {
    kind: "schema",
    type: "symbol",
    reference: symbol,
    expects: "symbol",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (typeof dataset.value === "symbol") dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(symbol, "symbol");
// @__NO_SIDE_EFFECTS__
function tuple(items, message$1) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tuple, "tuple");
// @__NO_SIDE_EFFECTS__
function tupleAsync(items, message$1) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tupleAsync,
    expects: "Array",
    async: true,
    items,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const itemDatasets = await Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        }));
        for (const [key2, value$1, itemDataset] of itemDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleAsync, "tupleAsync");
// @__NO_SIDE_EFFECTS__
function tupleWithRest(items, rest, message$1) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRest,
    expects: "Array",
    async: false,
    items,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.items[key2]["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (let key2 = this.items.length; key2 < input.length; key2++) {
          const value$1 = input[key2];
          const itemDataset = this.rest["~run"]({ value: value$1 }, config$1);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleWithRest, "tupleWithRest");
// @__NO_SIDE_EFFECTS__
function tupleWithRestAsync(items, rest, message$1) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRestAsync,
    expects: "Array",
    async: true,
    items,
    rest,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key2) => {
          const value$1 = input[key2];
          return [
            key2,
            value$1,
            await item["~run"]({ value: value$1 }, config$1)
          ];
        })), Promise.all(input.slice(this.items.length).map(async (value$1, key2) => {
          return [
            key2 + this.items.length,
            value$1,
            await this.rest["~run"]({ value: value$1 }, config$1)
          ];
        }))]);
        for (const [key2, value$1, itemDataset] of normalDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config$1.abortEarly) for (const [key2, value$1, itemDataset] of restDatasets) {
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value$1
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) issue.path.unshift(pathItem);
              else issue.path = [pathItem];
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) dataset.issues = itemDataset.issues;
            if (config$1.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) dataset.typed = false;
          dataset.value.push(itemDataset.value);
        }
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(tupleWithRestAsync, "tupleWithRestAsync");
// @__NO_SIDE_EFFECTS__
function undefined_(message$1) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(undefined_, "undefined_");
// @__NO_SIDE_EFFECTS__
function undefinedable(wrapped, default_) {
  return {
    kind: "schema",
    type: "undefinedable",
    reference: undefinedable,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(undefinedable, "undefinedable");
// @__NO_SIDE_EFFECTS__
function undefinedableAsync(wrapped, default_) {
  return {
    kind: "schema",
    type: "undefinedable",
    reference: undefinedableAsync,
    expects: `(${wrapped.expects} | undefined)`,
    async: true,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config$1);
    }
  };
}
__name(undefinedableAsync, "undefinedableAsync");
// @__NO_SIDE_EFFECTS__
function _subIssues(datasets) {
  let issues;
  if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
  else issues = dataset.issues;
  return issues;
}
__name(_subIssues, "_subIssues");
// @__NO_SIDE_EFFECTS__
function union(options2, message$1) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: /* @__PURE__ */ _joinExpects(options2.map((option) => option.expects), "|"),
    async: false,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
        else typedDatasets = [optionDataset];
        else {
          validDataset = optionDataset;
          break;
        }
        else if (untypedDatasets) untypedDatasets.push(optionDataset);
        else untypedDatasets = [optionDataset];
      }
      if (validDataset) return validDataset;
      if (typedDatasets) {
        if (typedDatasets.length === 1) return typedDatasets[0];
        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
      return dataset;
    }
  };
}
__name(union, "union");
// @__NO_SIDE_EFFECTS__
function unionAsync(options2, message$1) {
  return {
    kind: "schema",
    type: "union",
    reference: unionAsync,
    expects: /* @__PURE__ */ _joinExpects(options2.map((option) => option.expects), "|"),
    async: true,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = await schema["~run"]({ value: dataset.value }, config$1);
        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
        else typedDatasets = [optionDataset];
        else {
          validDataset = optionDataset;
          break;
        }
        else if (untypedDatasets) untypedDatasets.push(optionDataset);
        else untypedDatasets = [optionDataset];
      }
      if (validDataset) return validDataset;
      if (typedDatasets) {
        if (typedDatasets.length === 1) return typedDatasets[0];
        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
      return dataset;
    }
  };
}
__name(unionAsync, "unionAsync");
// @__NO_SIDE_EFFECTS__
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
__name(unknown, "unknown");
// @__NO_SIDE_EFFECTS__
function variant(key2, options2, message$1) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key: key2,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        let outputDataset;
        let maxDiscriminatorPriority = 0;
        let invalidDiscriminatorKey = this.key;
        let expectedDiscriminators = [];
        const parseOptions = /* @__PURE__ */ __name((variant$1, allKeys) => {
          for (const schema of variant$1.options) {
            if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
            else {
              let keysAreValid = true;
              let currentPriority = 0;
              for (const currentKey of allKeys) {
                const discriminatorSchema = schema.entries[currentKey];
                if (currentKey in input ? discriminatorSchema["~run"]({
                  typed: false,
                  value: input[currentKey]
                }, { abortEarly: true }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                  keysAreValid = false;
                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                    maxDiscriminatorPriority = currentPriority;
                    invalidDiscriminatorKey = currentKey;
                    expectedDiscriminators = [];
                  }
                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                  break;
                }
                currentPriority++;
              }
              if (keysAreValid) {
                const optionDataset = schema["~run"]({ value: input }, config$1);
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
              }
            }
            if (outputDataset && !outputDataset.issues) break;
          }
        }, "parseOptions");
        parseOptions(this, /* @__PURE__ */ new Set([this.key]));
        if (outputDataset) return outputDataset;
        _addIssue(this, "type", dataset, config$1, {
          input: input[invalidDiscriminatorKey],
          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
          path: [{
            type: "object",
            origin: "value",
            input,
            key: invalidDiscriminatorKey,
            value: input[invalidDiscriminatorKey]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(variant, "variant");
// @__NO_SIDE_EFFECTS__
function variantAsync(key2, options2, message$1) {
  return {
    kind: "schema",
    type: "variant",
    reference: variantAsync,
    expects: "Object",
    async: true,
    key: key2,
    options: options2,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        let outputDataset;
        let maxDiscriminatorPriority = 0;
        let invalidDiscriminatorKey = this.key;
        let expectedDiscriminators = [];
        const parseOptions = /* @__PURE__ */ __name(async (variant$1, allKeys) => {
          for (const schema of variant$1.options) {
            if (schema.type === "variant") await parseOptions(schema, new Set(allKeys).add(schema.key));
            else {
              let keysAreValid = true;
              let currentPriority = 0;
              for (const currentKey of allKeys) {
                const discriminatorSchema = schema.entries[currentKey];
                if (currentKey in input ? (await discriminatorSchema["~run"]({
                  typed: false,
                  value: input[currentKey]
                }, { abortEarly: true })).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                  keysAreValid = false;
                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                    maxDiscriminatorPriority = currentPriority;
                    invalidDiscriminatorKey = currentKey;
                    expectedDiscriminators = [];
                  }
                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                  break;
                }
                currentPriority++;
              }
              if (keysAreValid) {
                const optionDataset = await schema["~run"]({ value: input }, config$1);
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
              }
            }
            if (outputDataset && !outputDataset.issues) break;
          }
        }, "parseOptions");
        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));
        if (outputDataset) return outputDataset;
        _addIssue(this, "type", dataset, config$1, {
          input: input[invalidDiscriminatorKey],
          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
          path: [{
            type: "object",
            origin: "value",
            input,
            key: invalidDiscriminatorKey,
            value: input[invalidDiscriminatorKey]
          }]
        });
      } else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(variantAsync, "variantAsync");
// @__NO_SIDE_EFFECTS__
function void_(message$1) {
  return {
    kind: "schema",
    type: "void",
    reference: void_,
    expects: "void",
    async: false,
    message: message$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      if (dataset.value === void 0) dataset.typed = true;
      else _addIssue(this, "type", dataset, config$1);
      return dataset;
    }
  };
}
__name(void_, "void_");
// @__NO_SIDE_EFFECTS__
function keyof(schema, message$1) {
  return /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);
}
__name(keyof, "keyof");
// @__NO_SIDE_EFFECTS__
function message(schema, message_) {
  return {
    ...schema,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      return schema["~run"](dataset, {
        ...config$1,
        message: message_
      });
    }
  };
}
__name(message, "message");
// @__NO_SIDE_EFFECTS__
function omit(schema, keys) {
  const entries$1 = { ...schema.entries };
  for (const key2 of keys) delete entries$1[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(omit, "omit");
function parse$2(schema, input, config$1) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  if (dataset.issues) throw new ValiError(dataset.issues);
  return dataset.value;
}
__name(parse$2, "parse$2");
async function parseAsync(schema, input, config$1) {
  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  if (dataset.issues) throw new ValiError(dataset.issues);
  return dataset.value;
}
__name(parseAsync, "parseAsync");
// @__NO_SIDE_EFFECTS__
function parser(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => parse$2(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(parser, "parser");
// @__NO_SIDE_EFFECTS__
function parserAsync(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => parseAsync(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(parserAsync, "parserAsync");
// @__NO_SIDE_EFFECTS__
function partial(schema, keys) {
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ optional(schema.entries[key2]) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(partial, "partial");
// @__NO_SIDE_EFFECTS__
function partialAsync(schema, keys) {
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ optionalAsync(schema.entries[key2]) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(partialAsync, "partialAsync");
// @__NO_SIDE_EFFECTS__
function pick(schema, keys) {
  const entries$1 = {};
  for (const key2 of keys) entries$1[key2] = schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(pick, "pick");
// @__NO_SIDE_EFFECTS__
function pipe(...pipe$1) {
  return {
    ...pipe$1[0],
    pipe: pipe$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config$1) {
      for (const item of pipe$1) if (item.kind !== "metadata") {
        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
      }
      return dataset;
    }
  };
}
__name(pipe, "pipe");
// @__NO_SIDE_EFFECTS__
function pipeAsync(...pipe$1) {
  return {
    ...pipe$1[0],
    pipe: pipe$1,
    async: true,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    async "~run"(dataset, config$1) {
      for (const item of pipe$1) if (item.kind !== "metadata") {
        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item["~run"](dataset, config$1);
      }
      return dataset;
    }
  };
}
__name(pipeAsync, "pipeAsync");
// @__NO_SIDE_EFFECTS__
function required(schema, arg2, arg3) {
  const keys = Array.isArray(arg2) ? arg2 : void 0;
  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ nonOptional(schema.entries[key2], message$1) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(required, "required");
// @__NO_SIDE_EFFECTS__
function requiredAsync(schema, arg2, arg3) {
  const keys = Array.isArray(arg2) ? arg2 : void 0;
  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
  const entries$1 = {};
  for (const key2 in schema.entries) entries$1[key2] = !keys || keys.includes(key2) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key2], message$1) : schema.entries[key2];
  return {
    ...schema,
    entries: entries$1,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    }
  };
}
__name(requiredAsync, "requiredAsync");
// @__NO_SIDE_EFFECTS__
function safeParse(schema, input, config$1) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}
__name(safeParse, "safeParse");
// @__NO_SIDE_EFFECTS__
async function safeParseAsync(schema, input, config$1) {
  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}
__name(safeParseAsync, "safeParseAsync");
// @__NO_SIDE_EFFECTS__
function safeParser(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => /* @__PURE__ */ safeParse(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(safeParser, "safeParser");
// @__NO_SIDE_EFFECTS__
function safeParserAsync(schema, config$1) {
  const func = /* @__PURE__ */ __name((input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1), "func");
  func.schema = schema;
  func.config = config$1;
  return func;
}
__name(safeParserAsync, "safeParserAsync");
// @__NO_SIDE_EFFECTS__
function summarize(issues) {
  let summary = "";
  for (const issue of issues) {
    if (summary) summary += "\n";
    summary += `× ${issue.message}`;
    const dotPath = /* @__PURE__ */ getDotPath(issue);
    if (dotPath) summary += `
  → at ${dotPath}`;
  }
  return summary;
}
__name(summarize, "summarize");
// @__NO_SIDE_EFFECTS__
function unwrap(schema) {
  return schema.wrapped;
}
__name(unwrap, "unwrap");
function isStringValue(value2, expectedType) {
  return expectedType === "string" && typeof value2 === "string";
}
__name(isStringValue, "isStringValue");
const JournalEntrySchema = /* @__PURE__ */ object$1({
  id: /* @__PURE__ */ string$1(),
  name: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  flags: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string$1(), /* @__PURE__ */ unknown())),
  getFlag: /* @__PURE__ */ optional(
    /* @__PURE__ */ custom((val) => typeof val === "function")
  ),
  setFlag: /* @__PURE__ */ optional(
    /* @__PURE__ */ custom(
      (val) => typeof val === "function"
    )
  )
});
function validateJournalEntries(entries2) {
  const result = /* @__PURE__ */ safeParse(/* @__PURE__ */ array$1(JournalEntrySchema), entries2);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Journal entry validation failed",
        void 0,
        result.issues
      )
    );
  }
  return ok(result.output);
}
__name(validateJournalEntries, "validateJournalEntries");
function validateSettingValue(key2, value2, expectedType, choices) {
  if (expectedType === "string" && typeof value2 !== "string") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected string, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (expectedType === "number" && typeof value2 !== "number") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected number, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (expectedType === "boolean" && typeof value2 !== "boolean") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting ${key2}: Expected boolean, got ${typeof value2}`,
        { key: key2, value: value2, expectedType }
      )
    );
  }
  if (choices && isStringValue(value2, expectedType)) {
    if (!choices.includes(value2)) {
      return err(
        createFoundryError(
          "VALIDATION_FAILED",
          `Setting ${key2}: Invalid value "${value2}". Allowed: ${choices.join(", ")}`,
          { key: key2, value: value2, choices }
        )
      );
    }
  }
  return ok(value2);
}
__name(validateSettingValue, "validateSettingValue");
const SettingConfigSchema = /* @__PURE__ */ object$1({
  name: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  hint: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  scope: /* @__PURE__ */ optional(/* @__PURE__ */ picklist(["world", "client", "user"])),
  config: /* @__PURE__ */ optional(/* @__PURE__ */ boolean()),
  type: /* @__PURE__ */ optional(/* @__PURE__ */ any()),
  // typeof String, Number, Boolean - cannot validate constructors
  default: /* @__PURE__ */ optional(/* @__PURE__ */ any()),
  // Default value depends on type
  choices: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string$1(), /* @__PURE__ */ string$1())),
  // Record keys must be string in TS
  onChange: /* @__PURE__ */ optional(/* @__PURE__ */ custom((val) => typeof val === "function"))
});
function validateSettingConfig(namespace, key2, config2) {
  if (!namespace || typeof namespace !== "string") {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Invalid setting namespace: must be non-empty string",
        { namespace, key: key2 }
      )
    );
  }
  if (!key2 || typeof key2 !== "string") {
    return err(
      createFoundryError("VALIDATION_FAILED", "Invalid setting key: must be non-empty string", {
        namespace,
        key: key2
      })
    );
  }
  if (!config2 || typeof config2 !== "object") {
    return err(
      createFoundryError("VALIDATION_FAILED", "Invalid setting config: must be object", {
        namespace,
        key: key2
      })
    );
  }
  const result = /* @__PURE__ */ safeParse(SettingConfigSchema, config2);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Setting config validation failed for ${namespace}.${key2}: ${result.issues.map((i) => i.message).join(", ")}`,
        { namespace, key: key2, config: config2, issues: result.issues }
      )
    );
  }
  return ok(result.output);
}
__name(validateSettingConfig, "validateSettingConfig");
function sanitizeId(id2) {
  return id2.replace(/[^a-zA-Z0-9-_]/g, "");
}
__name(sanitizeId, "sanitizeId");
function sanitizeHtml$1(text2) {
  const div = document.createElement("div");
  div.textContent = text2;
  return div.innerHTML;
}
__name(sanitizeHtml$1, "sanitizeHtml$1");
const FoundryApplicationSchema = /* @__PURE__ */ object$1({
  // Application should have a string ID
  id: /* @__PURE__ */ string$1(),
  // Application should have object property (typed as record instead of any)
  object: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string$1(), /* @__PURE__ */ unknown())),
  // Application should have options property
  options: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string$1(), /* @__PURE__ */ unknown()))
});
function validateHookApp(app) {
  if (app === null || app === void 0) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Hook app parameter is null or undefined",
        void 0,
        void 0
      )
    );
  }
  const result = /* @__PURE__ */ safeParse(FoundryApplicationSchema, app);
  if (!result.success) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Hook app parameter validation failed",
        void 0,
        result.issues
      )
    );
  }
  return ok(result.output);
}
__name(validateHookApp, "validateHookApp");
const HOOK_THROTTLE_WINDOW_MS = 150;
const VALIDATION_CONSTRAINTS = {
  /** Maximale Länge für IDs und Keys */
  MAX_ID_LENGTH: 100,
  /** Maximale Länge für Namen */
  MAX_NAME_LENGTH: 100,
  /** Maximale Länge für Flag-Keys */
  MAX_FLAG_KEY_LENGTH: 100
};
const METRICS_CONFIG = {
  /** Größe des Circular-Buffers für Resolution-Zeiten */
  RESOLUTION_TIMES_BUFFER_SIZE: 100
};
Object.freeze(VALIDATION_CONSTRAINTS);
Object.freeze(METRICS_CONFIG);
function validateJournalId(id2) {
  if (id2.length === 0) {
    return err(createFoundryError("VALIDATION_FAILED", "ID cannot be empty"));
  }
  if (id2.length > VALIDATION_CONSTRAINTS.MAX_ID_LENGTH) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `ID too long (max ${VALIDATION_CONSTRAINTS.MAX_ID_LENGTH} characters)`
      )
    );
  }
  if (!/^[a-zA-Z0-9-_]+$/.test(id2)) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "ID contains invalid characters (allowed: a-z, A-Z, 0-9, -, _)",
        { id: id2 }
      )
    );
  }
  return ok(id2);
}
__name(validateJournalId, "validateJournalId");
function validateJournalName(name) {
  if (typeof name !== "string" || name.length === 0) {
    return err(createFoundryError("VALIDATION_FAILED", "Name cannot be empty"));
  }
  if (name.length > 255) {
    return err(createFoundryError("VALIDATION_FAILED", "Name too long (max 255 characters)"));
  }
  return ok(name);
}
__name(validateJournalName, "validateJournalName");
function validateFlagKey(key2) {
  if (typeof key2 !== "string" || key2.length === 0 || key2.length > VALIDATION_CONSTRAINTS.MAX_FLAG_KEY_LENGTH) {
    return err(createFoundryError("VALIDATION_FAILED", "Invalid flag key length"));
  }
  if (!/^[a-zA-Z0-9_]+$/.test(key2)) {
    return err(createFoundryError("VALIDATION_FAILED", "Invalid flag key format"));
  }
  return ok(key2);
}
__name(validateFlagKey, "validateFlagKey");
const _FoundryV13GamePort = class _FoundryV13GamePort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed);
    this.foundryAPI = foundryAPI;
    __privateSet(this, _disposed, false);
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
    this.cacheTtlMs = APP_DEFAULTS.CACHE_TTL_MS;
  }
  getJournalEntries() {
    if (__privateGet(this, _disposed)) {
      return err(createFoundryError("DISPOSED", "Cannot get journal entries on disposed port"));
    }
    if (!this.foundryAPI?.journal) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry game API not available"));
    }
    const now2 = Date.now();
    const cacheAge = now2 - this.lastCheckTimestamp;
    if (this.cachedEntries !== null && cacheAge < this.cacheTtlMs) {
      return { ok: true, value: this.cachedEntries };
    }
    const entries2 = tryCatch(
      () => Array.from(this.foundryAPI.journal.contents),
      (error3) => createFoundryError("OPERATION_FAILED", "Failed to access journal entries", void 0, error3)
    );
    if (!entries2.ok) {
      return entries2;
    }
    const validationResult = validateJournalEntries(entries2.value);
    if (!validationResult.ok) {
      return validationResult;
    }
    this.cachedEntries = entries2.value;
    this.lastCheckTimestamp = now2;
    return { ok: true, value: this.cachedEntries };
  }
  /**
   * Invalidates the journal entries cache.
   * Forces the next getJournalEntries() call to fetch and validate fresh data.
   */
  invalidateCache() {
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
  }
  getJournalEntryById(id2) {
    if (__privateGet(this, _disposed)) {
      return err(createFoundryError("DISPOSED", "Cannot get journal entry on disposed port"));
    }
    const validationResult = validateJournalId(id2);
    if (!validationResult.ok) {
      return validationResult;
    }
    if (!this.foundryAPI?.journal) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry game API not available"));
    }
    return tryCatch(
      () => {
        const entry = this.foundryAPI.journal.get(validationResult.value);
        return entry ?? null;
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to get journal entry by ID ${validationResult.value}`,
        { id: validationResult.value },
        error3
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed)) return;
    __privateSet(this, _disposed, true);
    this.cachedEntries = null;
    this.lastCheckTimestamp = 0;
  }
};
_disposed = new WeakMap();
__name(_FoundryV13GamePort, "FoundryV13GamePort");
let FoundryV13GamePort = _FoundryV13GamePort;
function createFoundryV13GamePort() {
  if (typeof game === "undefined" || !game?.journal) {
    return new FoundryV13GamePort({
      // type-coverage:ignore-next-line -- Required: null needed when API unavailable, but IFoundryGameAPI["journal"] is non-nullable
      journal: null
    });
  }
  return new FoundryV13GamePort({
    journal: {
      contents: Array.from(game.journal.contents),
      get: /* @__PURE__ */ __name((id2) => game.journal.get(id2), "get"),
      ...game.journal.directory && game.journal.directory.render ? {
        directory: {
          render: /* @__PURE__ */ __name(() => {
            game.journal.directory?.render();
          }, "render")
        }
      } : {}
    }
  });
}
__name(createFoundryV13GamePort, "createFoundryV13GamePort");
const _FoundryV13HooksPort = class _FoundryV13HooksPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed2, false);
    this.foundryAPI = foundryAPI;
  }
  on(hookName, callback) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot register hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        const hookId = this.foundryAPI.on(hookName, callback);
        return hookId;
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register hook ${hookName}`,
        { hookName },
        error3
      )
    );
  }
  once(hookName, callback) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot register one-time hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        const hookId = this.foundryAPI.once(hookName, callback);
        return hookId;
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register one-time hook ${hookName}`,
        { hookName },
        error3
      )
    );
  }
  off(hookName, callbackOrId) {
    if (__privateGet(this, _disposed2)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot unregister hook on disposed port", {
          hookName
        })
      };
    }
    return tryCatch(
      () => {
        if (!this.foundryAPI) {
          throw new Error("Foundry Hooks API is not available");
        }
        this.foundryAPI.off(hookName, callbackOrId);
        return void 0;
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to unregister hook ${hookName}`,
        { hookName },
        error3
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed2)) return;
    __privateSet(this, _disposed2, true);
  }
};
_disposed2 = new WeakMap();
__name(_FoundryV13HooksPort, "FoundryV13HooksPort");
let FoundryV13HooksPort = _FoundryV13HooksPort;
function createFoundryV13HooksPort() {
  if (typeof Hooks === "undefined") {
    throw new Error("Foundry Hooks API is not available");
  }
  return new FoundryV13HooksPort({
    on: /* @__PURE__ */ __name((hookName, callback) => {
      return Hooks.on(
        hookName,
        callback
      );
    }, "on"),
    once: /* @__PURE__ */ __name((hookName, callback) => {
      return Hooks.once(
        hookName,
        callback
      );
    }, "once"),
    off: /* @__PURE__ */ __name((hookName, callbackOrId) => {
      Hooks.off(
        hookName,
        callbackOrId
      );
    }, "off")
  });
}
__name(createFoundryV13HooksPort, "createFoundryV13HooksPort");
function hasMethod(obj, methodName) {
  return obj !== null && obj !== void 0 && typeof obj === "object" && methodName in obj && // type-coverage:ignore-next-line - Runtime type guard requires cast to check method type
  typeof obj[methodName] === "function";
}
__name(hasMethod, "hasMethod");
function hasProperty(obj, propertyName) {
  return obj !== null && obj !== void 0 && typeof obj === "object" && propertyName in obj;
}
__name(hasProperty, "hasProperty");
function hasOwnProperty$1(obj, propertyName) {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return false;
  }
  return Object.prototype.hasOwnProperty.call(obj, propertyName);
}
__name(hasOwnProperty$1, "hasOwnProperty$1");
function isObjectWithMethods(obj, methodNames) {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return false;
  }
  return methodNames.every((methodName) => hasMethod(obj, methodName));
}
__name(isObjectWithMethods, "isObjectWithMethods");
function isInitializable(obj) {
  return hasMethod(obj, "initialize");
}
__name(isInitializable, "isInitializable");
const RELATIONSHIP_FLAGS_MODULE_ID = "fvtt_relationship_app_module";
const JOURNAL_ENTRY_FLAGS = {
  HAS_RELATIONSHIP_NODE: `${RELATIONSHIP_FLAGS_MODULE_ID}.hasRelationshipNode`,
  HAS_RELATIONSHIP_GRAPH: `${RELATIONSHIP_FLAGS_MODULE_ID}.hasRelationshipGraph`
};
const JOURNAL_ENTRY_PAGE_FLAGS = {
  IS_RELATIONSHIP_NODE: `${RELATIONSHIP_FLAGS_MODULE_ID}.isRelationshipNode`,
  IS_RELATIONSHIP_GRAPH: `${RELATIONSHIP_FLAGS_MODULE_ID}.isRelationshipGraph`
};
function castFoundrySettingsApi(settings) {
  if (!isObjectWithMethods(settings, ["register", "get", "set"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "game.settings does not have required methods (register, get, set)",
        {
          missingMethods: ["register", "get", "set"]
        }
      )
    );
  }
  return ok(settings);
}
__name(castFoundrySettingsApi, "castFoundrySettingsApi");
function castFoundryDocumentForFlag(document2) {
  if (!isObjectWithMethods(document2, ["getFlag", "setFlag"])) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        "Document does not have required methods (getFlag, setFlag)",
        {
          missingMethods: ["getFlag", "setFlag"]
        }
      )
    );
  }
  return ok(document2);
}
__name(castFoundryDocumentForFlag, "castFoundryDocumentForFlag");
function castFoundryError(error3) {
  return error3;
}
__name(castFoundryError, "castFoundryError");
function castDisposablePort(port) {
  if (!port || typeof port !== "object") {
    return null;
  }
  if (hasMethod(port, "dispose")) {
    return port;
  }
  return null;
}
__name(castDisposablePort, "castDisposablePort");
function ensureNonEmptyArray(arr) {
  if (arr.length === 0) {
    return err(
      createFoundryError("VALIDATION_FAILED", "Array must not be empty", { arrayLength: 0 })
    );
  }
  return ok(arr);
}
__name(ensureNonEmptyArray, "ensureNonEmptyArray");
function extractHtmlElement(html2) {
  return html2 instanceof HTMLElement ? html2 : null;
}
__name(extractHtmlElement, "extractHtmlElement");
function isRecord$1(value2) {
  return value2 !== null && typeof value2 === "object" && !Array.isArray(value2);
}
__name(isRecord$1, "isRecord$1");
function getFactoryOrError(factories, version2) {
  const factory = factories.get(version2);
  if (!factory) {
    return err(
      createFoundryError("PORT_NOT_FOUND", `Factory for version ${version2} not found in registry`, {
        version: version2
      })
    );
  }
  return ok(factory);
}
__name(getFactoryOrError, "getFactoryOrError");
function castFoundryDocumentWithUpdate(document2) {
  if (!isObjectWithMethods(document2, ["update"])) {
    return err(
      createFoundryError("VALIDATION_FAILED", "Document does not have required method (update)", {
        missingMethods: ["update"]
      })
    );
  }
  return ok(document2);
}
__name(castFoundryDocumentWithUpdate, "castFoundryDocumentWithUpdate");
function castFoundryJournalEntryClass() {
  if (typeof globalThis !== "object" || globalThis === null || !("JournalEntry" in globalThis)) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "Foundry JournalEntry class not available in globalThis",
        {}
      )
    );
  }
  const journalEntryClass = globalThis.JournalEntry;
  if (!isObjectWithMethods(journalEntryClass, ["create"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "Foundry JournalEntry class does not have required method (create)",
        {
          missingMethods: ["create"]
        }
      )
    );
  }
  return ok(journalEntryClass);
}
__name(castFoundryJournalEntryClass, "castFoundryJournalEntryClass");
function castCreatedJournalEntry(document2) {
  return document2;
}
__name(castCreatedJournalEntry, "castCreatedJournalEntry");
function createEntityDataWithId(data4, id2) {
  return { ...data4, id: id2 };
}
__name(createEntityDataWithId, "createEntityDataWithId");
function castFoundryDocumentCollection(collections, documentType) {
  if (!isObjectWithMethods(collections, ["get"])) {
    return err(
      createFoundryError(
        "API_NOT_AVAILABLE",
        "game.collections does not have required method (get)",
        {
          missingMethods: ["get"]
        }
      )
    );
  }
  const collection4 = collections.get(documentType);
  if (!collection4) {
    return err(
      createFoundryError("NOT_FOUND", `Collection for document type "${documentType}" not found`, {
        documentType
      })
    );
  }
  if (!isObjectWithMethods(collection4, ["get", "has"])) {
    return err(
      createFoundryError(
        "VALIDATION_FAILED",
        `Collection for "${documentType}" does not have required methods (get, has)`,
        {
          documentType,
          missingMethods: ["get", "has"]
        }
      )
    );
  }
  return ok(collection4);
}
__name(castFoundryDocumentCollection, "castFoundryDocumentCollection");
function isRelationshipGraphPage(page) {
  if (!page || typeof page !== "object") {
    return false;
  }
  const pageObj = page;
  if ("type" in pageObj && typeof pageObj.type === "string") {
    if (pageObj.type === JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_GRAPH) {
      return true;
    }
  }
  if ("getFlag" in pageObj && typeof pageObj.getFlag === "function") {
    try {
      const fullFlagPath = JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_GRAPH;
      const flagKey = fullFlagPath.includes(".") ? fullFlagPath.split(".").pop() ?? "" : fullFlagPath;
      const flagValue = pageObj.getFlag(
        RELATIONSHIP_FLAGS_MODULE_ID,
        flagKey
      );
      return flagValue === true;
    } catch {
      return false;
    }
  }
  return false;
}
__name(isRelationshipGraphPage, "isRelationshipGraphPage");
function isRelationshipNodePage(page) {
  if (!page || typeof page !== "object") {
    return false;
  }
  const pageObj = page;
  if ("type" in pageObj && typeof pageObj.type === "string") {
    if (pageObj.type === JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_NODE) {
      return true;
    }
  }
  if ("getFlag" in pageObj && typeof pageObj.getFlag === "function") {
    try {
      const fullFlagPath = JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_NODE;
      const flagKey = fullFlagPath.includes(".") ? fullFlagPath.split(".").pop() ?? "" : fullFlagPath;
      const flagValue = pageObj.getFlag(
        RELATIONSHIP_FLAGS_MODULE_ID,
        flagKey
      );
      return flagValue === true;
    } catch {
      return false;
    }
  }
  return false;
}
__name(isRelationshipNodePage, "isRelationshipNodePage");
function castRelationshipGraphPage(page) {
  if (isRelationshipGraphPage(page)) {
    return ok(page);
  }
  return err(
    createFoundryError("VALIDATION_FAILED", "Page is not a relationship graph page", {
      pageId: typeof page?.id === "string" ? page.id : "unknown",
      pageType: typeof page?.type === "string" ? page.type : "unknown"
    })
  );
}
__name(castRelationshipGraphPage, "castRelationshipGraphPage");
function castRelationshipNodePage(page) {
  if (isRelationshipNodePage(page)) {
    return ok(page);
  }
  return err(
    createFoundryError("VALIDATION_FAILED", "Page is not a relationship node page", {
      pageId: typeof page?.id === "string" ? page.id : "unknown",
      pageType: typeof page?.type === "string" ? page.type : "unknown"
    })
  );
}
__name(castRelationshipNodePage, "castRelationshipNodePage");
function createRelationshipNodePageData(name, nodeData) {
  return {
    name,
    type: JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_NODE,
    system: nodeData
  };
}
__name(createRelationshipNodePageData, "createRelationshipNodePageData");
function createRelationshipGraphPageData(name, graphData) {
  return {
    name,
    type: JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_GRAPH,
    system: graphData
  };
}
__name(createRelationshipGraphPageData, "createRelationshipGraphPageData");
function castPageDataForCreateEmbeddedDocuments(pageDataArray) {
  return pageDataArray;
}
__name(castPageDataForCreateEmbeddedDocuments, "castPageDataForCreateEmbeddedDocuments");
const _FoundryV13DocumentPort = class _FoundryV13DocumentPort {
  constructor() {
    __privateAdd(this, _disposed3, false);
  }
  async create(documentClass, data4) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot create document on disposed port"));
    }
    return fromPromise(
      documentClass.create(data4),
      (error3) => createFoundryError("OPERATION_FAILED", "Failed to create document", { data: data4 }, error3)
    );
  }
  async update(document2, changes, options2) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot update document on disposed port"));
    }
    return fromPromise(
      document2.update(changes, options2),
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        "Failed to update document",
        { changes, options: options2 },
        error3
      )
    );
  }
  async delete(document2) {
    if (__privateGet(this, _disposed3)) {
      return err(createFoundryError("DISPOSED", "Cannot delete document on disposed port"));
    }
    return fromPromise(
      document2.delete().then(() => void 0),
      (error3) => createFoundryError("OPERATION_FAILED", "Failed to delete document", void 0, error3)
    );
  }
  getFlag(document2, scope, key2, schema) {
    if (__privateGet(this, _disposed3)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot get flag on disposed port", { scope, key: key2 })
      };
    }
    return tryCatch(
      () => {
        if (!document2?.getFlag) {
          throw new Error("Document does not have getFlag method");
        }
        const rawValue = document2.getFlag(scope, key2);
        if (rawValue === null || rawValue === void 0) {
          return null;
        }
        const parseResult = /* @__PURE__ */ safeParse(schema, rawValue);
        if (!parseResult.success) {
          const error3 = createFoundryError(
            "VALIDATION_FAILED",
            `Flag ${scope}.${key2} failed validation: ${parseResult.issues.map((i) => i.message).join(", ")}`,
            { scope, key: key2, rawValue, issues: parseResult.issues }
          );
          throw error3;
        }
        return parseResult.output;
      },
      (error3) => {
        if (error3 && typeof error3 === "object" && "code" in error3 && "message" in error3) {
          return castFoundryError(error3);
        }
        return createFoundryError(
          "OPERATION_FAILED",
          `Failed to get flag ${scope}.${key2}`,
          { scope, key: key2 },
          error3
        );
      }
    );
  }
  async setFlag(document2, scope, key2, value2) {
    if (__privateGet(this, _disposed3)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot set flag on disposed port", { scope, key: key2 })
      };
    }
    return fromPromise(
      (async () => {
        if (!document2?.setFlag) {
          throw new Error("Document does not have setFlag method");
        }
        await document2.setFlag(scope, key2, value2);
      })(),
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to set flag ${scope}.${key2}`,
        { scope, key: key2, value: value2 },
        error3
      )
    );
  }
  async unsetFlag(document2, scope, key2) {
    if (__privateGet(this, _disposed3)) {
      return err(
        createFoundryError("DISPOSED", "Cannot unset flag on disposed port", { scope, key: key2 })
      );
    }
    return fromPromise(
      (async () => {
        if (document2.unsetFlag) {
          await document2.unsetFlag(scope, key2);
        } else {
          const docWithUpdateResult = castFoundryDocumentWithUpdate(document2);
          if (!docWithUpdateResult.ok) {
            throw new Error(
              `Document does not support unsetFlag or update: ${docWithUpdateResult.error.message}`
            );
          }
          await docWithUpdateResult.value.update({
            [`flags.${scope}.-=${key2}`]: null
          });
        }
      })(),
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to unset flag ${scope}.${key2}`,
        { scope, key: key2 },
        error3
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed3)) return;
    __privateSet(this, _disposed3, true);
  }
};
_disposed3 = new WeakMap();
__name(_FoundryV13DocumentPort, "FoundryV13DocumentPort");
let FoundryV13DocumentPort = _FoundryV13DocumentPort;
const _FoundryV13UIPort = class _FoundryV13UIPort {
  constructor(foundryUIAPI, foundryGameJournalAPI, foundryDocumentAPI) {
    __privateAdd(this, _disposed4, false);
    this.foundryUIAPI = foundryUIAPI;
    this.foundryGameJournalAPI = foundryGameJournalAPI;
    this.foundryDocumentAPI = foundryDocumentAPI;
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    if (__privateGet(this, _disposed4)) {
      return err(
        createFoundryError("DISPOSED", "Cannot remove journal directory entry on disposed port")
      );
    }
    const elementResult = this.getDirectoryElement(directoryId);
    if (!elementResult.ok) {
      return err(elementResult.error);
    }
    const html2 = elementResult.value;
    if (!html2) {
      return err(
        createFoundryError(
          "NOT_FOUND",
          `Directory element not found for directory: ${directoryId}`,
          { directoryId, journalId, journalName }
        )
      );
    }
    const safeId = sanitizeId(journalId);
    const element3 = html2.querySelector(
      `li.directory-item[data-document-id="${safeId}"], li.directory-item[data-entry-id="${safeId}"]`
    );
    if (!element3) {
      return err(
        createFoundryError(
          "NOT_FOUND",
          `Could not find directory entry for journal: ${journalName}`,
          { journalName, journalId: safeId }
        )
      );
    }
    try {
      element3.remove();
      return ok(void 0);
    } catch (error3) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to remove element from DOM",
          { journalName, journalId: safeId },
          error3
        )
      );
    }
  }
  findElement(container2, selector) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot find element on disposed port"));
    }
    const element3 = container2.querySelector(selector);
    return ok(element3);
  }
  notify(message2, type, options2) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot show notification on disposed port"));
    }
    if (!this.foundryUIAPI?.notifications) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry UI notifications not available"));
    }
    try {
      switch (type) {
        case "info":
          this.foundryUIAPI.notifications.info(message2, options2);
          break;
        case "warning":
          this.foundryUIAPI.notifications.warn(message2, options2);
          break;
        case "error":
          this.foundryUIAPI.notifications.error(message2, options2);
          break;
      }
      return ok(void 0);
    } catch (error3) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to show notification",
          { message: message2, type },
          error3
        )
      );
    }
  }
  getDirectoryElement(directoryId) {
    if (__privateGet(this, _disposed4)) {
      return err(createFoundryError("DISPOSED", "Cannot get directory element on disposed port"));
    }
    try {
      if (directoryId === "journal") {
        const element3 = this.foundryDocumentAPI.querySelector("#journal");
        return ok(element3);
      }
      return ok(null);
    } catch (error3) {
      return err(
        createFoundryError(
          "OPERATION_FAILED",
          "Failed to get directory element",
          { directoryId },
          error3
        )
      );
    }
  }
  rerenderJournalDirectory() {
    if (__privateGet(this, _disposed4)) {
      return err(
        createFoundryError("DISPOSED", "Cannot rerender journal directory on disposed port")
      );
    }
    try {
      const journalElement = this.foundryDocumentAPI.querySelector("#journal");
      if (!journalElement) {
        return ok(false);
      }
      let rendered = false;
      if (this.foundryGameJournalAPI.directory?.render) {
        this.foundryGameJournalAPI.directory.render();
        rendered = true;
      }
      return ok(rendered);
    } catch (error3) {
      return err(
        createFoundryError("OPERATION_FAILED", "Failed to re-render journal directory", {}, error3)
      );
    }
  }
  dispose() {
    if (__privateGet(this, _disposed4)) return;
    __privateSet(this, _disposed4, true);
  }
};
_disposed4 = new WeakMap();
__name(_FoundryV13UIPort, "FoundryV13UIPort");
let FoundryV13UIPort = _FoundryV13UIPort;
function createFoundryV13UIPort() {
  if (typeof ui === "undefined" || !ui?.notifications) {
    throw new Error("Foundry UI API not available");
  }
  if (typeof game === "undefined" || !game?.journal) {
    throw new Error("Foundry game API not available");
  }
  const uiAPI = {
    notifications: {
      info: /* @__PURE__ */ __name((message2, options2) => {
        if (ui.notifications) {
          ui.notifications.info(message2, options2);
        }
      }, "info"),
      warn: /* @__PURE__ */ __name((message2, options2) => {
        if (ui.notifications) {
          ui.notifications.warn(message2, options2);
        }
      }, "warn"),
      error: /* @__PURE__ */ __name((message2, options2) => {
        if (ui.notifications) {
          ui.notifications.error(message2, options2);
        }
      }, "error")
    }
  };
  return new FoundryV13UIPort(
    uiAPI,
    {
      contents: Array.from(game.journal.contents),
      get: /* @__PURE__ */ __name((id2) => game.journal.get(id2), "get"),
      ...game.journal.directory && game.journal.directory.render ? {
        directory: {
          render: /* @__PURE__ */ __name(() => {
            game.journal.directory?.render();
          }, "render")
        }
      } : {}
    },
    {
      querySelector: /* @__PURE__ */ __name((selector) => document.querySelector(selector), "querySelector")
    }
  );
}
__name(createFoundryV13UIPort, "createFoundryV13UIPort");
const _FoundryV13SettingsPort = class _FoundryV13SettingsPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed5, false);
    this.foundryAPI = foundryAPI;
  }
  register(namespace, key2, config2) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot register setting on disposed port", {
          namespace,
          key: key2
        })
      );
    }
    const configValidation = validateSettingConfig(namespace, key2, config2);
    if (!configValidation.ok) {
      return err(configValidation.error);
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    const api2 = this.foundryAPI;
    return tryCatch(
      () => {
        api2.register(namespace, key2, config2);
        return void 0;
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to register setting ${namespace}.${key2}`,
        { namespace, key: key2 },
        error3
      )
    );
  }
  get(namespace, key2, schema) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot get setting on disposed port", { namespace, key: key2 })
      );
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    const api2 = this.foundryAPI;
    return tryCatch(
      () => {
        const rawValue = api2.get(namespace, key2);
        const parseResult = /* @__PURE__ */ safeParse(schema, rawValue);
        if (!parseResult.success) {
          const error3 = createFoundryError(
            "VALIDATION_FAILED",
            `Setting ${namespace}.${key2} failed validation: ${parseResult.issues.map((i) => i.message).join(", ")}`,
            { namespace, key: key2, rawValue, issues: parseResult.issues }
          );
          throw error3;
        }
        return parseResult.output;
      },
      (error3) => {
        if (error3 && typeof error3 === "object" && "code" in error3 && error3.code === "VALIDATION_FAILED") {
          return castFoundryError(error3);
        }
        return createFoundryError(
          "OPERATION_FAILED",
          `Failed to get setting ${namespace}.${key2}`,
          { namespace, key: key2 },
          error3
        );
      }
    );
  }
  async set(namespace, key2, value2) {
    if (__privateGet(this, _disposed5)) {
      return err(
        createFoundryError("DISPOSED", "Cannot set setting on disposed port", { namespace, key: key2 })
      );
    }
    if (!this.foundryAPI) {
      return err(createFoundryError("API_NOT_AVAILABLE", "Foundry settings API not available"));
    }
    return fromPromise(
      this.foundryAPI.set(namespace, key2, value2).then(() => void 0),
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to set setting ${namespace}.${key2}`,
        { namespace, key: key2, value: value2 },
        error3
      )
    );
  }
  dispose() {
    if (__privateGet(this, _disposed5)) return;
    __privateSet(this, _disposed5, true);
  }
};
_disposed5 = new WeakMap();
__name(_FoundryV13SettingsPort, "FoundryV13SettingsPort");
let FoundryV13SettingsPort = _FoundryV13SettingsPort;
function createFoundryV13SettingsPort() {
  if (typeof game === "undefined" || game === null || game.settings === void 0) {
    return new FoundryV13SettingsPort(null);
  }
  const settingsResult = castFoundrySettingsApi(game.settings);
  if (!settingsResult.ok) {
    const castError = settingsResult.error;
    return new FoundryV13SettingsPort({
      register: /* @__PURE__ */ __name(() => {
        throw castError;
      }, "register"),
      get: /* @__PURE__ */ __name(() => {
        throw castError;
      }, "get"),
      set: /* @__PURE__ */ __name(async () => {
        throw castError;
      }, "set")
    });
  }
  const settings = settingsResult.value;
  return new FoundryV13SettingsPort({
    register: /* @__PURE__ */ __name((namespace, key2, config2) => {
      settings.register(namespace, key2, config2);
    }, "register"),
    get: /* @__PURE__ */ __name((namespace, key2) => {
      return settings.get(namespace, key2);
    }, "get"),
    set: /* @__PURE__ */ __name((namespace, key2, value2) => {
      return settings.set(namespace, key2, value2).then(() => void 0);
    }, "set")
  });
}
__name(createFoundryV13SettingsPort, "createFoundryV13SettingsPort");
const _FoundryV13I18nPort = class _FoundryV13I18nPort {
  constructor(foundryAPI) {
    __privateAdd(this, _disposed6, false);
    this.foundryAPI = foundryAPI;
  }
  /**
   * Localizes a translation key using Foundry's i18n system.
   *
   * @param key - Translation key
   * @returns Result with translated string (returns key itself if not found)
   */
  localize(key2) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot localize on disposed port", { key: key2 })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(key2);
      }
      const translated = this.foundryAPI.localize(key2);
      return ok(translated);
    } catch {
      return ok(key2);
    }
  }
  /**
   * Formats a translation key with placeholder values.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @returns Result with formatted string
   */
  format(key2, data4) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot format translation on disposed port", {
          key: key2
        })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(key2);
      }
      const stringData = {};
      for (const [k, v] of Object.entries(data4)) {
        stringData[k] = String(v);
      }
      const formatted = this.foundryAPI.format(key2, stringData);
      return ok(formatted);
    } catch {
      return ok(key2);
    }
  }
  /**
   * Checks if a translation key exists.
   *
   * @param key - Translation key to check
   * @returns Result with boolean indicating existence
   */
  has(key2) {
    if (__privateGet(this, _disposed6)) {
      return {
        ok: false,
        error: createFoundryError("DISPOSED", "Cannot check translation key on disposed port", {
          key: key2
        })
      };
    }
    try {
      if (!this.foundryAPI) {
        return ok(false);
      }
      const exists = this.foundryAPI.has(key2);
      return ok(exists);
    } catch {
      return ok(false);
    }
  }
  dispose() {
    if (__privateGet(this, _disposed6)) return;
    __privateSet(this, _disposed6, true);
  }
};
_disposed6 = new WeakMap();
__name(_FoundryV13I18nPort, "FoundryV13I18nPort");
_FoundryV13I18nPort.dependencies = [];
let FoundryV13I18nPort = _FoundryV13I18nPort;
function createFoundryV13I18nPort() {
  if (typeof game === "undefined" || !game?.i18n) {
    return new FoundryV13I18nPort(null);
  }
  return new FoundryV13I18nPort({
    localize: /* @__PURE__ */ __name((key2) => game.i18n.localize(key2), "localize"),
    format: /* @__PURE__ */ __name((key2, data4) => game.i18n.format(key2, data4), "format"),
    has: /* @__PURE__ */ __name((key2) => game.i18n.has(key2), "has")
  });
}
__name(createFoundryV13I18nPort, "createFoundryV13I18nPort");
const _FoundryV13ModulePort = class _FoundryV13ModulePort {
  setModuleReady(moduleId) {
    if (typeof game === "undefined" || !game?.modules) {
      return false;
    }
    const mod = game.modules.get(moduleId);
    if (!mod) {
      return false;
    }
    mod.ready = true;
    return true;
  }
};
__name(_FoundryV13ModulePort, "FoundryV13ModulePort");
let FoundryV13ModulePort = _FoundryV13ModulePort;
function createFoundryV13ModulePort() {
  return new FoundryV13ModulePort();
}
__name(createFoundryV13ModulePort, "createFoundryV13ModulePort");
const foundryV13GamePortToken = createInjectionToken("FoundryV13GamePort");
const foundryV13HooksPortToken = createInjectionToken("FoundryV13HooksPort");
const foundryV13DocumentPortToken = createInjectionToken("FoundryV13DocumentPort");
const foundryV13UIPortToken = createInjectionToken("FoundryV13UIPort");
const foundryV13SettingsPortToken = createInjectionToken("FoundryV13SettingsPort");
const foundryV13I18nPortToken = createInjectionToken("FoundryV13I18nPort");
const foundryV13ModulePortToken = createInjectionToken("FoundryV13ModulePort");
function registerPortToRegistry(registry, version2, token, portName, errors) {
  const result = registry.register(version2, token);
  if (isErr(result)) {
    errors.push(`${portName} v${version2}: ${result.error}`);
  }
}
__name(registerPortToRegistry, "registerPortToRegistry");
function registerV13Ports(registries, container2) {
  const portRegistrationErrors = [];
  const gamePortResult = container2.registerFactory(
    foundryV13GamePortToken,
    createFoundryV13GamePort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(gamePortResult)) {
    portRegistrationErrors.push(`FoundryGame: ${gamePortResult.error.message}`);
  }
  const hooksPortResult = container2.registerFactory(
    foundryV13HooksPortToken,
    createFoundryV13HooksPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(hooksPortResult)) {
    portRegistrationErrors.push(`FoundryHooks: ${hooksPortResult.error.message}`);
  }
  container2.registerClass(
    foundryV13DocumentPortToken,
    FoundryV13DocumentPort,
    ServiceLifecycle.SINGLETON
  );
  const uiPortResult = container2.registerFactory(
    foundryV13UIPortToken,
    createFoundryV13UIPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(uiPortResult)) {
    portRegistrationErrors.push(`FoundryUI: ${uiPortResult.error.message}`);
  }
  const settingsPortResult = container2.registerFactory(
    foundryV13SettingsPortToken,
    createFoundryV13SettingsPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(settingsPortResult)) {
    portRegistrationErrors.push(`FoundrySettings: ${settingsPortResult.error.message}`);
  }
  const i18nPortResult = container2.registerFactory(
    foundryV13I18nPortToken,
    createFoundryV13I18nPort,
    ServiceLifecycle.SINGLETON,
    []
    // No dependencies
  );
  if (isErr(i18nPortResult)) {
    portRegistrationErrors.push(`FoundryI18n: ${i18nPortResult.error.message}`);
  }
  container2.registerValue(foundryV13ModulePortToken, createFoundryV13ModulePort());
  registerPortToRegistry(
    registries.gamePortRegistry,
    13,
    foundryV13GamePortToken,
    "FoundryGame",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.hooksPortRegistry,
    13,
    foundryV13HooksPortToken,
    "FoundryHooks",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.documentPortRegistry,
    13,
    foundryV13DocumentPortToken,
    "FoundryDocument",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.uiPortRegistry,
    13,
    foundryV13UIPortToken,
    "FoundryUI",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.settingsPortRegistry,
    13,
    foundryV13SettingsPortToken,
    "FoundrySettings",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.i18nPortRegistry,
    13,
    foundryV13I18nPortToken,
    "FoundryI18n",
    portRegistrationErrors
  );
  registerPortToRegistry(
    registries.modulePortRegistry,
    13,
    foundryV13ModulePortToken,
    "FoundryModule",
    portRegistrationErrors
  );
  if (portRegistrationErrors.length > 0) {
    return err(`Port registration failed: ${portRegistrationErrors.join("; ")}`);
  }
  return ok(void 0);
}
__name(registerV13Ports, "registerV13Ports");
const foundryUIToken = createInjectionToken("FoundryUI");
const _FoundryUIAdapter = class _FoundryUIAdapter {
  constructor(foundryUI) {
    this.foundryUI = foundryUI;
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    const result = this.foundryUI.removeJournalDirectoryEntry(directoryId, journalId, journalName);
    if (!result.ok) {
      return err({
        code: "DOM_MANIPULATION_FAILED",
        message: `Failed to remove journal directory entry '${journalName}' (${journalId}) from directory '${directoryId}': ${result.error.message}`,
        operation: "removeJournalDirectoryEntry",
        details: { directoryId, journalId, journalName, cause: result.error }
      });
    }
    return ok(void 0);
  }
  getDirectoryElement(directoryId) {
    const result = this.foundryUI.getDirectoryElement(directoryId);
    if (!result.ok) {
      return err({
        code: "DOM_ACCESS_FAILED",
        message: `Failed to get directory element for '${directoryId}': ${result.error.message}`,
        operation: "getDirectoryElement",
        details: { directoryId, cause: result.error }
      });
    }
    return ok(result.value);
  }
  rerenderJournalDirectory() {
    const result = this.foundryUI.rerenderJournalDirectory();
    if (!result.ok) {
      return err({
        code: "RERENDER_FAILED",
        message: `Failed to re-render journal directory: ${result.error.message}`,
        operation: "rerenderJournalDirectory",
        details: { cause: result.error }
      });
    }
    return ok(result.value);
  }
  notify(message2, type) {
    const result = this.foundryUI.notify(message2, type);
    if (!result.ok) {
      return err({
        code: result.error.code,
        message: result.error.message,
        operation: "notify",
        details: { cause: result.error }
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryUIAdapter, "FoundryUIAdapter");
let FoundryUIAdapter = _FoundryUIAdapter;
const _DIFoundryUIAdapter = class _DIFoundryUIAdapter extends FoundryUIAdapter {
  constructor(foundryUI) {
    super(foundryUI);
  }
};
__name(_DIFoundryUIAdapter, "DIFoundryUIAdapter");
_DIFoundryUIAdapter.dependencies = [foundryUIToken];
let DIFoundryUIAdapter = _DIFoundryUIAdapter;
const LOG_LEVEL_SCHEMA = /* @__PURE__ */ picklist([
  LogLevel.DEBUG,
  LogLevel.INFO,
  LogLevel.WARN,
  LogLevel.ERROR
]);
const _ValibotValidationAdapter = class _ValibotValidationAdapter {
  /**
   * Validates a log level value using Valibot schema.
   *
   * @param value - The value to validate
   * @returns Result with validated LogLevel or validation error
   */
  validateLogLevel(value2) {
    const validationResult = /* @__PURE__ */ safeParse(LOG_LEVEL_SCHEMA, value2);
    if (!validationResult.success) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Invalid log level value: ${String(value2)}. Must be one of: ${LogLevel.DEBUG}, ${LogLevel.INFO}, ${LogLevel.WARN}, ${LogLevel.ERROR}`,
        details: validationResult.issues
      });
    }
    return ok(validationResult.output);
  }
};
__name(_ValibotValidationAdapter, "ValibotValidationAdapter");
let ValibotValidationAdapter = _ValibotValidationAdapter;
const _DIValibotValidationAdapter = class _DIValibotValidationAdapter extends ValibotValidationAdapter {
  constructor() {
    super();
  }
};
__name(_DIValibotValidationAdapter, "DIValibotValidationAdapter");
_DIValibotValidationAdapter.dependencies = [];
let DIValibotValidationAdapter = _DIValibotValidationAdapter;
const _MetricsSnapshotAdapter = class _MetricsSnapshotAdapter {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
  }
  getSnapshot() {
    return this.metricsCollector.getSnapshot();
  }
};
__name(_MetricsSnapshotAdapter, "MetricsSnapshotAdapter");
let MetricsSnapshotAdapter = _MetricsSnapshotAdapter;
const _DIMetricsSnapshotAdapter = class _DIMetricsSnapshotAdapter extends MetricsSnapshotAdapter {
  constructor(metricsCollector) {
    super(metricsCollector);
  }
};
__name(_DIMetricsSnapshotAdapter, "DIMetricsSnapshotAdapter");
_DIMetricsSnapshotAdapter.dependencies = [metricsCollectorToken];
let DIMetricsSnapshotAdapter = _DIMetricsSnapshotAdapter;
function createPortRegistries(container2) {
  const gamePortRegistry = new PortRegistry();
  const hooksPortRegistry = new PortRegistry();
  const documentPortRegistry = new PortRegistry();
  const uiPortRegistry = new PortRegistry();
  const settingsPortRegistry = new PortRegistry();
  const i18nPortRegistry = new PortRegistry();
  const modulePortRegistry = new PortRegistry();
  const v13RegistrationResult = registerV13Ports(
    {
      gamePortRegistry,
      hooksPortRegistry,
      documentPortRegistry,
      uiPortRegistry,
      settingsPortRegistry,
      i18nPortRegistry,
      modulePortRegistry
    },
    container2
  );
  if (isErr(v13RegistrationResult)) {
    return v13RegistrationResult;
  }
  return ok({
    gamePortRegistry,
    hooksPortRegistry,
    documentPortRegistry,
    uiPortRegistry,
    settingsPortRegistry,
    i18nPortRegistry,
    modulePortRegistry
  });
}
__name(createPortRegistries, "createPortRegistries");
function registerPortInfrastructure(container2) {
  const versionDetectorResult = container2.registerClass(
    foundryVersionDetectorToken,
    DIFoundryVersionDetector,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(versionDetectorResult)) {
    return err(`Failed to register FoundryVersionDetector: ${versionDetectorResult.error.message}`);
  }
  const portSelectorResult = container2.registerClass(
    portSelectorToken,
    DIPortSelector,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(portSelectorResult)) {
    return err(`Failed to register PortSelector: ${portSelectorResult.error.message}`);
  }
  const platformUIPortResult = container2.registerClass(
    platformUIPortToken,
    DIFoundryUIAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(platformUIPortResult)) {
    return err(`Failed to register PlatformUIPort: ${platformUIPortResult.error.message}`);
  }
  const journalDirectoryUiAliasResult = container2.registerAlias(
    platformJournalDirectoryUiPortToken,
    platformUIPortToken
  );
  if (isErr(journalDirectoryUiAliasResult)) {
    return err(
      `Failed to register PlatformJournalDirectoryUiPort alias: ${journalDirectoryUiAliasResult.error.message}`
    );
  }
  const uiNotificationAliasResult = container2.registerAlias(
    platformUINotificationPortToken,
    platformUIPortToken
  );
  if (isErr(uiNotificationAliasResult)) {
    return err(
      `Failed to register UINotificationPort alias: ${uiNotificationAliasResult.error.message}`
    );
  }
  const platformValidationPortResult = container2.registerClass(
    platformValidationPortToken,
    DIValibotValidationAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(platformValidationPortResult)) {
    return err(
      `Failed to register PlatformValidationPort: ${platformValidationPortResult.error.message}`
    );
  }
  const loggingPortAliasResult = container2.registerAlias(platformLoggingPortToken, loggerToken);
  if (isErr(loggingPortAliasResult)) {
    return err(
      `Failed to register PlatformLoggingPort alias: ${loggingPortAliasResult.error.message}`
    );
  }
  const metricsSnapshotPortResult = container2.registerClass(
    platformMetricsSnapshotPortToken,
    DIMetricsSnapshotAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(metricsSnapshotPortResult)) {
    return err(
      `Failed to register PlatformMetricsSnapshotPort: ${metricsSnapshotPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerPortInfrastructure, "registerPortInfrastructure");
function registerPortRegistries(container2) {
  const portsResult = createPortRegistries(container2);
  if (isErr(portsResult)) return portsResult;
  const {
    gamePortRegistry,
    hooksPortRegistry,
    documentPortRegistry,
    uiPortRegistry,
    settingsPortRegistry,
    i18nPortRegistry,
    modulePortRegistry
  } = portsResult.value;
  const gameRegistryResult = container2.registerValue(
    foundryGamePortRegistryToken,
    gamePortRegistry
  );
  if (isErr(gameRegistryResult)) {
    return err(`Failed to register FoundryGame PortRegistry: ${gameRegistryResult.error.message}`);
  }
  const hooksRegistryResult = container2.registerValue(
    foundryHooksPortRegistryToken,
    hooksPortRegistry
  );
  if (isErr(hooksRegistryResult)) {
    return err(
      `Failed to register FoundryHooks PortRegistry: ${hooksRegistryResult.error.message}`
    );
  }
  const documentRegistryResult = container2.registerValue(
    foundryDocumentPortRegistryToken,
    documentPortRegistry
  );
  if (isErr(documentRegistryResult)) {
    return err(
      `Failed to register FoundryDocument PortRegistry: ${documentRegistryResult.error.message}`
    );
  }
  const uiRegistryResult = container2.registerValue(foundryUIPortRegistryToken, uiPortRegistry);
  if (isErr(uiRegistryResult)) {
    return err(`Failed to register FoundryUI PortRegistry: ${uiRegistryResult.error.message}`);
  }
  const settingsRegistryResult = container2.registerValue(
    foundrySettingsPortRegistryToken,
    settingsPortRegistry
  );
  if (isErr(settingsRegistryResult)) {
    return err(
      `Failed to register FoundrySettings PortRegistry: ${settingsRegistryResult.error.message}`
    );
  }
  const i18nRegistryResult = container2.registerValue(
    foundryI18nPortRegistryToken,
    i18nPortRegistry
  );
  if (isErr(i18nRegistryResult)) {
    return err(`Failed to register FoundryI18n PortRegistry: ${i18nRegistryResult.error.message}`);
  }
  const moduleRegistryResult = container2.registerValue(
    foundryModulePortRegistryToken,
    modulePortRegistry
  );
  if (isErr(moduleRegistryResult)) {
    return err(
      `Failed to register FoundryModule PortRegistry: ${moduleRegistryResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerPortRegistries, "registerPortRegistries");
registerDependencyStep({
  name: "PortInfrastructure",
  priority: 60,
  execute: registerPortInfrastructure
});
const cacheServiceConfigToken = createInjectionToken("CacheServiceConfig");
const cacheServiceToken = createInjectionToken("CacheService");
const cacheConfigSyncToken = createInjectionToken("CacheConfigSync");
const cacheMaintenancePortToken = createInjectionToken("CacheMaintenancePort");
const _CacheStore = class _CacheStore {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  get(key2) {
    return this.store.get(key2);
  }
  set(key2, entry) {
    this.store.set(key2, entry);
  }
  delete(key2) {
    return this.store.delete(key2);
  }
  has(key2) {
    return this.store.has(key2);
  }
  clear() {
    const size3 = this.store.size;
    this.store.clear();
    return size3;
  }
  get size() {
    return this.store.size;
  }
  entries() {
    return this.store.entries();
  }
};
__name(_CacheStore, "CacheStore");
let CacheStore = _CacheStore;
function clampTtl$1(ttl, fallback2) {
  if (typeof ttl !== "number" || Number.isNaN(ttl)) {
    return fallback2;
  }
  return ttl < 0 ? 0 : ttl;
}
__name(clampTtl$1, "clampTtl$1");
function defaultClock() {
  return Date.now();
}
__name(defaultClock, "defaultClock");
const _CacheExpirationManager = class _CacheExpirationManager {
  constructor(clock) {
    this.clock = clock ?? defaultClock;
  }
  isExpired(entry, now2) {
    return typeof entry.expiresAt === "number" && entry.expiresAt > 0 && entry.expiresAt <= now2;
  }
  createMetadata(key2, options2, now2, defaultTtlMs) {
    const ttlMs = clampTtl$1(options2?.ttlMs, defaultTtlMs);
    const expiresAt = ttlMs > 0 ? now2 + ttlMs : null;
    const tags = options2?.tags ? Array.from(new Set(options2.tags.map((tag2) => String(tag2)))) : [];
    return {
      key: key2,
      createdAt: now2,
      expiresAt,
      lastAccessedAt: now2,
      hits: 0,
      tags
    };
  }
  handleExpiration(key2, store2) {
    return store2.delete(key2);
  }
};
__name(_CacheExpirationManager, "CacheExpirationManager");
let CacheExpirationManager = _CacheExpirationManager;
const _CacheStatisticsCollector = class _CacheStatisticsCollector {
  constructor(metricsObserver) {
    this.metricsObserver = metricsObserver;
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0
    };
  }
  recordHit(key2) {
    this.metricsObserver.onCacheHit(key2);
    this.stats.hits++;
  }
  recordMiss(key2) {
    this.metricsObserver.onCacheMiss(key2);
    this.stats.misses++;
  }
  recordEviction(key2) {
    this.metricsObserver.onCacheEviction(key2);
    this.stats.evictions++;
  }
  getStatistics(size3, enabled) {
    return {
      hits: this.stats.hits,
      misses: this.stats.misses,
      evictions: this.stats.evictions,
      size: size3,
      enabled
    };
  }
  reset() {
    this.stats.hits = 0;
    this.stats.misses = 0;
    this.stats.evictions = 0;
  }
};
__name(_CacheStatisticsCollector, "CacheStatisticsCollector");
let CacheStatisticsCollector = _CacheStatisticsCollector;
const DEFAULT_CACHE_SERVICE_CONFIG$1 = {
  enabled: true,
  defaultTtlMs: APP_DEFAULTS.CACHE_TTL_MS,
  namespace: "global"
};
function clampTtl(ttl, fallback2) {
  if (typeof ttl !== "number" || Number.isNaN(ttl)) {
    return fallback2;
  }
  return ttl < 0 ? 0 : ttl;
}
__name(clampTtl, "clampTtl");
const _CacheConfigManager = class _CacheConfigManager {
  constructor(config2 = DEFAULT_CACHE_SERVICE_CONFIG$1) {
    const resolvedMaxEntries = typeof config2?.maxEntries === "number" && config2.maxEntries > 0 ? config2.maxEntries : void 0;
    this.config = {
      ...DEFAULT_CACHE_SERVICE_CONFIG$1,
      ...config2,
      defaultTtlMs: clampTtl(config2?.defaultTtlMs, DEFAULT_CACHE_SERVICE_CONFIG$1.defaultTtlMs),
      ...resolvedMaxEntries !== void 0 ? { maxEntries: resolvedMaxEntries } : {}
    };
  }
  updateConfig(partial2) {
    const merged = {
      ...this.config,
      ...partial2
    };
    merged.defaultTtlMs = clampTtl(merged.defaultTtlMs, DEFAULT_CACHE_SERVICE_CONFIG$1.defaultTtlMs);
    this.config = merged;
  }
  getConfig() {
    return { ...this.config };
  }
  isEnabled() {
    return this.config.enabled;
  }
};
__name(_CacheConfigManager, "CacheConfigManager");
let CacheConfigManager = _CacheConfigManager;
const _CacheCapacityManager = class _CacheCapacityManager {
  constructor(strategy, store2) {
    this.strategy = strategy;
    this.store = store2;
  }
  /**
   * Enforces capacity limit by evicting entries using the configured strategy.
   *
   * @param maxEntries - The maximum number of entries allowed
   * @returns Array of cache keys that were evicted
   */
  enforceCapacity(maxEntries2) {
    if (this.store.size <= maxEntries2) {
      return [];
    }
    const entriesMap = /* @__PURE__ */ new Map();
    for (const [key2, entry] of this.store.entries()) {
      entriesMap.set(key2, entry);
    }
    const keysToEvict = this.strategy.selectForEviction(entriesMap, maxEntries2);
    for (const key2 of keysToEvict) {
      this.store.delete(key2);
    }
    return keysToEvict;
  }
};
__name(_CacheCapacityManager, "CacheCapacityManager");
let CacheCapacityManager = _CacheCapacityManager;
const _LRUEvictionStrategy = class _LRUEvictionStrategy {
  /**
   * Selects entries for eviction using LRU algorithm.
   *
   * Sorts entries by lastAccessedAt (ascending) and selects the oldest entries
   * until the cache size is within maxEntries limit.
   *
   * @param entries - The current cache entries
   * @param maxEntries - The maximum number of entries allowed
   * @returns Array of cache keys to evict (oldest first)
   */
  selectForEviction(entries2, maxEntries2) {
    const toRemove = entries2.size - maxEntries2;
    if (toRemove <= 0) {
      return [];
    }
    const sorted = Array.from(entries2.entries()).sort(
      (a, b) => a[1].metadata.lastAccessedAt - b[1].metadata.lastAccessedAt
    );
    return sorted.slice(0, toRemove).map(([key2]) => key2);
  }
};
__name(_LRUEvictionStrategy, "LRUEvictionStrategy");
let LRUEvictionStrategy = _LRUEvictionStrategy;
const _EvictionStrategyRegistry = class _EvictionStrategyRegistry {
  constructor() {
    this.strategies = /* @__PURE__ */ new Map();
  }
  /**
   * Gets the singleton instance of the registry.
   *
   * @returns The singleton registry instance
   */
  static getInstance() {
    if (!_EvictionStrategyRegistry.instance) {
      _EvictionStrategyRegistry.instance = new _EvictionStrategyRegistry();
    }
    return _EvictionStrategyRegistry.instance;
  }
  /**
   * Registers a strategy with the given key.
   *
   * If a strategy with the same key already exists, it will be replaced.
   * This allows for runtime strategy updates.
   *
   * @param key - Unique identifier for the strategy (e.g., "lru", "fifo", "lfu")
   * @param strategy - The strategy instance to register
   * @returns true if a strategy was replaced, false if it's a new registration
   */
  register(key2, strategy) {
    const wasReplaced = this.strategies.has(key2);
    this.strategies.set(key2, strategy);
    return wasReplaced;
  }
  /**
   * Gets a strategy by key.
   *
   * @param key - The strategy key
   * @returns The strategy if found, undefined otherwise
   */
  get(key2) {
    return this.strategies.get(key2);
  }
  /**
   * Gets a strategy by key, or returns the default strategy if not found.
   *
   * @param key - The strategy key
   * @param defaultKey - The key of the default strategy to use if key is not found
   * @returns The strategy if found, the default strategy if defaultKey is found, undefined otherwise
   */
  getOrDefault(key2, defaultKey) {
    if (!key2) {
      return this.get(defaultKey);
    }
    return this.get(key2) ?? this.get(defaultKey);
  }
  /**
   * Checks if a strategy is registered.
   *
   * @param key - The strategy key
   * @returns true if the strategy is registered, false otherwise
   */
  has(key2) {
    return this.strategies.has(key2);
  }
  /**
   * Unregisters a strategy.
   *
   * @param key - The strategy key to unregister
   * @returns true if a strategy was removed, false if it didn't exist
   */
  unregister(key2) {
    return this.strategies.delete(key2);
  }
  /**
   * Gets all registered strategy keys.
   *
   * @returns Array of all registered strategy keys
   */
  getRegisteredKeys() {
    return Array.from(this.strategies.keys());
  }
  /**
   * Clears all registered strategies.
   * Useful for testing or reset scenarios.
   */
  clear() {
    this.strategies.clear();
  }
};
__name(_EvictionStrategyRegistry, "EvictionStrategyRegistry");
_EvictionStrategyRegistry.instance = null;
let EvictionStrategyRegistry = _EvictionStrategyRegistry;
const _CacheMetricsCollector = class _CacheMetricsCollector {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
  }
  /**
   * Records a cache hit.
   *
   * @param _key - The cache key that was hit
   */
  onCacheHit(_key) {
    this.metricsCollector?.recordCacheAccess(true);
  }
  /**
   * Records a cache miss.
   *
   * @param _key - The cache key that was missed
   */
  onCacheMiss(_key) {
    this.metricsCollector?.recordCacheAccess(false);
  }
  /**
   * Records a cache eviction.
   *
   * @param _key - The cache key that was evicted
   */
  onCacheEviction(_key) {
  }
};
__name(_CacheMetricsCollector, "CacheMetricsCollector");
let CacheMetricsCollector = _CacheMetricsCollector;
function toStringKeyArray(allowed) {
  return allowed;
}
__name(toStringKeyArray, "toStringKeyArray");
function castCacheValue(value2) {
  return value2;
}
__name(castCacheValue, "castCacheValue");
function getFirstArrayElement$1(array3) {
  return array3[0];
}
__name(getFirstArrayElement$1, "getFirstArrayElement$1");
function getFirstElementIfArray(value2, typeGuard) {
  if (Array.isArray(value2) && value2.length > 0) {
    const firstElement = value2[0];
    if (typeGuard(firstElement)) {
      return firstElement;
    }
  }
  return null;
}
__name(getFirstElementIfArray, "getFirstElementIfArray");
function castToRecord(value2) {
  return value2;
}
__name(castToRecord, "castToRecord");
function normalizeToRecord(value2) {
  return Object.assign({}, value2);
}
__name(normalizeToRecord, "normalizeToRecord");
function assertCacheKey(value2) {
  return value2;
}
__name(assertCacheKey, "assertCacheKey");
const _CacheRuntime = class _CacheRuntime {
  constructor(store2, expirationManager, configManager, telemetry, policy, clock) {
    this.store = store2;
    this.expirationManager = expirationManager;
    this.configManager = configManager;
    this.telemetry = telemetry;
    this.policy = policy;
    this.clock = clock;
  }
  get(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) {
      return null;
    }
    const entry = this.store.get(key2);
    if (!entry) {
      this.telemetry.recordMiss(key2);
      return null;
    }
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      this.handleExpiration(key2, entry);
      this.telemetry.recordEviction(key2);
      this.telemetry.recordMiss(key2);
      return null;
    }
    entry.metadata.hits += 1;
    entry.metadata.lastAccessedAt = now2;
    this.telemetry.recordHit(key2);
    return {
      hit: true,
      value: castCacheValue(entry.value),
      metadata: this.cloneMetadata(entry.metadata)
    };
  }
  set(key2, value2, options2) {
    const now2 = this.clock();
    const config2 = this.configManager.getConfig();
    const metadata2 = this.expirationManager.createMetadata(key2, options2, now2, config2.defaultTtlMs);
    if (!config2.enabled) {
      return metadata2;
    }
    const entry = {
      value: value2,
      expiresAt: metadata2.expiresAt,
      metadata: metadata2
    };
    this.store.set(key2, entry);
    const evictedKeys = this.policy.enforceCapacity(this.store.size, config2);
    for (const evictedKey of evictedKeys) {
      this.telemetry.recordEviction(evictedKey);
    }
    return { ...metadata2, tags: [...metadata2.tags] };
  }
  async getOrSet(key2, factory, options2) {
    const existing = this.get(key2);
    if (existing) {
      return ok(existing);
    }
    let factoryValue;
    try {
      const factoryResult = factory();
      if (factoryResult instanceof Promise) {
        const asyncResult = await fromPromise(
          factoryResult,
          (error3) => `Factory failed for cache key ${String(key2)}: ${String(error3)}`
        );
        if (!asyncResult.ok) {
          return asyncResult;
        }
        factoryValue = asyncResult.value;
      } else {
        factoryValue = factoryResult;
      }
    } catch (error3) {
      return err(`Factory failed for cache key ${String(key2)}: ${String(error3)}`);
    }
    const metadata2 = this.set(key2, factoryValue, options2);
    return ok({
      hit: false,
      value: factoryValue,
      metadata: metadata2
    });
  }
  handleExpiration(key2, entry) {
    const now2 = this.clock();
    if (this.expirationManager.isExpired(entry, now2)) {
      this.expirationManager.handleExpiration(key2, this.store);
    }
  }
  cloneMetadata(metadata2) {
    return {
      ...metadata2,
      tags: [...metadata2.tags]
    };
  }
};
__name(_CacheRuntime, "CacheRuntime");
let CacheRuntime = _CacheRuntime;
const _CachePolicy = class _CachePolicy {
  constructor(capacityManager) {
    this.capacityManager = capacityManager;
  }
  enforceCapacity(currentSize, config2) {
    if (!config2.maxEntries || currentSize <= config2.maxEntries) {
      return [];
    }
    return this.capacityManager.enforceCapacity(config2.maxEntries);
  }
  shouldExpire(expiresAt, now2) {
    if (expiresAt === null) {
      return false;
    }
    return now2 >= expiresAt;
  }
};
__name(_CachePolicy, "CachePolicy");
let CachePolicy = _CachePolicy;
const _CacheTelemetry = class _CacheTelemetry {
  constructor(statisticsCollector) {
    this.statisticsCollector = statisticsCollector;
  }
  recordHit(key2) {
    this.statisticsCollector.recordHit(key2);
  }
  recordMiss(key2) {
    this.statisticsCollector.recordMiss(key2);
  }
  recordEviction(key2) {
    this.statisticsCollector.recordEviction(key2);
  }
  getStatistics(currentSize, enabled) {
    return this.statisticsCollector.getStatistics(currentSize, enabled);
  }
};
__name(_CacheTelemetry, "CacheTelemetry");
let CacheTelemetry = _CacheTelemetry;
const _CacheCompositionFactory = class _CacheCompositionFactory {
  /**
   * Creates a complete cache composition from configuration.
   *
   * @param config - Cache service configuration
   * @param metricsCollector - Optional metrics collector
   * @param clock - Clock function (defaults to Date.now)
   * @param capacityManager - Optional capacity manager (created if not provided)
   * @param metricsObserver - Optional metrics observer (created if not provided)
   * @param store - Optional store (created if not provided)
   * @param expirationManager - Optional expiration manager (created if not provided)
   * @param statisticsCollector - Optional statistics collector (created if not provided)
   * @param configManager - Optional config manager (created if not provided)
   * @param runtime - Optional runtime (created if not provided)
   * @param policy - Optional policy (created if not provided)
   * @param telemetry - Optional telemetry (created if not provided)
   * @returns Complete cache composition
   */
  create(config2, metricsCollector, clock = () => Date.now(), capacityManager, metricsObserver, store2, expirationManager, statisticsCollector, configManager, runtime, policy, telemetry) {
    const resolvedStore = store2 ?? new CacheStore();
    const resolvedConfigManager = configManager ?? new CacheConfigManager(config2);
    const resolvedExpirationManager = expirationManager ?? new CacheExpirationManager(clock);
    let resolvedCapacityManager = capacityManager;
    if (!resolvedCapacityManager) {
      const registry = EvictionStrategyRegistry.getInstance();
      if (!registry.has("lru")) {
        registry.register("lru", new LRUEvictionStrategy());
      }
      const strategyKey = config2.evictionStrategyKey ?? "lru";
      const strategy = registry.getOrDefault(strategyKey, "lru");
      if (!strategy) {
        resolvedCapacityManager = new CacheCapacityManager(
          new LRUEvictionStrategy(),
          resolvedStore
        );
      } else {
        resolvedCapacityManager = new CacheCapacityManager(strategy, resolvedStore);
      }
    }
    const resolvedMetricsObserver = metricsObserver ?? new CacheMetricsCollector(metricsCollector);
    const resolvedStatisticsCollector = statisticsCollector ?? new CacheStatisticsCollector(resolvedMetricsObserver);
    const resolvedTelemetry = telemetry ?? new CacheTelemetry(resolvedStatisticsCollector);
    const resolvedPolicy = policy ?? new CachePolicy(resolvedCapacityManager);
    const resolvedRuntime = runtime ?? new CacheRuntime(
      resolvedStore,
      resolvedExpirationManager,
      resolvedConfigManager,
      resolvedTelemetry,
      resolvedPolicy,
      clock
    );
    return {
      runtime: resolvedRuntime,
      policy: resolvedPolicy,
      telemetry: resolvedTelemetry,
      store: resolvedStore,
      configManager: resolvedConfigManager,
      expirationManager: resolvedExpirationManager
    };
  }
};
__name(_CacheCompositionFactory, "CacheCompositionFactory");
let CacheCompositionFactory = _CacheCompositionFactory;
const DEFAULT_CACHE_SERVICE_CONFIG = {
  enabled: true,
  defaultTtlMs: APP_DEFAULTS.CACHE_TTL_MS,
  namespace: "global"
};
const _CacheService = class _CacheService {
  constructor(runtime, policy, telemetry, store2, configManager, expirationManager, clock = () => Date.now()) {
    this.runtime = runtime;
    this.policy = policy;
    this.telemetry = telemetry;
    this.store = store2;
    this.configManager = configManager;
    this.expirationManager = expirationManager;
    this.clock = clock;
  }
  get isEnabled() {
    return this.configManager.isEnabled();
  }
  get size() {
    return this.store.size;
  }
  get(key2) {
    return this.runtime.get(key2);
  }
  async getOrSet(key2, factory, options2) {
    return this.runtime.getOrSet(key2, factory, options2);
  }
  set(key2, value2, options2) {
    return this.runtime.set(key2, value2, options2);
  }
  delete(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return false;
    const removed = this.store.delete(key2);
    if (removed) {
      this.telemetry.recordEviction(key2);
    }
    return removed;
  }
  has(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return false;
    const entry = this.store.get(key2);
    if (!entry) {
      return false;
    }
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      this.expirationManager.handleExpiration(key2, this.store);
      this.telemetry.recordEviction(key2);
      return false;
    }
    return true;
  }
  clear() {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return 0;
    const keysToEvict = [];
    for (const [key2] of this.store.entries()) {
      keysToEvict.push(key2);
    }
    const removed = this.store.clear();
    if (removed > 0) {
      for (const key2 of keysToEvict) {
        this.telemetry.recordEviction(key2);
      }
    }
    return removed;
  }
  invalidateWhere(predicate) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return 0;
    let removed = 0;
    const keysToEvict = [];
    for (const [key2, entry] of this.store.entries()) {
      if (predicate(entry.metadata)) {
        keysToEvict.push(key2);
      }
    }
    for (const key2 of keysToEvict) {
      if (this.store.delete(key2)) {
        removed++;
        this.telemetry.recordEviction(key2);
      }
    }
    return removed;
  }
  getMetadata(key2) {
    const config2 = this.configManager.getConfig();
    if (!config2.enabled) return null;
    const entry = this.store.get(key2);
    if (!entry) return null;
    const now2 = this.clock();
    if (this.policy.shouldExpire(entry.expiresAt, now2)) {
      const wasRemoved = this.expirationManager.handleExpiration(key2, this.store);
      if (wasRemoved) {
        this.telemetry.recordEviction(key2);
      }
      return null;
    }
    return this.cloneMetadata(entry.metadata);
  }
  getStatistics() {
    return this.telemetry.getStatistics(this.store.size, this.isEnabled);
  }
  getConfigManager() {
    return this.configManager;
  }
  getStore() {
    return this.store;
  }
  getPolicy() {
    return this.policy;
  }
  cloneMetadata(metadata2) {
    return {
      ...metadata2,
      tags: [...metadata2.tags]
    };
  }
};
__name(_CacheService, "CacheService");
let CacheService = _CacheService;
const _DICacheService = class _DICacheService extends CacheService {
  constructor(_config, _metrics) {
    const factory = new CacheCompositionFactory();
    const composition = factory.create(_config, _metrics);
    super(
      composition.runtime,
      composition.policy,
      composition.telemetry,
      composition.store,
      composition.configManager,
      composition.expirationManager
    );
  }
};
__name(_DICacheService, "DICacheService");
_DICacheService.dependencies = [cacheServiceConfigToken, metricsCollectorToken];
let DICacheService = _DICacheService;
const _CacheConfigSyncObserver = class _CacheConfigSyncObserver {
  constructor(store2, policy, configManager) {
    this.store = store2;
    this.policy = policy;
    this.configManager = configManager;
  }
  /**
   * Called when cache configuration is updated.
   * Implements CacheConfigObserver to react to configuration changes.
   *
   * @param config - The updated cache configuration
   */
  onConfigUpdated(config2) {
    if (!config2.enabled) {
      this.clearStore();
      return;
    }
    const currentConfig = this.configManager.getConfig();
    if (typeof config2.maxEntries === "number" && config2.maxEntries !== currentConfig.maxEntries) {
      this.enforceCapacity(config2);
    }
  }
  clearStore() {
    this.store.clear();
  }
  enforceCapacity(config2) {
    if (!config2.maxEntries) {
      return;
    }
    this.policy.enforceCapacity(this.store.size, config2);
  }
};
__name(_CacheConfigSyncObserver, "CacheConfigSyncObserver");
let CacheConfigSyncObserver = _CacheConfigSyncObserver;
const _CacheConfigSync = class _CacheConfigSync {
  constructor(runtimeConfig, cacheMaintenance) {
    this.runtimeConfig = runtimeConfig;
    this.cacheMaintenance = cacheMaintenance;
    this.unsubscribe = null;
    this.observer = new CacheConfigSyncObserver(
      cacheMaintenance.getStore(),
      cacheMaintenance.getPolicy(),
      cacheMaintenance.getConfigManager()
    );
  }
  /**
   * Binds RuntimeConfig changes to CacheService.
   * Returns unsubscribe function for cleanup.
   *
   * @returns Unsubscribe function to clean up all subscriptions
   */
  bind() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
    const unsubscribers = [];
    unsubscribers.push(
      this.runtimeConfig.onChange("enableCacheService", (enabled) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({ enabled });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    unsubscribers.push(
      this.runtimeConfig.onChange("cacheDefaultTtlMs", (ttl) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({ defaultTtlMs: ttl });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    unsubscribers.push(
      this.runtimeConfig.onChange("cacheMaxEntries", (maxEntries2) => {
        const configManager = this.cacheMaintenance.getConfigManager();
        configManager.updateConfig({
          maxEntries: typeof maxEntries2 === "number" && maxEntries2 > 0 ? maxEntries2 : void 0
        });
        this.observer.onConfigUpdated(configManager.getConfig());
      })
    );
    this.unsubscribe = () => {
      for (const unsubscribe of unsubscribers) {
        unsubscribe();
      }
      this.unsubscribe = null;
    };
    return this.unsubscribe;
  }
  /**
   * Unbinds RuntimeConfig synchronization.
   */
  unbind() {
    this.unsubscribe?.();
  }
};
__name(_CacheConfigSync, "CacheConfigSync");
let CacheConfigSync = _CacheConfigSync;
const _DICacheConfigSync = class _DICacheConfigSync extends CacheConfigSync {
  constructor(runtimeConfig, cacheMaintenance) {
    super(runtimeConfig, cacheMaintenance);
  }
};
__name(_DICacheConfigSync, "DICacheConfigSync");
_DICacheConfigSync.dependencies = [runtimeConfigToken];
let DICacheConfigSync = _DICacheConfigSync;
const _CachePortAdapter = class _CachePortAdapter {
  constructor(cacheService) {
    this.cacheService = cacheService;
  }
  /**
   * Maps Domain cache key (plain string) to Infrastructure cache key (branded type).
   */
  mapDomainKeyToInfrastructure(key2) {
    return assertCacheKey(key2);
  }
  /**
   * Maps Infrastructure cache key (branded type) to Domain cache key (plain string).
   */
  mapInfrastructureKeyToDomain(key2) {
    return key2;
  }
  /**
   * Maps Domain cache options to Infrastructure cache options.
   */
  mapDomainOptionsToInfrastructure(options2) {
    if (!options2) return void 0;
    const result = {};
    if (options2.ttlMs !== void 0) {
      result.ttlMs = options2.ttlMs;
    }
    if (options2.tags !== void 0) {
      result.tags = options2.tags;
    }
    return Object.keys(result).length > 0 ? result : void 0;
  }
  /**
   * Maps Infrastructure cache metadata to Domain cache metadata.
   */
  mapInfrastructureMetadataToDomain(metadata2) {
    return {
      key: this.mapInfrastructureKeyToDomain(metadata2.key),
      createdAt: metadata2.createdAt,
      expiresAt: metadata2.expiresAt,
      lastAccessedAt: metadata2.lastAccessedAt,
      hits: metadata2.hits,
      tags: metadata2.tags
    };
  }
  /**
   * Maps Infrastructure cache lookup result to Domain cache lookup result.
   */
  mapInfrastructureLookupResultToDomain(result) {
    const domainResult = {
      hit: result.hit,
      metadata: this.mapInfrastructureMetadataToDomain(result.metadata)
    };
    if (result.value !== void 0) {
      domainResult.value = result.value;
    }
    return domainResult;
  }
  /**
   * Maps Infrastructure cache statistics to Domain cache statistics.
   */
  mapInfrastructureStatisticsToDomain(statistics) {
    return {
      hits: statistics.hits,
      misses: statistics.misses,
      evictions: statistics.evictions,
      size: statistics.size,
      enabled: statistics.enabled
    };
  }
  /**
   * Maps Domain invalidation predicate to Infrastructure invalidation predicate.
   */
  mapDomainPredicateToInfrastructure(predicate) {
    return (entry) => {
      const domainEntry = this.mapInfrastructureMetadataToDomain(entry);
      return predicate(domainEntry);
    };
  }
  get isEnabled() {
    return this.cacheService.isEnabled;
  }
  get size() {
    return this.cacheService.size;
  }
  get(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const result = this.cacheService.get(infraKey);
    if (!result) return null;
    return this.mapInfrastructureLookupResultToDomain(result);
  }
  set(key2, value2, options2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const infraOptions = this.mapDomainOptionsToInfrastructure(options2);
    const metadata2 = this.cacheService.set(infraKey, value2, infraOptions);
    return this.mapInfrastructureMetadataToDomain(metadata2);
  }
  delete(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    return this.cacheService.delete(infraKey);
  }
  has(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    return this.cacheService.has(infraKey);
  }
  clear() {
    return this.cacheService.clear();
  }
  invalidateWhere(predicate) {
    const infraPredicate = this.mapDomainPredicateToInfrastructure(predicate);
    return this.cacheService.invalidateWhere(infraPredicate);
  }
  getMetadata(key2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const metadata2 = this.cacheService.getMetadata(infraKey);
    if (!metadata2) return null;
    return this.mapInfrastructureMetadataToDomain(metadata2);
  }
  getStatistics() {
    const statistics = this.cacheService.getStatistics();
    return this.mapInfrastructureStatisticsToDomain(statistics);
  }
  async getOrSet(key2, factory, options2) {
    const infraKey = this.mapDomainKeyToInfrastructure(key2);
    const infraOptions = this.mapDomainOptionsToInfrastructure(options2);
    const result = await this.cacheService.getOrSet(infraKey, factory, infraOptions);
    if (!result.ok) {
      return result;
    }
    return {
      ok: true,
      value: this.mapInfrastructureLookupResultToDomain(result.value)
    };
  }
};
__name(_CachePortAdapter, "CachePortAdapter");
let CachePortAdapter = _CachePortAdapter;
const _DICachePortAdapter = class _DICachePortAdapter extends CachePortAdapter {
  constructor(cacheService) {
    super(cacheService);
  }
};
__name(_DICachePortAdapter, "DICachePortAdapter");
_DICachePortAdapter.dependencies = [cacheServiceToken];
let DICachePortAdapter = _DICachePortAdapter;
function registerCacheServices(container2) {
  const runtimeConfig = container2.getRegisteredValue(runtimeConfigToken);
  if (!runtimeConfig) {
    return err("PlatformRuntimeConfigPort not registered");
  }
  const maxEntries2 = runtimeConfig.get("cacheMaxEntries");
  const config2 = {
    enabled: runtimeConfig.get("enableCacheService"),
    defaultTtlMs: runtimeConfig.get("cacheDefaultTtlMs"),
    namespace: MODULE_METADATA.ID,
    ...typeof maxEntries2 === "number" && maxEntries2 > 0 ? { maxEntries: maxEntries2 } : {}
  };
  const configResult = container2.registerValue(cacheServiceConfigToken, config2);
  if (isErr(configResult)) {
    return err(`Failed to register CacheServiceConfig: ${configResult.error.message}`);
  }
  const serviceResult = container2.registerFactory(
    cacheServiceToken,
    () => {
      const configResult2 = container2.resolveWithError(cacheServiceConfigToken);
      if (!configResult2.ok) {
        throw new Error(`Failed to resolve CacheServiceConfig: ${configResult2.error.message}`);
      }
      const metricsResult = container2.resolveWithError(
        metricsCollectorToken
      );
      const metricsCollector = metricsResult.ok ? metricsResult.value : void 0;
      const factory = new CacheCompositionFactory();
      const composition = factory.create(configResult2.value, metricsCollector);
      return new CacheService(
        composition.runtime,
        composition.policy,
        composition.telemetry,
        composition.store,
        composition.configManager,
        composition.expirationManager
      );
    },
    ServiceLifecycle.SINGLETON,
    [cacheServiceConfigToken, metricsCollectorToken]
  );
  if (isErr(serviceResult)) {
    return err(`Failed to register CacheService: ${serviceResult.error.message}`);
  }
  const maintenancePortResult = container2.registerFactory(
    cacheMaintenancePortToken,
    () => {
      const serviceResult2 = container2.resolveWithError(cacheServiceToken);
      if (!serviceResult2.ok) {
        throw new Error(`Failed to resolve CacheService: ${serviceResult2.error.message}`);
      }
      return serviceResult2.value;
    },
    ServiceLifecycle.SINGLETON,
    [cacheServiceToken]
  );
  if (isErr(maintenancePortResult)) {
    return err(`Failed to register CacheMaintenancePort: ${maintenancePortResult.error.message}`);
  }
  const readerPortResult = container2.registerClass(
    cacheReaderPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(readerPortResult)) {
    return err(`Failed to register CacheReaderPort: ${readerPortResult.error.message}`);
  }
  const writerPortResult = container2.registerClass(
    cacheWriterPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(writerPortResult)) {
    return err(`Failed to register CacheWriterPort: ${writerPortResult.error.message}`);
  }
  const invalidationPortResult = container2.registerClass(
    cacheInvalidationPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(invalidationPortResult)) {
    return err(`Failed to register CacheInvalidationPort: ${invalidationPortResult.error.message}`);
  }
  const statsPortResult = container2.registerClass(
    cacheStatsPortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(statsPortResult)) {
    return err(`Failed to register CacheStatsPort: ${statsPortResult.error.message}`);
  }
  const computePortResult = container2.registerClass(
    cacheComputePortToken,
    DICachePortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(computePortResult)) {
    return err(`Failed to register CacheComputePort: ${computePortResult.error.message}`);
  }
  const configSyncResult = container2.registerFactory(
    cacheConfigSyncToken,
    () => {
      const runtimeConfigResult = container2.resolveWithError(runtimeConfigToken);
      if (!runtimeConfigResult.ok) {
        throw new Error(
          `Failed to resolve PlatformRuntimeConfigPort: ${runtimeConfigResult.error.message}`
        );
      }
      const maintenancePortResult2 = container2.resolveWithError(cacheMaintenancePortToken);
      if (!maintenancePortResult2.ok) {
        throw new Error(
          `Failed to resolve CacheMaintenancePort: ${maintenancePortResult2.error.message}`
        );
      }
      return new DICacheConfigSync(runtimeConfigResult.value, maintenancePortResult2.value);
    },
    ServiceLifecycle.SINGLETON,
    [runtimeConfigToken, cacheMaintenancePortToken]
  );
  if (isErr(configSyncResult)) {
    return err(`Failed to register CacheConfigSync: ${configSyncResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerCacheServices, "registerCacheServices");
function initializeCacheConfigSync(container2) {
  const configSyncResult = container2.resolveWithError(cacheConfigSyncToken);
  if (!configSyncResult.ok) {
    return ok(void 0);
  }
  const configSync = configSyncResult.value;
  configSync.bind();
  return ok(void 0);
}
__name(initializeCacheConfigSync, "initializeCacheConfigSync");
registerDependencyStep({
  name: "CacheServices",
  priority: 50,
  execute: registerCacheServices
});
const platformBootstrapEventPortToken = createInjectionToken(
  "PlatformBootstrapEventPort"
);
const metricsRecorderToken = createInjectionToken("MetricsRecorder");
const metricsSamplerToken = createInjectionToken("MetricsSampler");
const metricsReporterToken = createInjectionToken("MetricsReporter");
const traceContextToken = createInjectionToken("TraceContext");
const metricsStorageToken = createInjectionToken("MetricsStorage");
const metricsAggregatorToken = createInjectionToken("MetricsAggregator");
const metricsPersistenceManagerToken = createInjectionToken(
  "MetricsPersistenceManager"
);
const metricsStateManagerToken = createInjectionToken("MetricsStateManager");
const moduleApiInitializerToken = createInjectionToken("ModuleApiInitializer");
const moduleHealthServiceToken = createInjectionToken("ModuleHealthService");
function isValidMetricDefinition(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  return "key" in value2 && typeof value2.key === "string" && "initialValue" in value2 && typeof value2.initialValue !== "undefined" && "reducer" in value2 && typeof value2.reducer === "function" && "serializer" in value2 && typeof value2.serializer === "function";
}
__name(isValidMetricDefinition, "isValidMetricDefinition");
function castToMetricDefinition(definition) {
  if (!isValidMetricDefinition(definition)) {
    throw new Error(`Invalid metric definition structure for key "${definition.key}"`);
  }
  return definition;
}
__name(castToMetricDefinition, "castToMetricDefinition");
function castMetricValue(value2, key2) {
  if (value2 === void 0) {
    throw new Error(
      `Metric value for key "${key2}" is undefined. This indicates a registry initialization issue.`
    );
  }
  return value2;
}
__name(castMetricValue, "castMetricValue");
const _MetricDefinitionRegistry = class _MetricDefinitionRegistry {
  constructor() {
    this.definitions = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a metric definition.
   *
   * @param definition - Metric definition to register
   * @throws Error if a definition with the same key already exists or if the definition is invalid
   */
  register(definition) {
    if (this.definitions.has(definition.key)) {
      throw new Error(
        `Metric definition with key "${definition.key}" already exists. Use a different key or remove the existing definition first.`
      );
    }
    this.definitions.set(definition.key, castToMetricDefinition(definition));
  }
  /**
   * Gets a metric definition by key.
   *
   * @param key - Metric key
   * @returns Metric definition or undefined if not found
   */
  get(key2) {
    return this.definitions.get(key2);
  }
  /**
   * Gets all registered metric definitions.
   *
   * @returns Array of all metric definitions
   */
  getAll() {
    return Array.from(this.definitions.values());
  }
  /**
   * Checks if a metric definition exists.
   *
   * @param key - Metric key
   * @returns True if definition exists
   */
  has(key2) {
    return this.definitions.has(key2);
  }
  /**
   * Removes a metric definition.
   *
   * @param key - Metric key to remove
   * @returns True if definition was removed, false if it didn't exist
   */
  remove(key2) {
    return this.definitions.delete(key2);
  }
  /**
   * Clears all registered definitions.
   */
  clear() {
    this.definitions.clear();
  }
  /**
   * Gets the number of registered definitions.
   *
   * @returns Number of registered definitions
   */
  size() {
    return this.definitions.size;
  }
};
__name(_MetricDefinitionRegistry, "MetricDefinitionRegistry");
let MetricDefinitionRegistry = _MetricDefinitionRegistry;
function isResolutionEvent(event3) {
  return typeof event3 === "object" && event3 !== null && "durationMs" in event3 && typeof event3.durationMs === "number" && "success" in event3 && typeof event3.success === "boolean";
}
__name(isResolutionEvent, "isResolutionEvent");
function isPortSelectionEvent(event3) {
  return typeof event3 === "object" && event3 !== null && "version" in event3 && typeof event3.version === "number";
}
__name(isPortSelectionEvent, "isPortSelectionEvent");
function isCacheAccessEvent(event3) {
  return typeof event3 === "object" && event3 !== null && "hit" in event3 && typeof event3.hit === "boolean";
}
__name(isCacheAccessEvent, "isCacheAccessEvent");
const containerResolutionsDefinition = {
  key: "containerResolutions",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, _event) => current + 1, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const resolutionErrorsDefinition = {
  key: "resolutionErrors",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isResolutionEvent(event3)) {
      return current;
    }
    return event3.success ? current : current + 1;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const cacheHitsDefinition = {
  key: "cacheHits",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isCacheAccessEvent(event3)) {
      return current;
    }
    return event3.hit ? current + 1 : current;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const cacheMissesDefinition = {
  key: "cacheMisses",
  initialValue: 0,
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isCacheAccessEvent(event3)) {
      return current;
    }
    return event3.hit ? current : current + 1;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => value2, "serializer")
};
const portSelectionsDefinition = {
  key: "portSelections",
  initialValue: /* @__PURE__ */ new Map(),
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isPortSelectionEvent(event3)) {
      return current;
    }
    const count = current.get(event3.version) ?? 0;
    const updated = new Map(current);
    updated.set(event3.version, count + 1);
    return updated;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => Object.fromEntries(value2), "serializer")
};
const portSelectionFailuresDefinition = {
  key: "portSelectionFailures",
  initialValue: /* @__PURE__ */ new Map(),
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isPortSelectionEvent(event3)) {
      return current;
    }
    const count = current.get(event3.version) ?? 0;
    const updated = new Map(current);
    updated.set(event3.version, count + 1);
    return updated;
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => Object.fromEntries(value2), "serializer")
};
const resolutionTimesDefinition = {
  key: "resolutionTimes",
  initialValue: {
    buffer: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
    index: 0,
    count: 0
  },
  reducer: /* @__PURE__ */ __name((current, event3) => {
    if (!isResolutionEvent(event3)) {
      return current;
    }
    const buffer = new Float64Array(current.buffer);
    const maxSize2 = METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE;
    buffer[current.index] = event3.durationMs;
    const newIndex = (current.index + 1) % maxSize2;
    const newCount = Math.min(current.count + 1, maxSize2);
    return {
      buffer,
      index: newIndex,
      count: newCount
    };
  }, "reducer"),
  serializer: /* @__PURE__ */ __name((value2) => ({
    buffer: Array.from(value2.buffer),
    index: value2.index,
    count: value2.count
  }), "serializer")
};
function createDefaultMetricDefinitionRegistry() {
  const registry = new MetricDefinitionRegistry();
  registry.register(containerResolutionsDefinition);
  registry.register(resolutionErrorsDefinition);
  registry.register(cacheHitsDefinition);
  registry.register(cacheMissesDefinition);
  registry.register(portSelectionsDefinition);
  registry.register(portSelectionFailuresDefinition);
  registry.register(resolutionTimesDefinition);
  return registry;
}
__name(createDefaultMetricDefinitionRegistry, "createDefaultMetricDefinitionRegistry");
const _MetricsCollector = class _MetricsCollector {
  constructor(config2, aggregator, persistenceManager, stateManager, registry) {
    this.config = config2;
    this.metricStates = /* @__PURE__ */ new Map();
    this.registry = registry ?? createDefaultMetricDefinitionRegistry();
    this.initializeMetricStates();
    this.aggregator = aggregator;
    this.persistenceManager = persistenceManager;
    this.stateManager = stateManager;
  }
  /**
   * Initializes metric states from registry definitions.
   * Private method called during construction.
   */
  initializeMetricStates() {
    for (const definition of this.registry.getAll()) {
      this.metricStates.set(definition.key, {
        value: definition.initialValue,
        definition
      });
    }
  }
  /**
   * Updates a metric using its reducer function.
   *
   * @param key - Metric key
   * @param event - Event data for the reducer
   */
  updateMetric(key2, event3) {
    const state2 = this.metricStates.get(key2);
    if (!state2) {
      return;
    }
    const newValue = state2.definition.reducer(state2.value, event3);
    this.metricStates.set(key2, {
      value: newValue,
      definition: state2.definition
    });
  }
  /**
   * Records a service resolution attempt.
   *
   * @param token - The injection token that was resolved
   * @param durationMs - Time taken to resolve in milliseconds
   * @param success - Whether resolution succeeded
   */
  recordResolution(token, durationMs, success) {
    const event3 = { token, durationMs, success };
    this.updateMetric("containerResolutions", event3);
    this.updateMetric("resolutionErrors", event3);
    this.updateMetric("resolutionTimes", event3);
    this.notifyStateChanged();
  }
  /**
   * Records a port selection event.
   *
   * @param version - The Foundry version for which a port was selected
   */
  recordPortSelection(version2) {
    this.updateMetric("portSelections", { version: version2 });
    this.notifyStateChanged();
  }
  /**
   * Records a port selection failure.
   *
   * Useful for tracking when no compatible port is available for a version.
   *
   * @param version - The Foundry version for which port selection failed
   */
  recordPortSelectionFailure(version2) {
    this.updateMetric("portSelectionFailures", { version: version2 });
    this.notifyStateChanged();
  }
  /**
   * Records a cache access (hit or miss).
   *
   * @param hit - True if cache hit, false if cache miss
   */
  recordCacheAccess(hit) {
    const event3 = { hit };
    this.updateMetric("cacheHits", event3);
    this.updateMetric("cacheMisses", event3);
    this.notifyStateChanged();
  }
  /**
   * Gets a snapshot of current metrics.
   * Delegates aggregation to MetricsAggregator.
   *
   * @returns Immutable snapshot of metrics data
   */
  getSnapshot() {
    return this.aggregator.aggregate(this.getRawMetrics());
  }
  /**
   * Gets raw metrics data without aggregation.
   * Used internally by aggregator and persistence manager.
   *
   * Converts from generic Map structure to IRawMetrics for backward compatibility.
   *
   * @returns Raw metrics data
   */
  getRawMetrics() {
    const containerResolutions = this.getMetricValue("containerResolutions") ?? 0;
    const resolutionErrors = this.getMetricValue("resolutionErrors") ?? 0;
    const cacheHits = this.getMetricValue("cacheHits") ?? 0;
    const cacheMisses = this.getMetricValue("cacheMisses") ?? 0;
    const portSelectionsRaw = this.getMetricValue("portSelections");
    const portSelections = portSelectionsRaw instanceof Map ? portSelectionsRaw : /* @__PURE__ */ new Map();
    const portSelectionFailuresRaw = this.getMetricValue("portSelectionFailures");
    const portSelectionFailures = portSelectionFailuresRaw instanceof Map ? portSelectionFailuresRaw : /* @__PURE__ */ new Map();
    const resolutionTimesState = this.getMetricValue("resolutionTimes");
    return {
      containerResolutions,
      resolutionErrors,
      cacheHits,
      cacheMisses,
      portSelections,
      portSelectionFailures,
      resolutionTimes: resolutionTimesState?.buffer ?? new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: resolutionTimesState?.index ?? 0,
      resolutionTimesCount: resolutionTimesState?.count ?? 0
    };
  }
  /**
   * Gets a metric value by key.
   *
   * @param key - Metric key
   * @returns Metric value or undefined if not found
   */
  getMetricValue(key2) {
    const state2 = this.metricStates.get(key2);
    if (!state2) {
      return void 0;
    }
    return castMetricValue(state2.value, key2);
  }
  /**
   * Resets all collected metrics.
   * Useful for testing or starting fresh measurements.
   */
  reset() {
    for (const definition of this.registry.getAll()) {
      this.metricStates.set(definition.key, {
        value: definition.initialValue,
        definition
      });
    }
    this.stateManager.reset();
    this.notifyStateChanged();
  }
  /**
   * Hook invoked after state mutations. Subclasses can override to react
   * (e.g., persist metrics).
   */
  onStateChanged() {
    this.stateManager.notifyStateChanged();
  }
  /**
   * Notifies state manager of state changes.
   * Internal method that can be overridden by subclasses.
   */
  notifyStateChanged() {
    this.onStateChanged();
  }
  /**
   * Captures the internal state for persistence.
   * Delegates to MetricsPersistenceManager.
   *
   * @returns Serializable metrics state
   */
  getPersistenceState() {
    return this.persistenceManager.serialize(this.getRawMetrics());
  }
  /**
   * Restores internal state from a persisted snapshot.
   * Delegates to MetricsPersistenceManager.
   *
   * @param state - Persisted metrics state
   */
  restoreFromPersistenceState(state2) {
    const rawMetrics = this.persistenceManager.deserialize(state2);
    this.applyRawMetrics(rawMetrics);
  }
  /**
   * Applies raw metrics to internal state.
   * Internal method used by restoreFromPersistenceState.
   * Converts from IRawMetrics to generic Map structure.
   *
   * @param rawMetrics - Raw metrics to apply
   */
  applyRawMetrics(rawMetrics) {
    this.setMetricValue("containerResolutions", rawMetrics.containerResolutions);
    this.setMetricValue("resolutionErrors", rawMetrics.resolutionErrors);
    this.setMetricValue("cacheHits", rawMetrics.cacheHits);
    this.setMetricValue("cacheMisses", rawMetrics.cacheMisses);
    this.setMetricValue("portSelections", rawMetrics.portSelections);
    this.setMetricValue("portSelectionFailures", rawMetrics.portSelectionFailures);
    const resolutionTimesState = this.metricStates.get("resolutionTimes");
    if (resolutionTimesState) {
      const buffer = new Float64Array(rawMetrics.resolutionTimes);
      this.setMetricValue("resolutionTimes", {
        buffer,
        index: rawMetrics.resolutionTimesIndex,
        count: rawMetrics.resolutionTimesCount
      });
    }
  }
  /**
   * Sets a metric value by key.
   *
   * @param key - Metric key
   * @param value - New metric value
   */
  setMetricValue(key2, value2) {
    const state2 = this.metricStates.get(key2);
    if (state2) {
      this.metricStates.set(key2, {
        value: value2,
        definition: state2.definition
      });
    }
  }
};
__name(_MetricsCollector, "MetricsCollector");
_MetricsCollector.dependencies = [runtimeConfigToken];
let MetricsCollector = _MetricsCollector;
const _DIMetricsCollector = class _DIMetricsCollector extends MetricsCollector {
  constructor(config2, aggregator, persistenceManager, stateManager, registry) {
    super(config2, aggregator, persistenceManager, stateManager, registry);
  }
};
__name(_DIMetricsCollector, "DIMetricsCollector");
_DIMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsAggregatorToken,
  metricsPersistenceManagerToken,
  metricsStateManagerToken
];
let DIMetricsCollector = _DIMetricsCollector;
const _PersistentMetricsCollector = class _PersistentMetricsCollector extends MetricsCollector {
  constructor(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry) {
    super(config2, aggregator, persistenceManager, stateManager, registry);
    this.metricsStorage = metricsStorage;
    this.suppressPersistence = false;
    this.initialized = false;
  }
  /**
   * Initializes the collector by restoring state from storage.
   * Must be called explicitly after construction.
   *
   * @returns Result indicating success or error
   */
  initialize() {
    if (this.initialized) {
      return ok(void 0);
    }
    try {
      this.restoreFromStorage();
      this.initialized = true;
      return ok(void 0);
    } catch (error3) {
      const errorMessage = error3 instanceof Error ? error3.message : String(error3);
      return err(`Failed to initialize PersistentMetricsCollector: ${errorMessage}`);
    }
  }
  clearPersistentState() {
    this.metricsStorage.clear?.();
    this.suppressPersistence = true;
    try {
      super.reset();
    } finally {
      this.suppressPersistence = false;
    }
  }
  onStateChanged() {
    super.onStateChanged();
    if (this.suppressPersistence) {
      return;
    }
    this.persist();
  }
  restoreFromStorage() {
    let state2 = null;
    try {
      state2 = this.metricsStorage.load();
    } catch {
      state2 = null;
    }
    if (!state2) {
      return;
    }
    this.suppressPersistence = true;
    try {
      this.restoreFromPersistenceState(state2);
    } finally {
      this.suppressPersistence = false;
    }
  }
  persist() {
    try {
      this.metricsStorage.save(this.getPersistenceState());
    } catch {
    }
  }
};
__name(_PersistentMetricsCollector, "PersistentMetricsCollector");
_PersistentMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsStorageToken
];
let PersistentMetricsCollector = _PersistentMetricsCollector;
const _DIPersistentMetricsCollector = class _DIPersistentMetricsCollector extends PersistentMetricsCollector {
  constructor(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry) {
    super(config2, metricsStorage, aggregator, persistenceManager, stateManager, registry);
  }
};
__name(_DIPersistentMetricsCollector, "DIPersistentMetricsCollector");
_DIPersistentMetricsCollector.dependencies = [
  runtimeConfigToken,
  metricsStorageToken,
  metricsAggregatorToken,
  metricsPersistenceManagerToken,
  metricsStateManagerToken
];
let DIPersistentMetricsCollector = _DIPersistentMetricsCollector;
const _MetricsAggregator = class _MetricsAggregator {
  /**
   * Aggregates raw metrics into a snapshot.
   *
   * @param metrics - Raw metrics data
   * @returns Aggregated metrics snapshot
   */
  aggregate(metrics) {
    const avgTime = this.calculateAverage(metrics.resolutionTimes, metrics.resolutionTimesCount);
    const cacheHitRate = this.calculateCacheHitRate(metrics.cacheHits, metrics.cacheMisses);
    return {
      containerResolutions: metrics.containerResolutions,
      resolutionErrors: metrics.resolutionErrors,
      avgResolutionTimeMs: avgTime,
      portSelections: Object.fromEntries(metrics.portSelections),
      portSelectionFailures: Object.fromEntries(metrics.portSelectionFailures),
      cacheHitRate
    };
  }
  /**
   * Calculates the average of resolution times.
   *
   * @param times - Array of resolution times
   * @param count - Number of valid entries in the array
   * @returns Average time in milliseconds
   */
  calculateAverage(times, count) {
    if (count === 0) {
      return 0;
    }
    const slice2 = times.slice(0, count);
    const sum = slice2.reduce((acc, time2) => acc + time2, 0);
    return sum / count;
  }
  /**
   * Calculates the cache hit rate as a percentage.
   *
   * @param hits - Number of cache hits
   * @param misses - Number of cache misses
   * @returns Cache hit rate (0-100)
   */
  calculateCacheHitRate(hits, misses) {
    const totalAccess = hits + misses;
    if (totalAccess === 0) {
      return 0;
    }
    return hits / totalAccess * 100;
  }
};
__name(_MetricsAggregator, "MetricsAggregator");
let MetricsAggregator = _MetricsAggregator;
const _MetricsPersistenceManager = class _MetricsPersistenceManager {
  /**
   * Serializes raw metrics into a persistence state.
   *
   * @param metrics - Raw metrics data
   * @returns Serializable persistence state
   */
  serialize(metrics) {
    return {
      metrics: {
        containerResolutions: metrics.containerResolutions,
        resolutionErrors: metrics.resolutionErrors,
        cacheHits: metrics.cacheHits,
        cacheMisses: metrics.cacheMisses,
        portSelections: Object.fromEntries(metrics.portSelections),
        portSelectionFailures: Object.fromEntries(metrics.portSelectionFailures)
      },
      resolutionTimes: Array.from(metrics.resolutionTimes),
      resolutionTimesIndex: metrics.resolutionTimesIndex,
      resolutionTimesCount: metrics.resolutionTimesCount
    };
  }
  /**
   * Deserializes a persistence state into raw metrics.
   *
   * @param state - Persisted state (can be null or undefined)
   * @returns Raw metrics data
   */
  deserialize(state2) {
    if (!state2) {
      return this.createEmptyRawMetrics();
    }
    const { metrics, resolutionTimes, resolutionTimesCount, resolutionTimesIndex } = state2;
    const rawMetrics = {
      containerResolutions: Math.max(0, metrics?.containerResolutions ?? 0),
      resolutionErrors: Math.max(0, metrics?.resolutionErrors ?? 0),
      cacheHits: Math.max(0, metrics?.cacheHits ?? 0),
      cacheMisses: Math.max(0, metrics?.cacheMisses ?? 0),
      portSelections: new Map(
        Object.entries(metrics?.portSelections ?? {}).map(([key2, value2]) => [
          Number(key2),
          Number.isFinite(Number(value2)) ? Number(value2) : 0
        ])
      ),
      portSelectionFailures: new Map(
        Object.entries(metrics?.portSelectionFailures ?? {}).map(([key2, value2]) => [
          Number(key2),
          Number.isFinite(Number(value2)) ? Number(value2) : 0
        ])
      ),
      resolutionTimes: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: 0,
      resolutionTimesCount: 0
    };
    if (Array.isArray(resolutionTimes)) {
      const maxLength2 = Math.min(resolutionTimes.length, rawMetrics.resolutionTimes.length);
      for (let index2 = 0; index2 < maxLength2; index2++) {
        const value2 = Number(resolutionTimes[index2]);
        rawMetrics.resolutionTimes[index2] = Number.isFinite(value2) ? value2 : 0;
      }
      const safeIndex = Number.isFinite(resolutionTimesIndex) ? Number(resolutionTimesIndex) : 0;
      const safeCount = Number.isFinite(resolutionTimesCount) ? Number(resolutionTimesCount) : 0;
      rawMetrics.resolutionTimesIndex = Math.min(
        Math.max(0, safeIndex),
        METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE - 1
      );
      rawMetrics.resolutionTimesCount = Math.min(
        Math.max(0, safeCount),
        METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE
      );
    } else {
      rawMetrics.resolutionTimesIndex = 0;
      rawMetrics.resolutionTimesCount = 0;
    }
    return rawMetrics;
  }
  /**
   * Creates an empty raw metrics structure.
   *
   * @returns Empty raw metrics
   */
  createEmptyRawMetrics() {
    return {
      containerResolutions: 0,
      resolutionErrors: 0,
      cacheHits: 0,
      cacheMisses: 0,
      portSelections: /* @__PURE__ */ new Map(),
      portSelectionFailures: /* @__PURE__ */ new Map(),
      resolutionTimes: new Float64Array(METRICS_CONFIG.RESOLUTION_TIMES_BUFFER_SIZE),
      resolutionTimesIndex: 0,
      resolutionTimesCount: 0
    };
  }
};
__name(_MetricsPersistenceManager, "MetricsPersistenceManager");
let MetricsPersistenceManager = _MetricsPersistenceManager;
const _MetricsStateManager = class _MetricsStateManager {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
  }
  /**
   * Resets the state manager.
   * Clears all registered callbacks.
   */
  reset() {
    this.callbacks.clear();
  }
  /**
   * Subscribes to state changes.
   *
   * @param callback - Callback to invoke on state changes
   */
  onStateChanged(callback) {
    this.callbacks.add(callback);
  }
  /**
   * Unsubscribes from state changes.
   *
   * @param callback - Callback to remove
   */
  unsubscribe(callback) {
    this.callbacks.delete(callback);
  }
  /**
   * Notifies all registered callbacks of a state change.
   * Internal method used by MetricsCollector.
   */
  notifyStateChanged() {
    for (const callback of this.callbacks) {
      try {
        callback();
      } catch (error3) {
        console.error("Error in metrics state change callback:", error3);
      }
    }
  }
};
__name(_MetricsStateManager, "MetricsStateManager");
let MetricsStateManager = _MetricsStateManager;
const _MetricsSampler = class _MetricsSampler {
  constructor(config2) {
    this.config = config2;
  }
  /**
   * Determines if a performance operation should be sampled based on sampling rate.
   *
   * In production mode, uses probabilistic sampling to reduce overhead.
   * In development mode, always samples (returns true).
   *
   * @returns True if the operation should be measured/recorded
   *
   * @example
   * ```typescript
   * const sampler = container.resolve(metricsSamplerToken);
   * if (sampler.shouldSample()) {
   *   performance.mark('operation-start');
   *   // ... operation ...
   *   performance.mark('operation-end');
   *   performance.measure('operation', 'operation-start', 'operation-end');
   * }
   * ```
   */
  shouldSample() {
    if (this.config.get("isDevelopment")) {
      return true;
    }
    return Math.random() < this.config.get("performanceSamplingRate");
  }
};
__name(_MetricsSampler, "MetricsSampler");
let MetricsSampler = _MetricsSampler;
const _DIMetricsSampler = class _DIMetricsSampler extends MetricsSampler {
  constructor(config2) {
    super(config2);
  }
};
__name(_DIMetricsSampler, "DIMetricsSampler");
_DIMetricsSampler.dependencies = [runtimeConfigToken];
let DIMetricsSampler = _DIMetricsSampler;
const _MetricsReporter = class _MetricsReporter {
  constructor(collector, logger) {
    this.collector = collector;
    this.logger = logger;
  }
  /**
   * Logs a formatted metrics summary to the console.
   * Uses console.table() for easy-to-read tabular output.
   */
  logSummary() {
    const snapshot2 = this.collector.getSnapshot();
    const tableData = {
      "Total Resolutions": snapshot2.containerResolutions,
      Errors: snapshot2.resolutionErrors,
      "Avg Time (ms)": snapshot2.avgResolutionTimeMs.toFixed(2),
      "Cache Hit Rate": `${snapshot2.cacheHitRate.toFixed(1)}%`
    };
    console.table(tableData);
  }
  /**
   * Gibt Metrics als JSON zurück.
   *
   * @returns JSON string representation of metrics snapshot
   */
  toJSON() {
    return JSON.stringify(this.collector.getSnapshot(), null, 2);
  }
};
__name(_MetricsReporter, "MetricsReporter");
let MetricsReporter = _MetricsReporter;
const _DIMetricsReporter = class _DIMetricsReporter extends MetricsReporter {
  constructor(collector, logger) {
    super(collector, logger);
  }
};
__name(_DIMetricsReporter, "DIMetricsReporter");
_DIMetricsReporter.dependencies = [metricsCollectorToken, loggerToken];
let DIMetricsReporter = _DIMetricsReporter;
const _LocalStorageMetricsStorage = class _LocalStorageMetricsStorage {
  constructor(storageKey, storage = getStorage()) {
    this.storageKey = storageKey;
    this.storage = storage;
  }
  load() {
    if (!this.storage) {
      return null;
    }
    try {
      const raw = this.storage.getItem(this.storageKey);
      if (!raw) {
        return null;
      }
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }
  save(state2) {
    if (!this.storage) {
      return;
    }
    try {
      this.storage.setItem(this.storageKey, JSON.stringify(state2));
    } catch {
    }
  }
  clear() {
    if (!this.storage) {
      return;
    }
    try {
      this.storage.removeItem(this.storageKey);
    } catch {
    }
  }
};
__name(_LocalStorageMetricsStorage, "LocalStorageMetricsStorage");
let LocalStorageMetricsStorage = _LocalStorageMetricsStorage;
function getStorage() {
  try {
    if (typeof globalThis !== "undefined" && "localStorage" in globalThis) {
      return globalThis.localStorage;
    }
  } catch {
  }
  return null;
}
__name(getStorage, "getStorage");
function createMetricsStorage(key2) {
  return new LocalStorageMetricsStorage(key2);
}
__name(createMetricsStorage, "createMetricsStorage");
function createInMemoryMetricsStorage() {
  let state2 = null;
  return {
    load() {
      return state2;
    },
    save(newState) {
      state2 = newState;
    },
    clear() {
      state2 = null;
    }
  };
}
__name(createInMemoryMetricsStorage, "createInMemoryMetricsStorage");
const _TracedLogger = class _TracedLogger {
  constructor(baseLogger, traceId) {
    this.baseLogger = baseLogger;
    this.traceId = traceId;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatMessage(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatMessage(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatMessage(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatMessage(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatMessage(message2), ...optionalParams);
  }
  withTraceId(newTraceId) {
    return new _TracedLogger(this.baseLogger, `${this.traceId}/${newTraceId}`);
  }
  formatMessage(message2) {
    return `[${this.traceId}] ${message2}`;
  }
};
__name(_TracedLogger, "TracedLogger");
let TracedLogger = _TracedLogger;
const _BaseConsoleLogger = class _BaseConsoleLogger {
  constructor(minLevel) {
    this.minLevel = minLevel;
  }
  setMinLevel(level) {
    this.minLevel = level;
  }
  log(message2, ...optionalParams) {
    console.log(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    if (LogLevel.ERROR < this.minLevel) return;
    console.error(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    if (LogLevel.WARN < this.minLevel) return;
    console.warn(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    if (LogLevel.INFO < this.minLevel) return;
    console.info(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    if (LogLevel.DEBUG < this.minLevel) return;
    console.debug(`${LOG_PREFIX} ${message2}`, ...optionalParams);
  }
  withTraceId(traceId) {
    return new TracedLogger(this, traceId);
  }
};
__name(_BaseConsoleLogger, "BaseConsoleLogger");
let BaseConsoleLogger = _BaseConsoleLogger;
const _RuntimeConfigLoggerDecorator = class _RuntimeConfigLoggerDecorator {
  constructor(baseLogger, runtimeConfig) {
    this.baseLogger = baseLogger;
    this.runtimeConfig = runtimeConfig;
    this.unsubscribe = null;
    this.syncLogLevel();
  }
  syncLogLevel() {
    this.baseLogger.setMinLevel?.(this.runtimeConfig.get("logLevel"));
    this.unsubscribe?.();
    this.unsubscribe = this.runtimeConfig.onChange("logLevel", (level) => {
      this.baseLogger.setMinLevel?.(level);
    });
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(message2, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(message2, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(message2, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(message2, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(message2, ...optionalParams);
  }
  withTraceId(traceId) {
    return this.baseLogger.withTraceId?.(traceId) ?? this.baseLogger;
  }
  dispose() {
    this.unsubscribe?.();
  }
};
__name(_RuntimeConfigLoggerDecorator, "RuntimeConfigLoggerDecorator");
let RuntimeConfigLoggerDecorator = _RuntimeConfigLoggerDecorator;
const _StackTraceLoggerDecorator = class _StackTraceLoggerDecorator {
  constructor(baseLogger, runtimeConfig) {
    this.baseLogger = baseLogger;
    this.runtimeConfig = runtimeConfig;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  /**
   * Extracts the caller information from stack trace when debug mode is enabled.
   * Filters out logger-related frames to show the actual source of the log call.
   *
   * @returns Caller info in format "filename:line" or undefined if not in debug mode or extraction fails
   */
  getCallerInfo() {
    const currentLogLevel = this.runtimeConfig.get("logLevel");
    if (currentLogLevel !== LogLevel.DEBUG) {
      return void 0;
    }
    try {
      const stack2 = new Error().stack;
      if (!stack2) return void 0;
      const lines = stack2.split("\n");
      const loggerPatterns = [
        /StackTraceLoggerDecorator/,
        /BaseConsoleLogger/,
        /ConsoleLoggerService/,
        /RuntimeConfigLoggerDecorator/,
        /TraceContextLoggerDecorator/,
        /TracedLogger/,
        /at Object\./
      ];
      for (let i = 3; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const isLoggerFrame = loggerPatterns.some((pattern) => pattern.test(line));
        if (!isLoggerFrame && line.trim()) {
          const match2 = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/) || line.match(/at\s+(.+?):(\d+):(\d+)/);
          if (match2) {
            const filePath = match2[2] || match2[1];
            const lineNum = match2[3] || match2[2];
            if (filePath && lineNum) {
              const fileName = filePath.split(/[/\\]/).pop() || filePath;
              return `${fileName}:${lineNum}`;
            }
          }
          return line.trim().replace(/^at\s+/, "");
        }
      }
    } catch {
    }
    return void 0;
  }
  formatWithCallerInfo(message2) {
    const callerInfo = this.getCallerInfo();
    return callerInfo ? `${message2} [${callerInfo}]` : message2;
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatWithCallerInfo(message2), ...optionalParams);
  }
  withTraceId(traceId) {
    return this.baseLogger.withTraceId?.(traceId) ?? this.baseLogger;
  }
};
__name(_StackTraceLoggerDecorator, "StackTraceLoggerDecorator");
let StackTraceLoggerDecorator = _StackTraceLoggerDecorator;
const _TraceContextLoggerDecorator = class _TraceContextLoggerDecorator {
  constructor(baseLogger, traceContext) {
    this.baseLogger = baseLogger;
    this.traceContext = traceContext;
  }
  setMinLevel(level) {
    this.baseLogger.setMinLevel?.(level);
  }
  formatWithTrace(message2) {
    const traceId = this.traceContext?.getCurrentTraceId();
    return traceId ? `[${traceId}] ${message2}` : message2;
  }
  log(message2, ...optionalParams) {
    this.baseLogger.log(this.formatWithTrace(message2), ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.baseLogger.error(this.formatWithTrace(message2), ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.baseLogger.warn(this.formatWithTrace(message2), ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.baseLogger.info(this.formatWithTrace(message2), ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.baseLogger.debug(this.formatWithTrace(message2), ...optionalParams);
  }
  withTraceId(traceId) {
    return new TracedLogger(this, traceId);
  }
};
__name(_TraceContextLoggerDecorator, "TraceContextLoggerDecorator");
let TraceContextLoggerDecorator = _TraceContextLoggerDecorator;
const _LoggerCompositionFactory = class _LoggerCompositionFactory {
  /**
   * Creates a composed logger with all necessary decorators.
   *
   * @param config - Runtime configuration port
   * @param traceContext - Optional trace context for trace ID injection
   * @returns Composed logger instance
   */
  createLogger(config2, traceContext) {
    const baseLogger = new BaseConsoleLogger(config2.get("logLevel"));
    const withConfig = new RuntimeConfigLoggerDecorator(baseLogger, config2);
    const withStackTrace = new StackTraceLoggerDecorator(withConfig, config2);
    return traceContext ? new TraceContextLoggerDecorator(withStackTrace, traceContext) : withStackTrace;
  }
};
__name(_LoggerCompositionFactory, "LoggerCompositionFactory");
let LoggerCompositionFactory = _LoggerCompositionFactory;
const _ConsoleLoggerService = class _ConsoleLoggerService {
  constructor(config2, traceContext, factory) {
    const compositionFactory = factory ?? new LoggerCompositionFactory();
    this.logger = compositionFactory.createLogger(config2, traceContext);
  }
  // Delegate all methods to composed logger
  setMinLevel(level) {
    this.logger.setMinLevel?.(level);
  }
  log(message2, ...optionalParams) {
    this.logger.log(message2, ...optionalParams);
  }
  error(message2, ...optionalParams) {
    this.logger.error(message2, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    this.logger.warn(message2, ...optionalParams);
  }
  info(message2, ...optionalParams) {
    this.logger.info(message2, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    this.logger.debug(message2, ...optionalParams);
  }
  withTraceId(traceId) {
    return this.logger.withTraceId?.(traceId) ?? this.logger;
  }
};
__name(_ConsoleLoggerService, "ConsoleLoggerService");
let ConsoleLoggerService = _ConsoleLoggerService;
const _DIConsoleLoggerService = class _DIConsoleLoggerService extends ConsoleLoggerService {
  constructor(config2, traceContext) {
    super(config2, traceContext);
  }
};
__name(_DIConsoleLoggerService, "DIConsoleLoggerService");
_DIConsoleLoggerService.dependencies = [runtimeConfigToken, traceContextToken];
let DIConsoleLoggerService = _DIConsoleLoggerService;
function generateTraceId() {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 10);
  return `${timestamp}-${random}`;
}
__name(generateTraceId, "generateTraceId");
function getTraceTimestamp(traceId) {
  const parts = traceId.split("-");
  if (parts.length !== 2) {
    return null;
  }
  const [timestampStr, randomStr] = parts;
  if (!timestampStr || !randomStr) {
    return null;
  }
  const timestamp = parseInt(timestampStr, 10);
  return isNaN(timestamp) ? null : timestamp;
}
__name(getTraceTimestamp, "getTraceTimestamp");
const _TraceContext = class _TraceContext {
  constructor() {
    this.currentTraceId = null;
  }
  /**
   * Executes a synchronous function with trace context.
   *
   * Automatically generates a trace ID if not provided.
   * Maintains a context stack for nested traces.
   * Ensures proper cleanup via try/finally.
   *
   * @template T - The return type of the function
   * @param fn - Function to execute with trace context
   * @param options - Trace options (trace ID, operation name, metadata)
   * @returns The result of the function execution
   *
   * @example
   * ```typescript
   * const result = traceContext.trace(() => {
   *   logger.info("Processing"); // Automatically traced
   *   return processData();
   * });
   * ```
   */
  trace(fn3, options2) {
    const opts = typeof options2 === "string" ? { traceId: options2 } : options2;
    const traceId = opts?.traceId ?? generateTraceId();
    const previousTraceId = this.currentTraceId;
    this.currentTraceId = traceId;
    try {
      return fn3();
    } finally {
      this.currentTraceId = previousTraceId;
    }
  }
  /**
   * Executes an asynchronous function with trace context.
   *
   * Similar to trace() but for async operations.
   * Automatically generates a trace ID if not provided.
   * Maintains a context stack for nested traces.
   * Ensures proper cleanup via try/finally.
   *
   * @template T - The return type of the async function
   * @param fn - Async function to execute with trace context
   * @param options - Trace options (trace ID, operation name, metadata)
   * @returns Promise resolving to the result of the function execution
   *
   * @example
   * ```typescript
   * const result = await traceContext.traceAsync(async () => {
   *   logger.info("Fetching data"); // Automatically traced
   *   return await fetchData();
   * });
   * ```
   */
  async traceAsync(fn3, options2) {
    const opts = typeof options2 === "string" ? { traceId: options2 } : options2;
    const traceId = opts?.traceId ?? generateTraceId();
    const previousTraceId = this.currentTraceId;
    this.currentTraceId = traceId;
    try {
      return await fn3();
    } finally {
      this.currentTraceId = previousTraceId;
    }
  }
  /**
   * Gets the current trace ID from the context stack.
   *
   * Returns null if not currently in a traced context.
   * Useful for services that need to access the current trace ID
   * without having it passed as a parameter.
   *
   * @returns Current trace ID or null if not in traced context
   *
   * @example
   * ```typescript
   * const traceId = traceContext.getCurrentTraceId();
   * if (traceId) {
   *   console.log(`Current trace: ${traceId}`);
   * }
   * ```
   */
  getCurrentTraceId() {
    return this.currentTraceId;
  }
  /**
   * Cleans up resources.
   * For TraceContext, this resets the current trace ID.
   */
  dispose() {
    this.currentTraceId = null;
  }
};
__name(_TraceContext, "TraceContext");
_TraceContext.dependencies = [];
let TraceContext = _TraceContext;
const _DITraceContext = class _DITraceContext extends TraceContext {
  constructor() {
    super();
  }
};
__name(_DITraceContext, "DITraceContext");
_DITraceContext.dependencies = [];
let DITraceContext = _DITraceContext;
const _ModuleHealthService = class _ModuleHealthService {
  constructor(registry) {
    this.registry = registry;
    this.healthChecksInitialized = false;
  }
  /**
   * Gets the current health status of the module.
   *
   * Health is determined by running all registered health checks.
   * Overall status:
   * - "healthy": All checks pass
   * - "unhealthy": Container check fails
   * - "degraded": Other checks fail
   *
   * @returns HealthStatus with overall status, individual checks, and timestamp
   *
   * @example
   * ```typescript
   * const healthService = container.resolve(moduleHealthServiceToken);
   * const health = healthService.getHealth();
   *
   * if (health.status !== 'healthy') {
   *   console.warn('Module is not healthy:', health.checks);
   * }
   * ```
   */
  getHealth() {
    if (!this.healthChecksInitialized) {
      this.healthChecksInitialized = true;
    }
    const results = this.registry.runAll();
    const allHealthy = Array.from(results.values()).every((result) => result);
    const status = allHealthy ? "healthy" : results.get("container") === false ? "unhealthy" : "degraded";
    const checks = this.registry.getAllChecks();
    let lastError = null;
    for (const check2 of checks) {
      const result = results.get(check2.name);
      if (!result && check2.getDetails) {
        lastError = check2.getDetails();
      }
    }
    return {
      status,
      checks: {
        containerValidated: results.get("container") ?? true,
        portsSelected: results.get("metrics") ?? true,
        lastError
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
__name(_ModuleHealthService, "ModuleHealthService");
let ModuleHealthService = _ModuleHealthService;
const _DIModuleHealthService = class _DIModuleHealthService extends ModuleHealthService {
  constructor(registry) {
    super(registry);
  }
};
__name(_DIModuleHealthService, "DIModuleHealthService");
_DIModuleHealthService.dependencies = [healthCheckRegistryToken];
let DIModuleHealthService = _DIModuleHealthService;
const notificationCenterToken = createInjectionToken("NotificationCenter");
const journalVisibilityServiceToken = createInjectionToken("JournalVisibilityService");
const journalVisibilityConfigToken = createInjectionToken("JournalVisibilityConfig");
const hideJournalContextMenuHandlerToken = createInjectionToken(
  "HideJournalContextMenuHandler"
);
const journalContextMenuHandlersToken = createInjectionToken(
  "JournalContextMenuHandlers"
);
const journalDirectoryProcessorToken = createInjectionToken(
  "JournalDirectoryProcessor"
);
const runtimeConfigSyncToken = createInjectionToken("RuntimeConfigSync");
const runtimeConfigSettingsSyncToken = createInjectionToken(
  "RuntimeConfigSettingsSync"
);
const settingRegistrationErrorMapperToken = createInjectionToken(
  "SettingRegistrationErrorMapper"
);
const settingDefinitionRegistryToken = createInjectionToken(
  "SettingDefinitionRegistry"
);
const runtimeConfigBindingRegistryToken = createInjectionToken(
  "RuntimeConfigBindingRegistry"
);
const batchUpdateContextServiceToken = createInjectionToken(
  "BatchUpdateContextService"
);
const journalDirectoryRerenderSchedulerToken = createInjectionToken(
  "JournalDirectoryRerenderScheduler"
);
const eventRegistrarRegistryToken = createInjectionToken("EventRegistrarRegistry");
const journalOverviewServiceToken = createInjectionToken("JournalOverviewService");
const migrationServiceToken = createInjectionToken("MigrationService");
const nodeDataServiceToken = createInjectionToken("NodeDataService");
const graphDataServiceToken = createInjectionToken("GraphDataService");
const createNodePageUseCaseToken = createInjectionToken("CreateNodePageUseCase");
const createGraphPageUseCaseToken = createInjectionToken("CreateGraphPageUseCase");
const addNodeToGraphUseCaseToken = createInjectionToken("AddNodeToGraphUseCase");
const removeNodeFromGraphUseCaseToken = createInjectionToken(
  "RemoveNodeFromGraphUseCase"
);
const upsertEdgeUseCaseToken = createInjectionToken("UpsertEdgeUseCase");
const removeEdgeUseCaseToken = createInjectionToken("RemoveEdgeUseCase");
const i18nFacadeToken = createInjectionToken("I18nFacadeService");
const foundryGameToken = createInjectionToken("FoundryGame");
const foundryHooksToken = createInjectionToken("FoundryHooks");
const foundryDocumentToken = createInjectionToken("FoundryDocument");
const foundrySettingsToken = createInjectionToken("FoundrySettings");
const foundryJournalFacadeToken = createInjectionToken("FoundryJournalFacade");
function createApiTokens() {
  return {
    notificationCenterToken: markAsApiSafe(notificationCenterToken),
    journalVisibilityServiceToken: markAsApiSafe(journalVisibilityServiceToken),
    journalDirectoryProcessorToken: markAsApiSafe(journalDirectoryProcessorToken),
    foundryGameToken: markAsApiSafe(foundryGameToken),
    foundryHooksToken: markAsApiSafe(foundryHooksToken),
    foundryDocumentToken: markAsApiSafe(foundryDocumentToken),
    foundryUIToken: markAsApiSafe(foundryUIToken),
    foundrySettingsToken: markAsApiSafe(foundrySettingsToken),
    i18nFacadeToken: markAsApiSafe(i18nFacadeToken),
    foundryJournalFacadeToken: markAsApiSafe(foundryJournalFacadeToken),
    graphDataServiceToken: markAsApiSafe(graphDataServiceToken),
    nodeDataServiceToken: markAsApiSafe(nodeDataServiceToken)
  };
}
__name(createApiTokens, "createApiTokens");
const _ModuleApiBuilder = class _ModuleApiBuilder {
  constructor(serviceResolver, healthMetricsProvider) {
    this.serviceResolver = serviceResolver;
    this.healthMetricsProvider = healthMetricsProvider;
  }
  /**
   * Creates the well-known API tokens collection.
   *
   * @returns Type-safe token collection for external modules
   */
  createApiTokens() {
    return createApiTokens();
  }
  /**
   * Creates the complete ModuleApi object with all methods.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Complete ModuleApi object
   */
  createApi(container2, wellKnownTokens) {
    return {
      version: PUBLIC_API_VERSION,
      // Overloaded resolve method (throws on error)
      resolve: this.serviceResolver.createResolveFunction(container2, wellKnownTokens),
      // Result-Pattern method (safe, never throws)
      resolveWithError: this.serviceResolver.createResolveWithErrorFunction(
        container2,
        wellKnownTokens
      ),
      getAvailableTokens: /* @__PURE__ */ __name(() => {
        const tokenMap = /* @__PURE__ */ new Map();
        const tokenEntries = [
          ["journalVisibilityServiceToken", journalVisibilityServiceToken],
          ["journalDirectoryProcessorToken", journalDirectoryProcessorToken],
          ["foundryGameToken", foundryGameToken],
          ["foundryHooksToken", foundryHooksToken],
          ["foundryDocumentToken", foundryDocumentToken],
          ["foundryUIToken", foundryUIToken],
          ["foundrySettingsToken", foundrySettingsToken],
          ["i18nFacadeToken", i18nFacadeToken],
          ["foundryJournalFacadeToken", foundryJournalFacadeToken],
          ["notificationCenterToken", notificationCenterToken],
          ["graphDataServiceToken", graphDataServiceToken],
          ["nodeDataServiceToken", nodeDataServiceToken]
        ];
        for (const [, token] of tokenEntries) {
          const isRegisteredResult = container2.isRegistered(token);
          tokenMap.set(token, {
            description: String(token).replace("Symbol(", "").replace(")", ""),
            isRegistered: getRegistrationStatus(isRegisteredResult)
          });
        }
        return tokenMap;
      }, "getAvailableTokens"),
      tokens: wellKnownTokens,
      getMetrics: /* @__PURE__ */ __name(() => this.healthMetricsProvider.getMetrics(container2), "getMetrics"),
      getHealth: /* @__PURE__ */ __name(() => this.healthMetricsProvider.getHealth(container2), "getHealth")
    };
  }
};
__name(_ModuleApiBuilder, "ModuleApiBuilder");
let ModuleApiBuilder = _ModuleApiBuilder;
const _ApiWrapperStrategyRegistry = class _ApiWrapperStrategyRegistry {
  constructor() {
    this.strategies = [];
  }
  /**
   * Registers a wrapper strategy.
   *
   * @param strategy - Strategy to register
   */
  register(strategy) {
    this.strategies.push(strategy);
  }
  /**
   * Registers multiple wrapper strategies.
   *
   * @param strategies - Array of strategies to register
   */
  registerAll(strategies) {
    for (const strategy of strategies) {
      this.register(strategy);
    }
  }
  /**
   * Gets all registered strategies, sorted by priority (lower = higher priority).
   *
   * @returns Array of strategies in priority order
   */
  getAll() {
    return [...this.strategies].sort((a, b) => {
      const priorityA = a.getPriority?.() ?? 100;
      const priorityB = b.getPriority?.() ?? 100;
      return priorityA - priorityB;
    });
  }
  /**
   * Finds the first strategy that supports the given token.
   *
   * @param token - API token to find strategy for
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Strategy that supports the token, or null if none found
   */
  findStrategy(token, wellKnownTokens) {
    const sortedStrategies = this.getAll();
    for (const strategy of sortedStrategies) {
      if (strategy.supports(token, wellKnownTokens)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * Clears all registered strategies.
   * Useful for testing or reset scenarios.
   */
  clear() {
    this.strategies.length = 0;
  }
};
__name(_ApiWrapperStrategyRegistry, "ApiWrapperStrategyRegistry");
let ApiWrapperStrategyRegistry = _ApiWrapperStrategyRegistry;
function isAllowedKey(prop2, allowed) {
  if (typeof prop2 !== "string") {
    return false;
  }
  return allowed.includes(prop2);
}
__name(isAllowedKey, "isAllowedKey");
function createReadOnlyWrapper(service, allowedMethods) {
  return new Proxy(service, {
    get(target, prop2, receiver) {
      if (isAllowedKey(prop2, allowedMethods)) {
        const value2 = Reflect.get(target, prop2, receiver);
        if (typeof value2 === "function") {
          return value2.bind(target);
        }
        return value2;
      }
      throw new Error(
        `Property "${String(prop2)}" is not accessible via Public API. Only these methods are allowed: ${allowedMethods.map(String).join(", ")}`
      );
    },
    set() {
      throw new Error("Cannot modify services via Public API (read-only)");
    },
    deleteProperty() {
      throw new Error("Cannot delete properties via Public API (read-only)");
    }
  });
}
__name(createReadOnlyWrapper, "createReadOnlyWrapper");
function createPublicLogger(logger) {
  return createReadOnlyWrapper(logger, [
    "log",
    "debug",
    "info",
    "warn",
    "error",
    "withTraceId"
    // Decorator pattern for trace context
  ]);
}
__name(createPublicLogger, "createPublicLogger");
function createPublicI18n(i18n) {
  return createReadOnlyWrapper(i18n, ["translate", "format", "has"]);
}
__name(createPublicI18n, "createPublicI18n");
function createPublicNotificationCenter(notificationCenter) {
  return createReadOnlyWrapper(notificationCenter, [
    "debug",
    "info",
    "warn",
    "error",
    "getChannelNames"
  ]);
}
__name(createPublicNotificationCenter, "createPublicNotificationCenter");
function createPublicFoundrySettings(foundrySettings) {
  return createReadOnlyWrapper(foundrySettings, ["get"]);
}
__name(createPublicFoundrySettings, "createPublicFoundrySettings");
function wrapI18nService(service, create2) {
  return create2(service);
}
__name(wrapI18nService, "wrapI18nService");
function wrapNotificationCenterService(service, create2) {
  return create2(service);
}
__name(wrapNotificationCenterService, "wrapNotificationCenterService");
function wrapFoundrySettingsPort(service, create2) {
  return create2(service);
}
__name(wrapFoundrySettingsPort, "wrapFoundrySettingsPort");
const _I18nWrapperStrategy = class _I18nWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.i18nFacadeToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapI18nService(service, createPublicI18n);
  }
  getPriority() {
    return 10;
  }
};
__name(_I18nWrapperStrategy, "I18nWrapperStrategy");
let I18nWrapperStrategy = _I18nWrapperStrategy;
const _NotificationWrapperStrategy = class _NotificationWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.notificationCenterToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapNotificationCenterService(service, createPublicNotificationCenter);
  }
  getPriority() {
    return 10;
  }
};
__name(_NotificationWrapperStrategy, "NotificationWrapperStrategy");
let NotificationWrapperStrategy = _NotificationWrapperStrategy;
const _SettingsWrapperStrategy = class _SettingsWrapperStrategy {
  supports(token, wellKnownTokens) {
    return token === wellKnownTokens.foundrySettingsToken;
  }
  wrap(service, _token, _wellKnownTokens) {
    return wrapFoundrySettingsPort(service, createPublicFoundrySettings);
  }
  getPriority() {
    return 10;
  }
};
__name(_SettingsWrapperStrategy, "SettingsWrapperStrategy");
let SettingsWrapperStrategy = _SettingsWrapperStrategy;
const _NoopWrapperStrategy = class _NoopWrapperStrategy {
  supports(_token, _wellKnownTokens) {
    return true;
  }
  wrap(service, _token, _wellKnownTokens) {
    return service;
  }
  getPriority() {
    return 1e3;
  }
};
__name(_NoopWrapperStrategy, "NoopWrapperStrategy");
let NoopWrapperStrategy = _NoopWrapperStrategy;
const _ServiceWrapperFactory = class _ServiceWrapperFactory {
  constructor(strategyRegistry) {
    this.strategyRegistry = strategyRegistry ?? this.createDefaultRegistry();
  }
  /**
   * Creates the default strategy registry with standard wrapper strategies.
   *
   * @returns Registry with I18n, Notification, Settings, and Noop strategies
   */
  createDefaultRegistry() {
    const registry = new ApiWrapperStrategyRegistry();
    registry.registerAll([
      new I18nWrapperStrategy(),
      new NotificationWrapperStrategy(),
      new SettingsWrapperStrategy(),
      new NoopWrapperStrategy()
      // Fallback strategy
    ]);
    return registry;
  }
  /**
   * Applies read-only wrappers when API consumers resolve sensitive services.
   *
   * Delegates to registered strategies following Open/Closed Principle.
   * No token-specific if/else chains - all logic is in strategies.
   *
   * @param token - API token used for resolution
   * @param service - Service resolved from the container
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Wrapped service when applicable
   */
  wrapSensitiveService(token, service, wellKnownTokens) {
    const strategy = this.strategyRegistry.findStrategy(token, wellKnownTokens);
    if (strategy) {
      return strategy.wrap(service, token, wellKnownTokens);
    }
    return service;
  }
};
__name(_ServiceWrapperFactory, "ServiceWrapperFactory");
let ServiceWrapperFactory = _ServiceWrapperFactory;
function formatReplacementInfo(replacement) {
  return replacement ? `Use "${replacement}" instead.
` : "";
}
__name(formatReplacementInfo, "formatReplacementInfo");
const deprecationMetadata = /* @__PURE__ */ new Map();
function markAsDeprecated(token, reason, replacement, removedInVersion) {
  const apiSafeToken = markAsApiSafe(token);
  deprecationMetadata.set(apiSafeToken, {
    reason,
    replacement: replacement ? String(replacement) : null,
    removedInVersion,
    warningShown: false
  });
  return apiSafeToken;
}
__name(markAsDeprecated, "markAsDeprecated");
function getDeprecationInfo(token) {
  if (!token || typeof token !== "symbol") {
    return null;
  }
  return deprecationMetadata.get(token) || null;
}
__name(getDeprecationInfo, "getDeprecationInfo");
const _DeprecationHandler = class _DeprecationHandler {
  /**
   * Checks if a token is deprecated.
   *
   * @param token - Token to check
   * @returns DeprecationInfo if deprecated, null otherwise
   */
  checkDeprecation(token) {
    return getDeprecationInfo(token) ?? null;
  }
  /**
   * Handles deprecation warnings for tokens.
   * Logs warning to console if token is deprecated and warning hasn't been shown yet.
   *
   * Uses console.warn instead of Logger because:
   * - Deprecation warnings are for external API consumers (not internal logs)
   * - Should be visible even if Logger is disabled/configured differently
   * - Follows npm/Node.js convention for deprecation warnings
   *
   * @param token - Token to check for deprecation
   */
  handleDeprecationWarning(token) {
    const deprecationInfo = getDeprecationInfo(token);
    if (deprecationInfo && !deprecationInfo.warningShown) {
      const replacementInfo = formatReplacementInfo(deprecationInfo.replacement);
      console.warn(
        `[${MODULE_METADATA.ID}] DEPRECATED: Token "${String(token)}" is deprecated.
Reason: ${deprecationInfo.reason}
` + replacementInfo + `This token will be removed in version ${deprecationInfo.removedInVersion}.`
      );
      deprecationInfo.warningShown = true;
    }
  }
};
__name(_DeprecationHandler, "DeprecationHandler");
let DeprecationHandler = _DeprecationHandler;
const _ApiServiceResolver = class _ApiServiceResolver {
  constructor(deprecationHandler, serviceWrapperFactory) {
    this.deprecationHandler = deprecationHandler;
    this.serviceWrapperFactory = serviceWrapperFactory;
  }
  /**
   * Creates the resolve() function for the public API.
   * Resolves services and applies wrappers (throws on error).
   *
   * @param container - PlatformContainerPort for resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns Resolve function for ModuleApi
   */
  createResolveFunction(container2, wellKnownTokens) {
    return (token) => {
      this.deprecationHandler.handleDeprecationWarning(token);
      const service = container2.resolve(token);
      return this.serviceWrapperFactory.wrapSensitiveService(token, service, wellKnownTokens);
    };
  }
  /**
   * Creates the resolveWithError() function for the public API.
   * Resolves services with Result pattern (never throws).
   *
   * @param container - PlatformContainerPort for resolution
   * @param wellKnownTokens - Collection of API-safe tokens
   * @returns ResolveWithError function for ModuleApi
   */
  createResolveWithErrorFunction(container2, wellKnownTokens) {
    return (token) => {
      this.deprecationHandler.handleDeprecationWarning(token);
      const result = container2.resolveWithError(token);
      if (!result.ok) {
        const containerError = {
          code: castContainerErrorCode(result.error.code),
          message: result.error.message,
          cause: result.error.cause,
          tokenDescription: result.error.message
        };
        return err(containerError);
      }
      const service = castResolvedService$1(result.value);
      const wrappedService = this.serviceWrapperFactory.wrapSensitiveService(
        token,
        service,
        wellKnownTokens
      );
      return ok(wrappedService);
    };
  }
};
__name(_ApiServiceResolver, "ApiServiceResolver");
let ApiServiceResolver = _ApiServiceResolver;
const _ApiHealthMetricsProvider = class _ApiHealthMetricsProvider {
  /**
   * Gets a snapshot of performance metrics.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Current metrics snapshot
   */
  getMetrics(container2) {
    const metricsResult = container2.resolveWithError(metricsCollectorToken);
    if (!metricsResult.ok) {
      return {
        containerResolutions: 0,
        resolutionErrors: 0,
        avgResolutionTimeMs: 0,
        portSelections: {},
        portSelectionFailures: {},
        cacheHitRate: 0
      };
    }
    const metricsCollector = castResolvedService$1(metricsResult.value);
    return metricsCollector.getSnapshot();
  }
  /**
   * Gets module health status.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Health status with checks and overall status
   */
  getHealth(container2) {
    const healthServiceResult = container2.resolveWithError(moduleHealthServiceToken);
    if (!healthServiceResult.ok) {
      return {
        status: "unhealthy",
        checks: {
          containerValidated: false,
          portsSelected: false,
          lastError: "ModuleHealthService not available"
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    const healthService = castResolvedService$1(healthServiceResult.value);
    return healthService.getHealth();
  }
};
__name(_ApiHealthMetricsProvider, "ApiHealthMetricsProvider");
let ApiHealthMetricsProvider = _ApiHealthMetricsProvider;
const _ModuleApiInitializer = class _ModuleApiInitializer {
  constructor(deprecationHandler, serviceWrapperFactory, apiServiceResolver, healthMetricsProvider, apiBuilder) {
    this.deprecationHandler = deprecationHandler ?? new DeprecationHandler();
    this.serviceWrapperFactory = serviceWrapperFactory ?? new ServiceWrapperFactory();
    this.apiServiceResolver = apiServiceResolver ?? new ApiServiceResolver(this.deprecationHandler, this.serviceWrapperFactory);
    this.healthMetricsProvider = healthMetricsProvider ?? new ApiHealthMetricsProvider();
    this.apiBuilder = apiBuilder ?? new ModuleApiBuilder(this.apiServiceResolver, this.healthMetricsProvider);
  }
  /**
   * Exposes the module's public API to game.modules.get(MODULE_ID).api
   *
   * This method coordinates all components to create and expose the API.
   * It acts as a Facade, delegating to specialized components.
   *
   * @param container - Initialized and validated PlatformContainerPort
   * @returns Result<void, string> - Ok if successful, Err with error message
   */
  expose(container2) {
    if (typeof game === "undefined" || !game?.modules) {
      return err("Game modules not available - API cannot be exposed");
    }
    const mod = game.modules.get(MODULE_METADATA.ID);
    if (!mod) {
      return err(`Module '${MODULE_METADATA.ID}' not found in game.modules`);
    }
    const wellKnownTokens = this.apiBuilder.createApiTokens();
    const api2 = this.apiBuilder.createApi(container2, wellKnownTokens);
    mod.api = api2;
    return ok(void 0);
  }
};
__name(_ModuleApiInitializer, "ModuleApiInitializer");
_ModuleApiInitializer.dependencies = [];
let ModuleApiInitializer = _ModuleApiInitializer;
const _DIModuleApiInitializer = class _DIModuleApiInitializer extends ModuleApiInitializer {
  constructor() {
    super();
  }
};
__name(_DIModuleApiInitializer, "DIModuleApiInitializer");
_DIModuleApiInitializer.dependencies = [];
let DIModuleApiInitializer = _DIModuleApiInitializer;
const _HealthCheckRegistry = class _HealthCheckRegistry {
  constructor() {
    this.checks = /* @__PURE__ */ new Map();
  }
  register(check2) {
    this.checks.set(check2.name, check2);
  }
  unregister(name) {
    this.checks.delete(name);
  }
  runAll() {
    const results = /* @__PURE__ */ new Map();
    for (const [name, check2] of this.checks) {
      results.set(name, check2.check());
    }
    return results;
  }
  getCheck(name) {
    return this.checks.get(name);
  }
  getAllChecks() {
    return Array.from(this.checks.values());
  }
  dispose() {
    for (const check2 of this.checks.values()) {
      check2.dispose();
    }
    this.checks.clear();
  }
};
__name(_HealthCheckRegistry, "HealthCheckRegistry");
_HealthCheckRegistry.dependencies = [];
let HealthCheckRegistry = _HealthCheckRegistry;
const _DIHealthCheckRegistry = class _DIHealthCheckRegistry extends HealthCheckRegistry {
  constructor() {
    super();
  }
};
__name(_DIHealthCheckRegistry, "DIHealthCheckRegistry");
_DIHealthCheckRegistry.dependencies = [];
let DIHealthCheckRegistry = _DIHealthCheckRegistry;
const _HealthCheckRegistryAdapter = class _HealthCheckRegistryAdapter {
  constructor() {
    this.registry = new HealthCheckRegistry();
  }
  register(check2) {
    this.registry.register(check2);
  }
  unregister(name) {
    this.registry.unregister(name);
  }
  runAll() {
    return this.registry.runAll();
  }
  getCheck(name) {
    return this.registry.getCheck(name);
  }
  getAllChecks() {
    return this.registry.getAllChecks();
  }
};
__name(_HealthCheckRegistryAdapter, "HealthCheckRegistryAdapter");
let HealthCheckRegistryAdapter = _HealthCheckRegistryAdapter;
const _InitPhaseRegistry = class _InitPhaseRegistry {
  /**
   * Creates a new registry with the provided phases.
   *
   * @param phases - Array of init phases (will be sorted by priority)
   */
  constructor(phases = []) {
    this.phases = [];
    this.phases = [...phases];
    this.sortPhases();
  }
  /**
   * Returns all phases sorted by priority (ascending).
   *
   * @returns Sorted array of init phases
   */
  getAll() {
    return [...this.phases];
  }
  /**
   * Adds a phase to the registry and re-sorts.
   *
   * @param phase - Phase to add
   */
  add(phase) {
    this.phases.push(phase);
    this.sortPhases();
  }
  /**
   * Sorts phases by priority (ascending).
   */
  sortPhases() {
    this.phases.sort((a, b) => a.priority - b.priority);
  }
};
__name(_InitPhaseRegistry, "InitPhaseRegistry");
let InitPhaseRegistry = _InitPhaseRegistry;
var InitPhaseCriticality = /* @__PURE__ */ ((InitPhaseCriticality2) => {
  InitPhaseCriticality2["HALT_ON_ERROR"] = "haltOnError";
  InitPhaseCriticality2["WARN_AND_CONTINUE"] = "warnAndContinue";
  return InitPhaseCriticality2;
})(InitPhaseCriticality || {});
const _MetricsBootstrapper = class _MetricsBootstrapper {
  /**
   * Initializes metrics collector if it supports persistence.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success (warnings logged but don't fail bootstrap)
   */
  static initializeMetrics(container2) {
    const metricsResult = container2.resolveWithError(metricsCollectorToken);
    if (!metricsResult.ok) {
      return ok(void 0);
    }
    const collector = metricsResult.value;
    if (isInitializable(collector)) {
      const initResult = collector.initialize();
      if (!initResult.ok) {
        return ok(void 0);
      }
    }
    return ok(void 0);
  }
};
__name(_MetricsBootstrapper, "MetricsBootstrapper");
let MetricsBootstrapper = _MetricsBootstrapper;
const _MetricsInitPhase = class _MetricsInitPhase {
  constructor() {
    this.id = "metrics-initialization";
    this.priority = 1;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return MetricsBootstrapper.initializeMetrics(ctx.container);
  }
};
__name(_MetricsInitPhase, "MetricsInitPhase");
let MetricsInitPhase = _MetricsInitPhase;
const notificationChannelRegistryToken = createInjectionToken(
  "NotificationChannelRegistry"
);
const queuedUIChannelToken = createInjectionToken("QueuedUIChannel");
const _NotificationBootstrapper = class _NotificationBootstrapper {
  /**
   * Attaches UI notification channel to NotificationCenter.
   *
   * Uses QueuedUIChannel which queues notifications before UI is available
   * and flushes them when UI becomes available.
   *
   * This phase is optional - failures are logged as warnings but don't fail bootstrap.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static attachNotificationChannels(container2) {
    const channelRegistryResult = container2.resolveWithError(notificationChannelRegistryToken);
    if (!channelRegistryResult.ok) {
      return err(
        `NotificationChannelRegistry could not be resolved: ${channelRegistryResult.error.message}`
      );
    }
    const queuedUIChannelResult = container2.resolveWithError(queuedUIChannelToken);
    if (!queuedUIChannelResult.ok) {
      return err(`QueuedUIChannel could not be resolved: ${queuedUIChannelResult.error.message}`);
    }
    const channelRegistry = castResolvedService$1(
      channelRegistryResult.value
    );
    const queuedUIChannel = castResolvedService$1(queuedUIChannelResult.value);
    channelRegistry.addChannel(queuedUIChannel);
    return ok(void 0);
  }
};
__name(_NotificationBootstrapper, "NotificationBootstrapper");
let NotificationBootstrapper = _NotificationBootstrapper;
const _NotificationInitPhase = class _NotificationInitPhase {
  constructor() {
    this.id = "notification-channels";
    this.priority = 2;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return NotificationBootstrapper.attachNotificationChannels(ctx.container);
  }
};
__name(_NotificationInitPhase, "NotificationInitPhase");
let NotificationInitPhase = _NotificationInitPhase;
const _ApiBootstrapper = class _ApiBootstrapper {
  /**
   * Exposes the module's public API.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static exposeApi(container2) {
    const apiInitializerResult = container2.resolveWithError(moduleApiInitializerToken);
    if (!apiInitializerResult.ok) {
      return err(`Failed to resolve ModuleApiInitializer: ${apiInitializerResult.error.message}`);
    }
    const apiInitializer = castResolvedService$1(apiInitializerResult.value);
    const exposeResult = apiInitializer.expose(container2);
    if (!exposeResult.ok) {
      return err(`Failed to expose API: ${exposeResult.error}`);
    }
    return ok(void 0);
  }
};
__name(_ApiBootstrapper, "ApiBootstrapper");
let ApiBootstrapper = _ApiBootstrapper;
const _ApiInitPhase = class _ApiInitPhase {
  constructor() {
    this.id = "api-exposure";
    this.priority = 3;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return ApiBootstrapper.exposeApi(ctx.container);
  }
};
__name(_ApiInitPhase, "ApiInitPhase");
let ApiInitPhase = _ApiInitPhase;
const moduleSettingsRegistrarToken = createInjectionToken("ModuleSettingsRegistrar");
const _SettingsBootstrapper = class _SettingsBootstrapper {
  /**
   * Registers all module settings.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static registerSettings(container2) {
    const settingsRegistrarResult = container2.resolveWithError(moduleSettingsRegistrarToken);
    if (!settingsRegistrarResult.ok) {
      return err(
        `Failed to resolve ModuleSettingsRegistrar: ${settingsRegistrarResult.error.message}`
      );
    }
    const settingsRegistrar = castResolvedService$1(
      settingsRegistrarResult.value
    );
    settingsRegistrar.registerAll();
    return ok(void 0);
  }
};
__name(_SettingsBootstrapper, "SettingsBootstrapper");
let SettingsBootstrapper = _SettingsBootstrapper;
const _SettingsInitPhase = class _SettingsInitPhase {
  constructor() {
    this.id = "settings-registration";
    this.priority = 4;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return SettingsBootstrapper.registerSettings(ctx.container);
  }
};
__name(_SettingsInitPhase, "SettingsInitPhase");
let SettingsInitPhase = _SettingsInitPhase;
const RELATIONSHIP_NODE_SCHEMA_VERSION = 1;
const _RelationshipNodeDataModel = class _RelationshipNodeDataModel extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const fields = foundry.data.fields;
    const lastVersionField = new fields.SchemaField({
      schemaVersion: new fields.NumberField({
        required: true,
        initial: RELATIONSHIP_NODE_SCHEMA_VERSION
      })
    });
    const schema = {
      schemaVersion: new fields.NumberField({
        required: true,
        integer: true,
        initial: RELATIONSHIP_NODE_SCHEMA_VERSION
      }),
      nodeKey: new fields.StringField({ required: true, initial: "" }),
      name: new fields.StringField({ required: true, initial: "" }),
      kind: new fields.StringField({
        required: true,
        choices: ["person", "place", "object"],
        initial: "person"
      }),
      factionId: new fields.StringField({ required: false }),
      relation: new fields.StringField({
        required: true,
        choices: ["friend", "enemy", "neutral"],
        initial: "neutral"
      }),
      icon: new fields.StringField({ required: false }),
      descriptions: new fields.SchemaField({
        public: new fields.StringField({ required: false, blank: true, initial: "" }),
        hidden: new fields.StringField({ required: false, blank: true, initial: "" }),
        gm: new fields.StringField({ required: false, blank: true, initial: "" })
      }),
      reveal: new fields.SchemaField({
        public: new fields.BooleanField({ required: true, initial: false }),
        hidden: new fields.BooleanField({ required: true, initial: false })
      }),
      effects: new fields.SchemaField({
        friend: new fields.StringField({ required: false }),
        enemy: new fields.StringField({ required: false }),
        neutral: new fields.StringField({ required: false })
      }),
      linkedEntityUuid: new fields.StringField({ required: false }),
      lastVersion: lastVersionField
    };
    return schema;
  }
  /**
   * Migration for future schema versions (Phase 3).
   * Currently returns data as-is for schema version 1.
   */
  static migrateData(source2) {
    return super.migrateData(source2);
  }
};
__name(_RelationshipNodeDataModel, "RelationshipNodeDataModel");
let RelationshipNodeDataModel = _RelationshipNodeDataModel;
const RELATIONSHIP_GRAPH_SCHEMA_VERSION = 1;
const _RelationshipGraphDataModel = class _RelationshipGraphDataModel extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const fields = foundry.data.fields;
    const edgeField = new fields.SchemaField({
      id: new fields.StringField({ required: true }),
      source: new fields.StringField({ required: true }),
      target: new fields.StringField({ required: true }),
      knowledge: new fields.StringField({
        required: true,
        choices: ["public", "hidden", "secret"],
        initial: "public"
      }),
      label: new fields.StringField({ required: false })
    });
    const layoutField = new fields.SchemaField({
      positions: new fields.ObjectField({ required: false }),
      zoom: new fields.NumberField({ required: false }),
      pan: new fields.SchemaField({
        x: new fields.NumberField({ required: false }),
        y: new fields.NumberField({ required: false })
      })
    });
    const lastVersionField = new fields.SchemaField({
      schemaVersion: new fields.NumberField({
        required: true,
        initial: RELATIONSHIP_GRAPH_SCHEMA_VERSION
      })
    });
    const schema = {
      schemaVersion: new fields.NumberField({
        required: true,
        integer: true,
        initial: RELATIONSHIP_GRAPH_SCHEMA_VERSION
      }),
      graphKey: new fields.StringField({ required: true, initial: "" }),
      nodeKeys: new fields.ArrayField(new fields.StringField({ required: true, initial: "" }), {
        required: true
      }),
      edges: new fields.ArrayField(edgeField, { required: true }),
      layout: layoutField,
      lastVersion: lastVersionField
    };
    return schema;
  }
  static migrateData(source2) {
    return super.migrateData(source2);
  }
};
__name(_RelationshipGraphDataModel, "RelationshipGraphDataModel");
let RelationshipGraphDataModel = _RelationshipGraphDataModel;
var BROWSER = true;
var DEV = false;
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
__name(is_function, "is_function");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
function is_promise(value2) {
  return typeof value2?.then === "function";
}
__name(is_promise, "is_promise");
function run$2(fn3) {
  return fn3();
}
__name(run$2, "run$2");
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
__name(run_all, "run_all");
function deferred() {
  var resolve2;
  var reject2;
  var promise4 = new Promise((res, rej) => {
    resolve2 = res;
    reject2 = rej;
  });
  return { promise: promise4, resolve: resolve2, reject: reject2 };
}
__name(deferred, "deferred");
function fallback(value2, fallback2, lazy2 = false) {
  return value2 === void 0 ? lazy2 ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value2;
}
__name(fallback, "fallback");
function to_array(value2, n) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (n === void 0 || !(Symbol.iterator in value2)) {
    return Array.from(value2);
  }
  const array3 = [];
  for (const element3 of value2) {
    array3.push(element3);
    if (array3.length === n) break;
  }
  return array3;
}
__name(to_array, "to_array");
const DERIVED = 1 << 1;
const EFFECT = 1 << 2;
const RENDER_EFFECT = 1 << 3;
const MANAGED_EFFECT = 1 << 24;
const BLOCK_EFFECT = 1 << 4;
const BRANCH_EFFECT = 1 << 5;
const ROOT_EFFECT = 1 << 6;
const BOUNDARY_EFFECT = 1 << 7;
const CONNECTED = 1 << 9;
const CLEAN = 1 << 10;
const DIRTY = 1 << 11;
const MAYBE_DIRTY = 1 << 12;
const INERT = 1 << 13;
const DESTROYED = 1 << 14;
const EFFECT_RAN = 1 << 15;
const EFFECT_TRANSPARENT = 1 << 16;
const EAGER_EFFECT = 1 << 17;
const HEAD_EFFECT = 1 << 18;
const EFFECT_PRESERVED = 1 << 19;
const USER_EFFECT = 1 << 20;
const EFFECT_OFFSCREEN = 1 << 25;
const WAS_MARKED = 1 << 15;
const REACTION_IS_UPDATING = 1 << 21;
const ASYNC = 1 << 22;
const ERROR_VALUE = 1 << 23;
const STATE_SYMBOL = /* @__PURE__ */ Symbol("$state");
const LEGACY_PROPS = /* @__PURE__ */ Symbol("legacy props");
const LOADING_ATTR_SYMBOL = /* @__PURE__ */ Symbol("");
const PROXY_PATH_SYMBOL = /* @__PURE__ */ Symbol("proxy path");
const STALE_REACTION = new (_b = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}, __name(_b, "StaleReactionError"), _b)();
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const DOCUMENT_FRAGMENT_NODE = 11;
function experimental_async_required(name) {
  if (DEV) {
    const error3 = new Error(`experimental_async_required
Cannot use \`${name}(...)\` unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async_required`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/experimental_async_required`);
  }
}
__name(experimental_async_required, "experimental_async_required");
function invalid_default_snippet() {
  if (DEV) {
    const error3 = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
__name(invalid_default_snippet, "invalid_default_snippet");
function invalid_snippet_arguments() {
  if (DEV) {
    const error3 = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
__name(invalid_snippet_arguments, "invalid_snippet_arguments");
function lifecycle_outside_component(name) {
  if (DEV) {
    const error3 = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
__name(lifecycle_outside_component, "lifecycle_outside_component");
function missing_context() {
  if (DEV) {
    const error3 = new Error(`missing_context
Context was not set in a parent component
https://svelte.dev/e/missing_context`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/missing_context`);
  }
}
__name(missing_context, "missing_context");
function snippet_without_render_tag() {
  if (DEV) {
    const error3 = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
__name(snippet_without_render_tag, "snippet_without_render_tag");
function store_invalid_shape(name) {
  if (DEV) {
    const error3 = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
__name(store_invalid_shape, "store_invalid_shape");
function svelte_element_invalid_this_value() {
  if (DEV) {
    const error3 = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}
__name(svelte_element_invalid_this_value, "svelte_element_invalid_this_value");
function async_derived_orphan() {
  if (DEV) {
    const error3 = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
__name(async_derived_orphan, "async_derived_orphan");
function bind_invalid_checkbox_value() {
  if (DEV) {
    const error3 = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
__name(bind_invalid_checkbox_value, "bind_invalid_checkbox_value");
function bind_invalid_export(component3, key2, name) {
  if (DEV) {
    const error3 = new Error(`bind_invalid_export
Component ${component3} has an export named \`${key2}\` that a consumer component is trying to access using \`bind:${key2}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${name} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${key2}\`)
https://svelte.dev/e/bind_invalid_export`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_export`);
  }
}
__name(bind_invalid_export, "bind_invalid_export");
function bind_not_bindable(key2, component3, name) {
  if (DEV) {
    const error3 = new Error(`bind_not_bindable
A component is attempting to bind to a non-bindable property \`${key2}\` belonging to ${component3} (i.e. \`<${name} bind:${key2}={...}>\`). To mark a property as bindable: \`let { ${key2} = $bindable() } = $props()\`
https://svelte.dev/e/bind_not_bindable`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/bind_not_bindable`);
  }
}
__name(bind_not_bindable, "bind_not_bindable");
function component_api_changed(method, component3) {
  if (DEV) {
    const error3 = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component3}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
__name(component_api_changed, "component_api_changed");
function component_api_invalid_new(component3, name) {
  if (DEV) {
    const error3 = new Error(`component_api_invalid_new
Attempted to instantiate ${component3} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
__name(component_api_invalid_new, "component_api_invalid_new");
function derived_references_self() {
  if (DEV) {
    const error3 = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
__name(derived_references_self, "derived_references_self");
function each_key_duplicate(a, b, value2) {
  if (DEV) {
    const error3 = new Error(`each_key_duplicate
${value2 ? `Keyed each block has duplicate key \`${value2}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
__name(each_key_duplicate, "each_key_duplicate");
function effect_in_teardown(rune) {
  if (DEV) {
    const error3 = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
__name(effect_in_teardown, "effect_in_teardown");
function effect_in_unowned_derived() {
  if (DEV) {
    const error3 = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
__name(effect_in_unowned_derived, "effect_in_unowned_derived");
function effect_orphan(rune) {
  if (DEV) {
    const error3 = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
__name(effect_orphan, "effect_orphan");
function effect_pending_outside_reaction() {
  if (DEV) {
    const error3 = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
__name(effect_pending_outside_reaction, "effect_pending_outside_reaction");
function effect_update_depth_exceeded() {
  if (DEV) {
    const error3 = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function flush_sync_in_effect() {
  if (DEV) {
    const error3 = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
__name(flush_sync_in_effect, "flush_sync_in_effect");
function fork_discarded() {
  if (DEV) {
    const error3 = new Error(`fork_discarded
Cannot commit a fork that was already discarded
https://svelte.dev/e/fork_discarded`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/fork_discarded`);
  }
}
__name(fork_discarded, "fork_discarded");
function fork_timing() {
  if (DEV) {
    const error3 = new Error(`fork_timing
Cannot create a fork inside an effect or when state changes are pending
https://svelte.dev/e/fork_timing`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/fork_timing`);
  }
}
__name(fork_timing, "fork_timing");
function get_abort_signal_outside_reaction() {
  if (DEV) {
    const error3 = new Error(`get_abort_signal_outside_reaction
\`getAbortSignal()\` can only be called inside an effect or derived
https://svelte.dev/e/get_abort_signal_outside_reaction`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/get_abort_signal_outside_reaction`);
  }
}
__name(get_abort_signal_outside_reaction, "get_abort_signal_outside_reaction");
function hydratable_missing_but_required(key2) {
  if (DEV) {
    const error3 = new Error(`hydratable_missing_but_required
Expected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_required`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/hydratable_missing_but_required`);
  }
}
__name(hydratable_missing_but_required, "hydratable_missing_but_required");
function hydration_failed() {
  if (DEV) {
    const error3 = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
__name(hydration_failed, "hydration_failed");
function invalid_snippet() {
  if (DEV) {
    const error3 = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
__name(invalid_snippet, "invalid_snippet");
function lifecycle_legacy_only(name) {
  if (DEV) {
    const error3 = new Error(`lifecycle_legacy_only
\`${name}(...)\` cannot be used in runes mode
https://svelte.dev/e/lifecycle_legacy_only`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`);
  }
}
__name(lifecycle_legacy_only, "lifecycle_legacy_only");
function props_invalid_value(key2) {
  if (DEV) {
    const error3 = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
__name(props_invalid_value, "props_invalid_value");
function props_rest_readonly(property) {
  if (DEV) {
    const error3 = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
__name(props_rest_readonly, "props_rest_readonly");
function rune_outside_svelte(rune) {
  if (DEV) {
    const error3 = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
__name(rune_outside_svelte, "rune_outside_svelte");
function set_context_after_init() {
  if (DEV) {
    const error3 = new Error(`set_context_after_init
\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression
https://svelte.dev/e/set_context_after_init`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/set_context_after_init`);
  }
}
__name(set_context_after_init, "set_context_after_init");
function state_descriptors_fixed() {
  if (DEV) {
    const error3 = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
__name(state_descriptors_fixed, "state_descriptors_fixed");
function state_prototype_fixed() {
  if (DEV) {
    const error3 = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
__name(state_prototype_fixed, "state_prototype_fixed");
function state_unsafe_mutation() {
  if (DEV) {
    const error3 = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
function svelte_boundary_reset_onerror() {
  if (DEV) {
    const error3 = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error3.name = "Svelte error";
    throw error3;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
__name(svelte_boundary_reset_onerror, "svelte_boundary_reset_onerror");
const EACH_ITEM_REACTIVE = 1;
const EACH_INDEX_REACTIVE = 1 << 1;
const EACH_IS_CONTROLLED = 1 << 2;
const EACH_IS_ANIMATED = 1 << 3;
const EACH_ITEM_IMMUTABLE = 1 << 4;
const PROPS_IS_IMMUTABLE = 1;
const PROPS_IS_RUNES = 1 << 1;
const PROPS_IS_UPDATED = 1 << 2;
const PROPS_IS_BINDABLE = 1 << 3;
const PROPS_IS_LAZY_INITIAL = 1 << 4;
const TRANSITION_IN = 1;
const TRANSITION_OUT = 1 << 1;
const TRANSITION_GLOBAL = 1 << 2;
const TEMPLATE_FRAGMENT = 1;
const TEMPLATE_USE_IMPORT_NODE = 1 << 1;
const TEMPLATE_USE_SVG = 1 << 2;
const TEMPLATE_USE_MATHML = 1 << 3;
const HYDRATION_START = "[";
const HYDRATION_START_ELSE = "[!";
const HYDRATION_END = "]";
const HYDRATION_ERROR = {};
const ELEMENT_IS_NAMESPACED = 1;
const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
const ELEMENT_IS_INPUT = 1 << 2;
const UNINITIALIZED = /* @__PURE__ */ Symbol();
const FILENAME = /* @__PURE__ */ Symbol("filename");
const HMR = /* @__PURE__ */ Symbol("hmr");
const NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
const NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
const IGNORABLE_RUNTIME_WARNINGS = (
  /** @type {const} */
  [
    "await_waterfall",
    "await_reactivity_loss",
    "state_snapshot_uncloneable",
    "binding_property_non_reactive",
    "hydration_attribute_changed",
    "hydration_html_changed",
    "ownership_invalid_binding",
    "ownership_invalid_mutation"
  ]
);
const ELEMENTS_WITHOUT_TEXT = ["audio", "datalist", "dl", "optgroup", "select", "video"];
const ATTACHMENT_KEY = "@attach";
var bold$1 = "font-weight: bold";
var normal$1 = "font-weight: normal";
function assignment_value_stale(property, location) {
  if (DEV) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
__name(assignment_value_stale, "assignment_value_stale");
function await_reactivity_loss(name) {
  if (DEV) {
    console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
__name(await_reactivity_loss, "await_reactivity_loss");
function await_waterfall(name, location) {
  if (DEV) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
__name(await_waterfall, "await_waterfall");
function binding_property_non_reactive(binding, location) {
  if (DEV) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
__name(binding_property_non_reactive, "binding_property_non_reactive");
function console_log_state(method) {
  if (DEV) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
__name(console_log_state, "console_log_state");
function event_handler_invalid(handler, suggestion) {
  if (DEV) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
__name(event_handler_invalid, "event_handler_invalid");
function hydratable_missing_but_expected(key2) {
  if (DEV) {
    console.warn(`%c[svelte] hydratable_missing_but_expected
%cExpected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_expected`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/hydratable_missing_but_expected`);
  }
}
__name(hydratable_missing_but_expected, "hydratable_missing_but_expected");
function hydration_attribute_changed(attribute, html2, value2) {
  if (DEV) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value2}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
__name(hydration_attribute_changed, "hydration_attribute_changed");
function hydration_html_changed(location) {
  if (DEV) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
__name(hydration_html_changed, "hydration_html_changed");
function hydration_mismatch(location) {
  if (DEV) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold$1,
      normal$1
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
__name(hydration_mismatch, "hydration_mismatch");
function invalid_raw_snippet_render() {
  if (DEV) {
    console.warn(`%c[svelte] invalid_raw_snippet_render
%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element
https://svelte.dev/e/invalid_raw_snippet_render`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`);
  }
}
__name(invalid_raw_snippet_render, "invalid_raw_snippet_render");
function legacy_recursive_reactive_block(filename) {
  if (DEV) {
    console.warn(`%c[svelte] legacy_recursive_reactive_block
%cDetected a migrated \`$:\` reactive block in \`${filename}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.
https://svelte.dev/e/legacy_recursive_reactive_block`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`);
  }
}
__name(legacy_recursive_reactive_block, "legacy_recursive_reactive_block");
function lifecycle_double_unmount() {
  if (DEV) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
__name(lifecycle_double_unmount, "lifecycle_double_unmount");
function ownership_invalid_binding(parent4, prop2, child2, owner) {
  if (DEV) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent4} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent4} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
__name(ownership_invalid_binding, "ownership_invalid_binding");
function ownership_invalid_mutation(name, location, prop2, parent4) {
  if (DEV) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent4} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
__name(ownership_invalid_mutation, "ownership_invalid_mutation");
function select_multiple_invalid_value() {
  if (DEV) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
__name(select_multiple_invalid_value, "select_multiple_invalid_value");
function state_proxy_equality_mismatch(operator) {
  if (DEV) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
__name(state_proxy_equality_mismatch, "state_proxy_equality_mismatch");
function state_proxy_unmount() {
  if (DEV) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
__name(state_proxy_unmount, "state_proxy_unmount");
function svelte_boundary_reset_noop() {
  if (DEV) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
__name(svelte_boundary_reset_noop, "svelte_boundary_reset_noop");
function transition_slide_display(value2) {
  if (DEV) {
    console.warn(`%c[svelte] transition_slide_display
%cThe \`slide\` transition does not work correctly for elements with \`display: ${value2}\`
https://svelte.dev/e/transition_slide_display`, bold$1, normal$1);
  } else {
    console.warn(`https://svelte.dev/e/transition_slide_display`);
  }
}
__name(transition_slide_display, "transition_slide_display");
let hydrating = false;
function set_hydrating(value2) {
  hydrating = value2;
}
__name(set_hydrating, "set_hydrating");
let hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(/* @__PURE__ */ get_next_sibling(hydrate_node));
}
__name(hydrate_next, "hydrate_next");
function reset(node) {
  if (!hydrating) return;
  if (/* @__PURE__ */ get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
__name(reset, "reset");
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
__name(hydrate_template, "hydrate_template");
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
__name(next, "next");
function skip_nodes(remove2 = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data4 = (
        /** @type {Comment} */
        node.data
      );
      if (data4 === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data4 === HYDRATION_START || data4 === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    if (remove2) node.remove();
    node = next2;
  }
}
__name(skip_nodes, "skip_nodes");
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}
__name(read_hydration_instruction, "read_hydration_instruction");
function equals$1(value2) {
  return value2 === this.v;
}
__name(equals$1, "equals$1");
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
__name(safe_not_equal, "safe_not_equal");
function not_equal(a, b) {
  return a !== b;
}
__name(not_equal, "not_equal");
function safe_equals(value2) {
  return !safe_not_equal(value2, this.v);
}
__name(safe_equals, "safe_equals");
let async_mode_flag = false;
let legacy_mode_flag = false;
let tracing_mode_flag = false;
function enable_async_mode_flag() {
  async_mode_flag = true;
}
__name(enable_async_mode_flag, "enable_async_mode_flag");
function disable_async_mode_flag() {
  async_mode_flag = false;
}
__name(disable_async_mode_flag, "disable_async_mode_flag");
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}
__name(enable_legacy_mode_flag, "enable_legacy_mode_flag");
function enable_tracing_mode_flag() {
  tracing_mode_flag = true;
}
__name(enable_tracing_mode_flag, "enable_tracing_mode_flag");
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function dynamic_void_element_content(tag2) {
  if (DEV) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element — it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
__name(dynamic_void_element_content, "dynamic_void_element_content");
function state_snapshot_uncloneable(properties) {
  if (DEV) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` — the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}
__name(state_snapshot_uncloneable, "state_snapshot_uncloneable");
const empty = [];
function snapshot(value2, skip_warning = false, no_tojson = false) {
  if (DEV && !skip_warning) {
    const paths = [];
    const copy3 = clone$1(value2, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice2 = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice2.length;
      let uncloned = slice2.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy3;
  }
  return clone$1(value2, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
__name(snapshot, "snapshot");
function clone$1(value2, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value2 === "object" && value2 !== null) {
    var unwrapped = cloned.get(value2);
    if (unwrapped !== void 0) return unwrapped;
    if (value2 instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value2)
    );
    if (value2 instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value2)
    );
    if (is_array(value2)) {
      var copy3 = (
        /** @type {Snapshot<any>} */
        Array(value2.length)
      );
      cloned.set(value2, copy3);
      if (original !== null) {
        cloned.set(original, copy3);
      }
      for (var i = 0; i < value2.length; i += 1) {
        var element3 = value2[i];
        if (i in value2) {
          copy3[i] = clone$1(element3, cloned, DEV ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy3;
    }
    if (get_prototype_of(value2) === object_prototype) {
      copy3 = {};
      cloned.set(value2, copy3);
      if (original !== null) {
        cloned.set(original, copy3);
      }
      for (var key2 in value2) {
        copy3[key2] = clone$1(
          // @ts-expect-error
          value2[key2],
          cloned,
          DEV ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy3;
    }
    if (value2 instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value2)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value2.toJSON === "function" && !no_tojson) {
      return clone$1(
        /** @type {T & { toJSON(): any } } */
        value2.toJSON(),
        cloned,
        DEV ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value2
      );
    }
  }
  if (value2 instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value2
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value2)
    );
  } catch (e) {
    if (DEV) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value2
    );
  }
}
__name(clone$1, "clone$1");
let tracing_expressions = null;
function log_entry(signal, entry) {
  const value2 = signal.v;
  if (value2 === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style3 = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style3,
    dirty ? "font-weight: normal" : style3,
    typeof value2 === "object" && value2 !== null && STATE_SYMBOL in value2 ? snapshot(value2, true) : value2
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      if (updated.error) {
        console.log(updated.error);
      }
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
__name(log_entry, "log_entry");
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
__name(get_type, "get_type");
function trace(label2, fn3) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value2 = fn3();
    var time2 = (performance.now() - start).toFixed(2);
    var prefix = untrack(label2);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time2}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time2}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time2}ms)`, "color: grey");
      var entries2 = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries2) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value2;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
__name(trace, "trace");
function tag(source2, label2) {
  source2.label = label2;
  tag_proxy(source2.v, label2);
  return source2;
}
__name(tag, "tag");
function tag_proxy(value2, label2) {
  value2?.[PROXY_PATH_SYMBOL]?.(label2);
  return value2;
}
__name(tag_proxy, "tag_proxy");
function label(value2) {
  if (typeof value2 === "symbol") return `Symbol(${value2.description})`;
  if (typeof value2 === "function") return "<function>";
  if (typeof value2 === "object" && value2) return "<object>";
  return String(value2);
}
__name(label, "label");
function get_error(label2) {
  const error3 = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error3, "stack", {
    value: stack2.join("\n")
  });
  define_property(error3, "name", {
    value: label2
  });
  return (
    /** @type {Error & { stack: string }} */
    error3
  );
}
__name(get_error, "get_error");
function get_stack() {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit2;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}
__name(get_stack, "get_stack");
let component_context = null;
function set_component_context(context) {
  component_context = context;
}
__name(set_component_context, "set_component_context");
let dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
__name(set_dev_stack, "set_dev_stack");
function add_svelte_meta(callback, type, component3, line, column, additional) {
  const parent4 = dev_stack;
  dev_stack = {
    type,
    file: component3[FILENAME],
    line,
    column,
    parent: parent4,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent4;
  }
}
__name(add_svelte_meta, "add_svelte_meta");
let dev_current_component_function = null;
function set_dev_current_component_function(fn3) {
  dev_current_component_function = fn3;
}
__name(set_dev_current_component_function, "set_dev_current_component_function");
function createContext() {
  const key2 = {};
  return [
    () => {
      if (!hasContext(key2)) {
        missing_context();
      }
      return getContext(key2);
    },
    (context) => setContext(key2, context)
  ];
}
__name(createContext, "createContext");
function getContext(key2) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
__name(getContext, "getContext");
function setContext(key2, context) {
  const context_map = get_or_init_context_map("setContext");
  if (async_mode_flag) {
    var flags2 = (
      /** @type {Effect} */
      active_effect.f
    );
    var valid2 = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && // pop() runs synchronously, so this indicates we're setting context after an await
    !/** @type {ComponentContext} */
    component_context.i;
    if (!valid2) {
      set_context_after_init();
    }
  }
  context_map.set(key2, context);
  return context;
}
__name(setContext, "setContext");
function hasContext(key2) {
  const context_map = get_or_init_context_map("hasContext");
  return context_map.has(key2);
}
__name(hasContext, "hasContext");
function getAllContexts() {
  const context_map = get_or_init_context_map("getAllContexts");
  return (
    /** @type {T} */
    context_map
  );
}
__name(getAllContexts, "getAllContexts");
function push$1(props, runes = false, fn3) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (DEV) {
    component_context.function = fn3;
    dev_current_component_function = fn3;
  }
}
__name(push$1, "push$1");
function pop(component3) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn3 of effects) {
      create_user_effect(fn3);
    }
  }
  if (component3 !== void 0) {
    context.x = component3;
  }
  context.i = true;
  component_context = context.p;
  if (DEV) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component3 ?? /** @type {T} */
  {};
}
__name(pop, "pop");
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
__name(is_runes, "is_runes");
function get_or_init_context_map(name) {
  if (component_context === null) {
    lifecycle_outside_component(name);
  }
  return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
__name(get_or_init_context_map, "get_or_init_context_map");
function get_parent_context(component_context2) {
  let parent4 = component_context2.p;
  while (parent4 !== null) {
    const context_map = parent4.c;
    if (context_map !== null) {
      return context_map;
    }
    parent4 = parent4.p;
  }
  return null;
}
__name(get_parent_context, "get_parent_context");
let micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
__name(run_micro_tasks, "run_micro_tasks");
function queue_micro_task(fn3) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn3);
}
__name(queue_micro_task, "queue_micro_task");
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
__name(flush_tasks, "flush_tasks");
const adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error3) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error3;
  }
  if (DEV && error3 instanceof Error && !adjustments.has(error3)) {
    adjustments.set(error3, get_adjustments(error3, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (DEV && !effect2.parent && error3 instanceof Error) {
        apply_adjustments(error3);
      }
      throw error3;
    }
    effect2.b.error(error3);
  } else {
    invoke_error_boundary(error3, effect2);
  }
}
__name(handle_error, "handle_error");
function invoke_error_boundary(error3, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error3);
        return;
      } catch (e) {
        error3 = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (DEV && error3 instanceof Error) {
    apply_adjustments(error3);
  }
  throw error3;
}
__name(invoke_error_boundary, "invoke_error_boundary");
function get_adjustments(error3, effect2) {
  const message_descriptor = get_descriptor(error3, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error3.message + `
${component_stack}
`,
    stack: error3.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
__name(get_adjustments, "get_adjustments");
function apply_adjustments(error3) {
  const adjusted = adjustments.get(error3);
  if (adjusted) {
    define_property(error3, "message", {
      value: adjusted.message
    });
    define_property(error3, "stack", {
      value: adjusted.stack
    });
  }
}
__name(apply_adjustments, "apply_adjustments");
const batches = /* @__PURE__ */ new Set();
let current_batch = null;
let previous_batch = null;
let batch_values = null;
let queued_root_effects = [];
let last_scheduled_effect = null;
let is_flushing = false;
let is_flushing_sync = false;
const _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    __publicField(this, "committed", false);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __publicField(this, "previous", /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _commit_callbacks, /* @__PURE__ */ new Set());
    /**
     * If a fork is discarded, we need to destroy any effects that are no longer needed
     * @type {Set<(batch: Batch) => void>}
     */
    __privateAdd(this, _discard_callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * The number of async effects that are currently in flight, _not_ inside a pending boundary
     */
    __privateAdd(this, _blocking_pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _dirty_effects, /* @__PURE__ */ new Set());
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Set<Effect>}
     */
    __privateAdd(this, _maybe_dirty_effects, /* @__PURE__ */ new Set());
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed — we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
    __publicField(this, "is_fork", false);
  }
  is_deferred() {
    return this.is_fork || __privateGet(this, _blocking_pending) > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const root2 of root_effects) {
      __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root2, target);
    }
    if (!this.is_fork) {
      __privateMethod(this, _Batch_instances, resolve_fn).call(this);
    }
    if (this.is_deferred()) {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
    } else {
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      previous_batch = null;
      __privateGet(this, _deferred)?.resolve();
    }
    batch_values = null;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value2) {
    if (!this.previous.has(source2)) {
      this.previous.set(source2, value2);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values?.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch !== this) return;
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (__privateGet(this, _pending) === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn3 of __privateGet(this, _discard_callbacks)) fn3(this);
    __privateGet(this, _discard_callbacks).clear();
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) + 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) - 1);
    this.revive();
  }
  revive() {
    for (const e of __privateGet(this, _dirty_effects)) {
      __privateGet(this, _maybe_dirty_effects).delete(e);
      set_signal_status(e, DIRTY);
      schedule_effect(e);
    }
    for (const e of __privateGet(this, _maybe_dirty_effects)) {
      set_signal_status(e, MAYBE_DIRTY);
      schedule_effect(e);
    }
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(fn3) {
    __privateGet(this, _commit_callbacks).add(fn3);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(fn3) {
    __privateGet(this, _discard_callbacks).add(fn3);
  }
  settled() {
    return (__privateGet(this, _deferred) ?? __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch2 = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch2) {
            return;
          }
          batch2.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
    batch_values = new Map(this.current);
    for (const batch2 of batches) {
      if (batch2 === this) continue;
      for (const [source2, previous] of batch2.previous) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
};
_commit_callbacks = new WeakMap();
_discard_callbacks = new WeakMap();
_pending = new WeakMap();
_blocking_pending = new WeakMap();
_deferred = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_Batch_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 * @param {EffectTarget} target
 */
traverse_effect_tree_fn = /* @__PURE__ */ __name(function(root2, target) {
  root2.f ^= CLEAN;
  var effect2 = root2.first;
  while (effect2 !== null) {
    var flags2 = effect2.f;
    var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
    if ((effect2.f & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending()) {
      target = {
        parent: target,
        effect: effect2,
        effects: [],
        render_effects: []
      };
    }
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags2 & EFFECT) !== 0) {
        target.effects.push(effect2);
      } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
        target.render_effects.push(effect2);
      } else if (is_dirty(effect2)) {
        if ((effect2.f & BLOCK_EFFECT) !== 0) __privateGet(this, _dirty_effects).add(effect2);
        update_effect(effect2);
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent4 = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent4 !== null) {
      if (parent4 === target.effect) {
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
        target = /** @type {EffectTarget} */
        target.parent;
      }
      effect2 = parent4.next;
      parent4 = parent4.parent;
    }
  }
}, "#traverse_effect_tree");
/**
 * @param {Effect[]} effects
 */
defer_effects_fn = /* @__PURE__ */ __name(function(effects) {
  for (const e of effects) {
    if ((e.f & DIRTY) !== 0) {
      __privateGet(this, _dirty_effects).add(e);
    } else if ((e.f & MAYBE_DIRTY) !== 0) {
      __privateGet(this, _maybe_dirty_effects).add(e);
    }
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(this, e.deps);
    set_signal_status(e, CLEAN);
  }
}, "#defer_effects");
/**
 * @param {Value[] | null} deps
 */
clear_marked_fn = /* @__PURE__ */ __name(function(deps) {
  if (deps === null) return;
  for (const dep of deps) {
    if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
      continue;
    }
    dep.f ^= WAS_MARKED;
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(
      this,
      /** @type {Derived} */
      dep.deps
    );
  }
}, "#clear_marked");
resolve_fn = /* @__PURE__ */ __name(function() {
  if (__privateGet(this, _blocking_pending) === 0) {
    for (const fn3 of __privateGet(this, _commit_callbacks)) fn3();
    __privateGet(this, _commit_callbacks).clear();
  }
  if (__privateGet(this, _pending) === 0) {
    __privateMethod(this, _Batch_instances, commit_fn).call(this);
  }
}, "#resolve");
commit_fn = /* @__PURE__ */ __name(function() {
  var _a2;
  if (batches.size > 1) {
    this.previous.clear();
    var previous_batch_values = batch_values;
    var is_earlier = true;
    var dummy_target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const batch2 of batches) {
      if (batch2 === this) {
        is_earlier = false;
        continue;
      }
      const sources = [];
      for (const [source2, value2] of this.current) {
        if (batch2.current.has(source2)) {
          if (is_earlier && value2 !== batch2.current.get(source2)) {
            batch2.current.set(source2, value2);
          } else {
            continue;
          }
        }
        sources.push(source2);
      }
      if (sources.length === 0) {
        continue;
      }
      const others = [...batch2.current.keys()].filter((s) => !this.current.has(s));
      if (others.length > 0) {
        var prev_queued_root_effects = queued_root_effects;
        queued_root_effects = [];
        const marked = /* @__PURE__ */ new Set();
        const checked = /* @__PURE__ */ new Map();
        for (const source2 of sources) {
          mark_effects(source2, others, marked, checked);
        }
        if (queued_root_effects.length > 0) {
          current_batch = batch2;
          batch2.apply();
          for (const root2 of queued_root_effects) {
            __privateMethod(_a2 = batch2, _Batch_instances, traverse_effect_tree_fn).call(_a2, root2, dummy_target);
          }
          batch2.deactivate();
        }
        queued_root_effects = prev_queued_root_effects;
      }
    }
    current_batch = null;
    batch_values = previous_batch_values;
  }
  this.committed = true;
  batches.delete(this);
}, "#commit");
__name(_Batch, "Batch");
let Batch = _Batch;
function flushSync(fn3) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn3) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn3();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
__name(flushSync, "flushSync");
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = DEV ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch2 = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (DEV) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch2.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch2.process(queued_root_effects);
      old_values.clear();
      if (DEV) {
        for (const source2 of batch2.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (DEV) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
__name(flush_effects, "flush_effects");
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error3) {
    if (DEV) {
      define_property(error3, "stack", { value: "" });
    }
    invoke_error_boundary(error3, last_scheduled_effect);
  }
}
__name(infinite_loop_guard, "infinite_loop_guard");
let eager_block_effects = null;
function flush_queued_effects(effects) {
  var length2 = effects.length;
  if (length2 === 0) return;
  var i = 0;
  while (i < length2) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
__name(flush_queued_effects, "flush_queued_effects");
function mark_effects(value2, sources, marked, checked) {
  if (marked.has(value2)) return;
  marked.add(value2);
  if (value2.reactions !== null) {
    for (const reaction of value2.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_effects, "mark_effects");
function mark_eager_effects(value2, effects) {
  if (value2.reactions === null) return;
  for (const reaction of value2.reactions) {
    const flags2 = reaction.f;
    if ((flags2 & DERIVED) !== 0) {
      mark_eager_effects(
        /** @type {Derived} */
        reaction,
        effects
      );
    } else if ((flags2 & EAGER_EFFECT) !== 0) {
      set_signal_status(reaction, DIRTY);
      effects.add(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_eager_effects, "mark_eager_effects");
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
__name(depends_on, "depends_on");
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
__name(schedule_effect, "schedule_effect");
let eager_versions = [];
function eager_flush() {
  try {
    flushSync(() => {
      for (const version2 of eager_versions) {
        update(version2);
      }
    });
  } finally {
    eager_versions = [];
  }
}
__name(eager_flush, "eager_flush");
function eager(fn3) {
  var version2 = source(0);
  var initial = true;
  var value2 = (
    /** @type {T} */
    void 0
  );
  get$2(version2);
  eager_effect(() => {
    if (initial) {
      var previous_batch_values = batch_values;
      try {
        batch_values = null;
        value2 = fn3();
      } finally {
        batch_values = previous_batch_values;
      }
      return;
    }
    if (eager_versions.length === 0) {
      queue_micro_task(eager_flush);
    }
    eager_versions.push(version2);
  });
  initial = false;
  return value2;
}
__name(eager, "eager");
function fork(fn3) {
  if (!async_mode_flag) {
    experimental_async_required("fork");
  }
  if (current_batch !== null) {
    fork_timing();
  }
  var batch2 = Batch.ensure();
  batch2.is_fork = true;
  batch_values = /* @__PURE__ */ new Map();
  var committed = false;
  var settled2 = batch2.settled();
  flushSync(fn3);
  batch_values = null;
  for (var [source2, value2] of batch2.previous) {
    source2.v = value2;
  }
  return {
    commit: /* @__PURE__ */ __name(async () => {
      if (committed) {
        await settled2;
        return;
      }
      if (!batches.has(batch2)) {
        fork_discarded();
      }
      committed = true;
      batch2.is_fork = false;
      for (var [source3, value3] of batch2.current) {
        source3.v = value3;
      }
      flushSync(() => {
        var eager_effects2 = /* @__PURE__ */ new Set();
        for (var source4 of batch2.current.keys()) {
          mark_eager_effects(source4, eager_effects2);
        }
        set_eager_effects(eager_effects2);
        flush_eager_effects();
      });
      batch2.revive();
      await settled2;
    }, "commit"),
    discard: /* @__PURE__ */ __name(() => {
      if (!committed && batches.has(batch2)) {
        batches.delete(batch2);
        batch2.discard();
      }
    }, "discard")
  };
}
__name(fork, "fork");
function clear() {
  batches.clear();
}
__name(clear, "clear");
function createSubscriber(start) {
  let subscribers = 0;
  let version2 = source(0);
  let stop5;
  if (DEV) {
    tag(version2, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get$2(version2);
      render_effect(() => {
        if (subscribers === 0) {
          stop5 = untrack(() => start(() => increment(version2)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop5?.();
              stop5 = void 0;
              increment(version2);
            }
          });
        };
      });
    }
  };
}
__name(createSubscriber, "createSubscriber");
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
__name(boundary, "boundary");
const _Boundary = class _Boundary {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    __privateAdd(this, _Boundary_instances);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    __privateAdd(this, _pending2, false);
    /** @type {TemplateNode} */
    __privateAdd(this, _anchor);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _hydrate_open, hydrating ? hydrate_node : null);
    /** @type {BoundaryProps} */
    __privateAdd(this, _props);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _children);
    /** @type {Effect} */
    __privateAdd(this, _effect);
    /** @type {Effect | null} */
    __privateAdd(this, _main_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _pending_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _failed_effect, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _offscreen_fragment, null);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _pending_anchor, null);
    __privateAdd(this, _local_pending_count, 0);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _local_pending_count)));
      if (DEV) {
        tag(__privateGet(this, _effect_pending), "$effect.pending()");
      }
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children);
    this.parent = /** @type {Effect} */
    active_effect.b;
    __privateSet(this, _pending2, !!__privateGet(this, _props).pending);
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment2 = __privateGet(this, _hydrate_open);
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment2.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          __privateMethod(this, _Boundary_instances, hydrate_pending_content_fn).call(this);
        } else {
          __privateMethod(this, _Boundary_instances, hydrate_resolved_content_fn).call(this);
        }
      } else {
        var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
        try {
          __privateSet(this, _main_effect, branch(() => children(anchor)));
        } catch (error3) {
          this.error(error3);
        }
        if (__privateGet(this, _pending_count) > 0) {
          __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
        } else {
          __privateSet(this, _pending2, false);
        }
      }
      return () => {
        __privateGet(this, _pending_anchor)?.remove();
      };
    }, flags));
    if (hydrating) {
      __privateSet(this, _anchor, hydrate_node);
    }
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return __privateGet(this, _pending2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    __privateMethod(this, _Boundary_instances, update_pending_count_fn).call(this, d);
    __privateSet(this, _local_pending_count, __privateGet(this, _local_pending_count) + d);
    if (__privateGet(this, _effect_pending)) {
      internal_set(__privateGet(this, _effect_pending), __privateGet(this, _local_pending_count));
    }
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get$2(
      /** @type {Source<number>} */
      __privateGet(this, _effect_pending)
    );
  }
  /** @param {unknown} error */
  error(error3) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) {
      throw error3;
    }
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        __privateGet(this, _hydrate_open)
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset3 = /* @__PURE__ */ __name(() => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      __privateSet(this, _local_pending_count, 0);
      if (__privateGet(this, _failed_effect) !== null) {
        pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
      }
      __privateSet(this, _pending2, this.has_pending_snippet());
      __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        __privateSet(this, _is_creating_fallback, false);
        return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
      }));
      if (__privateGet(this, _pending_count) > 0) {
        __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
      } else {
        __privateSet(this, _pending2, false);
      }
    }, "reset");
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error3, reset3);
      calling_on_error = false;
    } catch (error22) {
      invoke_error_boundary(error22, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        __privateSet(this, _failed_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
          Batch.ensure();
          __privateSet(this, _is_creating_fallback, true);
          try {
            return branch(() => {
              failed(
                __privateGet(this, _anchor),
                () => error3,
                () => reset3
              );
            });
          } catch (error22) {
            invoke_error_boundary(
              error22,
              /** @type {Effect} */
              __privateGet(this, _effect).parent
            );
            return null;
          } finally {
            __privateSet(this, _is_creating_fallback, false);
          }
        }));
      });
    }
  }
};
_pending2 = new WeakMap();
_anchor = new WeakMap();
_hydrate_open = new WeakMap();
_props = new WeakMap();
_children = new WeakMap();
_effect = new WeakMap();
_main_effect = new WeakMap();
_pending_effect = new WeakMap();
_failed_effect = new WeakMap();
_offscreen_fragment = new WeakMap();
_pending_anchor = new WeakMap();
_local_pending_count = new WeakMap();
_pending_count = new WeakMap();
_is_creating_fallback = new WeakMap();
_effect_pending = new WeakMap();
_effect_pending_subscriber = new WeakMap();
_Boundary_instances = new WeakSet();
hydrate_resolved_content_fn = /* @__PURE__ */ __name(function() {
  try {
    __privateSet(this, _main_effect, branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor))));
  } catch (error3) {
    this.error(error3);
  }
  __privateSet(this, _pending2, false);
}, "#hydrate_resolved_content");
hydrate_pending_content_fn = /* @__PURE__ */ __name(function() {
  const pending2 = __privateGet(this, _props).pending;
  if (!pending2) {
    return;
  }
  __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  Batch.enqueue(() => {
    var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
    __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
      Batch.ensure();
      return branch(() => __privateGet(this, _children).call(this, anchor));
    }));
    if (__privateGet(this, _pending_count) > 0) {
      __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
    } else {
      pause_effect(
        /** @type {Effect} */
        __privateGet(this, _pending_effect),
        () => {
          __privateSet(this, _pending_effect, null);
        }
      );
      __privateSet(this, _pending2, false);
    }
  });
}, "#hydrate_pending_content");
get_anchor_fn = /* @__PURE__ */ __name(function() {
  var anchor = __privateGet(this, _anchor);
  if (__privateGet(this, _pending2)) {
    __privateSet(this, _pending_anchor, create_text());
    __privateGet(this, _anchor).before(__privateGet(this, _pending_anchor));
    anchor = __privateGet(this, _pending_anchor);
  }
  return anchor;
}, "#get_anchor");
/**
 * @param {() => Effect | null} fn
 */
run_fn = /* @__PURE__ */ __name(function(fn3) {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn3();
  } catch (e2) {
    handle_error(e2);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
}, "#run");
show_pending_snippet_fn = /* @__PURE__ */ __name(function() {
  const pending2 = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _props).pending
  );
  if (__privateGet(this, _main_effect) !== null) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    __privateGet(this, _offscreen_fragment).append(
      /** @type {TemplateNode} */
      __privateGet(this, _pending_anchor)
    );
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (__privateGet(this, _pending_effect) === null) {
    __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  }
}, "#show_pending_snippet");
/**
 * Updates the pending count associated with the currently visible pending snippet,
 * if any, such that we can replace the snippet with content once work is done
 * @param {1 | -1} d
 */
update_pending_count_fn = /* @__PURE__ */ __name(function(d) {
  var _a2;
  if (!this.has_pending_snippet()) {
    if (this.parent) {
      __privateMethod(_a2 = this.parent, _Boundary_instances, update_pending_count_fn).call(_a2, d);
    }
    return;
  }
  __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d);
  if (__privateGet(this, _pending_count) === 0) {
    __privateSet(this, _pending2, false);
    if (__privateGet(this, _pending_effect)) {
      pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
    }
    if (__privateGet(this, _offscreen_fragment)) {
      __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
      __privateSet(this, _offscreen_fragment, null);
    }
  }
}, "#update_pending_count");
__name(_Boundary, "Boundary");
let Boundary = _Boundary;
function get_boundary() {
  return (
    /** @type {Boundary} */
    /** @type {Effect} */
    active_effect.b
  );
}
__name(get_boundary, "get_boundary");
function pending$1() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}
__name(pending$1, "pending$1");
function flatten(blockers, sync, async2, fn3) {
  const d = is_runes() ? derived$1 : derived_safe_equal;
  if (async2.length === 0 && blockers.length === 0) {
    fn3(sync.map(d));
    return;
  }
  var batch2 = current_batch;
  var parent4 = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  function run2() {
    Promise.all(async2.map((expression) => /* @__PURE__ */ async_derived(expression))).then((result) => {
      restore();
      try {
        fn3([...sync.map(d), ...result]);
      } catch (error3) {
        if ((parent4.f & DESTROYED) === 0) {
          invoke_error_boundary(error3, parent4);
        }
      }
      batch2?.deactivate();
      unset_context();
    }).catch((error3) => {
      invoke_error_boundary(error3, parent4);
    });
  }
  __name(run2, "run");
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run2();
      } finally {
        batch2?.deactivate();
        unset_context();
      }
    });
  } else {
    run2();
  }
}
__name(flatten, "flatten");
function run_after_blockers(blockers, fn3) {
  flatten(blockers, [], [], fn3);
}
__name(run_after_blockers, "run_after_blockers");
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (DEV) {
    var previous_dev_stack = dev_stack;
  }
  return /* @__PURE__ */ __name(function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) previous_batch2?.activate();
    if (DEV) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  }, "restore");
}
__name(capture, "capture");
async function save(promise4) {
  var restore = capture();
  var value2 = await promise4;
  return () => {
    restore();
    return value2;
  };
}
__name(save, "save");
async function track_reactivity_loss(promise4) {
  var previous_async_effect = current_async_effect;
  var value2 = await promise4;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value2;
  };
}
__name(track_reactivity_loss, "track_reactivity_loss");
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value: value2 } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value2;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
__name(for_await_track_reactivity_loss, "for_await_track_reactivity_loss");
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (DEV) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}
__name(unset_context, "unset_context");
async function async_body(anchor, fn3) {
  var boundary2 = get_boundary();
  var batch2 = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch2.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var was_hydrating = hydrating;
  var next_hydrate_node = void 0;
  if (was_hydrating) {
    hydrate_next();
    next_hydrate_node = skip_nodes(false);
  }
  try {
    var promise4 = fn3(anchor);
  } finally {
    if (next_hydrate_node) {
      set_hydrate_node(next_hydrate_node);
      hydrate_next();
    }
  }
  try {
    await promise4;
  } catch (error3) {
    if (!aborted(active)) {
      invoke_error_boundary(error3, active);
    }
  } finally {
    boundary2.update_pending_count(-1);
    batch2.decrement(blocking);
    unset_context();
  }
}
__name(async_body, "async_body");
function run$1(thunks) {
  const restore = capture();
  var boundary2 = get_boundary();
  var batch2 = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch2.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var errored = null;
  const handle_error2 = /* @__PURE__ */ __name((error3) => {
    errored = { error: error3 };
    if (!aborted(active)) {
      invoke_error_boundary(error3, active);
    }
  }, "handle_error");
  var promise4 = Promise.resolve(thunks[0]()).catch(handle_error2);
  var promises = [promise4];
  for (const fn3 of thunks.slice(1)) {
    promise4 = promise4.then(() => {
      if (errored) {
        throw errored.error;
      }
      if (aborted(active)) {
        throw STALE_REACTION;
      }
      try {
        restore();
        return fn3();
      } finally {
        unset_context();
      }
    }).catch(handle_error2).finally(() => {
      unset_context();
    });
    promises.push(promise4);
  }
  promise4.then(() => Promise.resolve()).finally(() => {
    boundary2.update_pending_count(-1);
    batch2.decrement(blocking);
  });
  return promises;
}
__name(run$1, "run$1");
let current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
__name(set_from_async_derived, "set_from_async_derived");
const recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived$1(fn3) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals: equals$1,
    f: flags2,
    fn: fn3,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (DEV && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
__name(derived$1, "derived$1");
// @__NO_SIDE_EFFECTS__
function async_derived(fn3, location) {
  let parent4 = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent4 === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent4.b
  );
  var promise4 = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    if (DEV) current_async_effect = active_effect;
    var d = deferred();
    promise4 = d.promise;
    try {
      Promise.resolve(fn3()).then(d.resolve, d.reject).then(() => {
        if (batch2 === current_batch && batch2.committed) {
          batch2.deactivate();
        }
        unset_context();
      });
    } catch (error3) {
      d.reject(error3);
      unset_context();
    }
    if (DEV) current_async_effect = null;
    var batch2 = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch2.increment(blocking);
      deferreds.get(batch2)?.reject(STALE_REACTION);
      deferreds.delete(batch2);
      deferreds.set(batch2, d);
    }
    const handler = /* @__PURE__ */ __name((value2, error3 = void 0) => {
      current_async_effect = null;
      batch2.activate();
      if (error3) {
        if (error3 !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error3);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value2);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch2) break;
          d2.reject(STALE_REACTION);
        }
        if (DEV && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch2.decrement(blocking);
      }
    }, "handler");
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (DEV) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p2) {
      function go() {
        if (p2 === promise4) {
          fulfil(signal);
        } else {
          next2(promise4);
        }
      }
      __name(go, "go");
      p2.then(go, go);
    }
    __name(next2, "next");
    next2(promise4);
  });
}
__name(async_derived, "async_derived");
// @__NO_SIDE_EFFECTS__
function user_derived(fn3) {
  const d = /* @__PURE__ */ derived$1(fn3);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
__name(user_derived, "user_derived");
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn3) {
  const signal = /* @__PURE__ */ derived$1(fn3);
  signal.equals = safe_equals;
  return signal;
}
__name(derived_safe_equal, "derived_safe_equal");
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
__name(destroy_derived_effects, "destroy_derived_effects");
let stack = [];
function get_derived_parent_effect(derived2) {
  var parent4 = derived2.parent;
  while (parent4 !== null) {
    if ((parent4.f & DERIVED) === 0) {
      return (parent4.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent4
      ) : null;
    }
    parent4 = parent4.parent;
  }
  return null;
}
__name(get_derived_parent_effect, "get_derived_parent_effect");
function execute_derived(derived2) {
  var value2;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (DEV) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value2 = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value2 = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value2;
}
__name(execute_derived, "execute_derived");
function update_derived(derived2) {
  var value2 = execute_derived(derived2);
  if (!derived2.equals(value2)) {
    if (!current_batch?.is_fork) {
      derived2.v = value2;
    }
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived2, value2);
    }
  } else {
    var status = (derived2.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
__name(update_derived, "update_derived");
let eager_effects = /* @__PURE__ */ new Set();
const old_values = /* @__PURE__ */ new Map();
function set_eager_effects(v) {
  eager_effects = v;
}
__name(set_eager_effects, "set_eager_effects");
let eager_effects_deferred = false;
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
__name(set_eager_effects_deferred, "set_eager_effects_deferred");
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals: equals$1,
    rv: 0,
    wv: 0
  };
  if (DEV && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
__name(source, "source");
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
__name(state, "state");
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a2;
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_a2 = component_context.l).s ?? (_a2.s = [])).push(s);
  }
  return s;
}
__name(mutable_source, "mutable_source");
function mutate(source2, value2) {
  set$1(
    source2,
    untrack(() => get$2(source2))
  );
  return value2;
}
__name(mutate, "mutate");
function set$1(source2, value2, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value2) : value2;
  if (DEV) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
__name(set$1, "set$1");
function internal_set(source2, value2) {
  if (!source2.equals(value2)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value2);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value2;
    var batch2 = Batch.ensure();
    batch2.capture(source2, old_value);
    if (DEV) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ?? (source2.updated = /* @__PURE__ */ new Map());
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error3 = get_error("updated at");
          if (error3 !== null) {
            let entry = source2.updated.get(error3.stack);
            if (!entry) {
              entry = { error: error3, count: 0 };
              source2.updated.set(error3.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch2.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value2;
}
__name(internal_set, "internal_set");
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
__name(flush_eager_effects, "flush_eager_effects");
function update(source2, d = 1) {
  var value2 = get$2(source2);
  var result = d === 1 ? value2++ : value2--;
  set$1(source2, value2);
  return result;
}
__name(update, "update");
function update_pre(source2, d = 1) {
  var value2 = get$2(source2);
  return set$1(source2, d === 1 ? ++value2 : --value2);
}
__name(update_pre, "update_pre");
function increment(source2) {
  set$1(source2, source2.v + 1);
}
__name(increment, "increment");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length2 = reactions.length;
  for (var i = 0; i < length2; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (DEV && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived2 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived2);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived2, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_reactions, "mark_reactions");
const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value2) {
  if (typeof value2 !== "object" || value2 === null || STATE_SYMBOL in value2) {
    return value2;
  }
  const prototype = get_prototype_of(value2);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value2;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value2);
  var version2 = /* @__PURE__ */ state(0);
  var stack2 = DEV && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = /* @__PURE__ */ __name((fn3) => {
    if (update_version === parent_version) {
      return fn3();
    }
    var reaction = active_reaction;
    var version3 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn3();
    set_active_reaction(reaction);
    set_update_version(version3);
    return result;
  }, "with_parent");
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value2.length,
      stack2
    ));
    if (DEV) {
      value2 = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value2
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version2, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  __name(update_path, "update_path");
  return new Proxy(
    /** @type {any} */
    value2,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = /* @__PURE__ */ state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (DEV && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set$1(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version2);
            if (DEV) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set$1(s, UNINITIALIZED);
          increment(version2);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value2;
        }
        if (DEV && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p2 = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = /* @__PURE__ */ state(p2, stack2);
            if (DEV) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get$2(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get$2(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value3 = source2?.v;
          if (source2 !== void 0 && value3 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value3,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p2 = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = /* @__PURE__ */ state(p2, stack2);
              if (DEV) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value3 = get$2(s);
          if (value3 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value3, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value3; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set$1(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (DEV) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => /* @__PURE__ */ state(void 0, stack2));
            if (DEV) {
              tag(s, get_label(path, prop2));
            }
            set$1(s, proxy(value3));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p2 = with_parent(() => proxy(value3));
          set$1(s, p2);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value3);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set$1(ls, n + 1);
            }
          }
          increment(version2);
        }
        return true;
      },
      ownKeys(target) {
        get$2(version2);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
__name(proxy, "proxy");
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
__name(get_label, "get_label");
function get_proxied_value(value2) {
  try {
    if (value2 !== null && typeof value2 === "object" && STATE_SYMBOL in value2) {
      return value2[STATE_SYMBOL];
    }
  } catch {
  }
  return value2;
}
__name(get_proxied_value, "get_proxied_value");
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
__name(is, "is");
const ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array3) {
  return new Proxy(array3, {
    get(target, prop2, receiver) {
      var value2 = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value2;
      }
      return function(...args2) {
        set_eager_effects_deferred();
        var result = value2.apply(this, args2);
        flush_eager_effects();
        return result;
      };
    }
  });
}
__name(inspectable_array, "inspectable_array");
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes: includes2 } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes2.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes2;
  };
}
__name(init_array_prototype_warnings, "init_array_prototype_warnings");
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
__name(strict_equals, "strict_equals");
function equals(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}
__name(equals, "equals");
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (DEV) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
__name(init_operations, "init_operations");
function create_text(value2 = "") {
  return document.createTextNode(value2);
}
__name(create_text, "create_text");
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return (
    /** @type {TemplateNode | null} */
    first_child_getter.call(node)
  );
}
__name(get_first_child, "get_first_child");
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return (
    /** @type {TemplateNode | null} */
    next_sibling_getter.call(node)
  );
}
__name(get_next_sibling, "get_next_sibling");
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = /* @__PURE__ */ get_first_child(hydrate_node);
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
__name(child, "child");
function first_child(node, is_text = false) {
  if (!hydrating) {
    var first2 = /* @__PURE__ */ get_first_child(node);
    if (first2 instanceof Comment && first2.data === "") return /* @__PURE__ */ get_next_sibling(first2);
    return first2;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    hydrate_node?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
__name(first_child, "first_child");
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}
__name(sibling, "sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}
__name(should_defer_append, "should_defer_append");
function create_element(tag2, namespace, is3) {
  let options2 = is3 ? { is: is3 } : void 0;
  if (namespace) {
    return document.createElementNS(namespace, tag2, options2);
  }
  return document.createElement(tag2, options2);
}
__name(create_element, "create_element");
function create_fragment() {
  return document.createDocumentFragment();
}
__name(create_fragment, "create_fragment");
function create_comment(data4 = "") {
  return document.createComment(data4);
}
__name(create_comment, "create_comment");
function set_attribute$1(element3, key2, value2 = "") {
  if (key2.startsWith("xlink:")) {
    element3.setAttributeNS("http://www.w3.org/1999/xlink", key2, value2);
    return;
  }
  return element3.setAttribute(key2, value2);
}
__name(set_attribute$1, "set_attribute$1");
function autofocus(dom, value2) {
  if (value2) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
__name(autofocus, "autofocus");
function remove_textarea_child(dom) {
  if (hydrating && /* @__PURE__ */ get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
__name(remove_textarea_child, "remove_textarea_child");
let listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}
__name(add_form_reset_listener, "add_form_reset_listener");
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
__name(listen, "listen");
function without_reactive_context(fn3) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn3();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(without_reactive_context, "without_reactive_context");
function listen_to_event_and_reset_event(element3, event3, handler, on_reset = handler) {
  element3.addEventListener(event3, () => without_reactive_context(handler));
  const prev = element3.__on_r;
  if (prev) {
    element3.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element3.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}
__name(listen_to_event_and_reset_event, "listen_to_event_and_reset_event");
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
__name(validate_effect, "validate_effect");
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn3, sync) {
  var parent4 = active_effect;
  if (DEV) {
    while (parent4 !== null && (parent4.f & EAGER_EFFECT) !== 0) {
      parent4 = parent4.parent;
    }
  }
  if (parent4 !== null && (parent4.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn: fn3,
    last: null,
    next: null,
    parent: parent4,
    b: parent4 && parent4.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (DEV) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e3) {
      destroy_effect(effect2);
      throw e3;
    }
  } else if (fn3 !== null) {
    schedule_effect(effect2);
  }
  var e2 = effect2;
  if (sync && e2.deps === null && e2.teardown === null && e2.nodes === null && e2.first === e2.last && // either `null`, or a singular child
  (e2.f & EFFECT_PRESERVED) === 0) {
    e2 = e2.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e2 !== null) {
      e2.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e2 !== null) {
    e2.parent = parent4;
    if (parent4 !== null) {
      push_effect(e2, parent4);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.effects ?? (derived2.effects = [])).push(e2);
    }
  }
  return effect2;
}
__name(create_effect, "create_effect");
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
__name(effect_tracking, "effect_tracking");
function teardown(fn3) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn3;
  return effect2;
}
__name(teardown, "teardown");
function user_effect(fn3) {
  validate_effect("$effect");
  if (DEV) {
    define_property(fn3, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    (context.e ?? (context.e = [])).push(fn3);
  } else {
    return create_user_effect(fn3);
  }
}
__name(user_effect, "user_effect");
function create_user_effect(fn3) {
  return create_effect(EFFECT | USER_EFFECT, fn3, false);
}
__name(create_user_effect, "create_user_effect");
function user_pre_effect(fn3) {
  validate_effect("$effect.pre");
  if (DEV) {
    define_property(fn3, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn3, true);
}
__name(user_pre_effect, "user_pre_effect");
function eager_effect(fn3) {
  return create_effect(EAGER_EFFECT, fn3, true);
}
__name(eager_effect, "eager_effect");
function effect_root(fn3) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn3, true);
  return () => {
    destroy_effect(effect2);
  };
}
__name(effect_root, "effect_root");
function component_root(fn3) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn3, true);
  return (options2 = {}) => {
    return new Promise((fulfil) => {
      if (options2.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
__name(component_root, "component_root");
function effect(fn3) {
  return create_effect(EFFECT, fn3, false);
}
__name(effect, "effect");
function legacy_pre_effect(deps, fn3) {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn3);
  });
}
__name(legacy_pre_effect, "legacy_pre_effect");
function legacy_pre_effect_reset() {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
__name(legacy_pre_effect_reset, "legacy_pre_effect_reset");
function async_effect(fn3) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn3, true);
}
__name(async_effect, "async_effect");
function render_effect(fn3, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn3, true);
}
__name(render_effect, "render_effect");
function template_effect(fn3, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values2) => {
    create_effect(RENDER_EFFECT, () => fn3(...values2.map(get$2)), true);
  });
}
__name(template_effect, "template_effect");
function deferred_template_effect(fn3, sync = [], async2 = [], blockers = []) {
  var batch2 = (
    /** @type {Batch} */
    current_batch
  );
  var is_async = async2.length > 0 || blockers.length > 0;
  if (is_async) batch2.increment(true);
  flatten(blockers, sync, async2, (values2) => {
    create_effect(EFFECT, () => fn3(...values2.map(get$2)), false);
    if (is_async) batch2.decrement(true);
  });
}
__name(deferred_template_effect, "deferred_template_effect");
function block(fn3, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn3, true);
  if (DEV) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
__name(block, "block");
function managed(fn3, flags2 = 0) {
  var effect2 = create_effect(MANAGED_EFFECT | flags2, fn3, true);
  if (DEV) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
__name(managed, "managed");
function branch(fn3) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn3, true);
}
__name(branch, "branch");
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes !== null && effect2.nodes.end !== null) {
    remove_effect_dom(
      effect2.nodes.start,
      /** @type {TemplateNode} */
      effect2.nodes.end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent4 = effect2.parent;
  if (parent4 !== null && parent4.first !== null) {
    unlink_effect(effect2);
  }
  if (DEV) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}
__name(destroy_effect, "destroy_effect");
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
__name(remove_effect_dom, "remove_effect_dom");
function unlink_effect(effect2) {
  var parent4 = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent4 !== null) {
    if (parent4.first === effect2) parent4.first = next2;
    if (parent4.last === effect2) parent4.last = prev;
  }
}
__name(unlink_effect, "unlink_effect");
function pause_effect(effect2, callback, destroy2 = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn3 = /* @__PURE__ */ __name(() => {
    if (destroy2) destroy_effect(effect2);
    if (callback) callback();
  }, "fn");
  var remaining = transitions.length;
  if (remaining > 0) {
    var check2 = /* @__PURE__ */ __name(() => --remaining || fn3(), "check");
    for (var transition2 of transitions) {
      transition2.out(check2);
    }
  } else {
    fn3();
  }
}
__name(pause_effect, "pause_effect");
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent2 = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent2 ? local : false);
    child2 = sibling2;
  }
}
__name(pause_children, "pause_children");
function resume_effect(effect2) {
  resume_children(effect2, true);
}
__name(resume_effect, "resume_effect");
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent2 = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent2 ? local : false);
    child2 = sibling2;
  }
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
__name(resume_children, "resume_children");
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}
__name(aborted, "aborted");
function move_effect(effect2, fragment) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  while (node !== null) {
    var next2 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}
__name(move_effect, "move_effect");
let captured_signals = null;
function capture_signals(fn3) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn3);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
__name(capture_signals, "capture_signals");
function invalidate_inner_signals(fn3) {
  for (var signal of capture_signals(fn3)) {
    internal_set(signal, signal.v);
  }
}
__name(invalidate_inner_signals, "invalidate_inner_signals");
let is_updating_effect = false;
function set_is_updating_effect(value2) {
  is_updating_effect = value2;
}
__name(set_is_updating_effect, "set_is_updating_effect");
let is_destroying_effect = false;
function set_is_destroying_effect(value2) {
  is_destroying_effect = value2;
}
__name(set_is_destroying_effect, "set_is_destroying_effect");
let active_reaction = null;
let untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
let active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
__name(set_active_effect, "set_active_effect");
let current_sources = null;
function push_reaction_value(value2) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value2];
    } else {
      current_sources.push(value2);
    }
  }
}
__name(push_reaction_value, "push_reaction_value");
let new_deps = null;
let skipped_deps = 0;
let untracked_writes = null;
function set_untracked_writes(value2) {
  untracked_writes = value2;
}
__name(set_untracked_writes, "set_untracked_writes");
let write_version = 1;
let read_version = 0;
let update_version = read_version;
function set_update_version(value2) {
  update_version = value2;
}
__name(set_update_version, "set_update_version");
function increment_write_version() {
  return ++write_version;
}
__name(increment_write_version, "increment_write_version");
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length2 = dependencies.length;
      for (var i = 0; i < length2; i++) {
        var dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(is_dirty, "is_dirty");
function schedule_possible_effect_self_invalidation(signal, effect2, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(schedule_possible_effect_self_invalidation, "schedule_possible_effect_self_invalidation");
function update_reaction(reaction) {
  var _a2;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn3 = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn3();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          ((_a2 = deps[i]).reactions ?? (_a2.reactions = [])).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error3) {
    return handle_error(error3);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (DEV) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (DEV && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (DEV) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
__name(update_effect, "update_effect");
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
__name(tick, "tick");
function settled() {
  return Batch.ensure().settled();
}
__name(settled, "settled");
function get$2(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed2 = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed2 && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ?? (active_reaction.deps = [])).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (DEV) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last2 = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last2?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived2 = (
        /** @type {Derived} */
        signal
      );
      var value2 = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value2 = execute_derived(derived2);
      }
      old_values.set(derived2, value2);
      return value2;
    }
  } else if (is_derived && (!batch_values?.has(signal) || current_batch?.is_fork && !effect_tracking())) {
    derived2 = /** @type {Derived} */
    signal;
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
    if (is_updating_effect && effect_tracking() && (derived2.f & CONNECTED) === 0) {
      reconnect(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
__name(get$2, "get$2");
function reconnect(derived2) {
  if (derived2.deps === null) return;
  derived2.f ^= CONNECTED;
  for (const dep of derived2.deps) {
    (dep.reactions ?? (dep.reactions = [])).push(derived2);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
__name(reconnect, "reconnect");
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
__name(depends_on_old_values, "depends_on_old_values");
function safe_get(signal) {
  return signal && get$2(signal);
}
__name(safe_get, "safe_get");
function untrack(fn3) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn3();
  } finally {
    untracking = previous_untracking;
  }
}
__name(untrack, "untrack");
const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  for (var symbol2 of Object.getOwnPropertySymbols(obj)) {
    if (Object.propertyIsEnumerable.call(obj, symbol2) && !keys.includes(symbol2)) {
      result[symbol2] = obj[symbol2];
    }
  }
  return result;
}
__name(exclude_from_object, "exclude_from_object");
function deep_read_state(value2) {
  if (typeof value2 !== "object" || !value2 || value2 instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value2) {
    deep_read(value2);
  } else if (!Array.isArray(value2)) {
    for (let key2 in value2) {
      const prop2 = value2[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
__name(deep_read_state, "deep_read_state");
function deep_read(value2, visited = /* @__PURE__ */ new Set()) {
  if (typeof value2 === "object" && value2 !== null && // We don't want to traverse DOM elements
  !(value2 instanceof EventTarget) && !visited.has(value2)) {
    visited.add(value2);
    if (value2 instanceof Date) {
      value2.getTime();
    }
    for (let key2 in value2) {
      try {
        deep_read(value2[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value2);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get2 = descriptors[key2].get;
        if (get2) {
          try {
            get2.call(value2);
          } catch (e) {
          }
        }
      }
    }
  }
}
__name(deep_read, "deep_read");
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}
__name(createAttachmentKey, "createAttachmentKey");
function fromAction(action2, fn3 = (
  /** @type {() => T} */
  noop
)) {
  return (element3) => {
    const { update: update2, destroy: destroy2 } = untrack(() => action2(element3, fn3()) ?? {});
    if (update2) {
      var ran = false;
      render_effect(() => {
        const arg = fn3();
        if (ran) update2(arg);
      });
      ran = true;
    }
    if (destroy2) {
      teardown(destroy2);
    }
  };
}
__name(fromAction, "fromAction");
const regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
__name(hash, "hash");
const VOID_ELEMENT_NAMES = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
__name(is_void, "is_void");
const RESERVED_WORDS = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
function is_reserved(word) {
  return RESERVED_WORDS.includes(word);
}
__name(is_reserved, "is_reserved");
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
__name(is_capture_event, "is_capture_event");
const DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
__name(can_delegate_event, "can_delegate_event");
const DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
__name(is_boolean_attribute, "is_boolean_attribute");
const ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
__name(normalize_attribute, "normalize_attribute");
const DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
function is_dom_property(name) {
  return DOM_PROPERTIES.includes(name);
}
__name(is_dom_property, "is_dom_property");
const NON_STATIC_PROPERTIES = ["autofocus", "muted", "defaultValue", "defaultChecked"];
function cannot_be_set_statically(name) {
  return NON_STATIC_PROPERTIES.includes(name);
}
__name(cannot_be_set_statically, "cannot_be_set_statically");
const PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
__name(is_passive_event, "is_passive_event");
const CONTENT_EDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_content_editable_binding(name) {
  return CONTENT_EDITABLE_BINDINGS.includes(name);
}
__name(is_content_editable_binding, "is_content_editable_binding");
const LOAD_ERROR_ELEMENTS = [
  "body",
  "embed",
  "iframe",
  "img",
  "link",
  "object",
  "script",
  "style",
  "track"
];
function is_load_error_element(name) {
  return LOAD_ERROR_ELEMENTS.includes(name);
}
__name(is_load_error_element, "is_load_error_element");
const SVG_ELEMENTS = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg(name) {
  return SVG_ELEMENTS.includes(name);
}
__name(is_svg, "is_svg");
const MATHML_ELEMENTS = [
  "annotation",
  "annotation-xml",
  "maction",
  "math",
  "merror",
  "mfrac",
  "mi",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mprescripts",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
];
function is_mathml(name) {
  return MATHML_ELEMENTS.includes(name);
}
__name(is_mathml, "is_mathml");
const STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
const RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.eager",
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
function is_rune(name) {
  return RUNES.includes(
    /** @type {RuneName} */
    name
  );
}
__name(is_rune, "is_rune");
function is_state_creation_rune(name) {
  return STATE_CREATION_RUNES.includes(
    /** @type {StateCreationRuneName} */
    name
  );
}
__name(is_state_creation_rune, "is_state_creation_rune");
const RAW_TEXT_ELEMENTS = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
__name(is_raw_text_element, "is_raw_text_element");
function sanitize_location(location) {
  return (
    /** @type {T} */
    location?.replace(/\//g, "/​")
  );
}
__name(sanitize_location, "sanitize_location");
function compare(a, b, property, location) {
  if (a !== b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location)
    );
  }
  return a;
}
__name(compare, "compare");
function assign(object3, property, value2, location) {
  return compare(
    object3[property] = value2,
    untrack(() => object3[property]),
    property,
    location
  );
}
__name(assign, "assign");
function assign_and(object3, property, value2, location) {
  return compare(
    object3[property] && (object3[property] = value2),
    untrack(() => object3[property]),
    property,
    location
  );
}
__name(assign_and, "assign_and");
function assign_or(object3, property, value2, location) {
  return compare(
    object3[property] || (object3[property] = value2),
    untrack(() => object3[property]),
    property,
    location
  );
}
__name(assign_or, "assign_or");
function assign_nullish(object3, property, value2, location) {
  return compare(
    object3[property] ?? (object3[property] = value2),
    untrack(() => object3[property]),
    property,
    location
  );
}
__name(assign_nullish, "assign_nullish");
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style3) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style3);
}
__name(register_style, "register_style");
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style3 of styles) {
    style3.remove();
  }
  all_styles.delete(hash2);
}
__name(cleanup_styles, "cleanup_styles");
function add_locations(fn3, filename, locations) {
  return (...args2) => {
    const dom = fn3(...args2);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
__name(add_locations, "add_locations");
function assign_location(element3, filename, location) {
  element3.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element3.firstChild, filename, location[2]);
  }
}
__name(assign_location, "assign_location");
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}
__name(assign_locations, "assign_locations");
const all_registered_events = /* @__PURE__ */ new Set();
const root_event_handles = /* @__PURE__ */ new Set();
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event3 = dom.__e;
  if (event3 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event3);
      }
    });
  }
}
__name(replay_events, "replay_events");
function create_event(event_name, dom, handler, options2 = {}) {
  function target_handler(event3) {
    if (!options2.capture) {
      handle_event_propagation.call(dom, event3);
    }
    if (!event3.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event3);
      });
    }
  }
  __name(target_handler, "target_handler");
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options2);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options2);
  }
  return target_handler;
}
__name(create_event, "create_event");
function on(element3, type, handler, options2 = {}) {
  var target_handler = create_event(type, element3, handler, options2);
  return () => {
    element3.removeEventListener(type, target_handler, options2);
  };
}
__name(on, "on");
function event$1(event_name, dom, handler, capture2, passive2) {
  var options2 = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options2);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options2);
    });
  }
}
__name(event$1, "event$1");
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn3 of root_event_handles) {
    fn3(events);
  }
}
__name(delegate, "delegate");
let last_propagated_event = null;
function handle_event_propagation(event3) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event3.type;
  var path = event3.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event3.target
  );
  last_propagated_event = event3;
  var path_idx = 0;
  var handled_at = last_propagated_event === event3 && event3.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event3.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event3.target;
  if (current_target === handler_element) return;
  define_property(event3, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event3.target === current_target)) {
          delegated.call(current_target, event3);
        }
      } catch (error3) {
        if (throw_error) {
          other_errors.push(error3);
        } else {
          throw_error = error3;
        }
      }
      if (event3.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error3 of other_errors) {
        queueMicrotask(() => {
          throw error3;
        });
      }
      throw throw_error;
    }
  } finally {
    event3.__root = handler_element;
    delete event3.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function apply(thunk, element3, args2, component3, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error3;
  try {
    handler = thunk();
  } catch (e) {
    error3 = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error3)) {
    const filename = component3?.[FILENAME];
    const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args2[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args2[0]?.type + phase;
    const description2 = `\`${event_name}\` handler${location}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description2, suggestion);
    if (error3) {
      throw error3;
    }
  }
  handler?.apply(element3, args2);
}
__name(apply, "apply");
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "<!---->");
  return elem.content;
}
__name(create_fragment_from_html, "create_fragment_from_html");
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes === null) {
    effect2.nodes = { start, end, a: null, t: null };
  }
}
__name(assign_nodes, "assign_nodes");
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node);
    }
    var clone3 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone3)
      );
      var end = (
        /** @type {TemplateNode} */
        clone3.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone3, clone3);
    }
    return clone3;
  };
}
__name(from_html, "from_html");
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root2 = (
        /** @type {Element} */
        /* @__PURE__ */ get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (/* @__PURE__ */ get_first_child(root2)) {
          node.appendChild(
            /** @type {TemplateNode} */
            /* @__PURE__ */ get_first_child(root2)
          );
        }
      } else {
        node = /** @type {Element} */
        /* @__PURE__ */ get_first_child(root2);
      }
    }
    var clone3 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone3)
      );
      var end = (
        /** @type {TemplateNode} */
        clone3.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone3, clone3);
    }
    return clone3;
  };
}
__name(from_namespace, "from_namespace");
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
__name(from_svg, "from_svg");
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
__name(from_mathml, "from_mathml");
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element3 = create_element(name, namespace, attributes?.is);
    for (var key2 in attributes) {
      set_attribute$1(element3, key2, attributes[key2]);
    }
    if (children.length > 0) {
      var target = element3.tagName === "TEMPLATE" ? (
        /** @type {HTMLTemplateElement} */
        element3.content
      ) : element3;
      target.append(
        fragment_from_tree(children, element3.tagName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element3);
  }
  return fragment;
}
__name(fragment_from_tree, "fragment_from_tree");
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node);
    }
    var clone3 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(clone3)
      );
      var end = (
        /** @type {TemplateNode} */
        clone3.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone3, clone3);
    }
    return clone3;
  };
}
__name(from_tree, "from_tree");
function with_script(fn3) {
  return () => run_scripts(fn3());
}
__name(with_script, "with_script");
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  for (const script of scripts) {
    const clone3 = document.createElement("script");
    for (var attribute of script.attributes) {
      clone3.setAttribute(attribute.name, attribute.value);
    }
    clone3.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes.start = clone3;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes.end = clone3;
    }
    script.replaceWith(clone3);
  }
  return node;
}
__name(run_scripts, "run_scripts");
function text(value2 = "") {
  if (!hydrating) {
    var t = create_text(value2 + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
__name(text, "text");
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
__name(comment, "comment");
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect & { nodes: EffectNodes }} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes.end === null) {
      effect2.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
__name(append, "append");
function props_id() {
  var _a2;
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
    const id2 = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id2;
  }
  (_a2 = window.__svelte ?? (window.__svelte = {})).uid ?? (_a2.uid = 1);
  return `c${window.__svelte.uid++}`;
}
__name(props_id, "props_id");
let should_intro = true;
function set_should_intro(value2) {
  should_intro = value2;
}
__name(set_should_intro, "set_should_intro");
function set_text(text2, value2) {
  var str = value2 == null ? "" : typeof value2 === "object" ? value2 + "" : value2;
  if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
__name(set_text, "set_text");
function mount(component3, options2) {
  return _mount(component3, options2);
}
__name(mount, "mount");
function hydrate(component3, options2) {
  init_operations();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = /* @__PURE__ */ get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /* @__PURE__ */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance2 = _mount(component3, { ...options2, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance2
    );
  } catch (error3) {
    if (error3 instanceof Error && error3.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error3;
    }
    if (error3 !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error3);
    }
    if (options2.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component3, options2);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
const document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component3 = void 0;
  var unmount3 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: /* @__PURE__ */ __name(() => {
        }, "pending")
      },
      (anchor_node2) => {
        if (context) {
          push$1({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component3 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes.end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component3, unmount3);
  return component3;
}
__name(_mount, "_mount");
let mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component3, options2) {
  const fn3 = mounted_components.get(component3);
  if (fn3) {
    mounted_components.delete(component3);
    return fn3(options2);
  }
  if (DEV) {
    if (STATE_SYMBOL in component3) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
__name(unmount, "unmount");
function hmr(fn3) {
  const current = source(fn3);
  function wrapper(anchor, props) {
    let component3 = {};
    let instance2 = {};
    let effect2;
    let ran = false;
    block(() => {
      if (component3 === (component3 = get$2(current))) {
        return;
      }
      if (effect2) {
        for (var k in instance2) delete instance2[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance2,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component3(anchor, props) : component3(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance2;
  }
  __name(wrapper, "wrapper");
  wrapper[FILENAME] = fn3[FILENAME];
  wrapper[HMR] = {
    fn: fn3,
    current,
    update: /* @__PURE__ */ __name((incoming) => {
      set$1(wrapper[HMR].current, incoming[HMR].fn);
      incoming[HMR].current = wrapper[HMR].current;
    }, "update")
  };
  return wrapper;
}
__name(hmr, "hmr");
function create_ownership_validator(props) {
  const component3 = component_context?.function;
  const parent4 = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: /* @__PURE__ */ __name((prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent4) {
        return result;
      }
      let value2 = props;
      for (let i = 0; i < path.length - 1; i++) {
        value2 = value2[path[i]];
        if (!value2?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location = sanitize_location(`${component3[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location, prop2, parent4[FILENAME]);
      return result;
    }, "mutation"),
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: /* @__PURE__ */ __name((key2, child_component, value2) => {
      if (!is_bound_or_unset(props, key2) && parent4 && value2()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component3[FILENAME],
          key2,
          child_component[FILENAME],
          parent4[FILENAME]
        );
      }
    }, "binding")
  };
}
__name(create_ownership_validator, "create_ownership_validator");
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}
__name(is_bound_or_unset, "is_bound_or_unset");
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
__name(check_target, "check_target");
function legacy_api() {
  const component3 = component_context?.function;
  function error3(method) {
    component_api_changed(method, component3[FILENAME]);
  }
  __name(error3, "error");
  return {
    $destroy: /* @__PURE__ */ __name(() => error3("$destroy()"), "$destroy"),
    $on: /* @__PURE__ */ __name(() => error3("$on(...)"), "$on"),
    $set: /* @__PURE__ */ __name(() => error3("$set(...)"), "$set")
  };
}
__name(legacy_api, "legacy_api");
function inspect(get_value, inspector, show_stack = false) {
  validate_effect("$inspect");
  let initial = true;
  let error3 = (
    /** @type {any} */
    UNINITIALIZED
  );
  eager_effect(() => {
    try {
      var value2 = get_value();
    } catch (e) {
      error3 = e;
      return;
    }
    var snap = snapshot(value2, true, true);
    untrack(() => {
      if (show_stack) {
        inspector(...snap);
        if (!initial) {
          const stack2 = get_error("$inspect(...)");
          if (stack2) {
            console.groupCollapsed("stack trace");
            console.log(stack2);
            console.groupEnd();
          }
        }
      } else {
        inspector(initial ? "init" : "update", ...snap);
      }
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error3 !== UNINITIALIZED) {
      console.error(error3);
      error3 = UNINITIALIZED;
    }
  });
}
__name(inspect, "inspect");
function async(node, blockers = [], expressions = [], fn3) {
  var boundary2 = get_boundary();
  var batch2 = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch2.increment(blocking);
  var was_hydrating = hydrating;
  if (was_hydrating) {
    hydrate_next();
    var previous_hydrate_node = hydrate_node;
    var end = skip_nodes(false);
    set_hydrate_node(end);
  }
  flatten(blockers, [], expressions, (values2) => {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    try {
      for (const d of values2) get$2(d);
      fn3(node, ...values2);
    } finally {
      if (was_hydrating) {
        set_hydrating(false);
      }
      boundary2.update_pending_count(-1);
      batch2.decrement(blocking);
    }
  });
}
__name(async, "async");
function validate_snippet_args(anchor, ...args2) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args2) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}
__name(validate_snippet_args, "validate_snippet_args");
const _BranchManager = class _BranchManager {
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(anchor, transition2 = true) {
    /** @type {TemplateNode} */
    __publicField(this, "anchor");
    /** @type {Map<Batch, Key>} */
    __privateAdd(this, _batches, /* @__PURE__ */ new Map());
    /**
     * Map of keys to effects that are currently rendered in the DOM.
     * These effects are visible and actively part of the document tree.
     * Example:
     * ```
     * {#if condition}
     * 	foo
     * {:else}
     * 	bar
     * {/if}
     * ```
     * Can result in the entries `true->Effect` and `false->Effect`
     * @type {Map<Key, Effect>}
     */
    __privateAdd(this, _onscreen, /* @__PURE__ */ new Map());
    /**
     * Similar to #onscreen with respect to the keys, but contains branches that are not yet
     * in the DOM, because their insertion is deferred.
     * @type {Map<Key, Branch>}
     */
    __privateAdd(this, _offscreen, /* @__PURE__ */ new Map());
    /**
     * Keys of effects that are currently outroing
     * @type {Set<Key>}
     */
    __privateAdd(this, _outroing, /* @__PURE__ */ new Set());
    /**
     * Whether to pause (i.e. outro) on change, or destroy immediately.
     * This is necessary for `<svelte:element>`
     */
    __privateAdd(this, _transition, true);
    __privateAdd(this, _commit, /* @__PURE__ */ __name(() => {
      var batch2 = (
        /** @type {Batch} */
        current_batch
      );
      if (!__privateGet(this, _batches).has(batch2)) return;
      var key2 = (
        /** @type {Key} */
        __privateGet(this, _batches).get(batch2)
      );
      var onscreen = __privateGet(this, _onscreen).get(key2);
      if (onscreen) {
        resume_effect(onscreen);
        __privateGet(this, _outroing).delete(key2);
      } else {
        var offscreen = __privateGet(this, _offscreen).get(key2);
        if (offscreen) {
          __privateGet(this, _onscreen).set(key2, offscreen.effect);
          __privateGet(this, _offscreen).delete(key2);
          offscreen.fragment.lastChild.remove();
          this.anchor.before(offscreen.fragment);
          onscreen = offscreen.effect;
        }
      }
      for (const [b, k] of __privateGet(this, _batches)) {
        __privateGet(this, _batches).delete(b);
        if (b === batch2) {
          break;
        }
        const offscreen2 = __privateGet(this, _offscreen).get(k);
        if (offscreen2) {
          destroy_effect(offscreen2.effect);
          __privateGet(this, _offscreen).delete(k);
        }
      }
      for (const [k, effect2] of __privateGet(this, _onscreen)) {
        if (k === key2 || __privateGet(this, _outroing).has(k)) continue;
        const on_destroy = /* @__PURE__ */ __name(() => {
          const keys = Array.from(__privateGet(this, _batches).values());
          if (keys.includes(k)) {
            var fragment = document.createDocumentFragment();
            move_effect(effect2, fragment);
            fragment.append(create_text());
            __privateGet(this, _offscreen).set(k, { effect: effect2, fragment });
          } else {
            destroy_effect(effect2);
          }
          __privateGet(this, _outroing).delete(k);
          __privateGet(this, _onscreen).delete(k);
        }, "on_destroy");
        if (__privateGet(this, _transition) || !onscreen) {
          __privateGet(this, _outroing).add(k);
          pause_effect(effect2, on_destroy, false);
        } else {
          on_destroy();
        }
      }
    }, "#commit"));
    /**
     * @param {Batch} batch
     */
    __privateAdd(this, _discard, /* @__PURE__ */ __name((batch2) => {
      __privateGet(this, _batches).delete(batch2);
      const keys = Array.from(__privateGet(this, _batches).values());
      for (const [k, branch2] of __privateGet(this, _offscreen)) {
        if (!keys.includes(k)) {
          destroy_effect(branch2.effect);
          __privateGet(this, _offscreen).delete(k);
        }
      }
    }, "#discard"));
    this.anchor = anchor;
    __privateSet(this, _transition, transition2);
  }
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(key2, fn3) {
    var batch2 = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    if (fn3 && !__privateGet(this, _onscreen).has(key2) && !__privateGet(this, _offscreen).has(key2)) {
      if (defer) {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        __privateGet(this, _offscreen).set(key2, {
          effect: branch(() => fn3(target)),
          fragment
        });
      } else {
        __privateGet(this, _onscreen).set(
          key2,
          branch(() => fn3(this.anchor))
        );
      }
    }
    __privateGet(this, _batches).set(batch2, key2);
    if (defer) {
      for (const [k, effect2] of __privateGet(this, _onscreen)) {
        if (k === key2) {
          batch2.skipped_effects.delete(effect2);
        } else {
          batch2.skipped_effects.add(effect2);
        }
      }
      for (const [k, branch2] of __privateGet(this, _offscreen)) {
        if (k === key2) {
          batch2.skipped_effects.delete(branch2.effect);
        } else {
          batch2.skipped_effects.add(branch2.effect);
        }
      }
      batch2.oncommit(__privateGet(this, _commit));
      batch2.ondiscard(__privateGet(this, _discard));
    } else {
      if (hydrating) {
        this.anchor = hydrate_node;
      }
      __privateGet(this, _commit).call(this);
    }
  }
};
_batches = new WeakMap();
_onscreen = new WeakMap();
_offscreen = new WeakMap();
_outroing = new WeakMap();
_transition = new WeakMap();
_commit = new WeakMap();
_discard = new WeakMap();
__name(_BranchManager, "BranchManager");
let BranchManager = _BranchManager;
const PENDING = 0;
const THEN = 1;
const CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var runes = is_runes();
  var v = (
    /** @type {V} */
    UNINITIALIZED
  );
  var value2 = runes ? source(v) : /* @__PURE__ */ mutable_source(v, false, false);
  var error3 = runes ? source(v) : /* @__PURE__ */ mutable_source(v, false, false);
  var branches = new BranchManager(node);
  block(() => {
    var input = get_input();
    var destroyed2 = false;
    let mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);
    if (mismatch) {
      set_hydrate_node(skip_nodes());
      set_hydrating(false);
    }
    if (is_promise(input)) {
      var restore = capture();
      var resolved = false;
      const resolve2 = /* @__PURE__ */ __name((fn3) => {
        if (destroyed2) return;
        resolved = true;
        restore(false);
        Batch.ensure();
        if (hydrating) {
          set_hydrating(false);
        }
        try {
          fn3();
        } finally {
          unset_context();
          if (!is_flushing_sync) flushSync();
        }
      }, "resolve");
      input.then(
        (v3) => {
          resolve2(() => {
            internal_set(value2, v3);
            branches.ensure(THEN, then_fn && ((target) => then_fn(target, value2)));
          });
        },
        (e) => {
          resolve2(() => {
            internal_set(error3, e);
            branches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error3)));
            if (!catch_fn) {
              throw error3.v;
            }
          });
        }
      );
      if (hydrating) {
        branches.ensure(PENDING, pending_fn);
      } else {
        queue_micro_task(() => {
          if (!resolved) {
            resolve2(() => {
              branches.ensure(PENDING, pending_fn);
            });
          }
        });
      }
    } else {
      internal_set(value2, input);
      branches.ensure(THEN, then_fn && ((target) => then_fn(target, value2)));
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => {
      destroyed2 = true;
    };
  });
}
__name(await_block, "await_block");
function if_block(node, fn3, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(condition, fn4) {
    if (hydrating) {
      const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;
      if (condition === is_else) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(condition, fn4);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(condition, fn4);
  }
  __name(update_branch, "update_branch");
  block(() => {
    var has_branch = false;
    fn3((fn4, flag = true) => {
      has_branch = true;
      update_branch(flag, fn4);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}
__name(if_block, "if_block");
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var legacy = !is_runes();
  block(() => {
    var key2 = get_key();
    if (legacy && key2 !== null && typeof key2 === "object") {
      key2 = /** @type {V} */
      {};
    }
    branches.ensure(key2, render_fn);
  });
}
__name(key, "key");
function css_props(element3, get_styles) {
  if (hydrating) {
    set_hydrate_node(/* @__PURE__ */ get_first_child(element3));
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value2 = styles[key2];
      if (value2) {
        element3.style.setProperty(key2, value2);
      } else {
        element3.style.removeProperty(key2);
      }
    }
  });
}
__name(css_props, "css_props");
function index(_, i) {
  return i;
}
__name(index, "index");
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length2 = to_destroy.length;
  var group2;
  var remaining = to_destroy.length;
  for (var i = 0; i < length2; i++) {
    let effect2 = to_destroy[i];
    pause_effect(
      effect2,
      () => {
        if (group2) {
          group2.pending.delete(effect2);
          group2.done.add(effect2);
          if (group2.pending.size === 0) {
            var groups = (
              /** @type {Set<EachOutroGroup>} */
              state2.outrogroups
            );
            destroy_effects(array_from(group2.done));
            groups.delete(group2);
            if (groups.size === 0) {
              state2.outrogroups = null;
            }
          }
        } else {
          remaining -= 1;
        }
      },
      false
    );
  }
  if (remaining === 0) {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group2 = {
      pending: new Set(to_destroy),
      done: /* @__PURE__ */ new Set()
    };
    (state2.outrogroups ?? (state2.outrogroups = /* @__PURE__ */ new Set())).add(group2);
  }
}
__name(pause_effects, "pause_effects");
function destroy_effects(to_destroy, remove_dom = true) {
  for (var i = 0; i < to_destroy.length; i++) {
    destroy_effect(to_destroy[i], remove_dom);
  }
}
__name(destroy_effects, "destroy_effects");
var offscreen_anchor;
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(/* @__PURE__ */ get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var each_array = /* @__PURE__ */ derived_safe_equal(() => {
    var collection4 = get_collection();
    return is_array(collection4) ? collection4 : collection4 == null ? [] : array_from(collection4);
  });
  var array3;
  var first_run = true;
  function commit() {
    state2.fallback = fallback2;
    reconcile(state2, array3, anchor, flags2, get_key);
    if (fallback2 !== null) {
      if (array3.length === 0) {
        if ((fallback2.f & EFFECT_OFFSCREEN) === 0) {
          resume_effect(fallback2);
        } else {
          fallback2.f ^= EFFECT_OFFSCREEN;
          move(fallback2, null, anchor);
        }
      } else {
        pause_effect(fallback2, () => {
          fallback2 = null;
        });
      }
    }
  }
  __name(commit, "commit");
  var effect2 = block(() => {
    array3 = /** @type {V[]} */
    get$2(each_array);
    var length2 = array3.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length2 === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch2 = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    for (var index2 = 0; index2 < length2; index2 += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value2 = array3[index2];
      var key2 = get_key(value2, index2);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (item.v) internal_set(item.v, value2);
        if (item.i) internal_set(item.i, index2);
        if (defer) {
          batch2.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(
          items,
          first_run ? anchor : offscreen_anchor ?? (offscreen_anchor = create_text()),
          value2,
          key2,
          index2,
          render_fn,
          flags2,
          get_collection
        );
        if (!first_run) {
          item.e.f |= EFFECT_OFFSCREEN;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length2 === 0 && fallback_fn && !fallback2) {
      if (first_run) {
        fallback2 = branch(() => fallback_fn(anchor));
      } else {
        fallback2 = branch(() => fallback_fn(offscreen_anchor ?? (offscreen_anchor = create_text())));
        fallback2.f |= EFFECT_OFFSCREEN;
      }
    }
    if (hydrating && length2 > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch2.skipped_effects.add(item2.e);
          }
        }
        batch2.oncommit(commit);
        batch2.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get$2(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, outrogroups: null, fallback: fallback2 };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
__name(each, "each");
function reconcile(state2, array3, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length2 = array3.length;
  var items = state2.items;
  var current = state2.effect.first;
  var seen2;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value2;
  var key2;
  var effect2;
  var i;
  if (is_animated) {
    for (i = 0; i < length2; i += 1) {
      value2 = array3[i];
      key2 = get_key(value2, i);
      effect2 = /** @type {EachItem} */
      items.get(key2).e;
      if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
        effect2.nodes?.a?.measure();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(effect2);
      }
    }
  }
  for (i = 0; i < length2; i += 1) {
    value2 = array3[i];
    key2 = get_key(value2, i);
    effect2 = /** @type {EachItem} */
    items.get(key2).e;
    if (state2.outrogroups !== null) {
      for (const group2 of state2.outrogroups) {
        group2.pending.delete(effect2);
        group2.done.delete(effect2);
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) !== 0) {
      effect2.f ^= EFFECT_OFFSCREEN;
      if (effect2 === current) {
        move(effect2, null, anchor);
      } else {
        var next2 = prev ? prev.next : current;
        if (effect2 === state2.effect.last) {
          state2.effect.last = effect2.prev;
        }
        if (effect2.prev) effect2.prev.next = effect2.next;
        if (effect2.next) effect2.next.prev = effect2.prev;
        link(state2, prev, effect2);
        link(state2, effect2, next2);
        move(effect2, next2, anchor);
        prev = effect2;
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
    }
    if ((effect2.f & INERT) !== 0) {
      resume_effect(effect2);
      if (is_animated) {
        effect2.nodes?.a?.unfix();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(effect2);
      }
    }
    if (effect2 !== current) {
      if (seen2 !== void 0 && seen2.has(effect2)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen2.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen2.delete(effect2);
          move(effect2, current, anchor);
          link(state2, effect2.prev, effect2.next);
          link(state2, effect2, prev === null ? state2.effect.first : prev.next);
          link(state2, prev, effect2);
          prev = effect2;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current !== effect2) {
        (seen2 ?? (seen2 = /* @__PURE__ */ new Set())).add(current);
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
      matched.push(effect2);
    }
    prev = effect2;
    current = effect2.next;
  }
  if (state2.outrogroups !== null) {
    for (const group2 of state2.outrogroups) {
      if (group2.pending.size === 0) {
        destroy_effects(array_from(group2.done));
        state2.outrogroups?.delete(group2);
      }
    }
    if (state2.outrogroups.size === 0) {
      state2.outrogroups = null;
    }
  }
  if (current !== null || seen2 !== void 0) {
    var to_destroy = [];
    if (seen2 !== void 0) {
      for (effect2 of seen2) {
        if ((effect2.f & INERT) === 0) {
          to_destroy.push(effect2);
        }
      }
    }
    while (current !== null) {
      if ((current.f & INERT) === 0 && current !== state2.fallback) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length2 === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (effect2 of to_animate) {
        effect2.nodes?.a?.apply();
      }
    });
  }
}
__name(reconcile, "reconcile");
function create_item(items, anchor, value2, key2, index2, render_fn, flags2, get_collection) {
  var v = (flags2 & EACH_ITEM_REACTIVE) !== 0 ? (flags2 & EACH_ITEM_IMMUTABLE) === 0 ? /* @__PURE__ */ mutable_source(value2, false, false) : source(value2) : null;
  var i = (flags2 & EACH_INDEX_REACTIVE) !== 0 ? source(index2) : null;
  if (DEV && v) {
    v.trace = () => {
      get_collection()[i?.v ?? index2];
    };
  }
  return {
    v,
    i,
    e: branch(() => {
      render_fn(anchor, v ?? value2, i ?? index2, get_collection);
      return () => {
        items.delete(key2);
      };
    })
  };
}
__name(create_item, "create_item");
function move(effect2, next2, anchor) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  var dest = next2 && (next2.f & EFFECT_OFFSCREEN) === 0 ? (
    /** @type {EffectNodes} */
    next2.nodes.start
  ) : anchor;
  while (node !== null) {
    var next_node = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    dest.before(node);
    if (node === end) {
      return;
    }
    node = next_node;
  }
}
__name(move, "move");
function link(state2, prev, next2) {
  if (prev === null) {
    state2.effect.first = next2;
  } else {
    prev.next = next2;
  }
  if (next2 === null) {
    state2.effect.last = prev;
  } else {
    next2.prev = prev;
  }
}
__name(link, "link");
function check_hash(element3, server_hash, value2) {
  if (!server_hash || server_hash === hash(String(value2 ?? ""))) return;
  let location;
  const loc = element3.__svelte_meta?.loc;
  if (loc) {
    location = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location));
}
__name(check_hash, "check_hash");
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value2 = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value2 === (value2 = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes !== null) {
      remove_effect_dom(
        effect2.nodes.start,
        /** @type {TemplateNode} */
        effect2.nodes.end
      );
      effect2.nodes = null;
    }
    if (value2 === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last2 = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last2 = next2;
        next2 = /* @__PURE__ */ get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (DEV && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value2
        );
      }
      assign_nodes(hydrate_node, last2);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html2 = value2 + "";
    if (svg) html2 = `<svg>${html2}</svg>`;
    else if (mathml) html2 = `<math>${html2}</math>`;
    var node2 = create_fragment_from_html(html2);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      /* @__PURE__ */ get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (/* @__PURE__ */ get_first_child(node2)) {
        anchor.before(
          /** @type {TemplateNode} */
          /* @__PURE__ */ get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}
__name(html, "html");
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
__name(slot, "slot");
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}
__name(sanitize_slots, "sanitize_slots");
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
__name(validate_void_dynamic_element, "validate_void_dynamic_element");
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
__name(validate_dynamic_element_tag, "validate_dynamic_element_tag");
function validate_store(store2, name) {
  if (store2 != null && typeof store2.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
__name(validate_store, "validate_store");
function prevent_snippet_stringification(fn3) {
  fn3.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn3;
}
__name(prevent_snippet_stringification, "prevent_snippet_stringification");
function snippet(node, get_snippet, ...args2) {
  var branches = new BranchManager(node);
  block(() => {
    const snippet2 = get_snippet() ?? null;
    if (DEV && snippet2 == null) {
      invalid_snippet();
    }
    branches.ensure(snippet2, snippet2 && ((anchor) => snippet2(anchor, ...args2)));
  }, EFFECT_TRANSPARENT);
}
__name(snippet, "snippet");
function wrap_snippet(component3, fn3) {
  const snippet2 = /* @__PURE__ */ __name((node, ...args2) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component3);
    try {
      return fn3(node, ...args2);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  }, "snippet");
  prevent_snippet_stringification(snippet2);
  return snippet2;
}
__name(wrap_snippet, "wrap_snippet");
function createRawSnippet(fn3) {
  return (anchor, ...params) => {
    var snippet2 = fn3(...params);
    var element3;
    if (hydrating) {
      element3 = /** @type {Element} */
      hydrate_node;
      hydrate_next();
    } else {
      var html2 = snippet2.render().trim();
      var fragment = create_fragment_from_html(html2);
      element3 = /** @type {Element} */
      /* @__PURE__ */ get_first_child(fragment);
      if (DEV && (/* @__PURE__ */ get_next_sibling(element3) !== null || element3.nodeType !== ELEMENT_NODE)) {
        invalid_raw_snippet_render();
      }
      anchor.before(element3);
    }
    const result = snippet2.setup?.(element3);
    assign_nodes(element3, element3);
    if (typeof result === "function") {
      teardown(result);
    }
  };
}
__name(createRawSnippet, "createRawSnippet");
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  block(() => {
    var component3 = get_component() ?? null;
    branches.ensure(component3, component3 && ((target) => render_fn(target, component3)));
  }, EFFECT_TRANSPARENT);
}
__name(component, "component");
const now = BROWSER ? () => performance.now() : () => Date.now();
const raf$1 = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    /* @__PURE__ */ __name((_) => (BROWSER ? requestAnimationFrame : noop)(_), "tick")
  ),
  now: /* @__PURE__ */ __name(() => now(), "now"),
  tasks: /* @__PURE__ */ new Set()
};
function run_tasks() {
  const now2 = raf$1.now();
  raf$1.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf$1.tasks.delete(task);
      task.f();
    }
  });
  if (raf$1.tasks.size !== 0) {
    raf$1.tick(run_tasks);
  }
}
__name(run_tasks, "run_tasks");
function loop(callback) {
  let task;
  if (raf$1.tasks.size === 0) {
    raf$1.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill2) => {
      raf$1.tasks.add(task = { c: callback, f: fulfill2 });
    }),
    abort() {
      raf$1.tasks.delete(task);
    }
  };
}
__name(loop, "loop");
function dispatch_event(element3, type) {
  without_reactive_context(() => {
    element3.dispatchEvent(new CustomEvent(type));
  });
}
__name(dispatch_event, "dispatch_event");
function css_property_to_camelcase(style3) {
  if (style3 === "float") return "cssFloat";
  if (style3 === "offset") return "cssOffset";
  if (style3.startsWith("--")) return style3;
  const parts = style3.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
__name(css_property_to_camelcase, "css_property_to_camelcase");
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value2] = part.split(":");
    if (!property || value2 === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value2.trim();
  }
  return keyframe;
}
__name(css_to_keyframe, "css_to_keyframe");
const linear = /* @__PURE__ */ __name((t) => t, "linear");
let animation_effect_override = null;
function set_animation_effect_override(v) {
  animation_effect_override = v;
}
__name(set_animation_effect_override, "set_animation_effect_override");
function animation(element3, get_fn, get_params) {
  var effect2 = animation_effect_override ?? /** @type {Effect} */
  active_effect;
  var nodes3 = (
    /** @type {EffectNodes} */
    effect2.nodes
  );
  var from;
  var to;
  var animation22;
  var original_styles = null;
  nodes3.a ?? (nodes3.a = {
    element: element3,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation22?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options2 = get_fn()(this.element, { from, to }, get_params?.());
        animation22 = animate(this.element, options2, void 0, 1, () => {
          animation22?.abort();
          animation22 = void 0;
        });
      }
    },
    fix() {
      if (element3.getAnimations().length) return;
      var { position: position3, width: width2, height: height2 } = getComputedStyle(element3);
      if (position3 !== "absolute" && position3 !== "fixed") {
        var style3 = (
          /** @type {HTMLElement | SVGElement} */
          element3.style
        );
        original_styles = {
          position: style3.position,
          width: style3.width,
          height: style3.height,
          transform: style3.transform
        };
        style3.position = "absolute";
        style3.width = width2;
        style3.height = height2;
        var to2 = element3.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform7 = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style3.transform = style3.transform ? `${style3.transform} ${transform7}` : transform7;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style3 = (
          /** @type {HTMLElement | SVGElement} */
          element3.style
        );
        style3.position = original_styles.position;
        style3.width = original_styles.width;
        style3.height = original_styles.height;
        style3.transform = original_styles.transform;
      }
    }
  });
  nodes3.a.element = element3;
}
__name(animation, "animation");
function transition(flags2, element3, get_fn, get_params) {
  var _a2;
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element3.inert;
  var overflow = element3.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ?? (current_options = get_fn()(element3, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      }));
    });
  }
  __name(get_options, "get_options");
  var transition2 = {
    is_global,
    in() {
      element3.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      dispatch_event(element3, "introstart");
      intro = animate(element3, get_options(), outro, 1, () => {
        dispatch_event(element3, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element3.style.overflow = overflow;
      });
    },
    out(fn3) {
      if (!is_outro) {
        fn3?.();
        current_options = void 0;
        return;
      }
      element3.inert = true;
      dispatch_event(element3, "outrostart");
      outro = animate(element3, get_options(), intro, 0, () => {
        dispatch_event(element3, "outroend");
        fn3?.();
      });
    },
    stop: /* @__PURE__ */ __name(() => {
      intro?.abort();
      outro?.abort();
    }, "stop")
  };
  var e = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  ((_a2 = e.nodes).t ?? (_a2.t = [])).push(transition2);
  if (is_intro && should_intro) {
    var run2 = is_global;
    if (!run2) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run2) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
__name(transition, "transition");
function animate(element3, options2, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options2)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options2({ direction: is_intro ? "in" : "out" });
      a = animate(element3, o, counterpart, t2, on_finish);
    });
    return {
      abort: /* @__PURE__ */ __name(() => {
        aborted2 = true;
        a?.abort();
      }, "abort"),
      deactivate: /* @__PURE__ */ __name(() => a.deactivate(), "deactivate"),
      reset: /* @__PURE__ */ __name(() => a.reset(), "reset"),
      t: /* @__PURE__ */ __name(() => a.t(), "t")
    };
  }
  counterpart?.deactivate();
  if (!options2?.duration) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: /* @__PURE__ */ __name(() => t2, "t")
    };
  }
  const { delay: delay2 = 0, css, tick: tick2, easing = linear } = options2;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick2) {
      tick2(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = /* @__PURE__ */ __name(() => 1 - t2, "get_t");
  var animation22 = element3.animate(keyframes, { duration: delay2, fill: "forwards" });
  animation22.onfinish = () => {
    animation22.cancel();
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options2.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden || (needs_overflow_hidden = styles2.overflow === "hidden");
        }
      }
      if (needs_overflow_hidden) {
        element3.style.overflow = "hidden";
      }
      get_t = /* @__PURE__ */ __name(() => {
        var time2 = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation22.currentTime
        );
        return t1 + delta * easing(time2 / duration);
      }, "get_t");
      if (tick2) {
        loop(() => {
          if (animation22.playState !== "running") return false;
          var t3 = get_t();
          tick2(t3, 1 - t3);
          return true;
        });
      }
    }
    animation22 = element3.animate(keyframes2, { duration, fill: "forwards" });
    animation22.onfinish = () => {
      get_t = /* @__PURE__ */ __name(() => t2, "get_t");
      tick2?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: /* @__PURE__ */ __name(() => {
      if (animation22) {
        animation22.cancel();
        animation22.effect = null;
        animation22.onfinish = noop;
      }
    }, "abort"),
    deactivate: /* @__PURE__ */ __name(() => {
      on_finish = noop;
    }, "deactivate"),
    reset: /* @__PURE__ */ __name(() => {
      if (t2 === 0) {
        tick2?.(1, 0);
      }
    }, "reset"),
    t: /* @__PURE__ */ __name(() => get_t(), "t")
  };
}
__name(animate, "animate");
function element$1(node, get_tag, is_svg2, render_fn, get_namespace, location) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = DEV && location && component_context?.function[FILENAME];
  var element3 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element3 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  var branches = new BranchManager(anchor, false);
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg2 || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === null) {
      branches.ensure(null, null);
      set_should_intro(true);
      return;
    }
    branches.ensure(next_tag, (anchor2) => {
      if (next_tag) {
        element3 = hydrating ? (
          /** @type {Element} */
          element3
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (DEV && location) {
          element3.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element3, element3);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element3.append(document.createComment(""));
          }
          var child_anchor = hydrating ? /* @__PURE__ */ get_first_child(element3) : element3.appendChild(create_text());
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          set_animation_effect_override(parent_effect);
          render_fn(element3, child_anchor);
          set_animation_effect_override(null);
        }
        active_effect.nodes.end = element3;
        anchor2.before(element3);
      }
      if (hydrating) {
        set_hydrate_node(anchor2);
      }
    });
    set_should_intro(true);
    return () => {
      if (next_tag) {
        set_should_intro(false);
      }
    };
  }, EFFECT_TRANSPARENT);
  teardown(() => {
    set_should_intro(true);
  });
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}
__name(element$1, "element$1");
function head(hash2, render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    var head_anchor = /* @__PURE__ */ get_first_child(document.head);
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== hash2)) {
      head_anchor = /* @__PURE__ */ get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      var start = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_next_sibling(head_anchor)
      );
      head_anchor.remove();
      set_hydrate_node(start);
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}
__name(head, "head");
function append_styles$1(anchor, css) {
  effect(() => {
    var root2 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root2.host ? (
        /** @type {ShadowRoot} */
        root2
      ) : (
        /** @type {Document} */
        root2.head ?? /** @type {Document} */
        root2.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style3 = document.createElement("style");
      style3.id = css.hash;
      style3.textContent = css.code;
      target.appendChild(style3);
      if (DEV) {
        register_style(css.hash, style3);
      }
    }
  });
}
__name(append_styles$1, "append_styles$1");
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value2 = get_value();
        deep_read_state(value2);
        if (inited && safe_not_equal(prev, value2)) {
          prev = value2;
          payload.update(value2);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}
__name(action, "action");
function attach(node, get_fn) {
  var fn3 = void 0;
  var e;
  managed(() => {
    if (fn3 !== (fn3 = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn3) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn3(node)
          ));
        });
      }
    }
  });
}
__name(attach, "attach");
const ATTR_REGEX = /[&"<]/g;
const CONTENT_REGEX = /[&<]/g;
function escape_html(value2, is_attr) {
  const str = String(value2 ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last2 = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last2, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i + 1;
  }
  return escaped + str.substring(last2);
}
__name(escape_html, "escape_html");
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
__name(r, "r");
function clsx$1() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
__name(clsx$1, "clsx$1");
const replacements = {
  translate: /* @__PURE__ */ new Map([
    [true, "yes"],
    [false, "no"]
  ])
};
function attr(name, value2, is_boolean = false) {
  if (name === "hidden" && value2 !== "until-found") {
    is_boolean = true;
  }
  if (value2 == null || !value2 && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value2) || value2;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
__name(attr, "attr");
function clsx(value2) {
  if (typeof value2 === "object") {
    return clsx$1(value2);
  } else {
    return value2 ?? "";
  }
}
__name(clsx, "clsx");
const whitespace = [..." 	\n\r\f \v\uFEFF"];
function to_class(value2, hash2, directives) {
  var classname = value2 == null ? "" : "" + value2;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
__name(to_class, "to_class");
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value2 = styles[key2];
    if (value2 != null && value2 !== "") {
      css += " " + key2 + ": " + value2 + separator;
    }
  }
  return css;
}
__name(append_styles, "append_styles");
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
__name(to_css_name, "to_css_name");
function to_style(value2, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value2) {
      value2 = String(value2).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value2.length;
      for (var i = 0; i < len; i++) {
        var c = value2[i];
        if (in_comment) {
          if (c === "/" && value2[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value2[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value2.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value2.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value2 == null ? null : String(value2);
}
__name(to_style, "to_style");
function set_class(dom, is_html, value2, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value2 || prev === void 0) {
    var next_class_name = to_class(value2, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value2;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}
__name(set_class, "set_class");
function update_styles(dom, prev = {}, next2, priority3) {
  for (var key2 in next2) {
    var value2 = next2[key2];
    if (prev[key2] !== value2) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value2, priority3);
      }
    }
  }
}
__name(update_styles, "update_styles");
function set_style(dom, value2, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value2) {
    var next_style_attr = to_style(value2, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value2;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}
__name(set_style, "set_style");
function select_option(select, value2, mounting = false) {
  if (select.multiple) {
    if (value2 == void 0) {
      return;
    }
    if (!is_array(value2)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value2.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value2)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
__name(select_option, "select_option");
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
__name(init_select, "init_select");
function bind_select_value(select, get2, set2 = get2) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value2;
    if (select.multiple) {
      value2 = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value2 = selected_option && get_option_value(selected_option);
    }
    set2(value2);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var value2 = get2();
    if (select === document.activeElement) {
      var batch2 = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch2)) {
        return;
      }
    }
    select_option(select, value2, mounting);
    if (mounting && value2 === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value2 = get_option_value(selected_option);
        set2(value2);
      }
    }
    select.__value = value2;
    mounting = false;
  });
  init_select(select);
}
__name(bind_select_value, "bind_select_value");
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
__name(get_option_value, "get_option_value");
const CLASS = /* @__PURE__ */ Symbol("class");
const STYLE = /* @__PURE__ */ Symbol("style");
const IS_CUSTOM_ELEMENT = /* @__PURE__ */ Symbol("is custom element");
const IS_HTML = /* @__PURE__ */ Symbol("is html");
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = /* @__PURE__ */ __name(() => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value2 = input.value;
      set_attribute(input, "value", null);
      input.value = value2;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute(input, "checked", null);
      input.checked = checked;
    }
  }, "remove_defaults");
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
__name(remove_input_defaults, "remove_input_defaults");
function set_value(element3, value2) {
  var attributes = get_attributes(element3);
  if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
  value2 ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element3.value === value2 && (value2 !== 0 || element3.nodeName !== "PROGRESS")) {
    return;
  }
  element3.value = value2 ?? "";
}
__name(set_value, "set_value");
function set_checked(element3, checked) {
  var attributes = get_attributes(element3);
  if (attributes.checked === (attributes.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element3.checked = checked;
}
__name(set_checked, "set_checked");
function set_selected(element3, selected) {
  if (selected) {
    if (!element3.hasAttribute("selected")) {
      element3.setAttribute("selected", "");
    }
  } else {
    element3.removeAttribute("selected");
  }
}
__name(set_selected, "set_selected");
function set_default_checked(element3, checked) {
  const existing_value = element3.checked;
  element3.defaultChecked = checked;
  element3.checked = existing_value;
}
__name(set_default_checked, "set_default_checked");
function set_default_value(element3, value2) {
  const existing_value = element3.value;
  element3.defaultValue = value2;
  element3.value = existing_value;
}
__name(set_default_value, "set_default_value");
function set_attribute(element3, attribute, value2, skip_warning) {
  var attributes = get_attributes(element3);
  if (hydrating) {
    attributes[attribute] = element3.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element3.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element3, attribute, value2 ?? "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value2)) return;
  if (attribute === "loading") {
    element3[LOADING_ATTR_SYMBOL] = value2;
  }
  if (value2 == null) {
    element3.removeAttribute(attribute);
  } else if (typeof value2 !== "string" && get_setters(element3).includes(attribute)) {
    element3[attribute] = value2;
  } else {
    element3.setAttribute(attribute, value2);
  }
}
__name(set_attribute, "set_attribute");
function set_xlink_attribute(dom, attribute, value2) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value2);
}
__name(set_xlink_attribute, "set_xlink_attribute");
function set_custom_element_data(node, prop2, value2) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.tagName.toLowerCase()) ? get_setters(node).includes(prop2) : value2 && typeof value2 === "object")
    ) {
      node[prop2] = value2;
    } else {
      set_attribute(node, prop2, value2 == null ? value2 : String(value2));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
__name(set_custom_element_data, "set_custom_element_data");
function set_attributes(element3, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  if (hydrating && should_remove_defaults && element3.tagName === "INPUT") {
    var input = (
      /** @type {HTMLInputElement} */
      element3
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes = get_attributes(element3);
  var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element3.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ?? (next2.style = null);
  }
  var setters = get_setters(element3);
  for (const key3 in next2) {
    let value2 = next2[key3];
    if (is_option_element && key3 === "value" && value2 == null) {
      element3.value = element3.__value = "";
      current[key3] = value2;
      continue;
    }
    if (key3 === "class") {
      var is_html = element3.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element3, is_html, value2, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value2;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element3, value2, prev?.[STYLE], next2[STYLE]);
      current[key3] = value2;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value2 === prev_value && !(value2 === void 0 && element3.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value2;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = can_delegate_event(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value2 != null) continue;
        element3.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value2 != null) {
        if (!delegated) {
          let handle2 = function(evt) {
            current[key3].call(this, evt);
          };
          var handle = handle2;
          __name(handle2, "handle");
          current[event_handle_key] = create_event(event_name, element3, handle2, opts);
        } else {
          element3[`__${event_name}`] = value2;
          delegate([event_name]);
        }
      } else if (delegated) {
        element3[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute(element3, key3, value2);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element3,
        Boolean(value2)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value2 != null)) {
      element3.value = element3.__value = value2;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element3,
        value2
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value2 == null && !is_custom_element && !is_default) {
        attributes[key3] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element3
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element3.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value2 !== "string")) {
        element3[name] = value2;
        if (name in attributes) attributes[name] = UNINITIALIZED;
      } else if (typeof value2 !== "function") {
        set_attribute(element3, name, value2, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
__name(set_attributes, "set_attributes");
function attribute_effect(element3, fn3, sync = [], async2 = [], blockers = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(blockers, sync, async2, (values2) => {
    var prev = void 0;
    var effects = {};
    var is_select = element3.nodeName === "SELECT";
    var inited = false;
    managed(() => {
      var next2 = fn3(...values2.map(get$2));
      var current = set_attributes(
        element3,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element3,
          next2.value
        );
      }
      for (let symbol2 of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol2]) destroy_effect(effects[symbol2]);
      }
      for (let symbol2 of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol2];
        if (symbol2.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol2])) {
          if (effects[symbol2]) destroy_effect(effects[symbol2]);
          effects[symbol2] = branch(() => attach(element3, () => n));
        }
        current[symbol2] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element3
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
__name(attribute_effect, "attribute_effect");
function get_attributes(element3) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element3.__attributes ?? (element3.__attributes = {
      [IS_CUSTOM_ELEMENT]: element3.nodeName.includes("-"),
      [IS_HTML]: element3.namespaceURI === NAMESPACE_HTML
    })
  );
}
__name(get_attributes, "get_attributes");
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element3) {
  var cache_key = element3.getAttribute("is") || element3.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element3;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
__name(get_setters, "get_setters");
function check_src_in_dev_hydration(element3, attribute, value2) {
  if (!DEV) return;
  if (attribute === "srcset" && srcset_url_equal(element3, value2)) return;
  if (src_url_equal(element3.getAttribute(attribute) ?? "", value2)) return;
  hydration_attribute_changed(
    attribute,
    element3.outerHTML.replace(element3.innerHTML, element3.innerHTML && "..."),
    String(value2)
  );
}
__name(check_src_in_dev_hydration, "check_src_in_dev_hydration");
function src_url_equal(element_src, url2) {
  if (element_src === url2) return true;
  return new URL(element_src, document.baseURI).href === new URL(url2, document.baseURI).href;
}
__name(src_url_equal, "src_url_equal");
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
__name(split_srcset, "split_srcset");
function srcset_url_equal(element3, srcset) {
  var element_urls = split_srcset(element3.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url2, width2], i) => width2 === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url2) || src_url_equal(url2, element_urls[i][0]))
  );
}
__name(srcset_url_equal, "srcset_url_equal");
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event3) => {
    if (event3 && event3.type === "focusout" && /** @type {FocusEvent} */
    event3.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}
__name(bind_active_element, "bind_active_element");
function bind_value(input, get2, set2 = get2) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value2 = is_reset ? input.defaultValue : input.value;
    value2 = is_numberlike_input(input) ? to_number(value2) : value2;
    set2(value2);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value2 !== (value2 = get2())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      var length2 = input.value.length;
      input.value = value2 ?? "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start === end && end === length2 && new_length > length2) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get2) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value2 = get2();
    if (input === document.activeElement) {
      var batch2 = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch2)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value2 === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value2 && !input.value) {
      return;
    }
    if (value2 !== input.value) {
      input.value = value2 ?? "";
    }
  });
}
__name(bind_value, "bind_value");
const pending = /* @__PURE__ */ new Set();
function bind_group(inputs, group_index, input, get2, set2 = get2) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ?? (binding_group[index2] = []);
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value2 = input.__value;
      if (is_checkbox) {
        value2 = get_binding_group_value(binding_group, value2, input.checked);
      }
      set2(value2);
    },
    // TODO better default value handling
    () => set2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value2 = get2();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value2 = value2 || [];
      input.checked = value2.includes(input.__value);
    } else {
      input.checked = is(input.__value, value2);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending.has(binding_group)) {
    pending.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value2;
      if (is_checkbox) {
        value2 = get_binding_group_value(binding_group, value2, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value2 = hydration_input?.__value;
      }
      set2(value2);
    }
  });
}
__name(bind_group, "bind_group");
function bind_checked(input, get2, set2 = get2) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value2 = is_reset ? input.defaultChecked : input.checked;
    set2(value2);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get2) == null
  ) {
    set2(input.checked);
  }
  render_effect(() => {
    var value2 = get2();
    input.checked = Boolean(value2);
  });
}
__name(bind_checked, "bind_checked");
function get_binding_group_value(group2, __value, checked) {
  var value2 = /* @__PURE__ */ new Set();
  for (var i = 0; i < group2.length; i += 1) {
    if (group2[i].checked) {
      value2.add(group2[i].__value);
    }
  }
  if (!checked) {
    value2.delete(__value);
  }
  return Array.from(value2);
}
__name(get_binding_group_value, "get_binding_group_value");
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
__name(is_numberlike_input, "is_numberlike_input");
function to_number(value2) {
  return value2 === "" ? null : +value2;
}
__name(to_number, "to_number");
function bind_files(input, get2, set2 = get2) {
  listen_to_event_and_reset_event(input, "change", () => {
    set2(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set2(input.files);
  }
  render_effect(() => {
    input.files = get2();
  });
}
__name(bind_files, "bind_files");
function time_ranges_to_array(ranges) {
  var array3 = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array3.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array3;
}
__name(time_ranges_to_array, "time_ranges_to_array");
function bind_current_time(media, get2, set2 = get2) {
  var raf_id;
  var value2;
  var callback = /* @__PURE__ */ __name(() => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value2 !== next_value) {
      set2(value2 = next_value);
    }
  }, "callback");
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get2());
    if (value2 !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value2 = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
__name(bind_current_time, "bind_current_time");
function bind_buffered(media, set2) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set2(current);
    }
  });
}
__name(bind_buffered, "bind_buffered");
function bind_seekable(media, set2) {
  listen(media, ["loadedmetadata"], () => set2(time_ranges_to_array(media.seekable)));
}
__name(bind_seekable, "bind_seekable");
function bind_played(media, set2) {
  listen(media, ["timeupdate"], () => set2(time_ranges_to_array(media.played)));
}
__name(bind_played, "bind_played");
function bind_seeking(media, set2) {
  listen(media, ["seeking", "seeked"], () => set2(media.seeking));
}
__name(bind_seeking, "bind_seeking");
function bind_ended(media, set2) {
  listen(media, ["timeupdate", "ended"], () => set2(media.ended));
}
__name(bind_ended, "bind_ended");
function bind_ready_state(media, set2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set2(media.readyState)
  );
}
__name(bind_ready_state, "bind_ready_state");
function bind_playback_rate(media, get2, set2 = get2) {
  effect(() => {
    var value2 = Number(get2());
    if (value2 !== media.playbackRate && !isNaN(value2)) {
      media.playbackRate = value2;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set2(media.playbackRate);
    });
  });
}
__name(bind_playback_rate, "bind_playback_rate");
function bind_paused(media, get2, set2 = get2) {
  var paused = get2();
  var update2 = /* @__PURE__ */ __name(() => {
    if (paused !== media.paused) {
      set2(paused = media.paused);
    }
  }, "update");
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get2()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch(() => {
          set2(paused = true);
        });
      }
    }
  });
}
__name(bind_paused, "bind_paused");
function bind_volume(media, get2, set2 = get2) {
  var callback = /* @__PURE__ */ __name(() => {
    set2(media.volume);
  }, "callback");
  if (get2() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value2 = Number(get2());
    if (value2 !== media.volume && !isNaN(value2)) {
      media.volume = value2;
    }
  });
}
__name(bind_volume, "bind_volume");
function bind_muted(media, get2, set2 = get2) {
  var callback = /* @__PURE__ */ __name(() => {
    set2(media.muted);
  }, "callback");
  if (get2() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value2 = !!get2();
    if (media.muted !== value2) media.muted = value2;
  });
}
__name(bind_muted, "bind_muted");
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}
__name(bind_online, "bind_online");
function bind_prop(props, prop2, value2) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value2;
    teardown(() => {
      props[prop2] = null;
    });
  }
}
__name(bind_prop, "bind_prop");
const _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options2) {
    __privateAdd(this, _ResizeObserverSingleton_instances);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options);
    __privateSet(this, _options, options2);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element3, listener) {
    var listeners = __privateGet(this, _listeners).get(element3) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element3, listeners);
    __privateMethod(this, _ResizeObserverSingleton_instances, getObserver_fn).call(this).observe(element3, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element3);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element3);
        __privateGet(this, _observer).unobserve(element3);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_ResizeObserverSingleton_instances = new WeakSet();
getObserver_fn = /* @__PURE__ */ __name(function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries2) => {
      for (var entry of entries2) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
}, "#getObserver");
__name(_ResizeObserverSingleton, "ResizeObserverSingleton");
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
let ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(element3, type, set2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element3,
    /** @param {any} entry */
    (entry) => set2(entry[type])
  );
  teardown(unsub);
}
__name(bind_resize_observer, "bind_resize_observer");
function bind_element_size(element3, type, set2) {
  var unsub = resize_observer_border_box.observe(element3, () => set2(element3[type]));
  effect(() => {
    untrack(() => set2(element3[type]));
    return unsub;
  });
}
__name(bind_element_size, "bind_element_size");
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
__name(is_bound_this, "is_bound_this");
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}
__name(bind_this, "bind_this");
function bind_content_editable(property, element3, get2, set2 = get2) {
  element3.addEventListener("input", () => {
    set2(element3[property]);
  });
  render_effect(() => {
    var value2 = get2();
    if (element3[property] !== value2) {
      if (value2 == null) {
        var non_null_value = element3[property];
        set2(non_null_value);
      } else {
        element3[property] = value2 + "";
      }
    }
  });
}
__name(bind_content_editable, "bind_content_editable");
function bind_property(property, event_name, element3, set2, get2) {
  var handler = /* @__PURE__ */ __name(() => {
    set2(element3[property]);
  }, "handler");
  element3.addEventListener(event_name, handler);
  if (get2) {
    render_effect(() => {
      element3[property] = get2();
    });
  } else {
    handler();
  }
  if (element3 === document.body || element3 === window || element3 === document) {
    teardown(() => {
      element3.removeEventListener(event_name, handler);
    });
  }
}
__name(bind_property, "bind_property");
function bind_focused(element3, set2) {
  listen(element3, ["focus", "blur"], () => {
    set2(element3 === document.activeElement);
  });
}
__name(bind_focused, "bind_focused");
function bind_window_scroll(type, get2, set2 = get2) {
  var is_scrolling_x = type === "x";
  var target_handler = /* @__PURE__ */ __name(() => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear2, 100);
    set2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  }), "target_handler");
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear2 = /* @__PURE__ */ __name(() => {
    scrolling = false;
  }, "clear");
  var first2 = true;
  render_effect(() => {
    var latest_value = get2();
    if (first2) {
      first2 = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear2, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
__name(bind_window_scroll, "bind_window_scroll");
function bind_window_size(type, set2) {
  listen(window, ["resize"], () => without_reactive_context(() => set2(window[type])));
}
__name(bind_window_size, "bind_window_size");
function trusted(fn3) {
  return function(...args2) {
    var event3 = (
      /** @type {Event} */
      args2[0]
    );
    if (event3.isTrusted) {
      fn3?.apply(this, args2);
    }
  };
}
__name(trusted, "trusted");
function self$1(fn3) {
  return function(...args2) {
    var event3 = (
      /** @type {Event} */
      args2[0]
    );
    if (event3.target === this) {
      fn3?.apply(this, args2);
    }
  };
}
__name(self$1, "self$1");
function stopPropagation(fn3) {
  return function(...args2) {
    var event3 = (
      /** @type {Event} */
      args2[0]
    );
    event3.stopPropagation();
    return fn3?.apply(this, args2);
  };
}
__name(stopPropagation, "stopPropagation");
function once(fn3) {
  var ran = false;
  return function(...args2) {
    if (ran) return;
    ran = true;
    return fn3?.apply(this, args2);
  };
}
__name(once, "once");
function stopImmediatePropagation(fn3) {
  return function(...args2) {
    var event3 = (
      /** @type {Event} */
      args2[0]
    );
    event3.stopImmediatePropagation();
    return fn3?.apply(this, args2);
  };
}
__name(stopImmediatePropagation, "stopImmediatePropagation");
function preventDefault(fn3) {
  return function(...args2) {
    var event3 = (
      /** @type {Event} */
      args2[0]
    );
    event3.preventDefault();
    return fn3?.apply(this, args2);
  };
}
__name(preventDefault, "preventDefault");
function passive(node, [event3, handler]) {
  user_pre_effect(() => {
    return on(node, event3, handler() ?? noop, {
      passive: true
    });
  });
}
__name(passive, "passive");
function nonpassive(node, [event3, handler]) {
  user_pre_effect(() => {
    return on(node, event3, handler() ?? noop, {
      passive: false
    });
  });
}
__name(nonpassive, "nonpassive");
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = /* @__PURE__ */ __name(() => deep_read_state(context.s), "props");
  if (immutable) {
    let version2 = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = /* @__PURE__ */ derived$1(() => {
      let changed = false;
      const props2 = context.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version2++;
      return version2;
    });
    props = /* @__PURE__ */ __name(() => get$2(d), "props");
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run$2));
    return () => {
      for (const fn3 of fns) {
        if (typeof fn3 === "function") {
          fn3();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
__name(init, "init");
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get$2(signal);
  }
  props();
}
__name(observe_all, "observe_all");
function reactive_import(fn3) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set$1(s, get$2(s) + 1);
      return arguments[0];
    } else {
      get$2(s);
      return fn3();
    }
  };
}
__name(reactive_import, "reactive_import");
function bubble_event($$props, event3) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event3.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn3 of callbacks) {
    fn3.call(this, event3);
  }
}
__name(bubble_event, "bubble_event");
function add_legacy_event_listener($$props, event_name, event_callback) {
  var _a2;
  $$props.$$events || ($$props.$$events = {});
  (_a2 = $$props.$$events)[event_name] || (_a2[event_name] = []);
  $$props.$$events[event_name].push(event_callback);
}
__name(add_legacy_event_listener, "add_legacy_event_listener");
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}
__name(update_legacy_props, "update_legacy_props");
function subscribe_to_store(store2, run2, invalidate) {
  if (store2 == null) {
    run2(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store2.subscribe(
      run2,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
__name(subscribe_to_store, "subscribe_to_store");
const subscriber_queue = [];
function readable(value2, start) {
  return {
    subscribe: writable(value2, start).subscribe
  };
}
__name(readable, "readable");
function writable(value2, start = noop) {
  let stop5 = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop5) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set2, "set");
  function update2(fn3) {
    set2(fn3(
      /** @type {T} */
      value2
    ));
  }
  __name(update2, "update");
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop5 = start(set2, update2) || noop;
    }
    run2(
      /** @type {T} */
      value2
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop5) {
        stop5();
        stop5 = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set2, update: update2, subscribe };
}
__name(writable, "writable");
function derived(stores, fn3, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn3.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values2 = [];
    let pending2 = 0;
    let cleanup = noop;
    const sync = /* @__PURE__ */ __name(() => {
      if (pending2) {
        return;
      }
      cleanup();
      const result = fn3(single ? values2[0] : values2, set2, update2);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    }, "sync");
    const unsubscribers = stores_array.map(
      (store2, i) => subscribe_to_store(
        store2,
        (value2) => {
          values2[i] = value2;
          pending2 &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending2 |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return /* @__PURE__ */ __name(function stop5() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    }, "stop");
  });
}
__name(derived, "derived");
function readonly(store2) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store2.subscribe.bind(store2)
  };
}
__name(readonly, "readonly");
function get$1(store2) {
  let value2;
  subscribe_to_store(store2, (_) => value2 = _)();
  return value2;
}
__name(get$1, "get$1");
let is_store_binding = false;
let IS_UNMOUNTED = /* @__PURE__ */ Symbol();
function store_get(store2, store_name, stores) {
  const entry = stores[store_name] ?? (stores[store_name] = {
    store: null,
    source: /* @__PURE__ */ mutable_source(void 0),
    unsubscribe: noop
  });
  if (DEV) {
    entry.source.label = store_name;
  }
  if (entry.store !== store2 && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store2 ?? null;
    if (store2 == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store2, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set$1(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store2 && IS_UNMOUNTED in stores) {
    return get$1(store2);
  }
  return get$2(entry.source);
}
__name(store_get, "store_get");
function store_unsub(store2, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store2) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store2;
}
__name(store_unsub, "store_unsub");
function store_set(store2, value2) {
  store2.set(value2);
  return value2;
}
__name(store_set, "store_set");
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
__name(invalidate_store, "invalidate_store");
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  __name(cleanup, "cleanup");
  return [stores, cleanup];
}
__name(setup_stores, "setup_stores");
function store_mutate(store2, expression, new_value) {
  store2.set(new_value);
  return expression;
}
__name(store_mutate, "store_mutate");
function update_store(store2, store_value, d = 1) {
  store2.set(store_value + d);
  return store_value;
}
__name(update_store, "update_store");
function update_pre_store(store2, store_value, d = 1) {
  const value2 = store_value + d;
  store2.set(value2);
  return value2;
}
__name(update_pre_store, "update_pre_store");
function mark_store_binding() {
  is_store_binding = true;
}
__name(mark_store_binding, "mark_store_binding");
function capture_store_binding(fn3) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn3(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}
__name(capture_store_binding, "capture_store_binding");
function update_prop(fn3, d = 1) {
  const value2 = fn3();
  fn3(value2 + d);
  return value2;
}
__name(update_prop, "update_prop");
function update_pre_prop(fn3, d = 1) {
  const value2 = fn3() + d;
  fn3(value2);
  return value2;
}
__name(update_pre_prop, "update_pre_prop");
const rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    return target.props[key2];
  },
  set(target, key2) {
    if (DEV) {
      props_rest_readonly(`${target.name}.${String(key2)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    DEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
__name(rest_props, "rest_props");
const legacy_rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    get$2(target.version);
    return key2 in target.special ? target.special[key2]() : target.props[key2];
  },
  set(target, key2, value2) {
    if (!(key2 in target.special)) {
      var previous_effect = active_effect;
      try {
        set_active_effect(target.parent_effect);
        target.special[key2] = prop(
          {
            get [key2]() {
              return target.props[key2];
            }
          },
          /** @type {string} */
          key2,
          PROPS_IS_UPDATED
        );
      } finally {
        set_active_effect(previous_effect);
      }
    }
    target.special[key2](value2);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  deleteProperty(target, key2) {
    if (target.exclude.includes(key2)) return true;
    target.exclude.push(key2);
    update(target.version);
    return true;
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
__name(legacy_rest_props, "legacy_rest_props");
const spread_props_handler = {
  get(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p2 = target.props[i];
      if (is_function(p2)) p2 = p2();
      if (typeof p2 === "object" && p2 !== null && key2 in p2) return p2[key2];
    }
  },
  set(target, key2, value2) {
    let i = target.props.length;
    while (i--) {
      let p2 = target.props[i];
      if (is_function(p2)) p2 = p2();
      const desc = get_descriptor(p2, key2);
      if (desc && desc.set) {
        desc.set(value2);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p2 = target.props[i];
      if (is_function(p2)) p2 = p2();
      if (typeof p2 === "object" && p2 !== null && key2 in p2) {
        const descriptor = get_descriptor(p2, key2);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key2) {
    if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
    for (let p2 of target.props) {
      if (is_function(p2)) p2 = p2();
      if (p2 != null && key2 in p2) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p2 of target.props) {
      if (is_function(p2)) p2 = p2();
      if (!p2) continue;
      for (const key2 in p2) {
        if (!keys.includes(key2)) keys.push(key2);
      }
      for (const key2 of Object.getOwnPropertySymbols(p2)) {
        if (!keys.includes(key2)) keys.push(key2);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
__name(spread_props, "spread_props");
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy2 = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = /* @__PURE__ */ __name(() => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy2 ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  }, "get_fallback");
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = /* @__PURE__ */ __name(() => {
      var value2 = (
        /** @type {V} */
        props[key2]
      );
      if (value2 === void 0) return get_fallback();
      fallback_dirty = true;
      return value2;
    }, "getter");
  } else {
    getter = /* @__PURE__ */ __name(() => {
      var value2 = (
        /** @type {V} */
        props[key2]
      );
      if (value2 !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value2 === void 0 ? fallback_value : value2;
    }, "getter");
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value2, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value2);
          }
          return value2;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived$1 : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (DEV) {
    d.label = key2;
  }
  if (bindable) get$2(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value2, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get$2(d) : runes && bindable ? proxy(value2) : value2;
        set$1(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value2;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get$2(d);
    })
  );
}
__name(prop, "prop");
function validate_each_keys(collection4, key_fn) {
  render_effect(() => {
    const keys = /* @__PURE__ */ new Map();
    const maybe_array = collection4();
    const array3 = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
    const length2 = array3.length;
    for (let i = 0; i < length2; i++) {
      const key2 = key_fn(array3[i], i);
      if (keys.has(key2)) {
        const a = String(keys.get(key2));
        const b = String(i);
        let k = String(key2);
        if (k.startsWith("[object ")) k = null;
        each_key_duplicate(a, b, k);
      }
      keys.set(key2, i);
    }
  });
}
__name(validate_each_keys, "validate_each_keys");
function validate_binding(binding, blockers, get_object, get_property, line, column) {
  run_after_blockers(blockers, () => {
    var warned = false;
    var filename = dev_current_component_function?.[FILENAME];
    render_effect(() => {
      if (warned) return;
      var [object3, is_store_sub] = capture_store_binding(get_object);
      if (is_store_sub) return;
      var property = get_property();
      var ran = false;
      var effect2 = render_effect(() => {
        if (ran) return;
        object3[property];
      });
      ran = true;
      if (effect2.deps === null) {
        var location = `${filename}:${line}:${column}`;
        binding_property_non_reactive(binding, location);
        warned = true;
      }
    });
  });
}
__name(validate_binding, "validate_binding");
function createClassComponent(options2) {
  return new Svelte4Component(options2);
}
__name(createClassComponent, "createClassComponent");
function asClassComponent(component3) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component3,
        ...options2
      });
    }
  };
}
__name(asClassComponent, "asClassComponent");
const _Svelte4Component = class _Svelte4Component {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    /** @type {any} */
    __privateAdd(this, _events);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance);
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value2) => {
      var s = /* @__PURE__ */ mutable_source(value2, false, false);
      sources.set(key2, s);
      return s;
    }, "add_source");
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop2) {
          return get$2(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          if (prop2 === LEGACY_PROPS) return true;
          get$2(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value2) {
          set$1(sources.get(prop2) ?? add_source(prop2, value2), value2);
          return Reflect.set(target, prop2, value2);
        }
      }
    );
    __privateSet(this, _instance, (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      anchor: options2.anchor,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    }));
    if (!async_mode_flag && (!options2?.props?.$$host || options2.sync === false)) {
      flushSync();
    }
    __privateSet(this, _events, props.$$events);
    for (const key2 of Object.keys(__privateGet(this, _instance))) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return __privateGet(this, _instance)[key2];
        },
        /** @param {any} value */
        set(value2) {
          __privateGet(this, _instance)[key2] = value2;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event3, callback) {
    __privateGet(this, _events)[event3] = __privateGet(this, _events)[event3] || [];
    const cb = /* @__PURE__ */ __name((...args2) => callback.call(this, ...args2), "cb");
    __privateGet(this, _events)[event3].push(cb);
    return () => {
      __privateGet(this, _events)[event3] = __privateGet(this, _events)[event3].filter(
        /** @param {any} fn */
        (fn3) => fn3 !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();
__name(_Svelte4Component, "Svelte4Component");
let Svelte4Component = _Svelte4Component;
function run(fn3) {
  user_pre_effect(() => {
    fn3();
    var effect2 = (
      /** @type {import('#client').Effect} */
      active_effect
    );
    if ((effect2.f & DIRTY) !== 0) {
      let filename = "a file (we can't know which one)";
      if (DEV) {
        filename = dev_current_component_function?.[FILENAME] ?? filename;
      }
      legacy_recursive_reactive_block(filename);
      set_signal_status(effect2, MAYBE_DIRTY);
    }
  });
}
__name(run, "run");
function handlers(...handlers2) {
  return function(event3) {
    const { stopImmediatePropagation: stopImmediatePropagation3 } = event3;
    let stopped = false;
    event3.stopImmediatePropagation = () => {
      stopped = true;
      stopImmediatePropagation3.call(event3);
    };
    const errors = [];
    for (const handler of handlers2) {
      try {
        handler?.call(this, event3);
      } catch (e) {
        errors.push(e);
      }
      if (stopped) {
        break;
      }
    }
    for (let error3 of errors) {
      queueMicrotask(() => {
        throw error3;
      });
    }
  };
}
__name(handlers, "handlers");
function createBubbler() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createBubbler");
  }
  return (type) => (event3) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {any} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      for (const fn3 of callbacks) {
        fn3.call(active_component_context.x, event3);
      }
      return !event3.defaultPrevented;
    }
    return true;
  };
}
__name(createBubbler, "createBubbler");
let SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = (_c = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options2) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options2);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options2) {
      super.removeEventListener(type, listener, options2);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        var create_slot = create_slot2;
        __name(create_slot2, "create_slot");
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot2(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot2(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key2 in this.$$p_d) {
          if (!(key2 in this.$$d) && this[key2] !== void 0) {
            this.$$d[key2] = this[key2];
            delete this[key2];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key2 of object_keys(this.$$c)) {
              if (!this.$$p_d[key2]?.reflect) continue;
              this.$$d[key2] = this.$$c[key2];
              const attribute_value = get_custom_element_value(
                key2,
                this.$$d[key2],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key2].attribute || key2);
              } else {
                this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  }, __name(_c, "SvelteElement"), _c);
}
function get_custom_element_value(prop2, value2, props_definition, transform7) {
  const type = props_definition[prop2]?.type;
  value2 = type === "Boolean" && typeof value2 !== "boolean" ? value2 != null : value2;
  if (!transform7 || !props_definition[prop2]) {
    return value2;
  } else if (transform7 === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value2 == null ? null : JSON.stringify(value2);
      case "Boolean":
        return value2 ? "" : null;
      case "Number":
        return value2 == null ? null : value2;
      default:
        return value2;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value2 && JSON.parse(value2);
      case "Boolean":
        return value2;
      // conversion already handled above
      case "Number":
        return value2 != null ? +value2 : value2;
      default:
        return value2;
    }
  }
}
__name(get_custom_element_value, "get_custom_element_value");
function get_custom_elements_slots(element3) {
  const result = {};
  element3.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
__name(get_custom_elements_slots, "get_custom_elements_slots");
function create_custom_element(Component, props_definition, slots, exports$1, use_shadow_dom, extend2) {
  var _a2;
  let Class = (_a2 = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  }, __name(_a2, "Class"), _a2);
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value2) {
        value2 = get_custom_element_value(prop2, value2, props_definition);
        this.$$d[prop2] = value2;
        var component3 = this.$$c;
        if (component3) {
          var setter = get_descriptor(component3, prop2)?.get;
          if (setter) {
            component3[prop2] = value2;
          } else {
            component3.$set({ [prop2]: value2 });
          }
        }
      }
    });
  });
  exports$1.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend2) {
    Class = extend2(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}
__name(create_custom_element, "create_custom_element");
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}
__name(log_if_contains_state, "log_if_contains_state");
function hydratable(key2, fn3) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  if (hydrating) {
    const store2 = window.__svelte?.h;
    if (store2?.has(key2)) {
      return (
        /** @type {T} */
        store2.get(key2)
      );
    }
    if (DEV) {
      hydratable_missing_but_required(key2);
    } else {
      hydratable_missing_but_expected(key2);
    }
  }
  return fn3();
}
__name(hydratable, "hydratable");
if (DEV) {
  let throw_rune_error = /* @__PURE__ */ __name(function(rune) {
    if (!(rune in globalThis)) {
      let value2;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: /* @__PURE__ */ __name(() => {
          if (value2 !== void 0) {
            return value2;
          }
          rune_outside_svelte(rune);
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          value2 = v;
        }, "set")
      });
    }
  }, "throw_rune_error");
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
function getAbortSignal() {
  if (active_reaction === null) {
    get_abort_signal_outside_reaction();
  }
  return (active_reaction.ac ?? (active_reaction.ac = new AbortController())).signal;
}
__name(getAbortSignal, "getAbortSignal");
function onMount(fn3) {
  if (component_context === null) {
    lifecycle_outside_component("onMount");
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn3);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn3);
      if (typeof cleanup === "function") return (
        /** @type {() => void} */
        cleanup
      );
    });
  }
}
__name(onMount, "onMount");
function onDestroy(fn3) {
  if (component_context === null) {
    lifecycle_outside_component("onDestroy");
  }
  onMount(() => () => untrack(fn3));
}
__name(onDestroy, "onDestroy");
function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
__name(create_custom_event, "create_custom_event");
function createEventDispatcher() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createEventDispatcher");
  }
  return (type, detail, options2) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {string} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      const event3 = create_custom_event(
        /** @type {string} */
        type,
        detail,
        options2
      );
      for (const fn3 of callbacks) {
        fn3.call(active_component_context.x, event3);
      }
      return !event3.defaultPrevented;
    }
    return true;
  };
}
__name(createEventDispatcher, "createEventDispatcher");
function beforeUpdate(fn3) {
  if (component_context === null) {
    lifecycle_outside_component("beforeUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("beforeUpdate");
  }
  init_update_callbacks(component_context).b.push(fn3);
}
__name(beforeUpdate, "beforeUpdate");
function afterUpdate(fn3) {
  if (component_context === null) {
    lifecycle_outside_component("afterUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("afterUpdate");
  }
  init_update_callbacks(component_context).a.push(fn3);
}
__name(afterUpdate, "afterUpdate");
function init_update_callbacks(context) {
  var l = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return l.u ?? (l.u = { a: [], b: [], m: [] });
}
__name(init_update_callbacks, "init_update_callbacks");
function isRecord(value2) {
  return value2 !== null && typeof value2 === "object" && !Array.isArray(value2);
}
__name(isRecord, "isRecord");
function hasOwnProperty(obj, propertyName) {
  if (obj === null || obj === void 0 || typeof obj !== "object") {
    return false;
  }
  return Object.prototype.hasOwnProperty.call(obj, propertyName);
}
__name(hasOwnProperty, "hasOwnProperty");
function getMapValueOrCreate(map3, key2, factory) {
  let value2 = map3.get(key2);
  if (value2 === void 0) {
    value2 = factory();
    map3.set(key2, value2);
  }
  return value2;
}
__name(getMapValueOrCreate, "getMapValueOrCreate");
function getNestedValue(obj, path) {
  if (!path.includes(".")) {
    if (isRecord(obj)) {
      return obj[path];
    }
    return void 0;
  }
  const keys = path.split(".");
  let current = obj;
  for (const key2 of keys) {
    if (isRecord(current) && key2 in current) {
      current = current[key2];
    } else {
      return void 0;
    }
  }
  return current;
}
__name(getNestedValue, "getNestedValue");
function createNestedObject(path, value2) {
  if (!path.includes(".")) {
    return { [path]: value2 };
  }
  const keys = path.split(".");
  const nested = {};
  let current = nested;
  for (let i = 0; i < keys.length - 1; i++) {
    const key2 = keys[i];
    if (key2) {
      current[key2] = {};
      const next2 = current[key2];
      current = next2;
    }
  }
  const lastKey = keys[keys.length - 1];
  if (lastKey) {
    current[lastKey] = value2;
  }
  return nested;
}
__name(createNestedObject, "createNestedObject");
function castEventHandlerForSet(handler) {
  return handler;
}
__name(castEventHandlerForSet, "castEventHandlerForSet");
function extractPersistMeta(options2, key2) {
  if (!options2 || !isRecord(options2)) {
    return void 0;
  }
  const metaValue = options2[key2];
  if (isRecord(metaValue) && typeof metaValue.originClientId === "string" && typeof metaValue.originWindowInstanceId === "string" && typeof metaValue.render === "boolean") {
    return {
      originClientId: metaValue.originClientId,
      originWindowInstanceId: metaValue.originWindowInstanceId,
      render: metaValue.render
    };
  }
  return void 0;
}
__name(extractPersistMeta, "extractPersistMeta");
function castSvelteComponent(component3) {
  if (typeof component3 === "function") {
    return component3;
  }
  return null;
}
__name(castSvelteComponent, "castSvelteComponent");
const _SvelteRenderer = class _SvelteRenderer {
  mount(descriptor, target, viewModel) {
    if (descriptor.type !== "svelte") {
      return err({
        code: "InvalidType",
        message: `SvelteRenderer can only mount svelte components`
      });
    }
    try {
      const component3 = castSvelteComponent(descriptor.component);
      if (!component3) {
        return err({
          code: "InvalidType",
          message: "Component descriptor does not contain a valid Svelte component function"
        });
      }
      const props = {
        ...descriptor.props,
        ...viewModel,
        // Spread ViewModel properties as direct props
        viewModel
        // Also include viewModel for components that need it
      };
      const mounted = mount(component3, {
        target,
        props
      });
      return ok({
        id: `svelte-${Date.now()}-${Math.random()}`,
        type: "svelte",
        element: target,
        props,
        instance: mounted
        // Svelte-spezifisch: mount() Rückgabe
      });
    } catch (error3) {
      return err({
        code: "MountFailed",
        message: `Failed to mount svelte component: ${String(error3)}`,
        cause: error3
      });
    }
  }
  unmount(instance2) {
    try {
      if (instance2.instance) {
        unmount(instance2.instance);
      }
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "UnmountFailed",
        message: `Failed to unmount component: ${String(error3)}`,
        cause: error3
      });
    }
  }
  update(_instance2, _viewModel) {
    try {
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "UpdateFailed",
        message: `Failed to update component: ${String(error3)}`,
        cause: error3
      });
    }
  }
};
__name(_SvelteRenderer, "SvelteRenderer");
let SvelteRenderer = _SvelteRenderer;
const _SimpleStateWrapper = class _SimpleStateWrapper {
  constructor() {
    this.state = {};
  }
  get() {
    return this.state;
  }
  patch(updates) {
    this.state = { ...this.state, ...updates };
  }
  subscribe(fn3) {
    fn3(this.state);
    return () => {
    };
  }
};
__name(_SimpleStateWrapper, "SimpleStateWrapper");
let SimpleStateWrapper = _SimpleStateWrapper;
function JournalEntryPageWindowSystemBridgeMixin(BaseSheet, windowDefinition, moduleId = MODULE_METADATA.ID) {
  var _a2;
  const MixedClass = (_a2 = class extends BaseSheet {
    // Konstruktor für Mixin-Klasse (TypeScript erfordert explizite Signatur mit any[])
    // type-coverage:ignore-next-line -- Mixin Constructor: Variadic constructor requires any[] for mixin pattern
    constructor(...args2) {
      super(...args2);
      this.svelteRenderer = null;
      this.componentInstance = null;
      this.isMounted = false;
      this.currentComponentData = null;
      this.cachedNodeDataService = null;
      this.cachedGraphDataService = null;
      this.saveButtonListener = null;
      this.cachedIsEditMode = null;
      this.saveSuccessCallback = null;
    }
    /* eslint-enable @typescript-eslint/no-explicit-any */
    // DI-Service-Zugriff über Public API (wie externe Komponenten)
    get api() {
      if (typeof game === "undefined" || !game?.modules) {
        throw new Error("Foundry game API not available");
      }
      const mod = game.modules.get(moduleId);
      if (!mod?.api) {
        throw new Error(`Module API not available: ${moduleId}`);
      }
      return mod.api;
    }
    // Helper: Service über Public API auflösen (exception-based)
    resolveService(token) {
      return this.api.resolve(token);
    }
    // Alternative: Result-Pattern für explizite Fehlerbehandlung
    resolveServiceWithError(token) {
      return this.api.resolveWithError(token);
    }
    /**
     * Überschreibt _onRender für Svelte-Rendering
     *
     * WICHTIG: Wir verwenden _onRender statt _renderFrame, um die Template-Struktur
     * (Header/Footer) zu respektieren. Der Mount-Point sollte zwischen Header und Footer
     * platziert werden, wie in JournalEntryPageRelationshipGraphSheet.
     */
    async _onRender(context, options2) {
      await super._onRender(context, options2);
      const mountPoint = this.element.querySelector("#svelte-mount-point");
      if (!mountPoint) {
        console.warn(
          "[JournalEntryPageWindowSystemBridgeMixin] Mount point #svelte-mount-point not found in template"
        );
        return;
      }
      const mountPointIsEmpty = mountPoint.children.length === 0;
      const wasMounted = this.isMounted && this.componentInstance;
      if (wasMounted && !mountPointIsEmpty) {
        if (!this.saveButtonListener) {
          const saveButton = this.element.querySelector(
            'footer button[type="submit"], footer .form-footer button[type="submit"], button[type="submit"]'
          );
          if (saveButton) {
            this.saveButtonListener = async (event3) => {
              event3.preventDefault();
              event3.stopPropagation();
              const componentData = this.currentComponentData;
              if (!componentData) {
                console.warn(
                  "[JournalEntryPageWindowSystemBridgeMixin] No component data available for save"
                );
                return;
              }
              const pageId = this.document.id ?? this.document._id;
              if (!pageId) {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] No pageId found on document"
                );
                return;
              }
              if (this.cachedNodeDataService) {
                const nodeService = this.cachedNodeDataService;
                const result = await nodeService.saveNodeData(pageId, componentData);
                if (result.ok) {
                  if (this.saveSuccessCallback) {
                    try {
                      this.saveSuccessCallback();
                    } catch (error3) {
                      console.error(
                        "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                        error3
                      );
                    }
                  }
                } else {
                  console.error(
                    "[JournalEntryPageWindowSystemBridgeMixin] Failed to save node data via service:",
                    result.error
                  );
                }
              } else if (this.cachedGraphDataService) {
                const graphService = this.cachedGraphDataService;
                const result = await graphService.saveGraphData(pageId, componentData);
                if (result.ok) {
                  if (this.saveSuccessCallback) {
                    try {
                      this.saveSuccessCallback();
                    } catch (error3) {
                      console.error(
                        "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                        error3
                      );
                    }
                  }
                } else {
                  console.error(
                    "[JournalEntryPageWindowSystemBridgeMixin] Failed to save graph data via service:",
                    result.error
                  );
                }
              } else {
                console.warn(
                  "[JournalEntryPageWindowSystemBridgeMixin] No service available, using direct document.update() as fallback"
                );
                const updateData = {
                  system: componentData
                };
                try {
                  await this.document.update(updateData);
                } catch (error3) {
                  console.error(
                    "[JournalEntryPageWindowSystemBridgeMixin] Failed to update document:",
                    error3
                  );
                }
              }
            };
            saveButton.addEventListener("click", this.saveButtonListener);
          }
        }
        return;
      }
      if (wasMounted && mountPointIsEmpty) {
        this.isMounted = false;
        this.componentInstance = null;
      }
      if (!this.svelteRenderer) {
        this.svelteRenderer = new SvelteRenderer();
      }
      let graphDataService = null;
      let nodeDataService = null;
      let notificationCenter = null;
      try {
        graphDataService = this.resolveService(this.api.tokens.graphDataServiceToken);
        this.cachedGraphDataService = graphDataService;
      } catch (_error) {
      }
      try {
        nodeDataService = this.resolveService(this.api.tokens.nodeDataServiceToken);
        this.cachedNodeDataService = nodeDataService;
      } catch (_error) {
      }
      try {
        notificationCenter = this.resolveService(this.api.tokens.notificationCenterToken);
      } catch (error3) {
        console.warn("Failed to resolve notificationCenter:", error3);
      }
      const stateWrapper = new SimpleStateWrapper();
      const viewModel = {
        document: this.document,
        state: stateWrapper,
        computed: {},
        actions: {}
        // Services als Props übergeben (beide für Flexibilität)
        // Diese werden über das ViewModel als Props an die Komponente übergeben
      };
      const viewModelWithServices = viewModel;
      viewModelWithServices.graphDataService = graphDataService;
      viewModelWithServices.nodeDataService = nodeDataService;
      viewModelWithServices.notificationCenter = notificationCenter;
      const hasSaveButton = this.element.querySelector('footer button[type="submit"], button[type="submit"]') !== null;
      const sheetWithView = this;
      const contextEditable = context.editable;
      const thisIsEditable = this.isEditable;
      const isViewFromFoundry = sheetWithView.isView === true;
      let isEditMode;
      if (hasSaveButton) {
        isEditMode = true;
        this.cachedIsEditMode = true;
      } else if (this.cachedIsEditMode === true) {
        isEditMode = true;
      } else {
        isEditMode = isViewFromFoundry ? false : thisIsEditable === true || contextEditable === true;
        if (isEditMode) {
          this.cachedIsEditMode = true;
        } else {
          this.cachedIsEditMode = false;
        }
      }
      const readonly2 = !isEditMode;
      viewModelWithServices.readonly = readonly2;
      viewModelWithServices.onDataChange = (data4) => {
        this.currentComponentData = data4;
      };
      viewModelWithServices.onSaveSuccess = (callback) => {
        this.saveSuccessCallback = callback;
      };
      const finalMountPoint = this.element.querySelector("#svelte-mount-point");
      if (!finalMountPoint) {
        console.warn(
          "[JournalEntryPageWindowSystemBridgeMixin] Mount point not found after creation"
        );
        return;
      }
      const mountResult = this.svelteRenderer.mount(
        windowDefinition.component,
        finalMountPoint,
        viewModelWithServices
      );
      if (mountResult.ok) {
        this.componentInstance = mountResult.value;
        this.isMounted = true;
      } else {
        try {
          const notificationCenter2 = this.resolveService(this.api.tokens.notificationCenterToken);
          notificationCenter2.error(
            `Failed to mount component: ${mountResult.error.message}`,
            mountResult.error
          );
        } catch (_error) {
          console.error("Failed to mount component:", mountResult.error);
        }
      }
      if (!this.saveButtonListener) {
        const saveButton = this.element.querySelector(
          'footer button[type="submit"], footer .form-footer button[type="submit"], button[type="submit"]'
        );
        if (saveButton) {
          this.saveButtonListener = async (event3) => {
            event3.preventDefault();
            event3.stopPropagation();
            const componentData = this.currentComponentData;
            if (!componentData) {
              console.warn(
                "[JournalEntryPageWindowSystemBridgeMixin] No component data available for save"
              );
              return;
            }
            const pageId = this.document.id ?? this.document._id;
            if (!pageId) {
              console.error(
                "[JournalEntryPageWindowSystemBridgeMixin] No pageId found on document"
              );
              return;
            }
            if (this.cachedNodeDataService) {
              const nodeService = this.cachedNodeDataService;
              const result = await nodeService.saveNodeData(pageId, componentData);
              if (result.ok) {
                if (this.saveSuccessCallback) {
                  try {
                    this.saveSuccessCallback();
                  } catch (error3) {
                    console.error(
                      "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                      error3
                    );
                  }
                }
              } else {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] Failed to save node data via service:",
                  result.error
                );
              }
            } else if (this.cachedGraphDataService) {
              const graphService = this.cachedGraphDataService;
              const result = await graphService.saveGraphData(pageId, componentData);
              if (result.ok) {
                if (this.saveSuccessCallback) {
                  try {
                    this.saveSuccessCallback();
                  } catch (error3) {
                    console.error(
                      "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                      error3
                    );
                  }
                }
              } else {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] Failed to save graph data via service:",
                  result.error
                );
              }
            } else {
              console.warn(
                "[JournalEntryPageWindowSystemBridgeMixin] No service available, using direct document.update() as fallback"
              );
              const updateData = {
                system: componentData
              };
              try {
                await this.document.update(updateData);
              } catch (error3) {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] Failed to update document:",
                  error3
                );
              }
            }
          };
          saveButton.addEventListener("click", this.saveButtonListener);
        } else {
          console.warn("[JournalEntryPageWindowSystemBridgeMixin] Save button not found in footer");
        }
      }
    }
    /**
     * Überschreibt _updateObject für Form-Submission
     *
     * WICHTIG: Diese Methode wird von Foundry's Standard-Save-Button aufgerufen.
     * Wir holen die aktuellen Daten aus der Svelte-Komponente und schreiben sie
     * in updateData.system, damit Foundry sie speichern kann.
     *
     * NOTE: Foundry V11 verwendet möglicherweise eine andere Methode. Falls _updateObject
     * nicht existiert, müssen wir _onSubmit oder eine ähnliche Methode überschreiben.
     */
    async _updateObject(event3, formData) {
      const componentData = this.currentComponentData;
      let updateData;
      if (formData instanceof FormData) {
        updateData = {};
        formData.forEach((value2, key2) => {
          updateData[key2] = value2;
        });
      } else {
        updateData = formData;
      }
      if (componentData) {
        const pageId = this.document.id ?? this.document._id;
        if (!pageId) {
          console.error("[JournalEntryPageWindowSystemBridgeMixin] No pageId found on document");
          return;
        }
        if (this.cachedNodeDataService) {
          const nodeService = this.cachedNodeDataService;
          const result = await nodeService.saveNodeData(pageId, componentData);
          if (result.ok) {
            if (this.saveSuccessCallback) {
              try {
                this.saveSuccessCallback();
              } catch (error3) {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                  error3
                );
              }
            }
          } else {
            console.error(
              "[JournalEntryPageWindowSystemBridgeMixin] Failed to save node data via service:",
              result.error
            );
          }
          return;
        } else if (this.cachedGraphDataService) {
          const graphService = this.cachedGraphDataService;
          const result = await graphService.saveGraphData(pageId, componentData);
          if (result.ok) {
            if (this.saveSuccessCallback) {
              try {
                this.saveSuccessCallback();
              } catch (error3) {
                console.error(
                  "[JournalEntryPageWindowSystemBridgeMixin] Error calling saveSuccessCallback:",
                  error3
                );
              }
            }
          } else {
            console.error(
              "[JournalEntryPageWindowSystemBridgeMixin] Failed to save graph data via service:",
              result.error
            );
          }
          return;
        } else {
          console.warn(
            "[JournalEntryPageWindowSystemBridgeMixin] No service available, using direct document.update() as fallback"
          );
          updateData.system = componentData;
          try {
            await this.document.update(updateData);
          } catch (error3) {
            console.error(
              "[JournalEntryPageWindowSystemBridgeMixin] Failed to update document:",
              error3
            );
            throw error3;
          }
          return;
        }
      }
      await super._updateObject(event3, formData);
    }
    /**
     * Überschreibt close für Cleanup
     */
    async close(options2) {
      if (this.isMounted && this.componentInstance && this.svelteRenderer) {
        const unmountResult = this.svelteRenderer.unmount(this.componentInstance);
        if (!unmountResult.ok) {
          console.warn("Failed to unmount component:", unmountResult.error.message);
        }
        this.componentInstance = null;
        this.isMounted = false;
      }
      this.currentComponentData = null;
      this.cachedIsEditMode = null;
      if (this.saveButtonListener) {
        const saveButton = this.element.querySelector(
          'footer button[type="submit"], footer .form-footer button[type="submit"], button[type="submit"]'
        );
        if (saveButton) {
          saveButton.removeEventListener("click", this.saveButtonListener);
        }
        this.saveButtonListener = null;
      }
      this.saveSuccessCallback = null;
      return super.close(options2);
    }
  }, __name(_a2, "MixedClass"), _a2);
  return MixedClass;
}
__name(JournalEntryPageWindowSystemBridgeMixin, "JournalEntryPageWindowSystemBridgeMixin");
const VERSION = "5.46.1";
const PUBLIC_VERSION = "5";
if (typeof window !== "undefined") {
  ((_d = window.__svelte ?? (window.__svelte = {})).v ?? (_d.v = /* @__PURE__ */ new Set())).add(PUBLIC_VERSION);
}
var root$a = /* @__PURE__ */ from_html(`<div class="node-form svelte-194b1eq"><h3 class="svelte-194b1eq">Grunddaten</h3> <div class="form-field svelte-194b1eq"><label for="node-name" class="svelte-194b1eq">Name *</label> <input id="node-name" type="text" required class="svelte-194b1eq"/></div> <div class="form-field svelte-194b1eq"><label for="node-kind" class="svelte-194b1eq">Art *</label> <select id="node-kind" required class="svelte-194b1eq"><option>Person</option><option>Ort</option><option>Objekt</option></select></div> <div class="form-field svelte-194b1eq"><label for="node-faction" class="svelte-194b1eq">Fraktion</label> <input id="node-faction" type="text" class="svelte-194b1eq"/></div> <div class="form-field svelte-194b1eq"><label for="node-relation" class="svelte-194b1eq">Beziehung *</label> <select id="node-relation" required class="svelte-194b1eq"><option>Freund</option><option>Feind</option><option>Neutral</option></select></div> <div class="form-field svelte-194b1eq"><label for="node-icon" class="svelte-194b1eq">Icon</label> <input id="node-icon" type="text" placeholder="z.B. fas fa-user" class="svelte-194b1eq"/></div> <div class="form-field svelte-194b1eq"><label for="node-linked-entity" class="svelte-194b1eq">Verknüpfte Entity UUID</label> <input id="node-linked-entity" type="text" placeholder="UUID der verknüpften Entity" class="svelte-194b1eq"/></div></div>`);
const $$css$9 = {
  hash: "svelte-194b1eq",
  code: ".node-form.svelte-194b1eq {background:var(--color-bg-secondary, var(--color-cool-5-90));padding:1.5rem;border-radius:4px;border:1px solid var(--color-border, var(--color-border-light-primary));}.node-form.svelte-194b1eq h3:where(.svelte-194b1eq) {margin:0 0 1rem 0;font-size:1.2rem;border-bottom:1px solid var(--color-border, var(--color-border-light-tertiary));padding-bottom:0.5rem;color:var(--color-text-primary, var(--color-text-light-primary));}.form-field.svelte-194b1eq {display:flex;flex-direction:column;gap:0.5rem;margin-bottom:1rem;}.form-field.svelte-194b1eq label:where(.svelte-194b1eq) {font-weight:bold;font-size:0.9rem;color:var(--color-form-label);}.form-field.svelte-194b1eq input:where(.svelte-194b1eq),\r\n  .form-field.svelte-194b1eq select:where(.svelte-194b1eq) {padding:0.5rem;border:1px solid var(--input-border-color);border-radius:4px;font-size:0.95rem;background-color:var(--input-background-color);color:var(--input-text-color);}.form-field.svelte-194b1eq input:where(.svelte-194b1eq):focus,\r\n  .form-field.svelte-194b1eq select:where(.svelte-194b1eq):focus {outline:none;border-color:var(--input-focus-outline-color);color:var(--input-text-color);}"
};
function NodeForm($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$9);
  let readonly2 = prop($$props, "readonly", 3, false);
  var div = root$a();
  var div_1 = sibling(child(div), 2);
  var input = sibling(child(div_1), 2);
  remove_input_defaults(input);
  input.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, name: e.target.value });
  };
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var select = sibling(child(div_2), 2);
  select.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, kind: e.target.value });
  };
  var option = child(select);
  option.value = option.__value = "person";
  var option_1 = sibling(option);
  option_1.value = option_1.__value = "place";
  var option_2 = sibling(option_1);
  option_2.value = option_2.__value = "object";
  reset(select);
  var select_value;
  init_select(select);
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  var input_1 = sibling(child(div_3), 2);
  remove_input_defaults(input_1);
  input_1.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, factionId: e.target.value });
  };
  reset(div_3);
  var div_4 = sibling(div_3, 2);
  var select_1 = sibling(child(div_4), 2);
  select_1.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, relation: e.target.value });
  };
  var option_3 = child(select_1);
  option_3.value = option_3.__value = "friend";
  var option_4 = sibling(option_3);
  option_4.value = option_4.__value = "enemy";
  var option_5 = sibling(option_4);
  option_5.value = option_5.__value = "neutral";
  reset(select_1);
  var select_1_value;
  init_select(select_1);
  reset(div_4);
  var div_5 = sibling(div_4, 2);
  var input_2 = sibling(child(div_5), 2);
  remove_input_defaults(input_2);
  input_2.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, icon: e.target.value });
  };
  reset(div_5);
  var div_6 = sibling(div_5, 2);
  var input_3 = sibling(child(div_6), 2);
  remove_input_defaults(input_3);
  input_3.__change = (e) => {
    $$props.onDataChange({ ...$$props.nodeData, linkedEntityUuid: e.target.value });
  };
  reset(div_6);
  reset(div);
  template_effect(() => {
    set_value(input, $$props.nodeData.name ?? "");
    input.disabled = readonly2();
    select.disabled = readonly2();
    if (select_value !== (select_value = $$props.nodeData.kind ?? "person")) {
      select.value = (select.__value = $$props.nodeData.kind ?? "person") ?? "", select_option(select, $$props.nodeData.kind ?? "person");
    }
    set_value(input_1, $$props.nodeData.factionId ?? "");
    input_1.disabled = readonly2();
    select_1.disabled = readonly2();
    if (select_1_value !== (select_1_value = $$props.nodeData.relation ?? "neutral")) {
      select_1.value = (select_1.__value = $$props.nodeData.relation ?? "neutral") ?? "", select_option(select_1, $$props.nodeData.relation ?? "neutral");
    }
    set_value(input_2, $$props.nodeData.icon ?? "");
    input_2.disabled = readonly2();
    set_value(input_3, $$props.nodeData.linkedEntityUuid ?? "");
    input_3.disabled = readonly2();
  });
  append($$anchor, div);
  pop();
}
__name(NodeForm, "NodeForm");
delegate(["change"]);
var root$9 = /* @__PURE__ */ from_html(`<div class="node-description-editor svelte-pmtnuj"><h3 class="svelte-pmtnuj">Beschreibungen</h3> <div class="description-field svelte-pmtnuj"><label for="description-public" class="svelte-pmtnuj">Öffentlich</label> <textarea id="description-public" rows="4" placeholder="Öffentlich sichtbare Beschreibung" class="svelte-pmtnuj"></textarea></div> <div class="description-field svelte-pmtnuj"><label for="description-hidden" class="svelte-pmtnuj">Versteckt</label> <textarea id="description-hidden" rows="4" placeholder="Versteckte Beschreibung (nur für Spieler mit Berechtigung)" class="svelte-pmtnuj"></textarea></div> <div class="description-field svelte-pmtnuj"><label for="description-gm" class="svelte-pmtnuj">GM</label> <textarea id="description-gm" rows="4" placeholder="GM-Beschreibung (nur für Game Master)" class="svelte-pmtnuj"></textarea></div></div>`);
const $$css$8 = {
  hash: "svelte-pmtnuj",
  code: ".node-description-editor.svelte-pmtnuj {background:var(--color-bg-secondary, var(--color-cool-5-90));padding:1.5rem;border-radius:4px;border:1px solid var(--color-border, var(--color-border-light-primary));}.node-description-editor.svelte-pmtnuj h3:where(.svelte-pmtnuj) {margin:0 0 1rem 0;font-size:1.2rem;border-bottom:1px solid var(--color-border, var(--color-border-light-tertiary));padding-bottom:0.5rem;color:var(--color-text-primary, var(--color-text-light-primary));}.description-field.svelte-pmtnuj {display:flex;flex-direction:column;gap:0.5rem;margin-bottom:1rem;}.description-field.svelte-pmtnuj label:where(.svelte-pmtnuj) {font-weight:bold;font-size:0.9rem;color:var(--color-form-label);}.description-field.svelte-pmtnuj textarea:where(.svelte-pmtnuj) {padding:0.5rem;border:1px solid var(--input-border-color);border-radius:4px;font-size:0.95rem;font-family:inherit;resize:vertical;background-color:var(--input-background-color);color:var(--input-text-color);}.description-field.svelte-pmtnuj textarea:where(.svelte-pmtnuj):focus {outline:none;border-color:var(--input-focus-outline-color);color:var(--input-text-color);}"
};
function NodeDescriptionEditor($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$8);
  let descriptions = prop($$props, "descriptions", 19, () => ({})), readonly2 = prop($$props, "readonly", 3, false);
  var div = root$9();
  var div_1 = sibling(child(div), 2);
  var textarea = sibling(child(div_1), 2);
  remove_textarea_child(textarea);
  textarea.__change = (e) => {
    $$props.onDescriptionsChange({ ...descriptions(), public: e.target.value });
  };
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var textarea_1 = sibling(child(div_2), 2);
  remove_textarea_child(textarea_1);
  textarea_1.__change = (e) => {
    $$props.onDescriptionsChange({ ...descriptions(), hidden: e.target.value });
  };
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  var textarea_2 = sibling(child(div_3), 2);
  remove_textarea_child(textarea_2);
  textarea_2.__change = (e) => {
    $$props.onDescriptionsChange({ ...descriptions(), gm: e.target.value });
  };
  reset(div_3);
  reset(div);
  template_effect(() => {
    set_value(textarea, descriptions().public ?? "");
    textarea.disabled = readonly2();
    set_value(textarea_1, descriptions().hidden ?? "");
    textarea_1.disabled = readonly2();
    set_value(textarea_2, descriptions().gm ?? "");
    textarea_2.disabled = readonly2();
  });
  append($$anchor, div);
  pop();
}
__name(NodeDescriptionEditor, "NodeDescriptionEditor");
delegate(["change"]);
var root$8 = /* @__PURE__ */ from_html(`<div class="node-reveal-settings svelte-1auja0g"><h3 class="svelte-1auja0g">Sichtbarkeit</h3> <div class="reveal-field svelte-1auja0g"><label class="svelte-1auja0g"><input type="checkbox" class="svelte-1auja0g"/> <span>Öffentlich sichtbar</span></label> <p class="hint svelte-1auja0g">Diese Node ist für alle Spieler sichtbar</p></div> <div class="reveal-field svelte-1auja0g"><label class="svelte-1auja0g"><input type="checkbox" class="svelte-1auja0g"/> <span>Versteckt</span></label> <p class="hint svelte-1auja0g">Diese Node ist nur für Spieler mit entsprechender Berechtigung sichtbar</p></div></div>`);
const $$css$7 = {
  hash: "svelte-1auja0g",
  code: '.node-reveal-settings.svelte-1auja0g {background:var(--color-bg-secondary, var(--color-cool-5-90));padding:1.5rem;border-radius:4px;border:1px solid var(--color-border, var(--color-border-light-primary));}.node-reveal-settings.svelte-1auja0g h3:where(.svelte-1auja0g) {margin:0 0 1rem 0;font-size:1.2rem;border-bottom:1px solid var(--color-border, var(--color-border-light-tertiary));padding-bottom:0.5rem;color:var(--color-text-primary, var(--color-text-light-primary));}.reveal-field.svelte-1auja0g {margin-bottom:1rem;}.reveal-field.svelte-1auja0g label:where(.svelte-1auja0g) {display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-weight:bold;color:var(--color-form-label);}.reveal-field.svelte-1auja0g input[type="checkbox"]:where(.svelte-1auja0g) {width:1.2rem;height:1.2rem;cursor:pointer;accent-color:var(--checkbox-checked-color);}.reveal-field.svelte-1auja0g .hint:where(.svelte-1auja0g) {margin:0.25rem 0 0 1.7rem;font-size:0.85rem;color:var(--color-text-secondary, var(--color-text-light-secondary));font-weight:normal;}'
};
function NodeRevealSettings($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$7);
  let reveal = prop($$props, "reveal", 19, () => ({})), readonly2 = prop($$props, "readonly", 3, false);
  var div = root$8();
  var div_1 = sibling(child(div), 2);
  var label2 = child(div_1);
  var input = child(label2);
  remove_input_defaults(input);
  input.__change = (e) => {
    $$props.onRevealChange({ ...reveal(), public: e.target.checked });
  };
  next(2);
  reset(label2);
  next(2);
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var label_1 = child(div_2);
  var input_1 = child(label_1);
  remove_input_defaults(input_1);
  input_1.__change = (e) => {
    $$props.onRevealChange({ ...reveal(), hidden: e.target.checked });
  };
  next(2);
  reset(label_1);
  next(2);
  reset(div_2);
  reset(div);
  template_effect(() => {
    set_checked(input, reveal().public ?? false);
    input.disabled = readonly2();
    set_checked(input_1, reveal().hidden ?? false);
    input_1.disabled = readonly2();
  });
  append($$anchor, div);
  pop();
}
__name(NodeRevealSettings, "NodeRevealSettings");
delegate(["change"]);
var root_1$5 = /* @__PURE__ */ from_html(`<span class="unsaved-indicator svelte-1a6tt5q">● Ungespeicherte Änderungen</span>`);
var root_2$2 = /* @__PURE__ */ from_html(`<!> <!> <!>`, 1);
var root_3$2 = /* @__PURE__ */ from_html(`<div class="loading svelte-1a6tt5q">Lade Node-Daten...</div>`);
var root$7 = /* @__PURE__ */ from_html(`<div class="node-sheet-view svelte-1a6tt5q"><div class="node-sheet-header svelte-1a6tt5q"><h2 class="svelte-1a6tt5q">Beziehungsknoten</h2> <!></div> <div class="node-sheet-content svelte-1a6tt5q"><!></div></div>`);
const $$css$6 = {
  hash: "svelte-1a6tt5q",
  code: "\r\n  /* Global styles für Parent-Container - müssen außerhalb der Komponente sein */\r\n  /* Die Handlebars-Templates enthalten bereits die Flexbox-Struktur */#svelte-mount-point {height:100%;min-height:0;display:flex;flex-direction:column;overflow:hidden;}.node-sheet-view.svelte-1a6tt5q {padding:1rem;height:100%;min-height:0;max-height:100%;display:flex;flex-direction:column;overflow:hidden;}.node-sheet-header.svelte-1a6tt5q {display:flex;align-items:center;gap:1rem;margin-bottom:1rem;padding-bottom:1rem;border-bottom:1px solid var(--color-border, var(--color-border-light-primary));flex-shrink:0;}.node-sheet-header.svelte-1a6tt5q h2:where(.svelte-1a6tt5q) {margin:0;font-size:1.5rem;flex:1;color:var(--color-text-primary, var(--color-text-light-primary));}.unsaved-indicator.svelte-1a6tt5q {color:var(--color-error, var(--color-level-error));font-size:0.9rem;}.node-sheet-content.svelte-1a6tt5q {flex:1 1 0;min-height:0;max-height:100%;overflow-y:auto;overflow-x:hidden;display:flex;flex-direction:column;gap:1.5rem;\r\n    /* Explizite Höhenbegrenzung für Scrollbalken */height:0; /* Trick: Mit flex: 1 1 0 und height: 0 wird die Höhe durch flex bestimmt */\r\n    /* Scrollbar-Styling für bessere Sichtbarkeit */scrollbar-width:thin;scrollbar-color:var(--color-scrollbar, var(--color-border-light-primary)) transparent;}\r\n\r\n  /* Webkit-Scrollbar-Styling für Chrome/Safari */.node-sheet-content.svelte-1a6tt5q::-webkit-scrollbar {width:8px;}.node-sheet-content.svelte-1a6tt5q::-webkit-scrollbar-track {background:transparent;}.node-sheet-content.svelte-1a6tt5q::-webkit-scrollbar-thumb {background-color:var(--color-scrollbar, var(--color-border-light-primary));border-radius:4px;}.node-sheet-content.svelte-1a6tt5q::-webkit-scrollbar-thumb:hover {background-color:var(--color-border-highlight, var(--color-border-light-secondary));}.loading.svelte-1a6tt5q {text-align:center;color:var(--color-text-secondary, var(--color-text-light-secondary));padding:2rem;}"
};
function NodeSheetView($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$6);
  let initialState = prop($$props, "state", 19, () => ({})), readonly2 = prop($$props, "readonly", 3, false);
  const nodeDataServiceTyped = /* @__PURE__ */ user_derived(() => $$props.nodeDataService);
  const notificationCenterTyped = /* @__PURE__ */ user_derived(() => $$props.notificationCenter);
  let nodeData = /* @__PURE__ */ state(void 0);
  let pageId = /* @__PURE__ */ user_derived(() => () => {
    const doc = $$props.document;
    const id2 = doc?.id ?? doc?._id ?? "";
    if (!id2) {
      console.warn("[NodeSheetView] No pageId found. Document keys:", Object.keys(doc || {}));
    }
    return id2;
  });
  let hasUnsavedChanges = /* @__PURE__ */ state(false);
  user_effect(() => {
    console.log("[NodeSheetView] Component mounted. Document:", $$props.document, "pageId:", get$2(pageId), "service:", !!get$2(nodeDataServiceTyped));
  });
  user_effect(() => {
    const currentPageId = get$2(pageId)();
    if (currentPageId && get$2(nodeDataServiceTyped)) {
      loadNodeData();
    } else {
      if (!currentPageId) {
        console.warn("[NodeSheetView] No pageId available. Document:", $$props.document, "Document type:", typeof $$props.document);
      }
      if (!get$2(nodeDataServiceTyped)) {
        console.warn("[NodeSheetView] nodeDataService not available. Props:", {
          nodeDataService: !!$$props.nodeDataService,
          notificationCenter: !!$$props.notificationCenter
        });
      }
    }
  });
  async function loadNodeData() {
    const currentPageId = get$2(pageId)();
    if (!get$2(nodeDataServiceTyped) || !currentPageId) return;
    const result = await get$2(nodeDataServiceTyped).loadNodeData(currentPageId);
    if (result.ok) {
      if (result.value) {
        let extractedData;
        const value2 = result.value;
        if (value2 && typeof value2 === "object") {
          if ("toObject" in value2 && typeof value2.toObject === "function") {
            extractedData = value2.toObject();
          } else {
            const extracted = {
              schemaVersion: value2.schemaVersion,
              nodeKey: value2.nodeKey,
              name: value2.name,
              kind: value2.kind,
              factionId: value2.factionId,
              relation: value2.relation,
              icon: value2.icon,
              descriptions: value2.descriptions,
              reveal: value2.reveal,
              effects: value2.effects,
              linkedEntityUuid: value2.linkedEntityUuid
            };
            extractedData = Object.fromEntries(Object.entries(extracted).filter(([_, v]) => v !== void 0));
          }
        } else {
          extractedData = value2;
        }
        set$1(nodeData, extractedData, true);
        set$1(hasUnsavedChanges, false);
      } else {
        set$1(
          nodeData,
          {
            schemaVersion: 1,
            name: "",
            kind: "person",
            relation: "neutral"
          },
          true
        );
        set$1(hasUnsavedChanges, false);
      }
    } else {
      const errorCode = result.error?.code;
      if (errorCode === "PAGE_NOT_FOUND" || errorCode === "REPOSITORY_ERROR") {
        set$1(
          nodeData,
          {
            schemaVersion: 1,
            name: "",
            kind: "person",
            relation: "neutral"
          },
          true
        );
        set$1(hasUnsavedChanges, false);
      } else {
        get$2(notificationCenterTyped)?.error("Failed to load node data", result.error);
      }
    }
  }
  __name(loadNodeData, "loadNodeData");
  function handleDataChange(updatedData) {
    set$1(nodeData, updatedData, true);
    set$1(hasUnsavedChanges, true);
    if ($$props.onDataChange && get$2(nodeData)) {
      console.log("[NodeSheetView] Notifying parent about data change:", get$2(nodeData));
      $$props.onDataChange(get$2(nodeData));
    } else {
      console.warn("[NodeSheetView] onDataChange not available or nodeData is null", {
        onDataChange: !!$$props.onDataChange,
        nodeData: get$2(nodeData)
      });
    }
  }
  __name(handleDataChange, "handleDataChange");
  function handleSaveSuccess() {
    console.log("[NodeSheetView] Save successful, resetting hasUnsavedChanges");
    set$1(hasUnsavedChanges, false);
  }
  __name(handleSaveSuccess, "handleSaveSuccess");
  user_pre_effect(() => {
    if ($$props.onSaveSuccess) {
      console.log("[NodeSheetView] Registering save success callback");
      $$props.onSaveSuccess(handleSaveSuccess);
    } else {
      console.warn("[NodeSheetView] onSaveSuccess not available yet");
    }
  });
  var div = root$7();
  var div_1 = child(div);
  var node = sibling(child(div_1), 2);
  {
    var consequent = /* @__PURE__ */ __name(($$anchor2) => {
      var span = root_1$5();
      append($$anchor2, span);
    }, "consequent");
    if_block(node, ($$render) => {
      if (get$2(hasUnsavedChanges)) $$render(consequent);
    });
  }
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var node_1 = child(div_2);
  {
    var consequent_1 = /* @__PURE__ */ __name(($$anchor2) => {
      var fragment = root_2$2();
      var node_2 = first_child(fragment);
      NodeForm(node_2, {
        get nodeData() {
          return get$2(nodeData);
        },
        get readonly() {
          return readonly2();
        },
        onDataChange: handleDataChange
      });
      var node_3 = sibling(node_2, 2);
      {
        let $0 = /* @__PURE__ */ user_derived(() => get$2(nodeData).descriptions ?? {});
        NodeDescriptionEditor(node_3, {
          get descriptions() {
            return get$2($0);
          },
          get readonly() {
            return readonly2();
          },
          onDescriptionsChange: /* @__PURE__ */ __name((descriptions) => {
            handleDataChange({ ...get$2(nodeData), descriptions });
          }, "onDescriptionsChange")
        });
      }
      var node_4 = sibling(node_3, 2);
      {
        let $0 = /* @__PURE__ */ user_derived(() => get$2(nodeData).reveal ?? {});
        NodeRevealSettings(node_4, {
          get reveal() {
            return get$2($0);
          },
          get readonly() {
            return readonly2();
          },
          onRevealChange: /* @__PURE__ */ __name((reveal) => {
            handleDataChange({ ...get$2(nodeData), reveal });
          }, "onRevealChange")
        });
      }
      append($$anchor2, fragment);
    }, "consequent_1");
    var alternate = /* @__PURE__ */ __name(($$anchor2) => {
      var div_3 = root_3$2();
      append($$anchor2, div_3);
    }, "alternate");
    if_block(node_1, ($$render) => {
      if (get$2(nodeData)) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  reset(div_2);
  reset(div);
  append($$anchor, div);
  pop();
}
__name(NodeSheetView, "NodeSheetView");
const NodeSheetBase = JournalEntryPageWindowSystemBridgeMixin(
  foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet,
  {
    definitionId: "relationship-node-sheet",
    component: {
      type: "svelte",
      component: NodeSheetView
    },
    title: "Beziehungsknoten"
  },
  "fvtt_relationship_app_module"
);
const _RelationshipNodeSheet = class _RelationshipNodeSheet extends NodeSheetBase {
};
__name(_RelationshipNodeSheet, "RelationshipNodeSheet");
_RelationshipNodeSheet.DEFAULT_OPTIONS = {
  ...__superGet(_RelationshipNodeSheet, _RelationshipNodeSheet, "DEFAULT_OPTIONS"),
  id: "journal-entry-relationship-node",
  classes: ["journal-entry-page", "relationship-node"],
  width: 800,
  height: 600,
  resizable: true
};
_RelationshipNodeSheet.EDIT_PARTS = (() => {
  const baseSheet = foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet;
  const parts = (
    // @ts-expect-error TS2339 - EDIT_PARTS may not exist in base class type definition but exists at runtime
    baseSheet.EDIT_PARTS ?? {}
  );
  const { header, footer, ...rest } = parts;
  return {
    header,
    content: {
      template: "modules/fvtt_relationship_app_module/templates/journal/parts/node-content-edit.hbs"
    },
    ...rest,
    footer
  };
})();
_RelationshipNodeSheet.VIEW_PARTS = (() => {
  const baseSheet = foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet;
  const parts = (
    // @ts-expect-error TS2339 - VIEW_PARTS may not exist in base class type definition but exists at runtime
    baseSheet.VIEW_PARTS ?? {}
  );
  return {
    ...parts,
    content: {
      template: "modules/fvtt_relationship_app_module/templates/journal/parts/node-content-view.hbs"
    }
  };
})();
let RelationshipNodeSheet = _RelationshipNodeSheet;
const scriptRel = "modulepreload";
const assetsURL = /* @__PURE__ */ __name(function(dep) {
  return "/" + dep;
}, "assetsURL");
const seen = {};
const __vitePreload = /* @__PURE__ */ __name(function preload(baseModule, deps, importerUrl) {
  let promise4 = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled2 = function(promises$2) {
      return Promise.all(promises$2.map((p2) => Promise.resolve(p2).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    var allSettled = allSettled2;
    __name(allSettled2, "allSettled");
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise4 = allSettled2(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (!!importerUrl) for (let i$1 = links.length - 1; i$1 >= 0; i$1--) {
        const link$1 = links[i$1];
        if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
      }
      else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link2 = document.createElement("link");
      link2.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link2.as = "script";
      link2.crossOrigin = "";
      link2.href = dep;
      if (cspNonce) link2.setAttribute("nonce", cspNonce);
      document.head.appendChild(link2);
      if (isCss) return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  __name(handlePreloadError, "handlePreloadError");
  return promise4.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
}, "preload");
var root_1$4 = /* @__PURE__ */ from_html(`<div class="loading svelte-wckkd9">Lade Graph...</div>`);
var root$6 = /* @__PURE__ */ from_html(`<div class="cytoscape-graph svelte-wckkd9"><!></div>`);
const $$css$5 = {
  hash: "svelte-wckkd9",
  code: ".cytoscape-graph.svelte-wckkd9 {width:100%;height:100%;position:relative;}.loading.svelte-wckkd9 {position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);color:#666;}"
};
function CytoscapeGraph($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$5);
  let readonly2 = prop($$props, "readonly", 3, false);
  let containerElement = null;
  let cyInstance = /* @__PURE__ */ state(null);
  let structureChangeTimeout = null;
  onMount(() => {
    if (!containerElement) return;
    __vitePreload(() => Promise.resolve().then(function() {
      return cytoscape_esm;
    }), true ? void 0 : void 0).then((cytoscapeModule) => {
      const cytoscape3 = cytoscapeModule.default;
      set$1(
        cyInstance,
        cytoscape3({
          container: containerElement,
          elements: convertGraphDataToElements($$props.graphData),
          style: getGraphStyle(),
          layout: {
            name: "preset",
            positions: $$props.graphData?.layout?.positions,
            zoom: $$props.graphData?.layout?.zoom ?? 1,
            pan: $$props.graphData?.layout?.pan ?? { x: 0, y: 0 }
          },
          // Readonly-Modus: Interaktivität deaktivieren
          boxSelectionEnabled: !readonly2(),
          autoungrabify: readonly2(),
          autolock: readonly2(),
          userPanningEnabled: !readonly2(),
          userZoomingEnabled: !readonly2()
        }),
        true
      );
      setupEventHandlers();
    }).catch((error3) => {
      console.error("Failed to load cytoscape:", error3);
    });
  });
  onDestroy(() => {
    if (structureChangeTimeout) {
      clearTimeout(structureChangeTimeout);
    }
    if (get$2(cyInstance)) {
      get$2(cyInstance).destroy();
      set$1(cyInstance, null);
    }
  });
  function convertGraphDataToElements(graphData) {
    if (!graphData) return [];
    const elements = [];
    if (graphData.nodeKeys) {
      for (const nodeKey of graphData.nodeKeys) {
        elements.push({
          data: {
            id: nodeKey,
            label: nodeKey
            // TODO: Load actual node data
          }
        });
      }
    }
    if (graphData.edges) {
      for (const edge of graphData.edges) {
        elements.push({
          data: {
            id: edge.id,
            source: edge.source,
            target: edge.target,
            knowledge: edge.knowledge,
            label: edge.label
          }
        });
      }
    }
    return elements;
  }
  __name(convertGraphDataToElements, "convertGraphDataToElements");
  function getGraphStyle() {
    return [
      {
        selector: "node",
        style: {
          "background-color": "#666",
          label: "data(label)",
          "text-valign": "center",
          "text-halign": "center",
          width: 30,
          height: 30
        }
      },
      {
        selector: "edge",
        style: {
          width: 2,
          "line-color": "#ccc",
          "target-arrow-color": "#ccc",
          "target-arrow-shape": "triangle",
          "curve-style": "bezier",
          label: "data(label)"
        }
      }
    ];
  }
  __name(getGraphStyle, "getGraphStyle");
  function setupEventHandlers() {
    if (!get$2(cyInstance)) return;
    get$2(cyInstance).on("dragfree", () => {
      if (!get$2(cyInstance)) return;
      const positions2 = {};
      get$2(cyInstance).nodes().forEach((node) => {
        const pos = node.position();
        positions2[node.id()] = { x: pos.x, y: pos.y };
      });
      const zoom2 = get$2(cyInstance).zoom();
      const pan2 = get$2(cyInstance).pan();
      $$props.onLayoutChange?.({ positions: positions2, zoom: zoom2, pan: { x: pan2.x, y: pan2.y } });
    });
    get$2(cyInstance).on("add remove", () => {
      if (structureChangeTimeout) {
        clearTimeout(structureChangeTimeout);
      }
      structureChangeTimeout = setTimeout(
        () => {
          if (!get$2(cyInstance)) return;
          const graphData = convertElementsToGraphData();
          $$props.onStructureChange?.(graphData);
        },
        500
      );
    });
  }
  __name(setupEventHandlers, "setupEventHandlers");
  function convertElementsToGraphData() {
    if (!get$2(cyInstance)) return null;
    const nodeKeys = [];
    const edges3 = [];
    get$2(cyInstance).nodes().forEach((node) => {
      nodeKeys.push(node.id());
    });
    get$2(cyInstance).edges().forEach((edge) => {
      const knowledge = edge.data("knowledge");
      const label2 = edge.data("label");
      const edgeData = {
        id: edge.id(),
        source: edge.source().id(),
        target: edge.target().id()
      };
      if (knowledge !== void 0) {
        edgeData.knowledge = knowledge;
      }
      if (label2 !== void 0) {
        edgeData.label = label2;
      }
      edges3.push(edgeData);
    });
    return { nodeKeys, edges: edges3 };
  }
  __name(convertElementsToGraphData, "convertElementsToGraphData");
  var div = root$6();
  var node_1 = child(div);
  {
    var consequent = /* @__PURE__ */ __name(($$anchor2) => {
      var div_1 = root_1$4();
      append($$anchor2, div_1);
    }, "consequent");
    if_block(node_1, ($$render) => {
      if (!get$2(cyInstance)) $$render(consequent);
    });
  }
  reset(div);
  bind_this(div, ($$value) => containerElement = $$value, () => containerElement);
  append($$anchor, div);
  pop();
}
__name(CytoscapeGraph, "CytoscapeGraph");
var root$5 = /* @__PURE__ */ from_html(`<div class="graph-toolbar svelte-1swkth9"><button class="toolbar-button svelte-1swkth9" title="Graph anpassen"><span>🔍</span> Fit</button> <button class="toolbar-button svelte-1swkth9" title="Graph zentrieren"><span>🎯</span> Center</button> <div class="toolbar-separator svelte-1swkth9"></div> <button class="toolbar-button svelte-1swkth9" title="Kante hinzufügen"><span>➕</span> Add Edge</button> <button class="toolbar-button svelte-1swkth9" title="Ausgewähltes Element löschen"><span>🗑️</span> Delete</button></div>`);
const $$css$4 = {
  hash: "svelte-1swkth9",
  code: ".graph-toolbar.svelte-1swkth9 {display:flex;gap:0.5rem;padding:0.5rem;background:var(--color-bg-secondary, var(--color-cool-4));border-bottom:1px solid var(--color-border, var(--color-border-light-primary));}.toolbar-button.svelte-1swkth9 {padding:0.5rem 1rem;border:1px solid var(--button-border-color);background-color:var(--button-background-color);color:var(--button-text-color);cursor:pointer;border-radius:4px;font-size:0.9rem;transition:all 0.2s;}.toolbar-button.svelte-1swkth9:hover {background-color:var(--button-hover-background-color);border-color:var(--button-hover-border-color);color:var(--button-hover-text-color);}.toolbar-separator.svelte-1swkth9 {width:1px;background:var(--color-border-light-primary);margin:0 0.5rem;}"
};
function GraphToolbar($$anchor, $$props) {
  append_styles$1($$anchor, $$css$4);
  let readonly2 = prop($$props, "readonly", 3, false);
  var div = root$5();
  var button = child(div);
  button.__click = function(...$$args) {
    $$props.onFit?.apply(this, $$args);
  };
  var button_1 = sibling(button, 2);
  button_1.__click = function(...$$args) {
    $$props.onCenter?.apply(this, $$args);
  };
  var button_2 = sibling(button_1, 4);
  button_2.__click = function(...$$args) {
    $$props.onAddEdge?.apply(this, $$args);
  };
  var button_3 = sibling(button_2, 2);
  button_3.__click = function(...$$args) {
    $$props.onDelete?.apply(this, $$args);
  };
  reset(div);
  template_effect(() => {
    button_2.disabled = readonly2();
    button_3.disabled = readonly2();
  });
  append($$anchor, div);
}
__name(GraphToolbar, "GraphToolbar");
delegate(["click"]);
var root_2$1 = /* @__PURE__ */ from_html(`<div class="inspector-field svelte-1jihgd3"><label for="knowledge-level" class="svelte-1jihgd3">Knowledge Level:</label> <input id="knowledge-level" type="number" min="0" max="100" class="svelte-1jihgd3"/></div> <div class="inspector-field svelte-1jihgd3"><label for="edge-label" class="svelte-1jihgd3">Label:</label> <input id="edge-label" type="text" class="svelte-1jihgd3"/></div>`, 1);
var root_1$3 = /* @__PURE__ */ from_html(`<div class="inspector-header svelte-1jihgd3"><h3 class="svelte-1jihgd3"> </h3></div> <div class="inspector-content svelte-1jihgd3"><div class="inspector-field svelte-1jihgd3"><span class="field-label svelte-1jihgd3">ID:</span> <span> </span></div> <!></div>`, 1);
var root_3$1 = /* @__PURE__ */ from_html(`<div class="inspector-empty svelte-1jihgd3"><p>Kein Element ausgewählt</p> <p class="hint svelte-1jihgd3">Klicken Sie auf einen Node oder Edge, um Details anzuzeigen</p></div>`);
var root$4 = /* @__PURE__ */ from_html(`<div class="graph-inspector svelte-1jihgd3"><!></div>`);
const $$css$3 = {
  hash: "svelte-1jihgd3",
  code: ".graph-inspector.svelte-1jihgd3 {width:250px;background:var(--color-bg-secondary, var(--color-cool-5-90));border-left:1px solid var(--color-border, var(--color-border-light-primary));padding:1rem;overflow-y:auto;}.inspector-header.svelte-1jihgd3 {margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:1px solid var(--color-border, var(--color-border-light-primary));}.inspector-header.svelte-1jihgd3 h3:where(.svelte-1jihgd3) {margin:0;font-size:1.1rem;color:var(--color-text-primary, var(--color-text-light-primary));}.inspector-content.svelte-1jihgd3 {display:flex;flex-direction:column;gap:1rem;}.inspector-field.svelte-1jihgd3 {display:flex;flex-direction:column;gap:0.25rem;}.inspector-field.svelte-1jihgd3 label:where(.svelte-1jihgd3),\r\n  .inspector-field.svelte-1jihgd3 .field-label:where(.svelte-1jihgd3) {font-weight:bold;font-size:0.9rem;color:var(--color-form-label);}.inspector-field.svelte-1jihgd3 input:where(.svelte-1jihgd3) {padding:0.5rem;border:1px solid var(--input-border-color);border-radius:4px;background-color:var(--input-background-color);color:var(--input-text-color);}.inspector-field.svelte-1jihgd3 input:where(.svelte-1jihgd3):focus {outline:none;border-color:var(--input-focus-outline-color);color:var(--input-text-color);}.inspector-empty.svelte-1jihgd3 {text-align:center;color:var(--color-text-secondary, var(--color-text-light-secondary));padding:2rem 1rem;}.inspector-empty.svelte-1jihgd3 .hint:where(.svelte-1jihgd3) {font-size:0.85rem;margin-top:0.5rem;color:var(--color-text-secondary, var(--color-text-light-secondary));}"
};
function GraphInspector($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$3);
  let readonly2 = prop($$props, "readonly", 3, false);
  var div = root$4();
  var node = child(div);
  {
    var consequent_1 = /* @__PURE__ */ __name(($$anchor2) => {
      var fragment = root_1$3();
      var div_1 = first_child(fragment);
      var h3 = child(div_1);
      var text2 = child(h3);
      reset(h3);
      reset(div_1);
      var div_2 = sibling(div_1, 2);
      var div_3 = child(div_2);
      var span = sibling(child(div_3), 2);
      var text_1 = child(span, true);
      reset(span);
      reset(div_3);
      var node_1 = sibling(div_3, 2);
      {
        var consequent = /* @__PURE__ */ __name(($$anchor3) => {
          var fragment_1 = root_2$1();
          var div_4 = first_child(fragment_1);
          var input = sibling(child(div_4), 2);
          remove_input_defaults(input);
          input.__change = (e) => {
            const value2 = Number.parseInt(e.target.value, 10);
            $$props.onUpdate?.($$props.selectedElement.id, { ...$$props.selectedElement.data, knowledge: value2 });
          };
          reset(div_4);
          var div_5 = sibling(div_4, 2);
          var input_1 = sibling(child(div_5), 2);
          remove_input_defaults(input_1);
          input_1.__change = (e) => {
            const value2 = e.target.value;
            $$props.onUpdate?.($$props.selectedElement.id, { ...$$props.selectedElement.data, label: value2 });
          };
          reset(div_5);
          template_effect(() => {
            set_value(input, $$props.selectedElement.data?.knowledge ?? 0);
            input.disabled = readonly2();
            set_value(input_1, $$props.selectedElement.data?.label ?? "");
            input_1.disabled = readonly2();
          });
          append($$anchor3, fragment_1);
        }, "consequent");
        if_block(node_1, ($$render) => {
          if ($$props.selectedElement.type === "edge") $$render(consequent);
        });
      }
      reset(div_2);
      template_effect(() => {
        set_text(text2, `${$$props.selectedElement.type === "node" ? "Node" : "Edge"} Details`);
        set_text(text_1, $$props.selectedElement.id);
      });
      append($$anchor2, fragment);
    }, "consequent_1");
    var alternate = /* @__PURE__ */ __name(($$anchor2) => {
      var div_6 = root_3$1();
      append($$anchor2, div_6);
    }, "alternate");
    if_block(node, ($$render) => {
      if ($$props.selectedElement) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  reset(div);
  append($$anchor, div);
  pop();
}
__name(GraphInspector, "GraphInspector");
delegate(["change"]);
var root_2 = /* @__PURE__ */ from_html(`<li> </li>`);
var root_1$2 = /* @__PURE__ */ from_html(`<div class="json-editor-errors svelte-173vm0z"><h4 class="svelte-173vm0z">Validation Errors:</h4> <ul class="svelte-173vm0z"></ul></div>`);
var root$3 = /* @__PURE__ */ from_html(`<div class="graph-json-editor svelte-173vm0z"><div class="json-editor-header svelte-173vm0z"><h3 class="svelte-173vm0z">JSON Editor</h3> <div class="json-editor-actions svelte-173vm0z"><button class="action-button svelte-173vm0z">Validate</button> <button class="action-button primary svelte-173vm0z">Apply</button></div></div> <!> <div class="json-editor-content svelte-173vm0z"><textarea class="json-textarea svelte-173vm0z"></textarea></div></div>`);
const $$css$2 = {
  hash: "svelte-173vm0z",
  code: ".graph-json-editor.svelte-173vm0z {display:flex;flex-direction:column;height:100%;}.json-editor-header.svelte-173vm0z {display:flex;justify-content:space-between;align-items:center;padding:1rem;border-bottom:1px solid var(--color-border, var(--color-border-light-primary));background:var(--color-bg-secondary, var(--color-cool-4));}.json-editor-header.svelte-173vm0z h3:where(.svelte-173vm0z) {margin:0;font-size:1.1rem;color:var(--color-text-primary, var(--color-text-light-primary));}.json-editor-actions.svelte-173vm0z {display:flex;gap:0.5rem;}.action-button.svelte-173vm0z {padding:0.5rem 1rem;border:1px solid var(--button-border-color);background-color:var(--button-background-color);color:var(--button-text-color);cursor:pointer;border-radius:4px;font-size:0.9rem;transition:all 0.2s;}.action-button.svelte-173vm0z:hover {background-color:var(--button-hover-background-color);border-color:var(--button-hover-border-color);color:var(--button-hover-text-color);}.action-button.primary.svelte-173vm0z {background-color:var(--button-hover-background-color);color:var(--button-hover-text-color);border-color:var(--button-hover-border-color);}.action-button.primary.svelte-173vm0z:hover {background-color:var(--color-warm-1);border-color:var(--color-warm-2);color:var(--color-cool-5);}.json-editor-errors.svelte-173vm0z {padding:1rem;background:var(--color-level-error-bg);border-bottom:1px solid var(--color-level-error-border);color:var(--color-level-error);}.json-editor-errors.svelte-173vm0z h4:where(.svelte-173vm0z) {margin:0 0 0.5rem 0;font-size:1rem;}.json-editor-errors.svelte-173vm0z ul:where(.svelte-173vm0z) {margin:0;padding-left:1.5rem;}.json-editor-content.svelte-173vm0z {flex:1;padding:1rem;overflow:hidden;}.json-textarea.svelte-173vm0z {width:100%;height:100%;font-family:var(--font-monospace);font-size:0.9rem;padding:0.5rem;border:1px solid var(--input-border-color);border-radius:4px;resize:none;background-color:var(--input-background-color);color:var(--input-text-color);}.json-textarea.svelte-173vm0z:focus {outline:none;border-color:var(--input-focus-outline-color);color:var(--input-text-color);}"
};
function GraphJsonEditor($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$2);
  let readonly2 = prop($$props, "readonly", 3, false);
  let jsonText = /* @__PURE__ */ state("");
  let validationErrors = /* @__PURE__ */ state(proxy([]));
  let isValid = /* @__PURE__ */ state(true);
  user_effect(() => {
    set$1(jsonText, JSON.stringify($$props.graphData ?? {}, null, 2), true);
  });
  function handleValidate() {
    try {
      const parsed = JSON.parse(get$2(jsonText));
      const result = $$props.onValidate?.(parsed);
      if (result) {
        set$1(isValid, result.valid, true);
        set$1(validationErrors, result.errors ?? [], true);
      } else {
        set$1(isValid, true);
        set$1(validationErrors, [], true);
      }
    } catch (error3) {
      set$1(isValid, false);
      set$1(validationErrors, [error3 instanceof Error ? error3.message : String(error3)], true);
    }
  }
  __name(handleValidate, "handleValidate");
  function handleApply() {
    try {
      const parsed = JSON.parse(get$2(jsonText));
      const result = $$props.onValidate?.(parsed);
      if (result && !result.valid) {
        set$1(validationErrors, result.errors ?? [], true);
        set$1(isValid, false);
        return;
      }
      $$props.onApply?.(parsed);
      set$1(isValid, true);
      set$1(validationErrors, [], true);
    } catch (error3) {
      set$1(isValid, false);
      set$1(validationErrors, [error3 instanceof Error ? error3.message : String(error3)], true);
    }
  }
  __name(handleApply, "handleApply");
  var div = root$3();
  var div_1 = child(div);
  var div_2 = sibling(child(div_1), 2);
  var button = child(div_2);
  button.__click = handleValidate;
  var button_1 = sibling(button, 2);
  button_1.__click = handleApply;
  reset(div_2);
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent = /* @__PURE__ */ __name(($$anchor2) => {
      var div_3 = root_1$2();
      var ul = sibling(child(div_3), 2);
      each(ul, 21, () => get$2(validationErrors), index, ($$anchor3, error3) => {
        var li = root_2();
        var text2 = child(li, true);
        reset(li);
        template_effect(() => set_text(text2, get$2(error3)));
        append($$anchor3, li);
      });
      reset(ul);
      reset(div_3);
      append($$anchor2, div_3);
    }, "consequent");
    if_block(node, ($$render) => {
      if (!get$2(isValid) && get$2(validationErrors).length > 0) $$render(consequent);
    });
  }
  var div_4 = sibling(node, 2);
  var textarea = child(div_4);
  remove_textarea_child(textarea);
  set_attribute(textarea, "spellcheck", false);
  reset(div_4);
  reset(div);
  template_effect(() => {
    button.disabled = readonly2();
    button_1.disabled = readonly2();
    textarea.disabled = readonly2();
  });
  bind_value(textarea, () => get$2(jsonText), ($$value) => set$1(jsonText, $$value));
  append($$anchor, div);
  pop();
}
__name(GraphJsonEditor, "GraphJsonEditor");
delegate(["click"]);
var root_1$1 = /* @__PURE__ */ from_html(`<div class="graph-sheet-ui svelte-1cqg2z6"><!> <div class="graph-sheet-main svelte-1cqg2z6"><div class="graph-sheet-canvas svelte-1cqg2z6"><!></div> <!></div></div>`);
var root_4 = /* @__PURE__ */ from_html(`<div class="graph-sheet-json svelte-1cqg2z6"><!></div>`);
var root$2 = /* @__PURE__ */ from_html(`<div class="graph-sheet-view svelte-1cqg2z6"><div class="graph-sheet-tabs svelte-1cqg2z6"><button>UI Editor</button> <button>JSON Editor</button></div> <!></div>`);
const $$css$1 = {
  hash: "svelte-1cqg2z6",
  code: ".graph-sheet-view.svelte-1cqg2z6 {height:100%;display:flex;flex-direction:column;}.graph-sheet-tabs.svelte-1cqg2z6 {display:flex;border-bottom:1px solid var(--color-border, var(--color-border-light-primary));background:var(--color-bg-secondary, var(--color-cool-4));}.tab-button.svelte-1cqg2z6 {padding:0.75rem 1.5rem;border:none;background:transparent;cursor:pointer;border-bottom:2px solid transparent;font-size:0.95rem;color:var(--color-text-primary, var(--color-text-light-primary));}.tab-button.svelte-1cqg2z6:hover {background:var(--color-bg-hover, var(--color-cool-3));}.tab-button.active.svelte-1cqg2z6 {border-bottom-color:var(--color-primary, var(--color-border-highlight));background:var(--color-cool-5-90);}.graph-sheet-ui.svelte-1cqg2z6 {flex:1;display:flex;flex-direction:column;overflow:hidden;}.graph-sheet-main.svelte-1cqg2z6 {flex:1;display:flex;overflow:hidden;}.graph-sheet-canvas.svelte-1cqg2z6 {flex:1;position:relative;}.graph-sheet-json.svelte-1cqg2z6 {flex:1;overflow:hidden;}"
};
function GraphSheetView($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css$1);
  let initialState = prop($$props, "state", 19, () => ({})), readonly2 = prop($$props, "readonly", 3, false);
  const graphDataServiceTyped = /* @__PURE__ */ user_derived(() => $$props.graphDataService);
  const notificationCenterTyped = /* @__PURE__ */ user_derived(() => $$props.notificationCenter);
  let activeTab = /* @__PURE__ */ state("ui");
  let graphData = /* @__PURE__ */ state(void 0);
  let selectedElement = void 0;
  let cytoscapeInstance = null;
  let pageId = /* @__PURE__ */ user_derived(() => $$props.document?.id ?? "");
  user_effect(() => {
    if (get$2(pageId) && get$2(graphDataServiceTyped)) {
      loadGraphData();
    }
  });
  async function loadGraphData() {
    if (!get$2(graphDataServiceTyped) || !get$2(pageId)) return;
    const result = await get$2(graphDataServiceTyped).loadGraphData(get$2(pageId));
    if (result.ok && result.value) {
      set$1(graphData, result.value, true);
    } else {
      get$2(notificationCenterTyped)?.error("Failed to load graph data", result.error);
    }
  }
  __name(loadGraphData, "loadGraphData");
  function handleLayoutChange(layout4) {
    if (!get$2(graphData)) return;
    const updatedData = { ...get$2(graphData), layout: layout4 };
    if (get$2(graphDataServiceTyped) && get$2(pageId)) {
      get$2(graphDataServiceTyped).saveGraphData(get$2(pageId), updatedData).then((result) => {
        if (!result.ok) {
          get$2(notificationCenterTyped)?.error("Failed to save layout", result.error);
        }
      });
    }
    set$1(graphData, updatedData, true);
  }
  __name(handleLayoutChange, "handleLayoutChange");
  function handleStructureChange(newGraphData) {
    if (!get$2(graphDataServiceTyped) || !get$2(pageId)) return;
    const typedData = newGraphData;
    get$2(graphDataServiceTyped).saveGraphData(get$2(pageId), typedData).then((result) => {
      if (!result.ok) {
        get$2(notificationCenterTyped)?.error("Failed to save graph structure", result.error);
      } else {
        set$1(graphData, typedData, true);
        get$2(notificationCenterTyped)?.info("Graph structure saved");
      }
    });
  }
  __name(handleStructureChange, "handleStructureChange");
  function handleValidate(graphDataToValidate) {
    if (!get$2(graphDataServiceTyped)) return { valid: true };
    const result = get$2(graphDataServiceTyped).validateGraphData(graphDataToValidate);
    if (result.ok) {
      return { valid: true };
    }
    const errorMessage = result.error?.message ?? "Validation failed";
    return { valid: false, errors: [errorMessage] };
  }
  __name(handleValidate, "handleValidate");
  function handleApply(newGraphData) {
    set$1(graphData, newGraphData, true);
    loadGraphData();
  }
  __name(handleApply, "handleApply");
  function handleFit() {
    cytoscapeInstance?.fit();
  }
  __name(handleFit, "handleFit");
  function handleCenter() {
    cytoscapeInstance?.center();
  }
  __name(handleCenter, "handleCenter");
  function handleAddEdge() {
    get$2(notificationCenterTyped)?.info("Add edge feature coming soon");
  }
  __name(handleAddEdge, "handleAddEdge");
  function handleDelete() {
    get$2(notificationCenterTyped)?.info("Delete feature coming soon");
  }
  __name(handleDelete, "handleDelete");
  var div = root$2();
  var div_1 = child(div);
  var button = child(div_1);
  let classes2;
  button.__click = () => set$1(activeTab, "ui");
  var button_1 = sibling(button, 2);
  let classes_1;
  button_1.__click = () => set$1(activeTab, "json");
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent_2 = /* @__PURE__ */ __name(($$anchor2) => {
      var div_2 = root_1$1();
      var node_1 = child(div_2);
      GraphToolbar(node_1, {
        onFit: handleFit,
        onCenter: handleCenter,
        onAddEdge: handleAddEdge,
        onDelete: handleDelete
      });
      var div_3 = sibling(node_1, 2);
      var div_4 = child(div_3);
      var node_2 = child(div_4);
      {
        var consequent = /* @__PURE__ */ __name(($$anchor3) => {
          CytoscapeGraph($$anchor3, {
            get graphData() {
              return get$2(graphData);
            },
            get readonly() {
              return readonly2();
            },
            onLayoutChange: handleLayoutChange,
            onStructureChange: handleStructureChange
          });
        }, "consequent");
        if_block(node_2, ($$render) => {
          if (get$2(graphData)) $$render(consequent);
        });
      }
      reset(div_4);
      var node_3 = sibling(div_4, 2);
      {
        var consequent_1 = /* @__PURE__ */ __name(($$anchor3) => {
          GraphInspector($$anchor3, {
            selectedElement,
            get readonly() {
              return readonly2();
            },
            onUpdate: /* @__PURE__ */ __name((id2, data4) => {
              get$2(notificationCenterTyped)?.info("Update feature coming soon");
            }, "onUpdate")
          });
        }, "consequent_1");
        if_block(node_3, ($$render) => {
          if (selectedElement) $$render(consequent_1);
        });
      }
      reset(div_3);
      reset(div_2);
      append($$anchor2, div_2);
    }, "consequent_2");
    var alternate = /* @__PURE__ */ __name(($$anchor2) => {
      var div_5 = root_4();
      var node_4 = child(div_5);
      GraphJsonEditor(node_4, {
        get graphData() {
          return get$2(graphData);
        },
        get readonly() {
          return readonly2();
        },
        onApply: handleApply,
        onValidate: handleValidate
      });
      reset(div_5);
      append($$anchor2, div_5);
    }, "alternate");
    if_block(node, ($$render) => {
      if (get$2(activeTab) === "ui") $$render(consequent_2);
      else $$render(alternate, false);
    });
  }
  reset(div);
  template_effect(() => {
    classes2 = set_class(button, 1, "tab-button svelte-1cqg2z6", null, classes2, { active: get$2(activeTab) === "ui" });
    classes_1 = set_class(button_1, 1, "tab-button svelte-1cqg2z6", null, classes_1, { active: get$2(activeTab) === "json" });
  });
  append($$anchor, div);
  pop();
}
__name(GraphSheetView, "GraphSheetView");
delegate(["click"]);
const GraphSheetBase = JournalEntryPageWindowSystemBridgeMixin(
  foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet,
  {
    definitionId: "relationship-graph-sheet",
    component: {
      type: "svelte",
      component: GraphSheetView
    },
    title: "Beziehungsgraph"
  },
  "fvtt_relationship_app_module"
);
const _RelationshipGraphSheet = class _RelationshipGraphSheet extends GraphSheetBase {
};
__name(_RelationshipGraphSheet, "RelationshipGraphSheet");
_RelationshipGraphSheet.DEFAULT_OPTIONS = {
  ...__superGet(_RelationshipGraphSheet, _RelationshipGraphSheet, "DEFAULT_OPTIONS"),
  id: "journal-entry-relationship-graph",
  classes: ["journal-entry-page", "relationship-graph"],
  width: 800,
  height: 600,
  resizable: true
};
_RelationshipGraphSheet.EDIT_PARTS = (() => {
  const baseSheet = foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet;
  const parts = (
    // @ts-expect-error TS2339 - EDIT_PARTS may not exist in base class type definition but exists at runtime
    baseSheet.EDIT_PARTS ?? {}
  );
  const { header, footer, ...rest } = parts;
  return {
    header,
    content: {
      template: "modules/fvtt_relationship_app_module/templates/journal/parts/graph-content-edit.hbs"
    },
    ...rest,
    footer
  };
})();
_RelationshipGraphSheet.VIEW_PARTS = (() => {
  const baseSheet = foundry.applications.sheets.journal.JournalEntryPageHandlebarsSheet;
  const parts = (
    // @ts-expect-error TS2339 - VIEW_PARTS may not exist in base class type definition but exists at runtime
    baseSheet.VIEW_PARTS ?? {}
  );
  return {
    ...parts,
    content: {
      template: "modules/fvtt_relationship_app_module/templates/journal/parts/graph-content-view.hbs"
    }
  };
})();
let RelationshipGraphSheet = _RelationshipGraphSheet;
const _JournalEntryPageSheetBootstrapper = class _JournalEntryPageSheetBootstrapper {
  /**
   * Registers all JournalEntryPage Sheets and DataModels.
   *
   * @returns Result indicating success (no errors expected, Foundry API handles errors internally)
   */
  static registerSheetsAndDataModels() {
    Object.assign(CONFIG.JournalEntryPage.dataModels, {
      [JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_NODE]: RelationshipNodeDataModel,
      [JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_GRAPH]: RelationshipGraphDataModel
    });
    const DOCUMENT_SHEET_CONFIG = foundry.applications.apps.DocumentSheetConfig;
    DOCUMENT_SHEET_CONFIG.registerSheet(
      JournalEntryPage,
      MODULE_METADATA.ID,
      RelationshipNodeSheet,
      {
        types: [JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_NODE],
        makeDefault: true,
        label: /* @__PURE__ */ __name(() => {
          return game?.i18n?.localize("TYPES.JournalEntryPage.relationship_app_node") || "Beziehungsknoten";
        }, "label")
      }
    );
    DOCUMENT_SHEET_CONFIG.registerSheet(
      JournalEntryPage,
      MODULE_METADATA.ID,
      RelationshipGraphSheet,
      {
        types: [JOURNAL_PAGE_SHEET_TYPE.RELATIONSHIP_GRAPH],
        makeDefault: true,
        label: /* @__PURE__ */ __name(() => {
          return game?.i18n?.localize("TYPES.JournalEntryPage.relationship_app_graph") || "Beziehungsgraph";
        }, "label")
      }
    );
    return ok(void 0);
  }
};
__name(_JournalEntryPageSheetBootstrapper, "JournalEntryPageSheetBootstrapper");
let JournalEntryPageSheetBootstrapper = _JournalEntryPageSheetBootstrapper;
const _JournalEntryPageSheetInitPhase = class _JournalEntryPageSheetInitPhase {
  constructor() {
    this.id = "journal-entry-page-sheet-registration";
    this.priority = 5;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  // Sheets can fail without breaking the module
  execute(_ctx) {
    return JournalEntryPageSheetBootstrapper.registerSheetsAndDataModels();
  }
};
__name(_JournalEntryPageSheetInitPhase, "JournalEntryPageSheetInitPhase");
let JournalEntryPageSheetInitPhase = _JournalEntryPageSheetInitPhase;
const _LoggingBootstrapper = class _LoggingBootstrapper {
  /**
   * Configures logger with current setting value.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger instance to configure
   * @returns Result indicating success (always succeeds, settings are optional)
   */
  static configureLogging(container2, logger) {
    const settingsResult = container2.resolveWithError(foundrySettingsToken);
    if (!settingsResult.ok) {
      return ok(void 0);
    }
    const settings = castResolvedService$1(settingsResult.value);
    const logLevelResult = settings.get(
      MODULE_METADATA.ID,
      SETTING_KEYS.LOG_LEVEL,
      LOG_LEVEL_SCHEMA
    );
    if (logLevelResult.ok && logger.setMinLevel) {
      logger.setMinLevel(logLevelResult.value);
      logger.debug(`Logger configured with level: ${LogLevel[logLevelResult.value]}`);
    }
    return ok(void 0);
  }
};
__name(_LoggingBootstrapper, "LoggingBootstrapper");
let LoggingBootstrapper = _LoggingBootstrapper;
const _LoggingInitPhase = class _LoggingInitPhase {
  constructor() {
    this.id = "logging-configuration";
    this.priority = 5;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return LoggingBootstrapper.configureLogging(ctx.container, ctx.logger);
  }
};
__name(_LoggingInitPhase, "LoggingInitPhase");
let LoggingInitPhase = _LoggingInitPhase;
const invalidateJournalCacheOnChangeUseCaseToken = createInjectionToken(
  "InvalidateJournalCacheOnChangeUseCase"
);
const processJournalDirectoryOnRenderUseCaseToken = createInjectionToken(
  "ProcessJournalDirectoryOnRenderUseCase"
);
const triggerJournalDirectoryReRenderUseCaseToken = createInjectionToken(
  "TriggerJournalDirectoryReRenderUseCase"
);
const registerContextMenuUseCaseToken = createInjectionToken(
  "RegisterContextMenuUseCase"
);
const showAllHiddenJournalsUseCaseToken = createInjectionToken(
  "ShowAllHiddenJournalsUseCase"
);
const sidebarButtonBootstrapperToken = createInjectionToken(
  "SidebarButtonBootstrapper"
);
const moduleEventRegistrarToken = createInjectionToken("ModuleEventRegistrar");
const windowFactoryToken = createInjectionToken("WindowFactory");
const windowRegistryToken = createInjectionToken("WindowRegistry");
const windowControllerToken = createInjectionToken("WindowController");
const eventBusToken = createInjectionToken("EventBus");
const stateStoreToken = createInjectionToken("StateStore");
const actionDispatcherToken = createInjectionToken("ActionDispatcher");
const rendererRegistryToken = createInjectionToken("RendererRegistry");
const bindingEngineToken = createInjectionToken("BindingEngine");
const viewModelBuilderToken = createInjectionToken("ViewModelBuilder");
const remoteSyncGateToken = createInjectionToken("RemoteSyncGate");
const persistAdapterToken = createInjectionToken("PersistAdapter");
const foundryWindowAdapterToken = createInjectionToken("FoundryWindowAdapter");
const statePortFactoryToken = createInjectionToken("StatePortFactory");
const sharedDocumentCacheToken = createInjectionToken("SharedDocumentCache");
const windowPositionManagerToken = createInjectionToken("WindowPositionManager");
const windowHooksBridgeToken = createInjectionToken("WindowHooksBridge");
const windowDefaultStateProviderRegistryToken = createInjectionToken("WindowDefaultStateProviderRegistry");
const windowStateInitializerToken = createInjectionToken("WindowStateInitializer");
const windowRendererCoordinatorToken = createInjectionToken(
  "WindowRendererCoordinator"
);
const windowPersistenceCoordinatorToken = createInjectionToken("WindowPersistenceCoordinator");
const windowHooksServiceToken = createInjectionToken("WindowHooksService");
const _EventsBootstrapper = class _EventsBootstrapper {
  /**
   * Registers all event listeners.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error
   */
  static registerEvents(container2) {
    const eventRegistrarResult = container2.resolveWithError(moduleEventRegistrarToken);
    if (!eventRegistrarResult.ok) {
      return err(`Failed to resolve ModuleEventRegistrar: ${eventRegistrarResult.error.message}`);
    }
    const eventRegistrar = castResolvedService$1(eventRegistrarResult.value);
    const eventRegistrationResult = eventRegistrar.registerAll();
    if (!eventRegistrationResult.ok) {
      const errorMessages = eventRegistrationResult.error.map((e) => e.message).join(", ");
      return err(`Failed to register one or more event listeners: ${errorMessages}`);
    }
    const windowHooksResult = container2.resolveWithError(windowHooksServiceToken);
    if (windowHooksResult.ok) {
      const windowHooksService = castResolvedService$1(windowHooksResult.value);
      windowHooksService.register();
    }
    return ok(void 0);
  }
};
__name(_EventsBootstrapper, "EventsBootstrapper");
let EventsBootstrapper = _EventsBootstrapper;
const _EventsInitPhase = class _EventsInitPhase {
  constructor() {
    this.id = "event-registration";
    this.priority = 6;
    this.criticality = InitPhaseCriticality.HALT_ON_ERROR;
  }
  execute(ctx) {
    return EventsBootstrapper.registerEvents(ctx.container);
  }
};
__name(_EventsInitPhase, "EventsInitPhase");
let EventsInitPhase = _EventsInitPhase;
const journalContextMenuLibWrapperServiceToken = createInjectionToken("JournalContextMenuLibWrapperService");
const _ContextMenuBootstrapper = class _ContextMenuBootstrapper {
  /**
   * Registers context menu libWrapper and callbacks.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static registerContextMenu(container2) {
    const contextMenuLibWrapperResult = container2.resolveWithError(
      journalContextMenuLibWrapperServiceToken
    );
    if (!contextMenuLibWrapperResult.ok) {
      return err(
        `JournalContextMenuLibWrapperService could not be resolved: ${contextMenuLibWrapperResult.error.message}`
      );
    }
    const contextMenuLibWrapper = castResolvedService$1(
      contextMenuLibWrapperResult.value
    );
    const registerResult = contextMenuLibWrapper.register();
    if (!registerResult.ok) {
      return err(`Context menu libWrapper registration failed: ${registerResult.error.message}`);
    }
    const contextMenuUseCaseResult = container2.resolveWithError(registerContextMenuUseCaseToken);
    if (!contextMenuUseCaseResult.ok) {
      return err(
        `RegisterContextMenuUseCase could not be resolved: ${contextMenuUseCaseResult.error.message}`
      );
    }
    const contextMenuUseCase = castResolvedService$1(
      contextMenuUseCaseResult.value
    );
    const callbackRegisterResult = contextMenuUseCase.register();
    if (!callbackRegisterResult.ok) {
      return err(
        `Context menu callback registration failed: ${callbackRegisterResult.error.message}`
      );
    }
    return ok(void 0);
  }
};
__name(_ContextMenuBootstrapper, "ContextMenuBootstrapper");
let ContextMenuBootstrapper = _ContextMenuBootstrapper;
const _ContextMenuInitPhase = class _ContextMenuInitPhase {
  constructor() {
    this.id = "context-menu-registration";
    this.priority = 7;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return ContextMenuBootstrapper.registerContextMenu(ctx.container);
  }
};
__name(_ContextMenuInitPhase, "ContextMenuInitPhase");
let ContextMenuInitPhase = _ContextMenuInitPhase;
function isBoolean(value2) {
  return typeof value2 === "boolean";
}
__name(isBoolean, "isBoolean");
function canUserSeeJournalDirectoryButtons(settings, user) {
  if (!user || user.role === void 0) {
    return false;
  }
  let settingKey;
  if (user.role === 1) {
    settingKey = SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_PLAYER;
  } else if (user.role === 2) {
    settingKey = SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_TRUSTED;
  } else if (user.role === 3) {
    settingKey = SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_ASSISTANT;
  } else if (user.role === 4) {
    settingKey = SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_GAMEMASTER;
  } else {
    return false;
  }
  const settingResult = settings.getSettingValue(MODULE_METADATA.ID, settingKey, isBoolean);
  if (!settingResult.ok) {
    return false;
  }
  return settingResult.value;
}
__name(canUserSeeJournalDirectoryButtons, "canUserSeeJournalDirectoryButtons");
const _SidebarButtonBootstrapper = class _SidebarButtonBootstrapper {
  /**
   * Registers sidebar button for journal tab.
   *
   * @param container - PlatformContainerPort for service resolution
   * @returns Result indicating success or error (errors are logged as warnings but don't fail bootstrap)
   */
  static registerSidebarButton(container2) {
    const useCaseResult = container2.resolveWithError(showAllHiddenJournalsUseCaseToken);
    if (!useCaseResult.ok) {
      return err(
        `ShowAllHiddenJournalsUseCase could not be resolved: ${useCaseResult.error.message}`
      );
    }
    const useCase = castResolvedService$1(useCaseResult.value);
    const hooksResult = container2.resolveWithError(foundryHooksToken);
    if (!hooksResult.ok) {
      return err(`FoundryHooksPort could not be resolved: ${hooksResult.error.message}`);
    }
    const hooks = castResolvedService$1(hooksResult.value);
    const hookRegistrationResult = hooks.on("renderJournalDirectory", (...args2) => {
      if (args2.length < 2) {
        return;
      }
      const htmlArg = args2[1];
      if (!(htmlArg instanceof HTMLElement)) {
        return;
      }
      const html2 = htmlArg;
      const settingsResult = container2.resolveWithError(platformSettingsRegistrationPortToken);
      if (!settingsResult.ok) {
        return;
      }
      const settings = castResolvedService$1(settingsResult.value);
      const user = typeof game !== "undefined" && game.user ? game.user : void 0;
      if (!canUserSeeJournalDirectoryButtons(settings, user)) {
        return;
      }
      const actionButtons = html2.querySelector(".header-actions.action-buttons");
      const directoryHeader = html2.querySelector(".directory-header");
      const existingButton = html2.querySelector(".show-all-hidden-journals-button");
      if (!existingButton) {
        const button = document.createElement("button");
        button.className = "show-all-hidden-journals-button";
        button.type = "button";
        button.title = "Alle versteckten Journale wieder einblenden";
        button.innerHTML = '<i class="fas fa-eye"></i> Alle Journale einblenden';
        button.addEventListener("click", async () => {
          const result = await useCase.execute();
          if (result.ok) {
          } else {
          }
        });
        if (actionButtons) {
          actionButtons.appendChild(button);
        } else if (directoryHeader) {
          directoryHeader.appendChild(button);
        } else {
          html2.insertBefore(button, html2.firstChild);
        }
      }
      const existingOverviewButton = html2.querySelector(".journal-overview-button");
      if (!existingOverviewButton) {
        const windowFactoryResult = container2.resolveWithError(windowFactoryToken);
        if (!windowFactoryResult.ok) {
          console.warn(
            "[Journal Overview] WindowFactory not available:",
            windowFactoryResult.error.message
          );
          return;
        }
        const windowFactory = castResolvedService$1(windowFactoryResult.value);
        const overviewButton = document.createElement("button");
        overviewButton.className = "journal-overview-button";
        overviewButton.type = "button";
        overviewButton.title = "Journal-Übersicht anzeigen";
        overviewButton.innerHTML = '<i class="fas fa-list"></i> Übersicht';
        overviewButton.addEventListener("click", async () => {
          const result = await windowFactory.createWindow("journal-overview");
          if (result.ok) {
            await result.value.show();
          } else {
            console.error("Failed to open journal overview window:", result.error);
          }
        });
        if (actionButtons) {
          actionButtons.appendChild(overviewButton);
        } else if (directoryHeader) {
          directoryHeader.appendChild(overviewButton);
        } else {
          html2.insertBefore(overviewButton, html2.firstChild);
        }
      }
    });
    if (!hookRegistrationResult.ok) {
      return err(`Failed to register sidebar button hook: ${hookRegistrationResult.error.message}`);
    }
    return ok(void 0);
  }
};
__name(_SidebarButtonBootstrapper, "SidebarButtonBootstrapper");
let SidebarButtonBootstrapper = _SidebarButtonBootstrapper;
const _SidebarButtonInitPhase = class _SidebarButtonInitPhase {
  constructor() {
    this.id = "sidebar-button-registration";
    this.priority = 8;
    this.criticality = InitPhaseCriticality.WARN_AND_CONTINUE;
  }
  execute(ctx) {
    return SidebarButtonBootstrapper.registerSidebarButton(ctx.container);
  }
};
__name(_SidebarButtonInitPhase, "SidebarButtonInitPhase");
let SidebarButtonInitPhase = _SidebarButtonInitPhase;
function createDefaultInitPhaseRegistry() {
  return new InitPhaseRegistry([
    new MetricsInitPhase(),
    new NotificationInitPhase(),
    new ApiInitPhase(),
    new SettingsInitPhase(),
    new JournalEntryPageSheetInitPhase(),
    new LoggingInitPhase(),
    new EventsInitPhase(),
    new ContextMenuInitPhase(),
    new SidebarButtonInitPhase()
  ]);
}
__name(createDefaultInitPhaseRegistry, "createDefaultInitPhaseRegistry");
const _InitPhaseErrorHandler = class _InitPhaseErrorHandler {
  /**
   * Handles an error from a phase execution.
   *
   * @param phase - The phase that failed
   * @param error - The error message from the phase
   * @param errors - Array to collect critical errors (mutated if phase is critical)
   * @param logger - Logger for error reporting
   */
  handlePhaseError(phase, error3, errors, logger) {
    if (phase.criticality === InitPhaseCriticality.HALT_ON_ERROR) {
      errors.push({
        phase: phase.id,
        message: error3
      });
      logger.error(`Failed to execute phase '${phase.id}': ${error3}`);
    } else {
      logger.warn(`Phase '${phase.id}' failed: ${error3}`);
    }
  }
};
__name(_InitPhaseErrorHandler, "InitPhaseErrorHandler");
let InitPhaseErrorHandler = _InitPhaseErrorHandler;
const _InitOrchestrator = class _InitOrchestrator {
  /**
   * Creates a new InitOrchestrator instance.
   *
   * @param registry - Registry providing init phases (defaults to standard phases)
   */
  constructor(registry) {
    this.registry = registry ?? createDefaultInitPhaseRegistry();
  }
  /**
   * Executes the complete initialization sequence.
   *
   * Phases are executed in priority order (ascending). Error handling
   * follows each phase's criticality setting:
   * - HALT_ON_ERROR: Errors are collected and returned, stopping bootstrap
   * - WARN_AND_CONTINUE: Errors are logged as warnings but don't stop bootstrap
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger for error reporting
   * @returns Result indicating success or aggregated errors
   */
  execute(container2, logger) {
    const errors = [];
    const phases = this.registry.getAll();
    const ctx = { container: container2, logger };
    const errorHandler = new InitPhaseErrorHandler();
    for (const phase of phases) {
      const result = phase.execute(ctx);
      if (!result.ok) {
        errorHandler.handlePhaseError(phase, result.error, errors, logger);
      }
    }
    if (errors.length > 0) {
      return err(errors);
    }
    return ok(void 0);
  }
  /**
   * Static convenience method for backward compatibility.
   *
   * Creates a new orchestrator with default registry and executes.
   *
   * @param container - PlatformContainerPort for service resolution
   * @param logger - Logger for error reporting
   * @returns Result indicating success or aggregated errors
   */
  static execute(container2, logger) {
    const orchestrator = new _InitOrchestrator();
    return orchestrator.execute(container2, logger);
  }
};
__name(_InitOrchestrator, "InitOrchestrator");
let InitOrchestrator = _InitOrchestrator;
const _BootstrapInitHookService = class _BootstrapInitHookService {
  constructor(logger, container2, bootstrapEvents) {
    this.logger = logger;
    this.container = container2;
    this.bootstrapEvents = bootstrapEvents;
  }
  /**
   * Registers the init event via PlatformBootstrapEventPort.
   * Must be called before the platform's init hook fires.
   */
  register() {
    const result = this.bootstrapEvents.onInit(() => this.handleInit());
    if (!result.ok) {
      this.logger.warn(
        `Init hook registration failed: ${result.error.message}`,
        result.error.details
      );
    }
  }
  /* v8 ignore start -- @preserve */
  /* Foundry-Hooks und UI-spezifische Pfade hängen stark von der Laufzeitumgebung ab
   * und werden primär über Integrations-/E2E-Tests abgesichert. Für das aktuelle Quality-Gateway
   * blenden wir diese verzweigten Pfade temporär aus und reduzieren die Ignores später gezielt. */
  handleInit() {
    this.logger.info("init-phase");
    const result = InitOrchestrator.execute(this.container, this.logger);
    if (!result.ok) {
      const errorMessages = result.error.map((e) => `${e.phase}: ${e.message}`).join("; ");
      this.logger.error(`Init phase completed with errors: ${errorMessages}`);
    } else {
      this.logger.info("init-phase completed");
    }
  }
  /* v8 ignore stop -- @preserve */
};
__name(_BootstrapInitHookService, "BootstrapInitHookService");
let BootstrapInitHookService = _BootstrapInitHookService;
const _DIBootstrapInitHookService = class _DIBootstrapInitHookService extends BootstrapInitHookService {
  constructor(logger, container2, bootstrapEvents) {
    super(logger, container2, bootstrapEvents);
  }
};
__name(_DIBootstrapInitHookService, "DIBootstrapInitHookService");
_DIBootstrapInitHookService.dependencies = [
  loggerToken,
  platformContainerPortToken,
  platformBootstrapEventPortToken
];
let DIBootstrapInitHookService = _DIBootstrapInitHookService;
const _ModuleReadyService = class _ModuleReadyService {
  constructor(moduleReadyPort, loggingPort) {
    this.moduleReadyPort = moduleReadyPort;
    this.loggingPort = loggingPort;
  }
  /**
   * Sets module.ready to true (ready state).
   * Should be called when bootstrap-ready-hook completes.
   */
  setReady() {
    const result = this.moduleReadyPort.setReady();
    if (!result.ok) {
      this.loggingPort.warn(
        `Failed to set module.ready: ${result.error.message}`,
        result.error.details
      );
    } else {
      this.loggingPort.info("module.ready set to true");
    }
  }
};
__name(_ModuleReadyService, "ModuleReadyService");
let ModuleReadyService = _ModuleReadyService;
const _DIModuleReadyService = class _DIModuleReadyService extends ModuleReadyService {
  constructor(moduleReadyPort, loggingPort) {
    super(moduleReadyPort, loggingPort);
  }
};
__name(_DIModuleReadyService, "DIModuleReadyService");
_DIModuleReadyService.dependencies = [platformModuleReadyPortToken, platformLoggingPortToken];
let DIModuleReadyService = _DIModuleReadyService;
const moduleReadyServiceToken = createInjectionToken("ModuleReadyService");
const _BootstrapReadyHookService = class _BootstrapReadyHookService {
  constructor(logger, bootstrapEvents, moduleReadyService) {
    this.logger = logger;
    this.bootstrapEvents = bootstrapEvents;
    this.moduleReadyService = moduleReadyService;
  }
  /**
   * Registers the ready event via PlatformBootstrapEventPort.
   * Must be called before the platform's ready hook fires.
   */
  register() {
    const result = this.bootstrapEvents.onReady(() => this.handleReady());
    if (!result.ok) {
      this.logger.warn(
        `Ready hook registration failed: ${result.error.message}`,
        result.error.details
      );
    }
  }
  /* v8 ignore start -- @preserve */
  /* Foundry-Hooks und UI-spezifische Pfade hängen stark von der Laufzeitumgebung ab
   * und werden primär über Integrations-/E2E-Tests abgesichert. Für das aktuelle Quality-Gateway
   * blenden wir diese verzweigten Pfade temporär aus und reduzieren die Ignores später gezielt. */
  handleReady() {
    this.logger.info("ready-phase");
    this.moduleReadyService.setReady();
    this.logger.info("ready-phase completed");
  }
  /* v8 ignore stop -- @preserve */
};
__name(_BootstrapReadyHookService, "BootstrapReadyHookService");
let BootstrapReadyHookService = _BootstrapReadyHookService;
const _DIBootstrapReadyHookService = class _DIBootstrapReadyHookService extends BootstrapReadyHookService {
  constructor(logger, bootstrapEvents, moduleReadyService) {
    super(logger, bootstrapEvents, moduleReadyService);
  }
};
__name(_DIBootstrapReadyHookService, "DIBootstrapReadyHookService");
_DIBootstrapReadyHookService.dependencies = [
  loggerToken,
  platformBootstrapEventPortToken,
  moduleReadyServiceToken
];
let DIBootstrapReadyHookService = _DIBootstrapReadyHookService;
const _FoundryBootstrapEventAdapter = class _FoundryBootstrapEventAdapter {
  onInit(callback) {
    if (typeof Hooks === "undefined") {
      return err({
        code: "PLATFORM_NOT_AVAILABLE",
        message: "Foundry Hooks API not available"
      });
    }
    try {
      Hooks.on("init", callback);
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register init event: ${error3 instanceof Error ? error3.message : String(error3)}`,
        details: error3
      });
    }
  }
  onReady(callback) {
    if (typeof Hooks === "undefined") {
      return err({
        code: "PLATFORM_NOT_AVAILABLE",
        message: "Foundry Hooks API not available"
      });
    }
    try {
      Hooks.on("ready", callback);
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register ready event: ${error3 instanceof Error ? error3.message : String(error3)}`,
        details: error3
      });
    }
  }
};
__name(_FoundryBootstrapEventAdapter, "FoundryBootstrapEventAdapter");
let FoundryBootstrapEventAdapter = _FoundryBootstrapEventAdapter;
const _DIFoundryBootstrapEventAdapter = class _DIFoundryBootstrapEventAdapter extends FoundryBootstrapEventAdapter {
};
__name(_DIFoundryBootstrapEventAdapter, "DIFoundryBootstrapEventAdapter");
_DIFoundryBootstrapEventAdapter.dependencies = [];
let DIFoundryBootstrapEventAdapter = _DIFoundryBootstrapEventAdapter;
const retryServiceToken = createInjectionToken("RetryService");
const _PortLoader = class _PortLoader {
  constructor(portSelector, portRegistry) {
    this.port = null;
    this.portSelector = portSelector;
    this.portRegistry = portRegistry;
  }
  /**
   * Lazy-loads the appropriate port based on Foundry version.
   * Uses PortSelector with token-based selection to resolve ports from the DI container.
   *
   * CRITICAL: This prevents crashes when newer port constructors access
   * APIs not available in the current Foundry version. Ports are resolved
   * from the DI container, ensuring DIP (Dependency Inversion Principle) compliance.
   *
   * @param adapterName - Name for logging purposes (e.g., "FoundryGame")
   * @returns Result containing the port or a FoundryError if no compatible port can be selected
   */
  loadPort(adapterName) {
    if (this.port === null) {
      const tokens2 = this.portRegistry.getTokens();
      const portResult = this.portSelector.selectPortFromTokens(tokens2, void 0, adapterName);
      if (!portResult.ok) {
        return portResult;
      }
      this.port = portResult.value;
    }
    return { ok: true, value: this.port };
  }
  /**
   * Gets the currently loaded port without triggering lazy loading.
   * Useful for operations that don't need retry logic but need to check if port is loaded.
   *
   * @returns The loaded port or null if not yet loaded
   */
  getLoadedPort() {
    return this.port;
  }
  /**
   * Clears the cached port.
   * This forces the next loadPort() call to reload the port.
   * Useful for testing or when ports need to be refreshed.
   */
  clearCache() {
    this.port = null;
  }
};
__name(_PortLoader, "PortLoader");
let PortLoader = _PortLoader;
const _RetryableOperation = class _RetryableOperation {
  constructor(retryService) {
    this.retryService = retryService;
  }
  /**
   * Executes a Foundry API operation with automatic retry on transient failures.
   *
   * Use this for any port method call to handle:
   * - Race conditions (Foundry not fully initialized)
   * - Timing issues (DOM/Settings not ready)
   * - Transient port selection failures
   *
   * @template T - The success type
   * @param fn - Function to execute (should call port methods)
   * @param operationName - Operation name for logging (e.g., "FoundryGame.getJournalEntries")
   * @param maxAttempts - Max retry attempts (default: 2 = 1 retry)
   * @returns Result from operation or mapped error
   *
   * @example
   * ```typescript
   * const result = retryable.execute(
   *   () => {
   *     const portResult = portLoader.loadPort("FoundryGame");
   *     if (!portResult.ok) return portResult;
   *     return portResult.value.getJournalEntries();
   *   },
   *   "FoundryGame.getJournalEntries"
   * );
   * ```
   */
  execute(fn3, operationName, maxAttempts = 2) {
    return this.retryService.retrySync(fn3, {
      maxAttempts,
      operationName,
      mapException: /* @__PURE__ */ __name((error3, _attempt) => ({
        code: "OPERATION_FAILED",
        message: `${operationName} failed: ${String(error3)}`,
        cause: error3 instanceof Error ? error3 : void 0
      }), "mapException")
    });
  }
  /**
   * Async variant of execute for async operations.
   *
   * @template T - The success type
   * @param fn - Async function to execute
   * @param operationName - Operation name for logging
   * @param maxAttempts - Max retry attempts (default: 2)
   * @returns Promise resolving to Result
   *
   * @example
   * ```typescript
   * const result = await retryable.executeAsync(
   *   async () => {
   *     const portResult = portLoader.loadPort("FoundryDocument");
   *     if (!portResult.ok) return portResult;
   *     return await portResult.value.setFlag(doc, scope, key, value);
   *   },
   *   "FoundryDocument.setFlag"
   * );
   * ```
   */
  async executeAsync(fn3, operationName, maxAttempts = 2) {
    return this.retryService.retry(fn3, {
      maxAttempts,
      delayMs: 100,
      // 100ms delay between retries
      operationName,
      mapException: /* @__PURE__ */ __name((error3, _attempt) => ({
        code: "OPERATION_FAILED",
        message: `${operationName} failed: ${String(error3)}`,
        cause: error3 instanceof Error ? error3 : void 0
      }), "mapException")
    });
  }
};
__name(_RetryableOperation, "RetryableOperation");
let RetryableOperation = _RetryableOperation;
const _FoundryModuleReadyPort = class _FoundryModuleReadyPort {
  constructor(portSelector, portRegistry, retryService, moduleId) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
    this.moduleId = moduleId;
  }
  setReady() {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryModule");
      if (!portResult.ok) {
        return {
          ok: false,
          error: createFoundryError(
            "PORT_SELECTION_FAILED",
            portResult.error.message,
            portResult.error.details
          )
        };
      }
      const success = portResult.value.setModuleReady(this.moduleId);
      if (!success) {
        return {
          ok: false,
          error: createFoundryError("OPERATION_FAILED", `Module ${this.moduleId} not found`)
        };
      }
      return { ok: true, value: void 0 };
    }, "FoundryModule.setReady");
    if (!result.ok) {
      let errorCode;
      if (result.error.code === "PORT_SELECTION_FAILED" || result.error.code === "API_NOT_AVAILABLE") {
        errorCode = "PLATFORM_NOT_AVAILABLE";
      } else if (result.error.code === "OPERATION_FAILED") {
        errorCode = "OPERATION_FAILED";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return {
        ok: false,
        error: {
          code: errorCode,
          message: result.error.message,
          details: result.error.details
        }
      };
    }
    return { ok: true, value: void 0 };
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryModuleReadyPort, "FoundryModuleReadyPort");
let FoundryModuleReadyPort = _FoundryModuleReadyPort;
const _DIFoundryModuleReadyPort = class _DIFoundryModuleReadyPort extends FoundryModuleReadyPort {
  constructor(portSelector, portRegistry, retryService, moduleId) {
    super(portSelector, portRegistry, retryService, moduleId);
  }
};
__name(_DIFoundryModuleReadyPort, "DIFoundryModuleReadyPort");
_DIFoundryModuleReadyPort.dependencies = [
  portSelectorToken,
  foundryModulePortRegistryToken,
  retryServiceToken,
  moduleIdToken
];
let DIFoundryModuleReadyPort = _DIFoundryModuleReadyPort;
function registerCoreServices(container2) {
  const runtimeConfig = container2.getRegisteredValue(runtimeConfigToken);
  if (!runtimeConfig) {
    return err("RuntimeConfigService not registered");
  }
  const enablePersistence = runtimeConfig.get("enableMetricsPersistence") === true;
  const aggregatorResult = container2.registerClass(
    metricsAggregatorToken,
    MetricsAggregator,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(aggregatorResult)) {
    return err(`Failed to register MetricsAggregator: ${aggregatorResult.error.message}`);
  }
  const persistenceManagerResult = container2.registerClass(
    metricsPersistenceManagerToken,
    MetricsPersistenceManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(persistenceManagerResult)) {
    return err(
      `Failed to register MetricsPersistenceManager: ${persistenceManagerResult.error.message}`
    );
  }
  const stateManagerResult = container2.registerClass(
    metricsStateManagerToken,
    MetricsStateManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(stateManagerResult)) {
    return err(`Failed to register MetricsStateManager: ${stateManagerResult.error.message}`);
  }
  if (enablePersistence) {
    const metricsKey = runtimeConfig.get("metricsPersistenceKey") ?? "fvtt_relationship_app_module.metrics";
    const storageInstance = createMetricsStorage(metricsKey);
    const storageResult = container2.registerValue(metricsStorageToken, storageInstance);
    if (isErr(storageResult)) {
      return err(`Failed to register MetricsStorage: ${storageResult.error.message}`);
    }
    const persistentResult = container2.registerClass(
      metricsCollectorToken,
      DIPersistentMetricsCollector,
      ServiceLifecycle.SINGLETON
    );
    if (isErr(persistentResult)) {
      return err(
        `Failed to register PersistentMetricsCollector: ${persistentResult.error.message}`
      );
    }
  } else {
    const metricsResult = container2.registerClass(
      metricsCollectorToken,
      DIMetricsCollector,
      ServiceLifecycle.SINGLETON
    );
    if (isErr(metricsResult)) {
      return err(`Failed to register MetricsCollector: ${metricsResult.error.message}`);
    }
  }
  const samplerResult = container2.registerClass(
    metricsSamplerToken,
    DIMetricsSampler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(samplerResult)) {
    return err(`Failed to register MetricsSampler: ${samplerResult.error.message}`);
  }
  container2.registerAlias(metricsRecorderToken, metricsCollectorToken);
  const traceContextResult = container2.registerClass(
    traceContextToken,
    DITraceContext,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(traceContextResult)) {
    return err(`Failed to register TraceContext: ${traceContextResult.error.message}`);
  }
  const loggerResult = container2.registerClass(
    loggerToken,
    DIConsoleLoggerService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(loggerResult)) {
    return err(`Failed to register Logger: ${loggerResult.error.message}`);
  }
  const reporterResult = container2.registerClass(
    metricsReporterToken,
    DIMetricsReporter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(reporterResult)) {
    return err(`Failed to register MetricsReporter: ${reporterResult.error.message}`);
  }
  const registryResult = container2.registerClass(
    healthCheckRegistryToken,
    HealthCheckRegistryAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(registryResult)) {
    return err(`Failed to register HealthCheckRegistry: ${registryResult.error.message}`);
  }
  const healthResult = container2.registerClass(
    moduleHealthServiceToken,
    DIModuleHealthService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(healthResult)) {
    return err(`Failed to register ModuleHealthService: ${healthResult.error.message}`);
  }
  const apiInitResult = container2.registerClass(
    moduleApiInitializerToken,
    DIModuleApiInitializer,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(apiInitResult)) {
    return err(`Failed to register ModuleApiInitializer: ${apiInitResult.error.message}`);
  }
  const bootstrapEventsResult = container2.registerClass(
    platformBootstrapEventPortToken,
    DIFoundryBootstrapEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(bootstrapEventsResult)) {
    return err(
      `Failed to register PlatformBootstrapEventPort: ${bootstrapEventsResult.error.message}`
    );
  }
  const initHookResult = container2.registerClass(
    bootstrapInitHookServiceToken,
    DIBootstrapInitHookService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(initHookResult)) {
    return err(`Failed to register BootstrapInitHookService: ${initHookResult.error.message}`);
  }
  const moduleReadyPortResult = container2.registerClass(
    platformModuleReadyPortToken,
    DIFoundryModuleReadyPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(moduleReadyPortResult)) {
    return err(
      `Failed to register PlatformModuleReadyPort: ${moduleReadyPortResult.error.message}`
    );
  }
  const moduleReadyResult = container2.registerClass(
    moduleReadyServiceToken,
    DIModuleReadyService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(moduleReadyResult)) {
    return err(`Failed to register ModuleReadyService: ${moduleReadyResult.error.message}`);
  }
  const readyHookResult = container2.registerClass(
    bootstrapReadyHookServiceToken,
    DIBootstrapReadyHookService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(readyHookResult)) {
    return err(`Failed to register BootstrapReadyHookService: ${readyHookResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerCoreServices, "registerCoreServices");
registerDependencyStep({
  name: "CoreServices",
  priority: 20,
  execute: registerCoreServices
});
const observabilityRegistryToken = createInjectionToken("ObservabilityRegistry");
const _PortSelectionEventEmitter = class _PortSelectionEventEmitter {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Set();
  }
  subscribe(callback) {
    this.subscribers.add(callback);
    let active = true;
    return () => {
      if (!active) {
        return;
      }
      active = false;
      this.subscribers.delete(callback);
    };
  }
  emit(event3) {
    for (const callback of this.subscribers) {
      try {
        callback(event3);
      } catch (error3) {
        console.error("PortSelectionEventEmitter subscriber error", error3);
      }
    }
  }
  clear() {
    this.subscribers.clear();
  }
  getSubscriberCount() {
    return this.subscribers.size;
  }
};
__name(_PortSelectionEventEmitter, "PortSelectionEventEmitter");
let PortSelectionEventEmitter = _PortSelectionEventEmitter;
const _DIPortSelectionEventEmitter = class _DIPortSelectionEventEmitter extends PortSelectionEventEmitter {
};
__name(_DIPortSelectionEventEmitter, "DIPortSelectionEventEmitter");
_DIPortSelectionEventEmitter.dependencies = [];
let DIPortSelectionEventEmitter = _DIPortSelectionEventEmitter;
const _ObservabilityRegistry = class _ObservabilityRegistry {
  constructor(logger, metrics) {
    this.logger = logger;
    this.metrics = metrics;
    this.subscriptions = [];
  }
  /**
   * Register a PortSelector for observability.
   * Wires event emission to logging and metrics.
   *
   * @param service - Observable service that emits PortSelectionEvents
   */
  registerPortSelector(service) {
    const unsubscribe = service.onEvent((event3) => {
      if (event3.type === "success") {
        const adapterSuffix = event3.adapterName ? ` for ${event3.adapterName}` : "";
        this.logger.debug(
          `Port v${event3.selectedVersion} selected in ${event3.durationMs.toFixed(2)}ms${adapterSuffix}`
        );
        this.metrics.recordPortSelection(event3.selectedVersion);
      } else {
        this.logger.error("Port selection failed", {
          foundryVersion: event3.foundryVersion,
          availableVersions: event3.availableVersions,
          adapterName: event3.adapterName
        });
        this.metrics.recordPortSelectionFailure(event3.foundryVersion);
      }
    });
    this.subscriptions.push(unsubscribe);
  }
  /**
   * Disposes all registered observers and clears internal state.
   * Intended to be called when the DI container is disposed.
   */
  dispose() {
    while (this.subscriptions.length > 0) {
      const unsubscribe = this.subscriptions.pop();
      try {
        unsubscribe?.();
      } catch {
      }
    }
  }
  // Future: Add more registration methods for other observable services
  // registerSomeOtherService(service: ObservableService<OtherEvent>): void { ... }
};
__name(_ObservabilityRegistry, "ObservabilityRegistry");
let ObservabilityRegistry = _ObservabilityRegistry;
const _DIObservabilityRegistry = class _DIObservabilityRegistry extends ObservabilityRegistry {
  constructor(logger, metrics) {
    super(logger, metrics);
  }
};
__name(_DIObservabilityRegistry, "DIObservabilityRegistry");
_DIObservabilityRegistry.dependencies = [loggerToken, metricsRecorderToken];
let DIObservabilityRegistry = _DIObservabilityRegistry;
const _PortSelectionObservability = class _PortSelectionObservability {
  constructor(observabilityRegistry) {
    this.observabilityRegistry = observabilityRegistry;
  }
  /**
   * Register PortSelector with ObservabilityRegistry.
   * This enables automatic logging and metrics collection.
   */
  registerWithObservabilityRegistry(selector) {
    this.observabilityRegistry.registerPortSelector(selector);
  }
  /**
   * Setup observability for PortSelector.
   * Wires PortSelector events to PortSelectionObserver.
   */
  setupObservability(selector, observer) {
    selector.onEvent((event3) => {
      observer.handleEvent(event3);
    });
  }
};
__name(_PortSelectionObservability, "PortSelectionObservability");
let PortSelectionObservability = _PortSelectionObservability;
const _DIPortSelectionObservability = class _DIPortSelectionObservability extends PortSelectionObservability {
  constructor(observabilityRegistry) {
    super(observabilityRegistry);
  }
};
__name(_DIPortSelectionObservability, "DIPortSelectionObservability");
_DIPortSelectionObservability.dependencies = [observabilityRegistryToken];
let DIPortSelectionObservability = _DIPortSelectionObservability;
const _PortSelectionPerformanceTracker = class _PortSelectionPerformanceTracker {
  /**
   * Start performance tracking.
   * Records the current high-resolution timestamp.
   */
  startTracking() {
    this.startTime = performance.now();
  }
  /**
   * End performance tracking and return duration in milliseconds.
   * @returns Duration in milliseconds, or 0 if tracking was not started
   */
  endTracking() {
    if (this.startTime === void 0) {
      return 0;
    }
    const durationMs = performance.now() - this.startTime;
    this.startTime = void 0;
    return durationMs;
  }
};
__name(_PortSelectionPerformanceTracker, "PortSelectionPerformanceTracker");
let PortSelectionPerformanceTracker = _PortSelectionPerformanceTracker;
const _DIPortSelectionPerformanceTracker = class _DIPortSelectionPerformanceTracker extends PortSelectionPerformanceTracker {
  constructor() {
    super();
  }
};
__name(_DIPortSelectionPerformanceTracker, "DIPortSelectionPerformanceTracker");
_DIPortSelectionPerformanceTracker.dependencies = [];
let DIPortSelectionPerformanceTracker = _DIPortSelectionPerformanceTracker;
const _PortSelectionObserver = class _PortSelectionObserver {
  constructor(logger, metrics, eventEmitter) {
    this.logger = logger;
    this.metrics = metrics;
    this.eventEmitter = eventEmitter;
  }
  /**
   * Handle a port selection event.
   *
   * Performs appropriate logging, metrics recording, and event emission.
   *
   * @param event - The port selection event to handle
   */
  handleEvent(event3) {
    this.eventEmitter.emit(event3);
    if (event3.type === "success") {
      this.handleSuccess(event3);
    } else {
      this.handleFailure(event3);
    }
  }
  /**
   * Handle successful port selection.
   *
   * Logs debug message and records metrics.
   */
  handleSuccess(event3) {
    this.logger.debug(
      `Port selection completed in ${event3.durationMs.toFixed(2)}ms (selected: v${event3.selectedVersion}${event3.adapterName ? ` for ${event3.adapterName}` : ""})`
    );
    this.metrics.recordPortSelection(event3.selectedVersion);
  }
  /**
   * Handle failed port selection.
   *
   * Logs error and records failure metrics.
   */
  handleFailure(event3) {
    this.logger.error("No compatible port found", {
      foundryVersion: event3.foundryVersion,
      availableVersions: event3.availableVersions,
      adapterName: event3.adapterName
    });
    this.metrics.recordPortSelectionFailure(event3.foundryVersion);
  }
};
__name(_PortSelectionObserver, "PortSelectionObserver");
let PortSelectionObserver = _PortSelectionObserver;
const _DIPortSelectionObserver = class _DIPortSelectionObserver extends PortSelectionObserver {
  constructor(logger, metrics, eventEmitter) {
    super(logger, metrics, eventEmitter);
  }
};
__name(_DIPortSelectionObserver, "DIPortSelectionObserver");
_DIPortSelectionObserver.dependencies = [
  loggerToken,
  metricsRecorderToken,
  portSelectionEventEmitterToken
];
let DIPortSelectionObserver = _DIPortSelectionObserver;
function registerObservability(container2) {
  const emitterResult = container2.registerClass(
    portSelectionEventEmitterToken,
    DIPortSelectionEventEmitter,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(emitterResult)) {
    return err(`Failed to register PortSelectionEventEmitter: ${emitterResult.error.message}`);
  }
  const registryResult = container2.registerClass(
    observabilityRegistryToken,
    DIObservabilityRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(registryResult)) {
    return err(`Failed to register ObservabilityRegistry: ${registryResult.error.message}`);
  }
  const observabilityResult = container2.registerClass(
    portSelectionObservabilityToken,
    DIPortSelectionObservability,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(observabilityResult)) {
    return err(
      `Failed to register PortSelectionObservability: ${observabilityResult.error.message}`
    );
  }
  const performanceTrackerResult = container2.registerClass(
    portSelectionPerformanceTrackerToken,
    DIPortSelectionPerformanceTracker,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(performanceTrackerResult)) {
    return err(
      `Failed to register PortSelectionPerformanceTracker: ${performanceTrackerResult.error.message}`
    );
  }
  const observerResult = container2.registerClass(
    portSelectionObserverToken,
    DIPortSelectionObserver,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(observerResult)) {
    return err(`Failed to register PortSelectionObserver: ${observerResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerObservability, "registerObservability");
registerDependencyStep({
  name: "Observability",
  priority: 30,
  execute: registerObservability
});
const _FoundryGamePort = class _FoundryGamePort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  getJournalEntries() {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryGame");
      if (!portResult.ok) return portResult;
      return portResult.value.getJournalEntries();
    }, "FoundryGame.getJournalEntries");
  }
  getJournalEntryById(id2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryGame");
      if (!portResult.ok) return portResult;
      return portResult.value.getJournalEntryById(id2);
    }, "FoundryGame.getJournalEntryById");
  }
  invalidateCache() {
    const portResult = this.portLoader.loadPort("FoundryGame");
    if (portResult.ok) {
      portResult.value.invalidateCache();
    }
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryGamePort, "FoundryGamePort");
let FoundryGamePort = _FoundryGamePort;
const _DIFoundryGamePort = class _DIFoundryGamePort extends FoundryGamePort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryGamePort, "DIFoundryGamePort");
_DIFoundryGamePort.dependencies = [
  portSelectorToken,
  foundryGamePortRegistryToken,
  retryServiceToken
];
let DIFoundryGamePort = _DIFoundryGamePort;
const _FoundryHooksPort = class _FoundryHooksPort {
  constructor(portSelector, portRegistry, retryService, logger) {
    this.registeredHooks = /* @__PURE__ */ new Map();
    this.callbackToIdMap = /* @__PURE__ */ new Map();
    this.idToHookNameMap = /* @__PURE__ */ new Map();
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
    this.logger = logger;
  }
  on(hookName, callback) {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.on(hookName, callback);
    }, "FoundryHooks.on");
    if (result.ok) {
      let hookMap = this.registeredHooks.get(hookName);
      if (!hookMap) {
        hookMap = /* @__PURE__ */ new Map();
        this.registeredHooks.set(hookName, hookMap);
      }
      hookMap.set(result.value, callback);
      const existing = this.callbackToIdMap.get(callback) || [];
      existing.push({ hookName, id: result.value });
      this.callbackToIdMap.set(callback, existing);
      this.idToHookNameMap.set(result.value, hookName);
    }
    return result;
  }
  once(hookName, callback) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.once(hookName, callback);
    }, "FoundryHooks.once");
  }
  off(hookName, callbackOrId) {
    const result = this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryHooks");
      if (!portResult.ok) return portResult;
      return portResult.value.off(hookName, callbackOrId);
    }, "FoundryHooks.off");
    if (result.ok) {
      if (typeof callbackOrId === "number") {
        const hooks = this.registeredHooks.get(hookName);
        if (hooks) {
          const callback = hooks.get(callbackOrId);
          hooks.delete(callbackOrId);
          if (callback) {
            const hookInfos = this.callbackToIdMap.get(callback);
            if (hookInfos) {
              const filtered = hookInfos.filter(
                (info) => !(info.hookName === hookName && info.id === callbackOrId)
              );
              if (filtered.length === 0) {
                this.callbackToIdMap.delete(callback);
              } else {
                this.callbackToIdMap.set(callback, filtered);
              }
            }
          }
          this.idToHookNameMap.delete(callbackOrId);
        }
      } else {
        const hookInfos = this.callbackToIdMap.get(callbackOrId);
        if (hookInfos) {
          const matchingInfos = hookInfos.filter((info) => info.hookName === hookName);
          const hooks = this.registeredHooks.get(hookName);
          if (hooks) {
            for (const info of matchingInfos) {
              hooks.delete(info.id);
            }
          }
          const filtered = hookInfos.filter((info) => info.hookName !== hookName);
          if (filtered.length === 0) {
            this.callbackToIdMap.delete(callbackOrId);
          } else {
            this.callbackToIdMap.set(callbackOrId, filtered);
          }
        }
      }
    }
    return result;
  }
  /**
   * Cleans up all registered hooks.
   * Called automatically when the container is disposed.
   */
  dispose() {
    for (const [callback, hookInfos] of this.callbackToIdMap) {
      for (const info of hookInfos) {
        try {
          if (typeof Hooks !== "undefined") {
            Hooks.off(info.hookName, callback);
          }
        } catch (error3) {
          this.logger.warn("Failed to unregister hook", {
            hookName: info.hookName,
            hookId: info.id,
            error: error3
          });
        }
      }
    }
    this.registeredHooks.clear();
    this.callbackToIdMap.clear();
    this.idToHookNameMap.clear();
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
  // ===== PlatformEventPort Implementation =====
  /**
   * Register a listener for platform events.
   * Delegates to FoundryHooks.on() for Foundry-specific implementation.
   * Wraps the PlatformEventPort callback to receive Foundry hook arguments as an array.
   */
  registerListener(eventType, callback) {
    const foundryCallback = /* @__PURE__ */ __name((...args2) => {
      callback(args2);
    }, "foundryCallback");
    const result = this.on(eventType, foundryCallback);
    if (!result.ok) {
      return err({
        code: "EVENT_REGISTRATION_FAILED",
        message: `Failed to register listener for event "${eventType}": ${result.error.message}`,
        details: result.error
      });
    }
    return ok(result.value);
  }
  /**
   * Unregister a previously registered listener.
   * Requires mapping from registration ID to hook name.
   */
  unregisterListener(registrationId) {
    const id2 = typeof registrationId === "string" ? Number.parseInt(registrationId, 10) : registrationId;
    if (Number.isNaN(id2)) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `Invalid registration ID: ${String(registrationId)}`
      });
    }
    const hookName = this.idToHookNameMap.get(id2);
    if (!hookName) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `No registration found for ID ${id2}`
      });
    }
    const result = this.off(hookName, id2);
    if (!result.ok) {
      return err({
        code: "EVENT_UNREGISTRATION_FAILED",
        message: `Failed to unregister listener for event "${hookName}": ${result.error.message}`,
        details: result.error
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryHooksPort, "FoundryHooksPort");
let FoundryHooksPort = _FoundryHooksPort;
const _DIFoundryHooksPort = class _DIFoundryHooksPort extends FoundryHooksPort {
  constructor(portSelector, portRegistry, retryService, logger) {
    super(portSelector, portRegistry, retryService, logger);
  }
};
__name(_DIFoundryHooksPort, "DIFoundryHooksPort");
_DIFoundryHooksPort.dependencies = [
  portSelectorToken,
  foundryHooksPortRegistryToken,
  retryServiceToken,
  loggerToken
];
let DIFoundryHooksPort = _DIFoundryHooksPort;
const _FoundryDocumentPort = class _FoundryDocumentPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  async create(documentClass, data4) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.create(documentClass, data4);
    }, "FoundryDocument.create");
  }
  async update(document2, changes, options2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.update(document2, changes, options2);
    }, "FoundryDocument.update");
  }
  async delete(document2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.delete(document2);
    }, "FoundryDocument.delete");
  }
  getFlag(document2, scope, key2, schema) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return portResult.value.getFlag(document2, scope, key2, schema);
    }, "FoundryDocument.getFlag");
  }
  async setFlag(document2, scope, key2, value2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.setFlag(document2, scope, key2, value2);
    }, "FoundryDocument.setFlag");
  }
  async unsetFlag(document2, scope, key2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundryDocument");
      if (!portResult.ok) return portResult;
      return await portResult.value.unsetFlag(document2, scope, key2);
    }, "FoundryDocument.unsetFlag");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryDocumentPort, "FoundryDocumentPort");
let FoundryDocumentPort = _FoundryDocumentPort;
const _DIFoundryDocumentPort = class _DIFoundryDocumentPort extends FoundryDocumentPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryDocumentPort, "DIFoundryDocumentPort");
_DIFoundryDocumentPort.dependencies = [
  portSelectorToken,
  foundryDocumentPortRegistryToken,
  retryServiceToken
];
let DIFoundryDocumentPort = _DIFoundryDocumentPort;
const _FoundryUIPort = class _FoundryUIPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  removeJournalDirectoryEntry(directoryId, journalId, journalName) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.removeJournalDirectoryEntry(directoryId, journalId, journalName);
    }, "FoundryUI.removeJournalDirectoryEntry");
  }
  findElement(container2, selector) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.findElement(container2, selector);
    }, "FoundryUI.findElement");
  }
  notify(message2, type, options2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.notify(message2, type, options2);
    }, "FoundryUI.notify");
  }
  getDirectoryElement(directoryId) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.getDirectoryElement(directoryId);
    }, "FoundryUI.getDirectoryElement");
  }
  rerenderJournalDirectory() {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryUI");
      if (!portResult.ok) return portResult;
      return portResult.value.rerenderJournalDirectory();
    }, "FoundryUI.rerenderJournalDirectory");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryUIPort, "FoundryUIPort");
let FoundryUIPort = _FoundryUIPort;
const _DIFoundryUIPort = class _DIFoundryUIPort extends FoundryUIPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryUIPort, "DIFoundryUIPort");
_DIFoundryUIPort.dependencies = [portSelectorToken, foundryUIPortRegistryToken, retryServiceToken];
let DIFoundryUIPort = _DIFoundryUIPort;
const _FoundrySettingsPort = class _FoundrySettingsPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  register(namespace, key2, config2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.register(namespace, key2, config2);
    }, "FoundrySettings.register");
  }
  get(namespace, key2, schema) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.get(namespace, key2, schema);
    }, "FoundrySettings.get");
  }
  async set(namespace, key2, value2) {
    return this.retryable.executeAsync(async () => {
      const portResult = this.portLoader.loadPort("FoundrySettings");
      if (!portResult.ok) return portResult;
      return portResult.value.set(namespace, key2, value2);
    }, "FoundrySettings.set");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundrySettingsPort, "FoundrySettingsPort");
let FoundrySettingsPort = _FoundrySettingsPort;
const _DIFoundrySettingsPort = class _DIFoundrySettingsPort extends FoundrySettingsPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundrySettingsPort, "DIFoundrySettingsPort");
_DIFoundrySettingsPort.dependencies = [
  portSelectorToken,
  foundrySettingsPortRegistryToken,
  retryServiceToken
];
let DIFoundrySettingsPort = _DIFoundrySettingsPort;
const _FoundryJournalFacade = class _FoundryJournalFacade {
  constructor(game2, document2, ui2, moduleId) {
    this.game = game2;
    this.document = document2;
    this.ui = ui2;
    this.moduleId = moduleId;
  }
  /**
   * Get all journal entries from Foundry.
   *
   * Delegates to FoundryGame.getJournalEntries().
   */
  getJournalEntries() {
    return this.game.getJournalEntries();
  }
  /**
   * Get a module flag from a journal entry with runtime validation.
   *
   * Delegates to FoundryDocument.getFlag() with module scope and schema.
   *
   * @template T - The flag value type
   * @param entry - The Foundry journal entry
   * @param key - The flag key
   * @param schema - Valibot schema for validation
   */
  getEntryFlag(entry, key2, schema) {
    const documentResult = castFoundryDocumentForFlag(entry);
    if (!documentResult.ok) {
      return documentResult;
    }
    return this.document.getFlag(documentResult.value, this.moduleId, key2, schema);
  }
  /**
   * Set a module flag on a journal entry.
   *
   * Delegates to FoundryDocument.setFlag() with module scope.
   *
   * @param entry - The Foundry journal entry
   * @param key - The flag key
   * @param value - The boolean value to set
   * @returns Result indicating success or error
   */
  async setEntryFlag(entry, key2, value2) {
    const documentResult = castFoundryDocumentForFlag(entry);
    if (!documentResult.ok) {
      return documentResult;
    }
    return await this.document.setFlag(documentResult.value, this.moduleId, key2, value2);
  }
};
__name(_FoundryJournalFacade, "FoundryJournalFacade");
let FoundryJournalFacade = _FoundryJournalFacade;
const _DIFoundryJournalFacade = class _DIFoundryJournalFacade extends FoundryJournalFacade {
  constructor(game2, document2, ui2, moduleId) {
    super(game2, document2, ui2, moduleId);
  }
};
__name(_DIFoundryJournalFacade, "DIFoundryJournalFacade");
_DIFoundryJournalFacade.dependencies = [
  foundryGameToken,
  foundryDocumentToken,
  foundryUIToken,
  moduleIdToken
];
let DIFoundryJournalFacade = _DIFoundryJournalFacade;
function sanitizeHtml(text2) {
  const div = document.createElement("div");
  div.textContent = text2;
  return div.innerHTML;
}
__name(sanitizeHtml, "sanitizeHtml");
const HIDDEN_JOURNAL_CACHE_TAG = "journal:hidden";
const _JournalVisibilityService = class _JournalVisibilityService {
  constructor(journalCollection, journalRepository, notifications2, cacheReader, cacheWriter, config2) {
    this.journalCollection = journalCollection;
    this.journalRepository = journalRepository;
    this.notifications = notifications2;
    this.cacheReader = cacheReader;
    this.cacheWriter = cacheWriter;
    this.config = config2;
  }
  /**
   * Gets journal entries marked as hidden via module flag.
   * Logs warnings for entries where flag reading fails to aid diagnosis.
   */
  getHiddenJournalEntries() {
    const cacheKey = this.config.cacheKeyFactory("hidden-directory");
    const cached = this.cacheReader.get(cacheKey);
    if (cached?.hit && cached.value) {
      this.notifications.debug(
        `Serving ${cached.value.length} hidden journal entries from cache (ttl=${cached.metadata.expiresAt ?? "∞"})`,
        { context: { cached } },
        { channels: ["ConsoleChannel"] }
      );
      return { ok: true, value: cached.value };
    }
    const allEntriesResult = this.journalCollection.getAll();
    if (!allEntriesResult.ok) {
      return {
        ok: false,
        error: {
          code: "PLATFORM_ERROR",
          message: allEntriesResult.error.message
        }
      };
    }
    const hidden = [];
    for (const journal of allEntriesResult.value) {
      const flagResult = this.journalRepository.getFlag(
        journal.id,
        this.config.moduleNamespace,
        this.config.hiddenFlagKey
      );
      if (flagResult.ok) {
        if (flagResult.value === true) {
          hidden.push(journal);
        }
      } else {
        const journalIdentifier = journal.name ?? journal.id;
        this.notifications.warn(
          `Failed to read hidden flag for journal "${sanitizeHtml(journalIdentifier)}"`,
          {
            errorCode: flagResult.error.code,
            errorMessage: flagResult.error.message
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    this.cacheWriter.set(cacheKey, hidden.slice(), {
      tags: [HIDDEN_JOURNAL_CACHE_TAG]
    });
    return { ok: true, value: hidden };
  }
};
__name(_JournalVisibilityService, "JournalVisibilityService");
let JournalVisibilityService = _JournalVisibilityService;
const _DIJournalVisibilityService = class _DIJournalVisibilityService extends JournalVisibilityService {
  constructor(journalCollection, journalRepository, notifications2, cacheReader, cacheWriter, config2) {
    super(journalCollection, journalRepository, notifications2, cacheReader, cacheWriter, config2);
  }
};
__name(_DIJournalVisibilityService, "DIJournalVisibilityService");
_DIJournalVisibilityService.dependencies = [
  platformJournalCollectionPortToken,
  platformJournalRepositoryToken,
  notificationPublisherPortToken,
  cacheReaderPortToken,
  cacheWriterPortToken,
  journalVisibilityConfigToken
];
let DIJournalVisibilityService = _DIJournalVisibilityService;
function isNonEmptyArray(array3) {
  return array3.length > 0;
}
__name(isNonEmptyArray, "isNonEmptyArray");
function getFirstArrayElement(array3) {
  if (!isNonEmptyArray(array3)) {
    throw new Error("Array must have length > 0 (caller violated precondition)");
  }
  return array3[0];
}
__name(getFirstArrayElement, "getFirstArrayElement");
function getFirstArrayElementSafe(array3) {
  return isNonEmptyArray(array3) ? array3[0] : null;
}
__name(getFirstArrayElementSafe, "getFirstArrayElementSafe");
const _JournalDirectoryProcessor = class _JournalDirectoryProcessor {
  constructor(journalDirectoryUI, notifications2, config2) {
    this.journalDirectoryUI = journalDirectoryUI;
    this.notifications = notifications2;
    this.config = config2;
  }
  /**
   * Processes journal directory to hide flagged journal directory entries.
   *
   * A journal directory entry is the list position in the sidebar that displays a journal.
   * This is NOT a journal entry (which is a page within a journal).
   *
   * DIP-compliant: Works with directoryId instead of HTMLElement.
   * @param directoryId - The identifier for the directory (e.g., "journal" for Foundry)
   * @param hiddenEntries - Array of journals whose directory entries should be hidden
   * @returns Result indicating success or failure with aggregated errors
   */
  processDirectory(directoryId, hiddenEntries) {
    this.notifications.debug(
      "Processing journal directory for hidden entries",
      { context: { directoryId, hiddenCount: hiddenEntries.length } },
      {
        channels: ["ConsoleChannel"]
      }
    );
    if (hiddenEntries.length === 0) {
      this.notifications.debug(
        "No hidden entries to process",
        { context: {} },
        {
          channels: ["ConsoleChannel"]
        }
      );
      return { ok: true, value: void 0 };
    }
    this.notifications.debug(
      `Found ${hiddenEntries.length} hidden journal entries`,
      { context: { hidden: hiddenEntries } },
      {
        channels: ["ConsoleChannel"]
      }
    );
    return this.hideEntries(directoryId, hiddenEntries);
  }
  /**
   * Hides multiple journal directory entries in the directory.
   *
   * A journal directory entry is the list position in the sidebar that displays a journal.
   * This is NOT a journal entry (which is a page within a journal).
   *
   * DIP-compliant: Uses directoryId instead of HTMLElement.
   * @param directoryId - The identifier for the directory
   * @param entries - Array of journals whose directory entries should be hidden
   * @returns Result indicating success or failure with aggregated errors
   */
  hideEntries(directoryId, entries2) {
    const errors = [];
    for (const journal of entries2) {
      const journalName = journal.name ?? this.config.unknownName;
      const removeResult = this.journalDirectoryUI.removeJournalDirectoryEntry(
        directoryId,
        journal.id,
        journalName
      );
      if (!removeResult.ok) {
        const journalError = {
          code: "DOM_MANIPULATION_FAILED",
          entryId: journal.id,
          message: removeResult.error.message
        };
        errors.push(journalError);
        this.notifications.warn("Error removing journal directory entry", journalError, {
          channels: ["ConsoleChannel"]
        });
      } else {
        this.notifications.debug(
          `Removing journal directory entry: ${sanitizeHtml(journalName)}`,
          { context: { journal } },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return { ok: false, error: firstError };
    }
    return { ok: true, value: void 0 };
  }
};
__name(_JournalDirectoryProcessor, "JournalDirectoryProcessor");
let JournalDirectoryProcessor = _JournalDirectoryProcessor;
const _DIJournalDirectoryProcessor = class _DIJournalDirectoryProcessor extends JournalDirectoryProcessor {
  constructor(journalDirectoryUI, notifications2, config2) {
    super(journalDirectoryUI, notifications2, config2);
  }
};
__name(_DIJournalDirectoryProcessor, "DIJournalDirectoryProcessor");
_DIJournalDirectoryProcessor.dependencies = [
  platformJournalDirectoryUiPortToken,
  notificationPublisherPortToken,
  journalVisibilityConfigToken
];
let DIJournalDirectoryProcessor = _DIJournalDirectoryProcessor;
const _FoundryLibWrapperService = class _FoundryLibWrapperService {
  constructor(moduleId, logger) {
    this.moduleId = moduleId;
    this.logger = logger;
    this.registeredTargets = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  register(target, wrapperFn, type) {
    if (typeof globalThis.libWrapper === "undefined") {
      return err({
        code: "LIBWRAPPER_NOT_AVAILABLE",
        message: "libWrapper is not available"
      });
    }
    if (this.registeredTargets.has(target)) {
      return err({
        code: "REGISTRATION_FAILED",
        message: `Target "${target}" is already registered`,
        details: { target }
      });
    }
    const result = tryCatch(
      () => {
        const libWrapperInstance = globalThis.libWrapper;
        if (typeof libWrapperInstance === "undefined") {
          throw new Error("libWrapper is not available");
        }
        libWrapperInstance.register(this.moduleId, target, wrapperFn, type);
        this.registeredTargets.set(target, true);
        const registrationId = this.nextId++;
        return registrationId;
      },
      (error3) => ({
        code: "REGISTRATION_FAILED",
        message: `Failed to register wrapper for target "${target}": ${String(error3)}`,
        details: { target, error: error3 }
      })
    );
    if (result.ok) {
      return ok(result.value);
    }
    return result;
  }
  unregister(target) {
    if (!this.registeredTargets.has(target)) {
      return err({
        code: "TARGET_NOT_REGISTERED",
        message: `Target "${target}" is not registered`,
        details: { target }
      });
    }
    if (typeof globalThis.libWrapper === "undefined") {
      return err({
        code: "LIBWRAPPER_NOT_AVAILABLE",
        message: "libWrapper is not available"
      });
    }
    const result = tryCatch(
      () => {
        const libWrapperInstance = globalThis.libWrapper;
        if (typeof libWrapperInstance === "undefined") {
          throw new Error("libWrapper is not available");
        }
        libWrapperInstance.unregister(this.moduleId, target);
        this.registeredTargets.delete(target);
      },
      (error3) => ({
        code: "UNREGISTRATION_FAILED",
        message: `Failed to unregister wrapper for target "${target}": ${String(error3)}`,
        details: { target, error: error3 }
      })
    );
    if (result.ok) {
      return ok(void 0);
    }
    return result;
  }
  /**
   * Cleanup all registered wrappers.
   * Should be called during module shutdown.
   */
  dispose() {
    const targets = Array.from(this.registeredTargets.keys());
    for (const target of targets) {
      const result = this.unregister(target);
      if (!result.ok) {
        this.logger.warn("Failed to unregister libWrapper target during dispose", {
          target,
          error: result.error
        });
      }
    }
    this.registeredTargets.clear();
  }
};
__name(_FoundryLibWrapperService, "FoundryLibWrapperService");
let FoundryLibWrapperService = _FoundryLibWrapperService;
const _DIFoundryLibWrapperService = class _DIFoundryLibWrapperService extends FoundryLibWrapperService {
  constructor(moduleId, logger) {
    super(moduleId, logger);
  }
};
__name(_DIFoundryLibWrapperService, "DIFoundryLibWrapperService");
_DIFoundryLibWrapperService.dependencies = [moduleIdToken, loggerToken];
let DIFoundryLibWrapperService = _DIFoundryLibWrapperService;
const libWrapperServiceToken = createInjectionToken("LibWrapperService");
const menuItemJournalIdMap = /* @__PURE__ */ new WeakMap();
const _JournalContextMenuLibWrapperService = class _JournalContextMenuLibWrapperService {
  constructor(libWrapperService, logger) {
    this.libWrapperService = libWrapperService;
    this.logger = logger;
    this.libWrapperRegistered = false;
    this.callbacks = [];
  }
  /**
   * Register libWrapper for ContextMenu.render.
   * Should be called once during module initialization.
   *
   * @returns Success or error if registration failed
   */
  register() {
    if (this.libWrapperRegistered) {
      return ok(void 0);
    }
    const contextMenuClass = globalThis.foundry?.applications?.ux?.ContextMenu?.implementation;
    if (!contextMenuClass) {
      return err(new Error("ContextMenu is not available"));
    }
    const wrapperFn = this.createWrapperFunction();
    const result = this.libWrapperService.register(
      "foundry.applications.ux.ContextMenu.implementation.prototype.render",
      wrapperFn,
      "WRAPPER"
    );
    if (!result.ok) {
      return err(new Error(result.error.message));
    }
    this.registrationId = result.value;
    this.libWrapperRegistered = true;
    this.logger.debug("Journal context menu libWrapper registered");
    return ok(void 0);
  }
  /**
   * Add a callback that will be called when a journal context menu is rendered.
   *
   * @param callback - Callback function that receives the context menu event
   */
  addCallback(callback) {
    this.callbacks.push(callback);
  }
  /**
   * Remove a previously registered callback.
   *
   * @param callback - The callback function to remove
   */
  removeCallback(callback) {
    const index2 = this.callbacks.indexOf(callback);
    if (index2 > -1) {
      this.callbacks.splice(index2, 1);
    }
  }
  /**
   * Cleanup: Unregister libWrapper.
   * Should be called during module shutdown.
   */
  dispose() {
    if (this.libWrapperRegistered) {
      const result = this.libWrapperService.unregister(
        "foundry.applications.ux.ContextMenu.implementation.prototype.render"
      );
      if (!result.ok) {
        this.logger.warn("Failed to unregister context menu libWrapper", {
          error: result.error
        });
      }
      this.libWrapperRegistered = false;
      this.registrationId = void 0;
    }
    this.callbacks = [];
  }
  /**
   * Create the wrapper function for libWrapper.
   * This function intercepts ContextMenu.render calls and allows
   * registered callbacks to modify the menu options.
   */
  createWrapperFunction() {
    const callbacksRef = this.callbacks;
    const loggerRef = this.logger;
    return function(wrapped, ...args2) {
      const firstArg = args2[0];
      const target = firstArg instanceof HTMLElement ? firstArg : void 0;
      if (!target) {
        return wrapped.call(this, ...args2);
      }
      const menuItemsRaw = this.menuItems;
      if (!menuItemsRaw) {
        return wrapped.call(this, ...args2);
      }
      const menuItems = menuItemsRaw;
      const journalId = target.getAttribute?.("data-entry-id") || target.getAttribute?.("data-document-id");
      if (journalId) {
        const ourOptionName = "Journal ausblenden";
        for (let i = menuItems.length - 1; i >= 0; i--) {
          const item = menuItems[i];
          if (item?.name === ourOptionName) {
            menuItemJournalIdMap.delete(item);
            menuItems.splice(i, 1);
          }
        }
        const event3 = {
          journalId,
          options: menuItems.map((item) => ({
            name: item.name,
            icon: item.icon,
            // ContextMenuOption.callback erwartet jetzt journalId statt HTMLElement
            callback: /* @__PURE__ */ __name((_id) => {
              item.callback();
            }, "callback")
          })),
          timestamp: Date.now()
        };
        for (const cb of callbacksRef) {
          cb(event3);
        }
        const existingNames = new Set(menuItems.map((item) => item.name));
        for (const newOption of event3.options) {
          if (!existingNames.has(newOption.name)) {
            const menuItem = {
              name: newOption.name,
              icon: newOption.icon,
              callback: /* @__PURE__ */ __name(() => {
                const dynamicJournalId = menuItemJournalIdMap.get(menuItem);
                if (!dynamicJournalId) {
                  loggerRef.error("Failed to determine journalId dynamically from WeakMap", {
                    menuItemName: menuItem.name,
                    fallbackJournalId: journalId
                  });
                  const contextMenuElement = document.querySelector(".context-menu");
                  if (contextMenuElement) {
                    const journalElement = contextMenuElement.closest("[data-entry-id], [data-document-id]") || document.querySelector(`[data-entry-id], [data-document-id]`);
                    if (journalElement) {
                      const domJournalId = journalElement.getAttribute("data-entry-id") || journalElement.getAttribute("data-document-id");
                      if (domJournalId) {
                        const result2 = newOption.callback(domJournalId);
                        if (result2 instanceof Promise) {
                          result2.catch(() => {
                          });
                        }
                        return;
                      }
                    }
                  }
                  return;
                }
                const result = newOption.callback(dynamicJournalId);
                if (result instanceof Promise) {
                  result.catch(() => {
                  });
                }
              }, "callback")
            };
            menuItemJournalIdMap.set(menuItem, journalId);
            menuItems.push(menuItem);
            existingNames.add(newOption.name);
          }
        }
      }
      return wrapped.call(this, ...args2);
    };
  }
};
__name(_JournalContextMenuLibWrapperService, "JournalContextMenuLibWrapperService");
let JournalContextMenuLibWrapperService = _JournalContextMenuLibWrapperService;
const _DIJournalContextMenuLibWrapperService = class _DIJournalContextMenuLibWrapperService extends JournalContextMenuLibWrapperService {
  constructor(libWrapperService, logger) {
    super(libWrapperService, logger);
  }
};
__name(_DIJournalContextMenuLibWrapperService, "DIJournalContextMenuLibWrapperService");
_DIJournalContextMenuLibWrapperService.dependencies = [libWrapperServiceToken, loggerToken];
let DIJournalContextMenuLibWrapperService = _DIJournalContextMenuLibWrapperService;
const _FoundrySettingsRegistrationAdapter = class _FoundrySettingsRegistrationAdapter {
  constructor(foundrySettings) {
    this.foundrySettings = foundrySettings;
  }
  registerSetting(namespace, key2, config2) {
    const foundryConfig = {
      name: config2.name,
      ...config2.hint !== void 0 && { hint: config2.hint },
      scope: config2.scope,
      config: config2.config,
      type: this.mapDomainTypeToFoundryType(config2.type),
      ...config2.choices !== void 0 && { choices: config2.choices },
      default: config2.default,
      ...config2.onChange !== void 0 && { onChange: config2.onChange }
    };
    const result = this.foundrySettings.register(namespace, key2, foundryConfig);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "register", key2)
      };
    }
    return { ok: true, value: void 0 };
  }
  getSettingValue(namespace, key2, validator) {
    const permissiveSchema = /* @__PURE__ */ unknown();
    const result = this.foundrySettings.get(namespace, key2, permissiveSchema);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "get", key2)
      };
    }
    if (!validator(result.value)) {
      return {
        ok: false,
        error: {
          code: "INVALID_SETTING_VALUE",
          message: `Setting "${namespace}.${key2}" has invalid value type`,
          details: { value: result.value }
        }
      };
    }
    return { ok: true, value: result.value };
  }
  async setSettingValue(namespace, key2, value2) {
    const result = await this.foundrySettings.set(namespace, key2, value2);
    if (!result.ok) {
      return {
        ok: false,
        error: this.mapFoundryError(result.error, "set", key2)
      };
    }
    return { ok: true, value: void 0 };
  }
  // ===== Private Helpers =====
  /**
   * Maps domain-agnostic setting type (string literal) to Foundry constructor type.
   *
   * This mapping encapsulates the platform-specific detail of using constructor types
   * instead of string literals, keeping the domain layer platform-agnostic.
   */
  mapDomainTypeToFoundryType(domainType) {
    switch (domainType) {
      case "string":
        return String;
      case "number":
        return Number;
      case "boolean":
        return Boolean;
      default:
        const exhaustiveCheck = domainType;
        throw new Error(`Unknown domain setting type: ${exhaustiveCheck}`);
    }
  }
  mapFoundryError(foundryError, operation, key2) {
    let code;
    switch (foundryError.code) {
      case "API_NOT_AVAILABLE":
        code = "PLATFORM_NOT_AVAILABLE";
        break;
      case "VALIDATION_FAILED":
        code = "INVALID_SETTING_VALUE";
        break;
      case "OPERATION_FAILED":
        if (operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else if (operation === "get") {
          code = "SETTING_READ_FAILED";
        } else {
          code = "SETTING_WRITE_FAILED";
        }
        break;
      default:
        code = operation === "register" ? "SETTING_REGISTRATION_FAILED" : operation === "get" ? "SETTING_READ_FAILED" : "SETTING_WRITE_FAILED";
    }
    return {
      code,
      message: `Failed to ${operation} setting "${key2}": ${foundryError.message}`,
      details: foundryError
    };
  }
};
__name(_FoundrySettingsRegistrationAdapter, "FoundrySettingsRegistrationAdapter");
let FoundrySettingsRegistrationAdapter = _FoundrySettingsRegistrationAdapter;
const _DIFoundrySettingsRegistrationAdapter = class _DIFoundrySettingsRegistrationAdapter extends FoundrySettingsRegistrationAdapter {
  constructor(foundrySettings) {
    super(foundrySettings);
  }
};
__name(_DIFoundrySettingsRegistrationAdapter, "DIFoundrySettingsRegistrationAdapter");
_DIFoundrySettingsRegistrationAdapter.dependencies = [foundrySettingsToken];
let DIFoundrySettingsRegistrationAdapter = _DIFoundrySettingsRegistrationAdapter;
function registerFoundryServices(container2) {
  const gameServiceResult = container2.registerClass(
    foundryGameToken,
    DIFoundryGamePort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(gameServiceResult)) {
    return err(`Failed to register FoundryGame service: ${gameServiceResult.error.message}`);
  }
  const hooksServiceResult = container2.registerClass(
    foundryHooksToken,
    DIFoundryHooksPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(hooksServiceResult)) {
    return err(`Failed to register FoundryHooks service: ${hooksServiceResult.error.message}`);
  }
  const documentServiceResult = container2.registerClass(
    foundryDocumentToken,
    DIFoundryDocumentPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(documentServiceResult)) {
    return err(
      `Failed to register FoundryDocument service: ${documentServiceResult.error.message}`
    );
  }
  const uiServiceResult = container2.registerClass(
    foundryUIToken,
    DIFoundryUIPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiServiceResult)) {
    return err(`Failed to register FoundryUI service: ${uiServiceResult.error.message}`);
  }
  const settingsServiceResult = container2.registerClass(
    foundrySettingsToken,
    DIFoundrySettingsPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsServiceResult)) {
    return err(
      `Failed to register FoundrySettings service: ${settingsServiceResult.error.message}`
    );
  }
  const settingsRegistrationResult = container2.registerClass(
    platformSettingsRegistrationPortToken,
    DIFoundrySettingsRegistrationAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsRegistrationResult)) {
    return err(
      `Failed to register PlatformSettingsRegistrationPort: ${settingsRegistrationResult.error.message}`
    );
  }
  const journalFacadeResult = container2.registerClass(
    foundryJournalFacadeToken,
    DIFoundryJournalFacade,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalFacadeResult)) {
    return err(`Failed to register FoundryJournalFacade: ${journalFacadeResult.error.message}`);
  }
  const journalVisibilityResult = container2.registerClass(
    journalVisibilityServiceToken,
    DIJournalVisibilityService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalVisibilityResult)) {
    return err(
      `Failed to register JournalVisibility service: ${journalVisibilityResult.error.message}`
    );
  }
  const journalDirectoryProcessorResult = container2.registerClass(
    journalDirectoryProcessorToken,
    DIJournalDirectoryProcessor,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalDirectoryProcessorResult)) {
    return err(
      `Failed to register JournalDirectoryProcessor: ${journalDirectoryProcessorResult.error.message}`
    );
  }
  const libWrapperServiceResult = container2.registerClass(
    libWrapperServiceToken,
    DIFoundryLibWrapperService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(libWrapperServiceResult)) {
    return err(`Failed to register LibWrapperService: ${libWrapperServiceResult.error.message}`);
  }
  const contextMenuLibWrapperResult = container2.registerClass(
    journalContextMenuLibWrapperServiceToken,
    DIJournalContextMenuLibWrapperService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(contextMenuLibWrapperResult)) {
    return err(
      `Failed to register JournalContextMenuLibWrapperService: ${contextMenuLibWrapperResult.error.message}`
    );
  }
  const contextMenuPortResult = container2.registerAlias(
    platformContextMenuRegistrationPortToken,
    journalContextMenuLibWrapperServiceToken
  );
  if (isErr(contextMenuPortResult)) {
    return err(
      `Failed to register PlatformContextMenuRegistrationPort: ${contextMenuPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerFoundryServices, "registerFoundryServices");
registerDependencyStep({
  name: "FoundryServices",
  priority: 80,
  execute: registerFoundryServices
});
const performanceTrackingServiceToken = createInjectionToken(
  "PerformanceTrackingService"
);
const _PerformanceTrackingService = class _PerformanceTrackingService extends PerformanceTrackerImpl {
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_PerformanceTrackingService, "PerformanceTrackingService");
let PerformanceTrackingService = _PerformanceTrackingService;
const _DIPerformanceTrackingService = class _DIPerformanceTrackingService extends PerformanceTrackingService {
  constructor(config2, sampler) {
    super(config2, sampler);
  }
};
__name(_DIPerformanceTrackingService, "DIPerformanceTrackingService");
_DIPerformanceTrackingService.dependencies = [runtimeConfigToken, metricsSamplerToken];
let DIPerformanceTrackingService = _DIPerformanceTrackingService;
const _BaseRetryService = class _BaseRetryService {
  /**
   * Retries an async operation with exponential backoff.
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options
   * @returns Promise resolving to the Result (success or last error)
   */
  async retry(fn3, options2) {
    const maxAttempts = options2.maxAttempts ?? 3;
    const delayMs = options2.delayMs ?? 100;
    const backoffFactor = options2.backoffFactor ?? 1;
    const { mapException } = options2;
    if (maxAttempts < 1) {
      return err(mapException("maxAttempts must be >= 1", 0));
    }
    let lastError = mapException("Initial retry error", 0);
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const result = await fn3();
        if (result.ok) {
          return result;
        }
        lastError = result.error;
        if (attempt === maxAttempts) {
          break;
        }
        const delay2 = delayMs * Math.pow(attempt, backoffFactor);
        await new Promise((resolve2) => setTimeout(resolve2, delay2));
      } catch (error3) {
        lastError = mapException(error3, attempt);
        if (attempt === maxAttempts) {
          break;
        }
        const delay2 = delayMs * Math.pow(attempt, backoffFactor);
        await new Promise((resolve2) => setTimeout(resolve2, delay2));
      }
    }
    return err(lastError);
  }
  /**
   * Retries a synchronous operation.
   * Similar to retry but for sync functions.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options (without delayMs and backoffFactor)
   * @returns The Result (success or last error)
   */
  retrySync(fn3, options2) {
    const maxAttempts = options2.maxAttempts ?? 3;
    const { mapException } = options2;
    if (maxAttempts < 1) {
      return err(mapException("maxAttempts must be >= 1", 0));
    }
    let lastError = mapException("Initial retry error", 0);
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const result = fn3();
        if (result.ok) {
          return result;
        }
        lastError = result.error;
        if (attempt === maxAttempts) {
          break;
        }
      } catch (error3) {
        lastError = mapException(error3, attempt);
        if (attempt === maxAttempts) {
          break;
        }
      }
    }
    return err(lastError);
  }
};
__name(_BaseRetryService, "BaseRetryService");
let BaseRetryService = _BaseRetryService;
const _RetryObservabilityDecorator = class _RetryObservabilityDecorator extends BaseRetryService {
  constructor(logger) {
    super();
    this.logger = logger;
  }
  /**
   * Retries an async operation with exponential backoff and observability.
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options with optional observability
   * @returns Promise resolving to the Result (success or last error)
   */
  async retry(fn3, options2) {
    const { operationName, ...baseOptions } = options2;
    const startTime = performance.now();
    let attemptCount = 0;
    const wrappedFn = /* @__PURE__ */ __name(async () => {
      attemptCount++;
      try {
        const result2 = await fn3();
        if (!result2.ok && attemptCount < (baseOptions.maxAttempts ?? 3)) {
          if (operationName) {
            this.logger.debug(
              `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} failed for "${operationName}"`,
              { error: result2.error }
            );
          }
        }
        return result2;
      } catch (error3) {
        if (attemptCount < (baseOptions.maxAttempts ?? 3) && operationName) {
          this.logger.warn(
            `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} threw exception for "${operationName}"`,
            { error: error3 }
          );
        }
        throw error3;
      }
    }, "wrappedFn");
    const result = await super.retry(wrappedFn, baseOptions);
    const duration = performance.now() - startTime;
    if (operationName) {
      if (result.ok && attemptCount > 1) {
        this.logger.debug(
          `Retry succeeded for "${operationName}" after ${attemptCount} attempts (${duration.toFixed(2)}ms)`
        );
      } else if (!result.ok) {
        this.logger.warn(
          `All retry attempts exhausted for "${operationName}" after ${baseOptions.maxAttempts ?? 3} attempts (${duration.toFixed(2)}ms)`
        );
      }
    }
    return result;
  }
  /**
   * Retries a synchronous operation with observability.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options (without delayMs and backoffFactor)
   * @returns The Result (success or last error)
   */
  retrySync(fn3, options2) {
    const { operationName, ...baseOptions } = options2;
    let attemptCount = 0;
    const wrappedFn = /* @__PURE__ */ __name(() => {
      attemptCount++;
      try {
        const result2 = fn3();
        if (!result2.ok && attemptCount < (baseOptions.maxAttempts ?? 3)) {
          if (operationName) {
            this.logger.debug(
              `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} failed for "${operationName}"`,
              { error: result2.error }
            );
          }
        }
        return result2;
      } catch (error3) {
        if (attemptCount < (baseOptions.maxAttempts ?? 3) && operationName) {
          this.logger.warn(
            `Retry attempt ${attemptCount}/${baseOptions.maxAttempts ?? 3} threw exception for "${operationName}"`,
            { error: error3 }
          );
        }
        throw error3;
      }
    }, "wrappedFn");
    const result = super.retrySync(wrappedFn, baseOptions);
    if (operationName && !result.ok) {
      this.logger.warn(
        `All retry attempts exhausted for "${operationName}" after ${baseOptions.maxAttempts ?? 3} attempts`
      );
    } else if (operationName && result.ok && attemptCount > 1) {
      this.logger.debug(`Retry succeeded for "${operationName}" after ${attemptCount} attempts`);
    }
    return result;
  }
};
__name(_RetryObservabilityDecorator, "RetryObservabilityDecorator");
let RetryObservabilityDecorator = _RetryObservabilityDecorator;
function isLogger(value2) {
  return !(value2 instanceof BaseRetryService);
}
__name(isLogger, "isLogger");
const _RetryService = class _RetryService {
  constructor(loggerOrBaseService, observabilityDecorator) {
    if (observabilityDecorator) {
      this.composedService = observabilityDecorator;
    } else {
      if (!isLogger(loggerOrBaseService)) {
        throw new Error("BaseRetryService cannot be used without RetryObservabilityDecorator");
      }
      this.composedService = new RetryObservabilityDecorator(loggerOrBaseService);
    }
  }
  /**
   * Retries an async operation with exponential backoff.
   *
   * Useful for handling transient failures in external APIs (e.g., Foundry API calls).
   *
   * @template SuccessType - The success type of the operation
   * @template ErrorType - The error type of the operation
   * @param fn - Async function that returns a Result
   * @param options - Retry configuration options
   * @returns Promise resolving to the Result (success or last error)
   *
   * @example
   * ```typescript
   * const result = await retryService.retry(
   *   () => foundryApi.fetchData(),
   *   {
   *     maxAttempts: 3,
   *     delayMs: 100,
   *     operationName: "fetchData",
   *     mapException: (error, attempt) => ({
   *       code: 'OPERATION_FAILED' as const,
   *       message: `Attempt ${attempt} failed: ${String(error)}`
   *     })
   *   }
   * );
   * ```
   */
  async retry(fn3, options2) {
    return this.composedService.retry(fn3, options2);
  }
  /**
   * Retries a synchronous operation.
   * Similar to retry but for sync functions.
   *
   * @template SuccessType - The success type
   * @template ErrorType - The error type
   * @param fn - Function that returns a Result
   * @param options - Retry configuration options
   * @returns The Result (success or last error)
   *
   * @example
   * ```typescript
   * const result = retryService.retrySync(
   *   () => parseData(input),
   *   {
   *     maxAttempts: 3,
   *     operationName: "parseData",
   *     mapException: (error, attempt) => ({
   *       code: 'PARSE_FAILED' as const,
   *       message: `Parse attempt ${attempt} failed: ${String(error)}`
   *     })
   *   }
   * );
   * ```
   */
  retrySync(fn3, options2) {
    return this.composedService.retrySync(fn3, options2);
  }
};
__name(_RetryService, "RetryService");
let RetryService = _RetryService;
const _DIRetryService = class _DIRetryService extends RetryService {
  constructor(logger) {
    super(logger);
  }
};
__name(_DIRetryService, "DIRetryService");
_DIRetryService.dependencies = [loggerToken];
let DIRetryService = _DIRetryService;
function registerUtilityServices(container2) {
  const perfTrackingResult = container2.registerClass(
    performanceTrackingServiceToken,
    DIPerformanceTrackingService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(perfTrackingResult)) {
    return err(
      `Failed to register PerformanceTrackingService: ${perfTrackingResult.error.message}`
    );
  }
  const retryServiceResult = container2.registerClass(
    retryServiceToken,
    DIRetryService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(retryServiceResult)) {
    return err(`Failed to register RetryService: ${retryServiceResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerUtilityServices, "registerUtilityServices");
registerDependencyStep({
  name: "UtilityServices",
  priority: 40,
  execute: registerUtilityServices
});
const foundryI18nToken = createInjectionToken("FoundryI18nPort");
const localI18nToken = createInjectionToken("LocalI18nService");
const foundryTranslationHandlerToken = createInjectionToken(
  "FoundryTranslationHandler"
);
const localTranslationHandlerToken = createInjectionToken("LocalTranslationHandler");
const fallbackTranslationHandlerToken = createInjectionToken(
  "FallbackTranslationHandler"
);
const translationHandlerChainToken = createInjectionToken("TranslationHandlerChain");
const translationHandlersToken = createInjectionToken("TranslationHandlers");
const _FoundryI18nPort = class _FoundryI18nPort {
  constructor(portSelector, portRegistry, retryService) {
    this.portLoader = new PortLoader(portSelector, portRegistry);
    this.retryable = new RetryableOperation(retryService);
  }
  localize(key2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.localize(key2);
    }, "FoundryI18n.localize");
  }
  format(key2, data4) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.format(key2, data4);
    }, "FoundryI18n.format");
  }
  has(key2) {
    return this.retryable.execute(() => {
      const portResult = this.portLoader.loadPort("FoundryI18n");
      if (!portResult.ok) return portResult;
      return portResult.value.has(key2);
    }, "FoundryI18n.has");
  }
  /**
   * Cleans up resources.
   * Disposes the port if it implements Disposable, then clears the cache.
   */
  dispose() {
    const port = this.portLoader.getLoadedPort();
    const disposable = castDisposablePort(port);
    if (disposable) {
      disposable.dispose();
    }
    this.portLoader.clearCache();
  }
};
__name(_FoundryI18nPort, "FoundryI18nPort");
let FoundryI18nPort = _FoundryI18nPort;
const _DIFoundryI18nPort = class _DIFoundryI18nPort extends FoundryI18nPort {
  constructor(portSelector, portRegistry, retryService) {
    super(portSelector, portRegistry, retryService);
  }
};
__name(_DIFoundryI18nPort, "DIFoundryI18nPort");
_DIFoundryI18nPort.dependencies = [
  portSelectorToken,
  foundryI18nPortRegistryToken,
  retryServiceToken
];
let DIFoundryI18nPort = _DIFoundryI18nPort;
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
const _LocalI18nService = class _LocalI18nService {
  constructor() {
    this.translations = /* @__PURE__ */ new Map();
    this.currentLocale = "en";
    this.detectLocale();
  }
  /**
   * Detects browser locale and sets current language.
   * Falls back to 'en' if detection fails.
   */
  detectLocale() {
    if (typeof navigator !== "undefined" && navigator.language) {
      const lang = navigator.language.split("-")[0];
      this.currentLocale = lang ?? "en";
    }
  }
  /**
   * Loads translations from a JSON object.
   * Useful for testing or pre-loaded translation data.
   *
   * @param translations - Object with key-value pairs
   *
   * @example
   * ```typescript
   * const i18n = new LocalI18nService();
   * i18n.loadTranslations({
   *   "MODULE.SETTINGS.logLevel.name": "Log Level",
   *   "MODULE.WELCOME": "Welcome, {name}!"
   * });
   * ```
   */
  loadTranslations(translations) {
    for (const [key2, value2] of Object.entries(translations)) {
      this.translations.set(key2, value2);
    }
  }
  /**
   * Translates a key using local translations.
   *
   * @param key - Translation key
   * @returns Result with translated string (or key itself if not found)
   *
   * @example
   * ```typescript
   * const result = i18n.translate("MODULE.SETTINGS.logLevel.name");
   * if (result.ok) {
   *   console.log(result.value); // "Enable Feature" or key if not found
   * }
   * ```
   */
  translate(key2) {
    const value2 = this.translations.get(key2);
    return ok(value2 ?? key2);
  }
  /**
   * Formats a string with placeholders.
   * Simple implementation: replaces `{key}` with values from data object.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @returns Result with formatted string
   *
   * @example
   * ```typescript
   * // Translation: "Welcome, {name}!"
   * const result = i18n.format("MODULE.WELCOME", { name: "Alice" });
   * if (result.ok) {
   *   console.log(result.value); // "Welcome, Alice!"
   * }
   * ```
   */
  format(key2, data4) {
    const template = this.translations.get(key2) ?? key2;
    let formatted = template;
    for (const [placeholder, value2] of Object.entries(data4)) {
      const escapedPlaceholder = escapeRegex(placeholder);
      const regex2 = new RegExp(`\\{${escapedPlaceholder}\\}`, "g");
      formatted = formatted.replace(regex2, String(value2));
    }
    return ok(formatted);
  }
  /**
   * Checks if a translation key exists.
   *
   * @param key - Translation key to check
   * @returns Result with boolean
   */
  has(key2) {
    return ok(this.translations.has(key2));
  }
  /**
   * Gets the current locale.
   *
   * @returns Current locale string (e.g., "en", "de")
   */
  getCurrentLocale() {
    return this.currentLocale;
  }
  /**
   * Sets the current locale.
   * Note: Changing locale requires reloading translations for the new language.
   *
   * @param locale - Locale code (e.g., "en", "de", "fr")
   */
  setLocale(locale) {
    this.currentLocale = locale;
  }
};
__name(_LocalI18nService, "LocalI18nService");
_LocalI18nService.dependencies = [];
let LocalI18nService = _LocalI18nService;
const _DILocalI18nService = class _DILocalI18nService extends LocalI18nService {
  constructor() {
    super();
  }
};
__name(_DILocalI18nService, "DILocalI18nService");
_DILocalI18nService.dependencies = [];
let DILocalI18nService = _DILocalI18nService;
const _I18nFacadeService = class _I18nFacadeService {
  constructor(handlerChain, localI18n) {
    this.handlerChain = handlerChain;
    this.localI18n = localI18n;
  }
  /**
   * Translates a key using the handler chain: Foundry → Local → Fallback.
   *
   * @param key - Translation key
   * @param fallback - Optional fallback string (defaults to key itself)
   * @returns Result with translated string or fallback
   *
   * @example
   * ```typescript
   * // With fallback
   * const result = i18n.translate("MODULE.UNKNOWN_KEY", "Default Text");
   * if (result.ok) {
   *   console.log(result.value); // "Default Text"
   * }
   *
   * // Without fallback (returns key as fallback)
   * const result2 = i18n.translate("MODULE.UNKNOWN_KEY");
   * if (result2.ok) {
   *   console.log(result2.value); // "MODULE.UNKNOWN_KEY"
   * }
   * ```
   */
  translate(key2, fallback2) {
    return this.handlerChain.handle(key2, void 0, fallback2);
  }
  /**
   * Formats a string with placeholders using the handler chain.
   *
   * @param key - Translation key
   * @param data - Object with placeholder values
   * @param fallback - Optional fallback string
   * @returns Result with formatted string or fallback
   *
   * @example
   * ```typescript
   * const result = i18n.format("MODULE.WELCOME", { name: "Alice" }, "Welcome!");
   * if (result.ok) {
   *   console.log(result.value); // "Welcome, Alice!" or "Welcome!"
   * }
   * ```
   */
  format(key2, data4, fallback2) {
    return this.handlerChain.handle(key2, data4, fallback2);
  }
  /**
   * Checks if a translation key exists in the handler chain.
   * Checks Foundry → Local (Fallback always returns false for has()).
   *
   * @param key - Translation key to check
   * @returns Result with true if key exists in Foundry or local i18n
   */
  has(key2) {
    return this.handlerChain.has(key2);
  }
  /**
   * Loads local translations from a JSON object.
   * Useful for initializing translations on module startup.
   *
   * @param translations - Object with key-value pairs
   *
   * @example
   * ```typescript
   * i18n.loadLocalTranslations({
   *   "MODULE.SETTINGS.logLevel.name": "Log Level",
   *   "MODULE.WELCOME": "Welcome, {name}!"
   * });
   * ```
   */
  loadLocalTranslations(translations) {
    this.localI18n.loadTranslations(translations);
  }
};
__name(_I18nFacadeService, "I18nFacadeService");
let I18nFacadeService = _I18nFacadeService;
const _DII18nFacadeService = class _DII18nFacadeService extends I18nFacadeService {
  constructor(handlerChain, localI18n) {
    super(handlerChain, localI18n);
  }
};
__name(_DII18nFacadeService, "DII18nFacadeService");
_DII18nFacadeService.dependencies = [translationHandlerChainToken, localI18nToken];
let DII18nFacadeService = _DII18nFacadeService;
const _AbstractTranslationHandler = class _AbstractTranslationHandler {
  constructor() {
    this.nextHandler = null;
  }
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  handle(key2, data4, fallback2) {
    const result = this.doHandle(key2, data4, fallback2);
    if (result.ok) {
      return result;
    }
    if (this.nextHandler) {
      return this.nextHandler.handle(key2, data4, fallback2);
    }
    if (fallback2 !== void 0) {
      return ok(fallback2);
    }
    return err(`Translation key not found: ${key2}`);
  }
  has(key2) {
    const ourResult = this.doHas(key2);
    if (!ourResult.ok) {
      return ourResult;
    }
    if (ourResult.value) {
      return ok(true);
    }
    if (this.nextHandler) {
      return this.nextHandler.has(key2);
    }
    return ok(false);
  }
};
__name(_AbstractTranslationHandler, "AbstractTranslationHandler");
let AbstractTranslationHandler = _AbstractTranslationHandler;
const _FoundryTranslationHandler = class _FoundryTranslationHandler extends AbstractTranslationHandler {
  constructor(foundryI18n) {
    super();
    this.foundryI18n = foundryI18n;
  }
  doHandle(key2, data4, _fallback) {
    const result = data4 ? this.foundryI18n.format(key2, data4) : this.foundryI18n.localize(key2);
    if (result.ok && result.value !== key2) {
      return ok(result.value);
    }
    return err(`Foundry i18n could not translate key: ${key2}`);
  }
  doHas(key2) {
    const result = this.foundryI18n.has(key2);
    if (!result.ok) {
      return err(`Failed to check Foundry i18n for key: ${key2}`);
    }
    return ok(result.value);
  }
};
__name(_FoundryTranslationHandler, "FoundryTranslationHandler");
let FoundryTranslationHandler = _FoundryTranslationHandler;
const _DIFoundryTranslationHandler = class _DIFoundryTranslationHandler extends FoundryTranslationHandler {
  constructor(foundryI18n) {
    super(foundryI18n);
  }
};
__name(_DIFoundryTranslationHandler, "DIFoundryTranslationHandler");
_DIFoundryTranslationHandler.dependencies = [foundryI18nToken];
let DIFoundryTranslationHandler = _DIFoundryTranslationHandler;
const _LocalTranslationHandler = class _LocalTranslationHandler extends AbstractTranslationHandler {
  constructor(localI18n) {
    super();
    this.localI18n = localI18n;
  }
  doHandle(key2, data4, _fallback) {
    const result = data4 ? this.localI18n.format(key2, data4) : this.localI18n.translate(key2);
    if (result.ok && result.value !== key2) {
      return ok(result.value);
    }
    return err(`Local i18n could not translate key: ${key2}`);
  }
  doHas(key2) {
    const result = this.localI18n.has(key2);
    if (!result.ok) {
      return err(`Failed to check local i18n for key: ${key2}`);
    }
    return ok(result.value);
  }
};
__name(_LocalTranslationHandler, "LocalTranslationHandler");
let LocalTranslationHandler = _LocalTranslationHandler;
const _DILocalTranslationHandler = class _DILocalTranslationHandler extends LocalTranslationHandler {
  constructor(localI18n) {
    super(localI18n);
  }
};
__name(_DILocalTranslationHandler, "DILocalTranslationHandler");
_DILocalTranslationHandler.dependencies = [localI18nToken];
let DILocalTranslationHandler = _DILocalTranslationHandler;
const _FallbackTranslationHandler = class _FallbackTranslationHandler {
  handle(key2, _data, fallback2) {
    return ok(fallback2 ?? key2);
  }
  has(_key) {
    return ok(false);
  }
};
__name(_FallbackTranslationHandler, "FallbackTranslationHandler");
_FallbackTranslationHandler.dependencies = [];
let FallbackTranslationHandler = _FallbackTranslationHandler;
const _DIFallbackTranslationHandler = class _DIFallbackTranslationHandler extends FallbackTranslationHandler {
  constructor() {
    super();
  }
};
__name(_DIFallbackTranslationHandler, "DIFallbackTranslationHandler");
_DIFallbackTranslationHandler.dependencies = [];
let DIFallbackTranslationHandler = _DIFallbackTranslationHandler;
const _TranslationHandlerChain = class _TranslationHandlerChain {
  constructor(handlers2) {
    assertNonEmptyHandlers(handlers2);
    const [head2, ...rest] = handlers2;
    this.head = head2;
    let current = head2;
    for (const handler of rest) {
      current = current.setNext(handler);
    }
  }
  setNext(handler) {
    return this.head.setNext(handler);
  }
  handle(key2, data4, fallback2) {
    return this.head.handle(key2, data4, fallback2);
  }
  has(key2) {
    return this.head.has(key2);
  }
};
__name(_TranslationHandlerChain, "TranslationHandlerChain");
let TranslationHandlerChain = _TranslationHandlerChain;
const _DITranslationHandlerChain = class _DITranslationHandlerChain extends TranslationHandlerChain {
  constructor(handlers2) {
    super(handlers2);
  }
};
__name(_DITranslationHandlerChain, "DITranslationHandlerChain");
_DITranslationHandlerChain.dependencies = [translationHandlersToken];
let DITranslationHandlerChain = _DITranslationHandlerChain;
function assertNonEmptyHandlers(handlers2) {
  if (handlers2.length === 0) {
    throw new Error("TranslationHandlerChain requires at least one handler");
  }
}
__name(assertNonEmptyHandlers, "assertNonEmptyHandlers");
const _TerminalTranslationHandlerAdapter = class _TerminalTranslationHandlerAdapter {
  constructor(terminalHandler) {
    this.terminalHandler = terminalHandler;
  }
  setNext(_handler) {
    return this;
  }
  handle(key2, data4, fallback2) {
    return this.terminalHandler.handle(key2, data4, fallback2);
  }
  has(key2) {
    return this.terminalHandler.has(key2);
  }
};
__name(_TerminalTranslationHandlerAdapter, "TerminalTranslationHandlerAdapter");
let TerminalTranslationHandlerAdapter = _TerminalTranslationHandlerAdapter;
const _I18nPortAdapter = class _I18nPortAdapter {
  constructor(i18nFacade) {
    this.i18nFacade = i18nFacade;
  }
  translate(key2, fallback2) {
    return this.i18nFacade.translate(key2, fallback2);
  }
  format(key2, data4, fallback2) {
    return this.i18nFacade.format(key2, data4, fallback2);
  }
  has(key2) {
    return this.i18nFacade.has(key2);
  }
  loadLocalTranslations(translations) {
    this.i18nFacade.loadLocalTranslations(translations);
  }
};
__name(_I18nPortAdapter, "I18nPortAdapter");
let I18nPortAdapter = _I18nPortAdapter;
const _DII18nPortAdapter = class _DII18nPortAdapter extends I18nPortAdapter {
  constructor(i18nFacade) {
    super(i18nFacade);
  }
};
__name(_DII18nPortAdapter, "DII18nPortAdapter");
_DII18nPortAdapter.dependencies = [i18nFacadeToken];
let DII18nPortAdapter = _DII18nPortAdapter;
function registerI18nServices(container2) {
  const foundryI18nResult = container2.registerClass(
    foundryI18nToken,
    DIFoundryI18nPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryI18nResult)) {
    return err(`Failed to register FoundryI18nPort: ${foundryI18nResult.error.message}`);
  }
  const localI18nResult = container2.registerClass(
    localI18nToken,
    DILocalI18nService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(localI18nResult)) {
    return err(`Failed to register LocalI18nService: ${localI18nResult.error.message}`);
  }
  const foundryHandlerResult = container2.registerClass(
    foundryTranslationHandlerToken,
    DIFoundryTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryHandlerResult)) {
    return err(
      `Failed to register FoundryTranslationHandler: ${foundryHandlerResult.error.message}`
    );
  }
  const localHandlerResult = container2.registerClass(
    localTranslationHandlerToken,
    DILocalTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(localHandlerResult)) {
    return err(`Failed to register LocalTranslationHandler: ${localHandlerResult.error.message}`);
  }
  const fallbackHandlerResult = container2.registerClass(
    fallbackTranslationHandlerToken,
    DIFallbackTranslationHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(fallbackHandlerResult)) {
    return err(
      `Failed to register FallbackTranslationHandler: ${fallbackHandlerResult.error.message}`
    );
  }
  const handlersArrayResult = container2.registerFactory(
    translationHandlersToken,
    () => {
      const foundryHandlerResult2 = container2.resolveWithError(foundryTranslationHandlerToken);
      if (!foundryHandlerResult2.ok) {
        throw new Error(
          `Failed to resolve FoundryTranslationHandler: ${foundryHandlerResult2.error.message}`
        );
      }
      const foundryHandler = castResolvedService$1(foundryHandlerResult2.value);
      const localHandlerResult2 = container2.resolveWithError(localTranslationHandlerToken);
      if (!localHandlerResult2.ok) {
        throw new Error(
          `Failed to resolve LocalTranslationHandler: ${localHandlerResult2.error.message}`
        );
      }
      const localHandler = castResolvedService$1(localHandlerResult2.value);
      const fallbackHandlerResult2 = container2.resolveWithError(fallbackTranslationHandlerToken);
      if (!fallbackHandlerResult2.ok) {
        throw new Error(
          `Failed to resolve FallbackTranslationHandler: ${fallbackHandlerResult2.error.message}`
        );
      }
      const fallbackHandler = castResolvedService$1(
        fallbackHandlerResult2.value
      );
      const fallbackHandlerAdapter = new TerminalTranslationHandlerAdapter(fallbackHandler);
      return [foundryHandler, localHandler, fallbackHandlerAdapter];
    },
    ServiceLifecycle.SINGLETON,
    [foundryTranslationHandlerToken, localTranslationHandlerToken, fallbackTranslationHandlerToken]
  );
  if (isErr(handlersArrayResult)) {
    return err(
      `Failed to register TranslationHandlers array: ${handlersArrayResult.error.message}`
    );
  }
  const chainResult = container2.registerClass(
    translationHandlerChainToken,
    DITranslationHandlerChain,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(chainResult)) {
    return err(`Failed to register TranslationHandlerChain: ${chainResult.error.message}`);
  }
  const facadeResult = container2.registerClass(
    i18nFacadeToken,
    DII18nFacadeService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(facadeResult)) {
    return err(`Failed to register I18nFacadeService: ${facadeResult.error.message}`);
  }
  const i18nPortResult = container2.registerClass(
    platformI18nPortToken,
    DII18nPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(i18nPortResult)) {
    return err(`Failed to register PlatformI18nPort: ${i18nPortResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerI18nServices, "registerI18nServices");
registerDependencyStep({
  name: "I18nServices",
  priority: 120,
  execute: registerI18nServices
});
const notificationSenderToken = createInjectionToken("NotificationSender");
const consoleChannelToken = createInjectionToken("ConsoleChannel");
const uiChannelToken = createInjectionToken("UIChannel");
const notificationQueueToken = createInjectionToken("NotificationQueue");
const _NotificationCenter = class _NotificationCenter {
  constructor(initialChannels) {
    this.channels = [...initialChannels];
  }
  debug(context, data4, options2) {
    const payload = data4 === void 0 ? {} : { data: data4 };
    return this.notify("debug", context, payload, options2);
  }
  info(context, data4, options2) {
    const payload = data4 === void 0 ? {} : { data: data4 };
    return this.notify("info", context, payload, options2);
  }
  warn(context, data4, options2) {
    const payload = data4 === void 0 ? {} : { data: data4 };
    return this.notify("warn", context, payload, options2);
  }
  error(context, error3, options2) {
    const payload = error3 === void 0 ? {} : { error: error3 };
    return this.notify("error", context, payload, options2);
  }
  addChannel(channel) {
    const alreadyRegistered = this.channels.some((existing) => existing.name === channel.name);
    if (!alreadyRegistered) {
      this.channels.push(channel);
    }
  }
  removeChannel(name) {
    const index2 = this.channels.findIndex((channel) => channel.name === name);
    if (index2 === -1) {
      return false;
    }
    this.channels.splice(index2, 1);
    return true;
  }
  getChannelNames() {
    return this.channels.map((channel) => channel.name);
  }
  notify(level, context, payload, options2) {
    const notification = {
      level,
      context,
      timestamp: /* @__PURE__ */ new Date(),
      ...payload.data !== void 0 ? { data: payload.data } : {},
      ...payload.error !== void 0 ? { error: payload.error } : {},
      ...options2?.traceId !== void 0 ? { traceId: options2.traceId } : {},
      ...options2?.uiOptions !== void 0 ? { uiOptions: options2.uiOptions } : {}
    };
    const targetChannels = this.selectChannels(options2?.channels);
    let attempted = false;
    let succeeded = false;
    const failures = [];
    for (const channel of targetChannels) {
      if (!channel.canHandle(notification)) {
        continue;
      }
      attempted = true;
      const result = channel.send(notification);
      if (result.ok) {
        succeeded = true;
      } else {
        failures.push(`${channel.name}: ${result.error.message}`);
      }
    }
    if (!attempted) {
      if (options2?.channels && options2.channels.length > 0) {
        return err(
          `No channels attempted to handle notification (requested: ${options2.channels.join(", ")})`
        );
      }
      return ok(void 0);
    }
    if (succeeded) {
      return ok(void 0);
    }
    return err(`All channels failed: ${failures.join("; ")}`);
  }
  selectChannels(channelNames) {
    if (!channelNames || channelNames.length === 0) {
      return this.channels;
    }
    return this.channels.filter((channel) => channelNames.includes(channel.name));
  }
};
__name(_NotificationCenter, "NotificationCenter");
let NotificationCenter = _NotificationCenter;
const _DINotificationCenter = class _DINotificationCenter extends NotificationCenter {
  constructor(consoleChannel, uiChannel) {
    super([consoleChannel, uiChannel]);
  }
};
__name(_DINotificationCenter, "DINotificationCenter");
_DINotificationCenter.dependencies = [consoleChannelToken, uiChannelToken];
let DINotificationCenter = _DINotificationCenter;
const _ConsoleChannel = class _ConsoleChannel {
  constructor(logger) {
    this.logger = logger;
    this.name = "ConsoleChannel";
  }
  canHandle() {
    return true;
  }
  send(notification) {
    const { level, context, data: data4, error: error3 } = notification;
    const payload = level === "error" ? error3 ?? data4 : data4 ?? error3;
    this.log(level, context, payload);
    return ok(void 0);
  }
  log(level, message2, data4) {
    switch (level) {
      case "debug":
        this.logger.debug(message2, data4);
        break;
      case "info":
        this.logger.info(message2, data4);
        break;
      case "warn":
        this.logger.warn(message2, data4);
        break;
      case "error":
        this.logger.error(message2, data4);
        break;
    }
  }
};
__name(_ConsoleChannel, "ConsoleChannel");
let ConsoleChannel = _ConsoleChannel;
const _DIConsoleChannel = class _DIConsoleChannel extends ConsoleChannel {
  constructor(logger) {
    super(logger);
  }
};
__name(_DIConsoleChannel, "DIConsoleChannel");
_DIConsoleChannel.dependencies = [platformLoggingPortToken];
let DIConsoleChannel = _DIConsoleChannel;
const _UIChannel = class _UIChannel {
  constructor(platformUI, config2) {
    this.platformUI = platformUI;
    this.config = config2;
    this.name = "UIChannel";
  }
  canHandle(notification) {
    return notification.level !== "debug";
  }
  send(notification) {
    const sanitizedMessage = this.sanitizeForUI(notification);
    const uiTypeResult = this.mapLevelToUIType(notification.level);
    if (!uiTypeResult.ok) {
      return err({
        code: "MAPPING_FAILED",
        message: uiTypeResult.error,
        channelName: this.name
      });
    }
    const result = this.platformUI.notify(sanitizedMessage, uiTypeResult.value);
    if (!result.ok) {
      return err({
        code: "UI_NOTIFICATION_FAILED",
        message: result.error.message,
        channelName: this.name,
        details: result.error
      });
    }
    return ok(void 0);
  }
  notify(message2, type) {
    const result = this.platformUI.notify(message2, type);
    if (!result.ok) {
      return err({
        code: "UI_NOTIFICATION_FAILED",
        message: result.error.message,
        channelName: this.name,
        details: result.error
      });
    }
    return ok(void 0);
  }
  /**
   * Sanitizes notification message for UI display.
   *
   * Development: Shows detailed messages
   * Production: Shows generic messages to prevent information leakage
   */
  sanitizeForUI(notification) {
    const { level, context, data: data4, error: error3 } = notification;
    if (this.config.get("isDevelopment")) {
      if (level === "error" && error3) {
        return `${context}: ${error3.message}`;
      }
      if (data4 && typeof data4 === "object" && "message" in data4) {
        return `${context}: ${String(data4.message)}`;
      }
      return context;
    }
    if (level === "error" && error3) {
      return `${context}. Please try again or contact support. (Error: ${error3.code})`;
    }
    return context;
  }
  /**
   * Maps notification level to UI notification type.
   * Protected to allow testing of exhaustive type check.
   */
  mapLevelToUIType(level) {
    switch (level) {
      case "info":
        return ok("info");
      case "warn":
        return ok("warning");
      case "error":
        return ok("error");
      case "debug": {
        return err(`Debug level should be filtered by canHandle(). Received: ${level}`);
      }
    }
  }
};
__name(_UIChannel, "UIChannel");
let UIChannel = _UIChannel;
const _DIUIChannel = class _DIUIChannel extends UIChannel {
  constructor(platformUI, config2) {
    super(platformUI, config2);
  }
};
__name(_DIUIChannel, "DIUIChannel");
_DIUIChannel.dependencies = [platformUINotificationPortToken, runtimeConfigToken];
let DIUIChannel = _DIUIChannel;
const _QueuedUIChannel = class _QueuedUIChannel {
  constructor(queue, uiAvailability, container2) {
    this.queue = queue;
    this.uiAvailability = uiAvailability;
    this.container = container2;
    this.name = "UIChannel";
    this.realChannel = null;
    this.hasFlushed = false;
  }
  /**
   * Gets or creates the real UIChannel.
   * Uses lazy initialization to avoid creating channel before UI is available.
   */
  getRealChannel() {
    if (this.realChannel) {
      return this.realChannel;
    }
    const channelResult = this.container.resolveWithError(uiChannelToken);
    if (!channelResult.ok) {
      return null;
    }
    this.realChannel = channelResult.value;
    return this.realChannel;
  }
  /**
   * Determines if this channel should handle the notification.
   * Delegates to real channel if available, otherwise uses same logic as UIChannel.
   */
  canHandle(notification) {
    if (notification.level === "debug") {
      return false;
    }
    const realChannel = this.getRealChannel();
    if (realChannel) {
      return realChannel.canHandle(notification);
    }
    return true;
  }
  /**
   * Sends notification to UI or queues it if UI is not available.
   */
  send(notification) {
    if (this.uiAvailability.isAvailable()) {
      if (!this.hasFlushed && this.queue.size > 0) {
        const realChannel2 = this.getRealChannel();
        if (realChannel2) {
          this.queue.flush((n) => {
            realChannel2.send(n);
          });
        }
        this.hasFlushed = true;
      }
      const realChannel = this.getRealChannel();
      if (!realChannel) {
        this.queue.enqueue(notification);
        return ok(void 0);
      }
      return realChannel.send(notification);
    }
    if (notification.level === "debug") {
      return ok(void 0);
    }
    this.queue.enqueue(notification);
    return ok(void 0);
  }
  /**
   * Sends notification directly to UI (bypasses queue).
   * Used for immediate notifications when UI is available.
   */
  notify(message2, type) {
    if (this.uiAvailability.isAvailable()) {
      const realChannel = this.getRealChannel();
      if (!realChannel) {
        return err({
          code: "CHANNEL_NOT_AVAILABLE",
          message: "UIChannel could not be resolved",
          channelName: this.name
        });
      }
      return realChannel.notify(message2, type);
    }
    return err({
      code: "UI_NOT_AVAILABLE",
      message: "UI is not available for immediate notifications",
      channelName: this.name
    });
  }
};
__name(_QueuedUIChannel, "QueuedUIChannel");
let QueuedUIChannel = _QueuedUIChannel;
const _DIQueuedUIChannel = class _DIQueuedUIChannel extends QueuedUIChannel {
  constructor(queue, uiAvailability, container2) {
    super(queue, uiAvailability, container2);
  }
};
__name(_DIQueuedUIChannel, "DIQueuedUIChannel");
_DIQueuedUIChannel.dependencies = [
  notificationQueueToken,
  platformUIAvailabilityPortToken,
  platformContainerPortToken
];
let DIQueuedUIChannel = _DIQueuedUIChannel;
const _NotificationPortAdapter = class _NotificationPortAdapter {
  constructor(notificationCenter) {
    this.notificationCenter = notificationCenter;
  }
  debug(context, data4, options2) {
    const centerOptions = this.mapToCenterOptions(options2);
    const result = this.notificationCenter.debug(context, data4, centerOptions);
    return this.mapResult(result);
  }
  info(context, data4, options2) {
    const centerOptions = this.mapToCenterOptions(options2);
    const result = this.notificationCenter.info(context, data4, centerOptions);
    return this.mapResult(result);
  }
  warn(context, data4, options2) {
    const centerOptions = this.mapToCenterOptions(options2);
    const result = this.notificationCenter.warn(context, data4, centerOptions);
    return this.mapResult(result);
  }
  error(context, error3, options2) {
    const centerOptions = this.mapToCenterOptions(options2);
    const result = this.notificationCenter.error(context, error3, centerOptions);
    return this.mapResult(result);
  }
  addChannel(_channelName) {
    return err({
      code: "OPERATION_NOT_SUPPORTED",
      message: "Dynamic channel addition via name not supported. Use NotificationCenter.addChannel() directly.",
      operation: "addChannel"
    });
  }
  removeChannel(channelName) {
    const removed = this.notificationCenter.removeChannel(channelName);
    return ok(removed);
  }
  getChannelNames() {
    const names = this.notificationCenter.getChannelNames();
    return ok(names);
  }
  // ===== Private Helpers =====
  /**
   * Maps platform-agnostic options to NotificationCenter options.
   * Handles Foundry-specific options via type guard if present.
   */
  mapToCenterOptions(options2) {
    if (!options2) return void 0;
    const centerOptions = {
      ...options2.channels !== void 0 && { channels: options2.channels },
      ...options2.traceId !== void 0 && { traceId: options2.traceId }
    };
    if (this.isFoundryNotificationOptions(options2)) {
      const foundryOptions = {
        ...options2.permanent !== void 0 && { permanent: options2.permanent },
        ...options2.console !== void 0 && { console: options2.console },
        ...options2.localize !== void 0 && { localize: options2.localize },
        ...options2.progress !== void 0 && { progress: options2.progress },
        ...options2.clean !== void 0 && { clean: options2.clean },
        ...options2.escape !== void 0 && { escape: options2.escape },
        ...options2.format !== void 0 && { format: options2.format }
      };
      centerOptions.uiOptions = foundryOptions;
    }
    return centerOptions;
  }
  /**
   * Type guard to detect Foundry-specific notification options.
   * This allows adapters to pass Foundry options without exposing them in the domain interface.
   */
  isFoundryNotificationOptions(options2) {
    return typeof options2 === "object" && options2 !== null && ("permanent" in options2 || "console" in options2 || "localize" in options2 || "progress" in options2 || "clean" in options2 || "escape" in options2 || "format" in options2);
  }
  /**
   * Maps NotificationCenter Result to PlatformNotificationPort Result.
   */
  mapResult(result) {
    if (result.ok) {
      return ok(void 0);
    }
    return err({
      code: "NOTIFICATION_FAILED",
      message: result.error,
      operation: "notify"
    });
  }
};
__name(_NotificationPortAdapter, "NotificationPortAdapter");
let NotificationPortAdapter = _NotificationPortAdapter;
const _DINotificationPortAdapter = class _DINotificationPortAdapter extends NotificationPortAdapter {
  constructor(notificationCenter) {
    super(notificationCenter);
  }
};
__name(_DINotificationPortAdapter, "DINotificationPortAdapter");
_DINotificationPortAdapter.dependencies = [notificationCenterToken];
let DINotificationPortAdapter = _DINotificationPortAdapter;
const _NotificationQueue = class _NotificationQueue {
  constructor(runtimeConfig, env) {
    this.runtimeConfig = runtimeConfig;
    this.env = env;
    this.queue = [];
  }
  /**
   * Gets the maximum queue size from RuntimeConfig, with ENV fallback.
   */
  getMaxSize() {
    const value2 = this.runtimeConfig.get("notificationQueueMaxSize");
    return value2 ?? this.env.notificationQueueDefaultSize;
  }
  /**
   * Adds a notification to the queue.
   * If the queue is full, removes the oldest notification.
   */
  enqueue(notification) {
    const maxSize2 = this.getMaxSize();
    if (this.queue.length >= maxSize2) {
      this.queue.shift();
    }
    this.queue.push(notification);
  }
  /**
   * Flushes all queued notifications by calling the handler for each.
   * Queue is cleared after flushing.
   */
  flush(handler) {
    for (const notification of this.queue) {
      try {
        handler(notification);
      } catch (_error) {
      }
    }
    this.queue.length = 0;
  }
  /**
   * Clears all queued notifications without processing them.
   */
  clear() {
    this.queue.length = 0;
  }
  /**
   * Gets the current number of queued notifications.
   */
  get size() {
    return this.queue.length;
  }
};
__name(_NotificationQueue, "NotificationQueue");
let NotificationQueue = _NotificationQueue;
const _DINotificationQueue = class _DINotificationQueue extends NotificationQueue {
  constructor(runtimeConfig, env) {
    super(runtimeConfig, env);
  }
};
__name(_DINotificationQueue, "DINotificationQueue");
_DINotificationQueue.dependencies = [runtimeConfigToken, environmentConfigToken];
let DINotificationQueue = _DINotificationQueue;
const _FoundryUIAvailabilityPort = class _FoundryUIAvailabilityPort {
  /**
   * Checks if Foundry UI is available.
   * UI is available when `ui` is defined and `ui.notifications` exists.
   */
  isAvailable() {
    return typeof ui !== "undefined" && ui?.notifications !== void 0;
  }
  /**
   * Optional callback registration for when UI becomes available.
   * Not implemented for now - can be extended with event-based approach later.
   */
  onAvailable(_callback) {
  }
};
__name(_FoundryUIAvailabilityPort, "FoundryUIAvailabilityPort");
let FoundryUIAvailabilityPort = _FoundryUIAvailabilityPort;
const _DIFoundryUIAvailabilityPort = class _DIFoundryUIAvailabilityPort extends FoundryUIAvailabilityPort {
  constructor() {
    super();
  }
};
__name(_DIFoundryUIAvailabilityPort, "DIFoundryUIAvailabilityPort");
_DIFoundryUIAvailabilityPort.dependencies = [];
let DIFoundryUIAvailabilityPort = _DIFoundryUIAvailabilityPort;
function registerNotifications(container2) {
  const notificationQueueResult = container2.registerClass(
    notificationQueueToken,
    DINotificationQueue,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationQueueResult)) {
    return err(`Failed to register NotificationQueue: ${notificationQueueResult.error.message}`);
  }
  const uiAvailabilityResult = container2.registerClass(
    platformUIAvailabilityPortToken,
    DIFoundryUIAvailabilityPort,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiAvailabilityResult)) {
    return err(
      `Failed to register PlatformUIAvailabilityPort: ${uiAvailabilityResult.error.message}`
    );
  }
  const consoleChannelResult = container2.registerClass(
    consoleChannelToken,
    DIConsoleChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(consoleChannelResult)) {
    return err(`Failed to register ConsoleChannel: ${consoleChannelResult.error.message}`);
  }
  const uiChannelResult = container2.registerClass(
    uiChannelToken,
    DIUIChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiChannelResult)) {
    return err(`Failed to register UIChannel: ${uiChannelResult.error.message}`);
  }
  const queuedUIChannelResult = container2.registerClass(
    queuedUIChannelToken,
    DIQueuedUIChannel,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(queuedUIChannelResult)) {
    return err(`Failed to register QueuedUIChannel: ${queuedUIChannelResult.error.message}`);
  }
  const notificationCenterResult = container2.registerClass(
    notificationCenterToken,
    DINotificationCenter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationCenterResult)) {
    return err(`Failed to register NotificationCenter: ${notificationCenterResult.error.message}`);
  }
  const notificationSenderAliasResult = container2.registerAlias(
    notificationSenderToken,
    notificationCenterToken
  );
  if (isErr(notificationSenderAliasResult)) {
    return err(
      `Failed to register NotificationSender alias: ${notificationSenderAliasResult.error.message}`
    );
  }
  const notificationChannelRegistryAliasResult = container2.registerAlias(
    notificationChannelRegistryToken,
    notificationCenterToken
  );
  if (isErr(notificationChannelRegistryAliasResult)) {
    return err(
      `Failed to register NotificationChannelRegistry alias: ${notificationChannelRegistryAliasResult.error.message}`
    );
  }
  const notificationPortResult = container2.registerClass(
    platformNotificationPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(notificationPortResult)) {
    return err(
      `Failed to register PlatformNotificationPort: ${notificationPortResult.error.message}`
    );
  }
  const publisherPortResult = container2.registerClass(
    notificationPublisherPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(publisherPortResult)) {
    return err(
      `Failed to register NotificationPublisherPort: ${publisherPortResult.error.message}`
    );
  }
  const channelRegistryPortResult = container2.registerClass(
    notificationChannelRegistryPortToken,
    DINotificationPortAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(channelRegistryPortResult)) {
    return err(
      `Failed to register NotificationChannelRegistryPort: ${channelRegistryPortResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerNotifications, "registerNotifications");
registerDependencyStep({
  name: "Notifications",
  priority: 130,
  execute: registerNotifications
});
const _ModuleSettingsRegistrar = class _ModuleSettingsRegistrar {
  constructor(settings, runtimeConfigSettingsSync, errorMapper, notifications2, i18n, logger, validator, settingDefinitionRegistry, runtimeConfigBindingRegistry) {
    this.settings = settings;
    this.runtimeConfigSettingsSync = runtimeConfigSettingsSync;
    this.errorMapper = errorMapper;
    this.notifications = notifications2;
    this.i18n = i18n;
    this.logger = logger;
    this.validator = validator;
    this.settingDefinitionRegistry = settingDefinitionRegistry;
    this.runtimeConfigBindingRegistry = runtimeConfigBindingRegistry;
  }
  /**
   * Registers all module settings.
   * Must be called during or after the 'init' hook.
   *
   * Iterates over settings from SettingDefinitionRegistry and applies
   * corresponding bindings from RuntimeConfigBindingRegistry.
   *
   * Implements Open/Closed Principle: New settings can be added via registry
   * extension without modifying this method.
   */
  registerAll() {
    const definitions = this.settingDefinitionRegistry.getAll();
    const bindings = this.runtimeConfigBindingRegistry.getAll();
    for (const definition of definitions) {
      const binding = bindings.get(definition.key);
      this.registerDefinition(
        definition,
        binding,
        this.settings,
        this.runtimeConfigSettingsSync,
        this.errorMapper,
        this.i18n,
        this.logger,
        this.validator
      );
    }
  }
  registerDefinition(definition, binding, settings, runtimeConfigSettingsSync, errorMapper, i18n, logger, validator) {
    const config2 = definition.createConfig(i18n, logger, validator);
    const configWithRuntimeBridge = binding ? runtimeConfigSettingsSync.attachBinding(config2, binding) : config2;
    const result = settings.registerSetting(
      MODULE_METADATA.ID,
      definition.key,
      configWithRuntimeBridge
    );
    if (!result.ok) {
      errorMapper.mapAndNotify(result.error, definition.key);
      return;
    }
    if (binding) {
      runtimeConfigSettingsSync.syncInitialValue(settings, binding, definition.key);
    }
  }
};
__name(_ModuleSettingsRegistrar, "ModuleSettingsRegistrar");
let ModuleSettingsRegistrar = _ModuleSettingsRegistrar;
const _DIModuleSettingsRegistrar = class _DIModuleSettingsRegistrar extends ModuleSettingsRegistrar {
  constructor(settings, runtimeConfigSettingsSync, errorMapper, notifications2, i18n, logger, validator, settingDefinitionRegistry, runtimeConfigBindingRegistry) {
    super(
      settings,
      runtimeConfigSettingsSync,
      errorMapper,
      notifications2,
      i18n,
      logger,
      validator,
      settingDefinitionRegistry,
      runtimeConfigBindingRegistry
    );
  }
};
__name(_DIModuleSettingsRegistrar, "DIModuleSettingsRegistrar");
_DIModuleSettingsRegistrar.dependencies = [
  platformSettingsRegistrationPortToken,
  runtimeConfigSettingsSyncToken,
  settingRegistrationErrorMapperToken,
  notificationPublisherPortToken,
  platformI18nPortToken,
  platformLoggingPortToken,
  platformValidationPortToken,
  settingDefinitionRegistryToken,
  runtimeConfigBindingRegistryToken
];
let DIModuleSettingsRegistrar = _DIModuleSettingsRegistrar;
const _RuntimeConfigSync = class _RuntimeConfigSync {
  constructor(runtimeConfig, notifications2) {
    this.runtimeConfig = runtimeConfig;
    this.notifications = notifications2;
  }
  /**
   * Bindet RuntimeConfig-Synchronisation an ein Setting.
   *
   * Wraps the original onChange callback and adds RuntimeConfig synchronization.
   *
   * @param config - The Setting configuration (platform-agnostic DomainSettingConfig)
   * @param binding - Binding configuration for RuntimeConfig sync
   * @returns Modified config with RuntimeConfig bridge attached
   */
  attachBinding(config2, binding) {
    const originalOnChange = config2.onChange;
    return {
      ...config2,
      onChange: /* @__PURE__ */ __name((value2) => {
        const normalized = binding.normalize(value2);
        this.runtimeConfig.setFromPlatform(binding.runtimeKey, normalized);
        originalOnChange?.(value2);
      }, "onChange")
    };
  }
  /**
   * Synchronisiert initialen Setting-Wert zu RuntimeConfig.
   *
   * Reads the current Setting value and updates RuntimeConfig accordingly.
   *
   * @param settings - Settings port for reading values
   * @param binding - Binding configuration for RuntimeConfig sync
   * @param settingKey - The Setting key to read
   */
  syncInitialValue(settings, binding, settingKey) {
    const currentValue = settings.getSettingValue(
      MODULE_METADATA.ID,
      settingKey,
      binding.validator
    );
    if (!currentValue.ok) {
      this.notifications.warn(
        `Failed to read initial value for ${settingKey}`,
        currentValue.error,
        {
          channels: ["ConsoleChannel"]
        }
      );
      return;
    }
    this.runtimeConfig.setFromPlatform(binding.runtimeKey, binding.normalize(currentValue.value));
  }
};
__name(_RuntimeConfigSync, "RuntimeConfigSync");
let RuntimeConfigSync = _RuntimeConfigSync;
const _DIRuntimeConfigSync = class _DIRuntimeConfigSync extends RuntimeConfigSync {
  constructor(runtimeConfig, notifications2) {
    super(runtimeConfig, notifications2);
  }
};
__name(_DIRuntimeConfigSync, "DIRuntimeConfigSync");
_DIRuntimeConfigSync.dependencies = [runtimeConfigToken, notificationPublisherPortToken];
let DIRuntimeConfigSync = _DIRuntimeConfigSync;
const _RuntimeConfigSettingsSync = class _RuntimeConfigSettingsSync {
  constructor(runtimeConfigSync) {
    this.runtimeConfigSync = runtimeConfigSync;
  }
  /**
   * Attaches RuntimeConfig synchronization binding to a setting configuration.
   *
   * Delegates to RuntimeConfigSync.attachBinding().
   *
   * @param config - The Setting configuration (platform-agnostic DomainSettingConfig)
   * @param binding - Binding configuration for RuntimeConfig sync
   * @returns Modified config with RuntimeConfig bridge attached
   */
  attachBinding(config2, binding) {
    return this.runtimeConfigSync.attachBinding(config2, binding);
  }
  /**
   * Synchronizes initial Setting value to RuntimeConfig.
   *
   * Delegates to RuntimeConfigSync.syncInitialValue().
   *
   * @param settings - Settings port for reading values
   * @param binding - Binding configuration for RuntimeConfig sync
   * @param settingKey - The Setting key to read
   */
  syncInitialValue(settings, binding, settingKey) {
    this.runtimeConfigSync.syncInitialValue(settings, binding, settingKey);
  }
};
__name(_RuntimeConfigSettingsSync, "RuntimeConfigSettingsSync");
let RuntimeConfigSettingsSync = _RuntimeConfigSettingsSync;
const _DIRuntimeConfigSettingsSync = class _DIRuntimeConfigSettingsSync extends RuntimeConfigSettingsSync {
  constructor(runtimeConfigSync) {
    super(runtimeConfigSync);
  }
};
__name(_DIRuntimeConfigSettingsSync, "DIRuntimeConfigSettingsSync");
_DIRuntimeConfigSettingsSync.dependencies = [runtimeConfigSyncToken];
let DIRuntimeConfigSettingsSync = _DIRuntimeConfigSettingsSync;
const _SettingRegistrationErrorMapper = class _SettingRegistrationErrorMapper {
  constructor(notifications2) {
    this.notifications = notifications2;
  }
  mapAndNotify(error3, settingKey) {
    const notificationError = {
      code: error3.code,
      message: error3.message,
      ...error3.details !== void 0 && { details: error3.details }
    };
    this.notifications.error(`Failed to register ${settingKey} setting`, notificationError, {
      channels: ["ConsoleChannel"]
    });
  }
};
__name(_SettingRegistrationErrorMapper, "SettingRegistrationErrorMapper");
let SettingRegistrationErrorMapper = _SettingRegistrationErrorMapper;
const _DISettingRegistrationErrorMapper = class _DISettingRegistrationErrorMapper extends SettingRegistrationErrorMapper {
  constructor(notifications2) {
    super(notifications2);
  }
};
__name(_DISettingRegistrationErrorMapper, "DISettingRegistrationErrorMapper");
_DISettingRegistrationErrorMapper.dependencies = [notificationPublisherPortToken];
let DISettingRegistrationErrorMapper = _DISettingRegistrationErrorMapper;
function castSettingDefinitionToUnknown(definition) {
  return definition;
}
__name(castSettingDefinitionToUnknown, "castSettingDefinitionToUnknown");
function castBindingToUnknown(binding) {
  return binding;
}
__name(castBindingToUnknown, "castBindingToUnknown");
function validateAndSetLogLevel(value2, logger, validator) {
  const validationResult = validator.validateLogLevel(value2);
  if (!validationResult.ok) {
    logger.warn(`Invalid log level value received: ${value2}, using default INFO`);
    if (logger.setMinLevel) {
      logger.setMinLevel(LogLevel.INFO);
    }
    return;
  }
  if (logger.setMinLevel) {
    logger.setMinLevel(validationResult.value);
    logger.info(`Log level changed to: ${LogLevel[validationResult.value]}`);
  }
}
__name(validateAndSetLogLevel, "validateAndSetLogLevel");
const logLevelSetting = {
  key: SETTING_KEYS.LOG_LEVEL,
  createConfig(i18n, logger, validator) {
    return {
      name: unwrapOr(i18n.translate("MODULE.SETTINGS.logLevel.name", "Log Level"), "Log Level"),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.logLevel.hint",
          "Minimum log level for module output. DEBUG shows all logs, ERROR only critical errors."
        ),
        "Minimum log level for module output. DEBUG shows all logs, ERROR only critical errors."
      ),
      scope: "world",
      config: true,
      type: "number",
      choices: {
        [LogLevel.DEBUG]: unwrapOr(
          i18n.translate(
            "MODULE.SETTINGS.logLevel.choices.debug",
            "DEBUG (All logs - for debugging)"
          ),
          "DEBUG (All logs - for debugging)"
        ),
        [LogLevel.INFO]: unwrapOr(
          i18n.translate("MODULE.SETTINGS.logLevel.choices.info", "INFO (Standard)"),
          "INFO (Standard)"
        ),
        [LogLevel.WARN]: unwrapOr(
          i18n.translate(
            "MODULE.SETTINGS.logLevel.choices.warn",
            "WARN (Warnings and errors only)"
          ),
          "WARN (Warnings and errors only)"
        ),
        [LogLevel.ERROR]: unwrapOr(
          i18n.translate("MODULE.SETTINGS.logLevel.choices.error", "ERROR (Critical errors only)"),
          "ERROR (Critical errors only)"
        )
      },
      default: LogLevel.INFO,
      onChange: /* @__PURE__ */ __name((value2) => {
        validateAndSetLogLevel(value2, logger, validator);
      }, "onChange")
    };
  }
};
const cacheEnabledSetting = {
  key: SETTING_KEYS.CACHE_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheEnabled.name", "Enable Cache Service"),
        "Enable Cache Service"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheEnabled.hint",
          "Toggle the global CacheService. When disabled, all cache interactions bypass the cache layer."
        ),
        "Toggle the global CacheService. When disabled, all cache interactions bypass the cache layer."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: true,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`CacheService ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const cacheDefaultTtlSetting = {
  key: SETTING_KEYS.CACHE_TTL_MS,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheDefaultTtlMs.name", "Cache TTL (ms)"),
        "Cache TTL (ms)"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheDefaultTtlMs.hint",
          "Default lifetime for cache entries in milliseconds. Use 0 to disable TTL (entries live until invalidated)."
        ),
        "Default lifetime for cache entries in milliseconds. Use 0 to disable TTL (entries live until invalidated)."
      ),
      scope: "world",
      config: true,
      type: "number",
      default: APP_DEFAULTS.CACHE_TTL_MS,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const sanitized = Number.isFinite(numericValue) && numericValue >= 0 ? numericValue : 0;
        logger.info(`Cache TTL updated via settings: ${sanitized}ms`);
      }, "onChange")
    };
  }
};
const cacheMaxEntriesSetting = {
  key: SETTING_KEYS.CACHE_MAX_ENTRIES,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.cacheMaxEntries.name", "Cache Max Entries"),
        "Cache Max Entries"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.cacheMaxEntries.hint",
          "Optional LRU limit. Use 0 to allow unlimited cache entries."
        ),
        "Optional LRU limit. Use 0 to allow unlimited cache entries."
      ),
      scope: "world",
      config: true,
      type: "number",
      default: 0,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const sanitized = Number.isFinite(numericValue) && numericValue > 0 ? Math.floor(numericValue) : 0;
        if (sanitized === 0) {
          logger.info("Cache max entries reset to unlimited via settings.");
        } else {
          logger.info(`Cache max entries updated via settings: ${sanitized}`);
        }
      }, "onChange")
    };
  }
};
const performanceTrackingSetting = {
  key: SETTING_KEYS.PERFORMANCE_TRACKING_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.performanceTracking.name", "Performance Tracking"),
        "Performance Tracking"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.performanceTracking.hint",
          "Enables internal performance instrumentation (requires sampling)."
        ),
        "Enables internal performance instrumentation (requires sampling)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: false,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`Performance tracking ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const performanceSamplingSetting = {
  key: SETTING_KEYS.PERFORMANCE_SAMPLING_RATE,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.performanceSamplingRate.name", "Performance Sampling Rate"),
        "Performance Sampling Rate"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.performanceSamplingRate.hint",
          "Fraction of operations to instrument (0 = 0%, 1 = 100%)."
        ),
        "Fraction of operations to instrument (0 = 0%, 1 = 100%)."
      ),
      scope: "world",
      config: true,
      type: "number",
      default: 1,
      onChange: /* @__PURE__ */ __name((value2) => {
        const clamped = Math.max(0, Math.min(1, Number(value2) || 0));
        logger.info(
          `Performance sampling rate updated via settings: ${(clamped * 100).toFixed(1)}%`
        );
      }, "onChange")
    };
  }
};
const metricsPersistenceEnabledSetting = {
  key: SETTING_KEYS.METRICS_PERSISTENCE_ENABLED,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.metricsPersistenceEnabled.name", "Persist Metrics"),
        "Persist Metrics"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.metricsPersistenceEnabled.hint",
          "Keeps observability metrics across Foundry restarts (uses LocalStorage)."
        ),
        "Keeps observability metrics across Foundry restarts (uses LocalStorage)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: false,
      onChange: /* @__PURE__ */ __name((value2) => {
        const action2 = value2 ? "enabled" : "disabled";
        logger.info(`Metrics persistence ${action2} via module setting.`);
      }, "onChange")
    };
  }
};
const metricsPersistenceKeySetting = {
  key: SETTING_KEYS.METRICS_PERSISTENCE_KEY,
  createConfig(i18n, logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("MODULE.SETTINGS.metricsPersistenceKey.name", "Metrics Storage Key"),
        "Metrics Storage Key"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.metricsPersistenceKey.hint",
          "LocalStorage key used when metrics persistence is enabled."
        ),
        "LocalStorage key used when metrics persistence is enabled."
      ),
      scope: "world",
      config: true,
      type: "string",
      default: `${MODULE_METADATA.ID}.metrics`,
      onChange: /* @__PURE__ */ __name((value2) => {
        logger.info(`Metrics persistence key set to: ${value2 || "(empty)"}`);
      }, "onChange")
    };
  }
};
const NOTIFICATION_QUEUE_CONSTANTS = {
  minSize: 10,
  maxSize: 1e3,
  defaultSize: 50
};
function getNotificationQueueConstants() {
  return NOTIFICATION_QUEUE_CONSTANTS;
}
__name(getNotificationQueueConstants, "getNotificationQueueConstants");
const notificationQueueMaxSizeSetting = {
  key: SETTING_KEYS.NOTIFICATION_QUEUE_MAX_SIZE,
  createConfig(i18n, logger, _validator) {
    const constants = getNotificationQueueConstants();
    return {
      name: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.notificationQueueMaxSize.name",
          "Notification Queue Max Size"
        ),
        "Notification Queue Max Size"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.notificationQueueMaxSize.hint",
          `Maximum number of notifications queued before UI is available. Range: ${constants.minSize}-${constants.maxSize}.`
        ),
        `Maximum number of notifications queued before UI is available. Range: ${constants.minSize}-${constants.maxSize}.`
      ),
      scope: "world",
      config: true,
      type: "number",
      default: constants.defaultSize,
      onChange: /* @__PURE__ */ __name((value2) => {
        const numericValue = Number(value2);
        const clamped = Math.max(
          constants.minSize,
          Math.min(constants.maxSize, Math.floor(numericValue))
        );
        if (clamped !== numericValue) {
          logger.info(
            `Notification queue max size clamped from ${numericValue} to ${clamped} (range: ${constants.minSize}-${constants.maxSize})`
          );
        } else {
          logger.info(`Notification queue max size updated via settings: ${clamped}`);
        }
      }, "onChange")
    };
  }
};
const journalDirectoryButtonsPlayerSetting = {
  key: SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_PLAYER,
  createConfig(i18n, _logger, _validator) {
    return {
      name: unwrapOr(i18n.translate("USER.RolePlayer", "Player"), "Player"),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.journalDirectoryButtonsPlayer.hint",
          "Allow Players to see the journal directory buttons (Show All Hidden Journals and Overview)."
        ),
        "Allow Players to see the journal directory buttons (Show All Hidden Journals and Overview)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: false
    };
  }
};
const journalDirectoryButtonsTrustedSetting = {
  key: SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_TRUSTED,
  createConfig(i18n, _logger, _validator) {
    return {
      name: unwrapOr(i18n.translate("USER.RoleTrustedPlayer", "Trusted Player"), "Trusted Player"),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.journalDirectoryButtonsTrusted.hint",
          "Allow Trusted Players to see the journal directory buttons (Show All Hidden Journals and Overview)."
        ),
        "Allow Trusted Players to see the journal directory buttons (Show All Hidden Journals and Overview)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: false
    };
  }
};
const journalDirectoryButtonsAssistantSetting = {
  key: SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_ASSISTANT,
  createConfig(i18n, _logger, _validator) {
    return {
      name: unwrapOr(
        i18n.translate("USER.RoleAssistantGM", "Assistant Game Master"),
        "Assistant Game Master"
      ),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.journalDirectoryButtonsAssistant.hint",
          "Allow Assistant Game Masters to see the journal directory buttons (Show All Hidden Journals and Overview)."
        ),
        "Allow Assistant Game Masters to see the journal directory buttons (Show All Hidden Journals and Overview)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: false
    };
  }
};
const journalDirectoryButtonsGamemasterSetting = {
  key: SETTING_KEYS.JOURNAL_DIRECTORY_BUTTONS_GAMEMASTER,
  createConfig(i18n, _logger, _validator) {
    return {
      name: unwrapOr(i18n.translate("USER.RoleGamemaster", "Game Master"), "Game Master"),
      hint: unwrapOr(
        i18n.translate(
          "MODULE.SETTINGS.journalDirectoryButtonsGamemaster.hint",
          "Allow Game Masters to see the journal directory buttons (Show All Hidden Journals and Overview)."
        ),
        "Allow Game Masters to see the journal directory buttons (Show All Hidden Journals and Overview)."
      ),
      scope: "world",
      config: true,
      type: "boolean",
      default: true
    };
  }
};
const _DefaultSettingDefinitionRegistry = class _DefaultSettingDefinitionRegistry {
  getAll() {
    return [
      castSettingDefinitionToUnknown(logLevelSetting),
      castSettingDefinitionToUnknown(cacheEnabledSetting),
      castSettingDefinitionToUnknown(cacheDefaultTtlSetting),
      castSettingDefinitionToUnknown(cacheMaxEntriesSetting),
      castSettingDefinitionToUnknown(performanceTrackingSetting),
      castSettingDefinitionToUnknown(performanceSamplingSetting),
      castSettingDefinitionToUnknown(metricsPersistenceEnabledSetting),
      castSettingDefinitionToUnknown(metricsPersistenceKeySetting),
      castSettingDefinitionToUnknown(notificationQueueMaxSizeSetting),
      castSettingDefinitionToUnknown(journalDirectoryButtonsPlayerSetting),
      castSettingDefinitionToUnknown(journalDirectoryButtonsTrustedSetting),
      castSettingDefinitionToUnknown(journalDirectoryButtonsAssistantSetting),
      castSettingDefinitionToUnknown(journalDirectoryButtonsGamemasterSetting)
    ];
  }
};
__name(_DefaultSettingDefinitionRegistry, "DefaultSettingDefinitionRegistry");
let DefaultSettingDefinitionRegistry = _DefaultSettingDefinitionRegistry;
function createSettingValidators() {
  const customValidators = /* @__PURE__ */ new Map();
  const standardValidators = {
    /**
     * Validates that value is a boolean.
     */
    boolean: /* @__PURE__ */ __name((value2) => typeof value2 === "boolean", "boolean"),
    /**
     * Validates that value is a number.
     */
    number: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2), "number"),
    /**
     * Validates that value is a non-negative number.
     */
    nonNegativeNumber: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2) && value2 >= 0, "nonNegativeNumber"),
    /**
     * Validates that value is a non-negative integer.
     */
    nonNegativeInteger: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && Number.isInteger(value2) && value2 >= 0, "nonNegativeInteger"),
    /**
     * Validates that value is a positive integer (greater than 0).
     */
    positiveInteger: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && Number.isInteger(value2) && value2 > 0, "positiveInteger"),
    /**
     * Validates that value is a string.
     */
    string: /* @__PURE__ */ __name((value2) => typeof value2 === "string", "string"),
    /**
     * Validates that value is a non-empty string.
     */
    nonEmptyString: /* @__PURE__ */ __name((value2) => typeof value2 === "string" && value2.length > 0, "nonEmptyString"),
    /**
     * Validates that value is a number between 0 and 1 (inclusive).
     */
    samplingRate: /* @__PURE__ */ __name((value2) => typeof value2 === "number" && !Number.isNaN(value2) && value2 >= 0 && value2 <= 1, "samplingRate"),
    /**
     * Creates a validator for enum values.
     */
    oneOf: /* @__PURE__ */ __name((validValues) => {
      return (value2) => (typeof value2 === "string" || typeof value2 === "number") && validValues.includes(value2);
    }, "oneOf")
  };
  const registry = {
    register(name, validator) {
      if (name in standardValidators) {
        throw new Error(
          `Cannot override built-in validator: ${name}. Use a different name for your custom validator.`
        );
      }
      if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
        throw new Error(`Invalid validator name: ${name}. Must be a valid JavaScript identifier.`);
      }
      customValidators.set(name, validator);
    },
    get(name) {
      const standard = standardValidators[name];
      if (standard) {
        return standard;
      }
      return customValidators.get(name);
    },
    has(name) {
      return name in standardValidators || customValidators.has(name);
    }
  };
  return new Proxy({ ...standardValidators, ...registry }, {
    get(target, prop2) {
      if (typeof prop2 === "symbol") {
        return target[prop2];
      }
      if (prop2 in standardValidators) {
        return standardValidators[prop2];
      }
      if (prop2 in registry) {
        return registry[prop2];
      }
      const custom2 = customValidators.get(prop2);
      if (custom2) {
        return custom2;
      }
      return target[prop2];
    }
  });
}
__name(createSettingValidators, "createSettingValidators");
const SettingValidators = createSettingValidators();
const isLogLevel = /* @__PURE__ */ __name((value2) => typeof value2 === "number" && value2 >= 0 && value2 <= 3, "isLogLevel");
const runtimeConfigBindings = {
  [SETTING_KEYS.LOG_LEVEL]: {
    runtimeKey: "logLevel",
    validator: isLogLevel,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_ENABLED]: {
    runtimeKey: "enableCacheService",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_TTL_MS]: {
    runtimeKey: "cacheDefaultTtlMs",
    validator: SettingValidators.nonNegativeNumber,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.CACHE_MAX_ENTRIES]: {
    runtimeKey: "cacheMaxEntries",
    validator: SettingValidators.nonNegativeInteger,
    normalize: /* @__PURE__ */ __name((value2) => value2 > 0 ? value2 : void 0, "normalize")
  },
  [SETTING_KEYS.PERFORMANCE_TRACKING_ENABLED]: {
    runtimeKey: "enablePerformanceTracking",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.PERFORMANCE_SAMPLING_RATE]: {
    runtimeKey: "performanceSamplingRate",
    validator: SettingValidators.samplingRate,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.METRICS_PERSISTENCE_ENABLED]: {
    runtimeKey: "enableMetricsPersistence",
    validator: SettingValidators.boolean,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.METRICS_PERSISTENCE_KEY]: {
    runtimeKey: "metricsPersistenceKey",
    validator: SettingValidators.nonEmptyString,
    normalize: /* @__PURE__ */ __name((value2) => value2, "normalize")
  },
  [SETTING_KEYS.NOTIFICATION_QUEUE_MAX_SIZE]: {
    runtimeKey: "notificationQueueMaxSize",
    validator: SettingValidators.positiveInteger,
    normalize: /* @__PURE__ */ __name((value2) => {
      const constants = getNotificationQueueConstants();
      return Math.max(constants.minSize, Math.min(constants.maxSize, Math.floor(value2)));
    }, "normalize")
  }
};
const _DefaultRuntimeConfigBindingRegistry = class _DefaultRuntimeConfigBindingRegistry {
  getAll() {
    const map3 = /* @__PURE__ */ new Map();
    Object.entries(runtimeConfigBindings).forEach(([key2, binding]) => {
      map3.set(key2, castBindingToUnknown(binding));
    });
    return map3;
  }
};
__name(_DefaultRuntimeConfigBindingRegistry, "DefaultRuntimeConfigBindingRegistry");
let DefaultRuntimeConfigBindingRegistry = _DefaultRuntimeConfigBindingRegistry;
function registerRegistrars(container2) {
  const runtimeConfigSyncResult = container2.registerClass(
    runtimeConfigSyncToken,
    DIRuntimeConfigSync,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigSyncResult)) {
    return err(`Failed to register RuntimeConfigSync: ${runtimeConfigSyncResult.error.message}`);
  }
  const runtimeConfigSettingsSyncResult = container2.registerClass(
    runtimeConfigSettingsSyncToken,
    DIRuntimeConfigSettingsSync,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigSettingsSyncResult)) {
    return err(
      `Failed to register RuntimeConfigSettingsSync: ${runtimeConfigSettingsSyncResult.error.message}`
    );
  }
  const errorMapperResult = container2.registerClass(
    settingRegistrationErrorMapperToken,
    DISettingRegistrationErrorMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(errorMapperResult)) {
    return err(
      `Failed to register SettingRegistrationErrorMapper: ${errorMapperResult.error.message}`
    );
  }
  const settingDefinitionRegistryResult = container2.registerClass(
    settingDefinitionRegistryToken,
    DefaultSettingDefinitionRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingDefinitionRegistryResult)) {
    return err(
      `Failed to register SettingDefinitionRegistry: ${settingDefinitionRegistryResult.error.message}`
    );
  }
  const runtimeConfigBindingRegistryResult = container2.registerClass(
    runtimeConfigBindingRegistryToken,
    DefaultRuntimeConfigBindingRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(runtimeConfigBindingRegistryResult)) {
    return err(
      `Failed to register RuntimeConfigBindingRegistry: ${runtimeConfigBindingRegistryResult.error.message}`
    );
  }
  const settingsRegistrarResult = container2.registerClass(
    moduleSettingsRegistrarToken,
    DIModuleSettingsRegistrar,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsRegistrarResult)) {
    return err(
      `Failed to register ModuleSettingsRegistrar: ${settingsRegistrarResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerRegistrars, "registerRegistrars");
registerDependencyStep({
  name: "Registrars",
  priority: 150,
  execute: registerRegistrars
});
const _FoundryJournalEventAdapter = class _FoundryJournalEventAdapter {
  constructor(foundryHooksPort) {
    this.foundryHooksPort = foundryHooksPort;
    this.registrations = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  // ===== Specialized Journal Methods =====
  onJournalCreated(callback) {
    return this.registerFoundryHook(
      "createJournalEntry",
      // Foundry-spezifischer Hook-Name
      (...args2) => {
        const [foundryEntry] = args2;
        const event3 = {
          journalId: this.extractId(foundryEntry),
          timestamp: Date.now()
        };
        callback(event3);
      }
    );
  }
  onJournalUpdated(callback) {
    return this.registerFoundryHook(
      "updateJournalEntry",
      // Foundry-spezifisch
      (...args2) => {
        const [foundryEntry, changes] = args2;
        const event3 = {
          journalId: this.extractId(foundryEntry),
          changes: this.normalizeChanges(changes),
          timestamp: Date.now()
        };
        callback(event3);
      }
    );
  }
  onJournalDeleted(callback) {
    return this.registerFoundryHook("deleteJournalEntry", (...args2) => {
      const [foundryEntry] = args2;
      const event3 = {
        journalId: this.extractId(foundryEntry),
        timestamp: Date.now()
      };
      callback(event3);
    });
  }
  unregisterListener(registrationId) {
    const cleanup = this.registrations.get(registrationId);
    if (!cleanup) {
      return {
        ok: false,
        error: {
          code: "EVENT_UNREGISTRATION_FAILED",
          message: `No registration found for ID ${registrationId}`
        }
      };
    }
    cleanup();
    this.registrations.delete(registrationId);
    return { ok: true, value: void 0 };
  }
  // ===== Lifecycle =====
  /**
   * Cleanup all registered listeners.
   * Should be called during module shutdown.
   */
  dispose() {
    for (const cleanup of this.registrations.values()) {
      cleanup();
    }
    this.registrations.clear();
  }
  // ===== Private Helpers =====
  registerFoundryHook(hookName, callback) {
    const platformCallback = /* @__PURE__ */ __name((event3) => {
      function isArrayOfUnknown(value2) {
        return Array.isArray(value2);
      }
      __name(isArrayOfUnknown, "isArrayOfUnknown");
      if (isArrayOfUnknown(event3)) {
        let isValidArg = /* @__PURE__ */ __name(function(arg) {
          return arg !== null && arg !== void 0;
        }, "isValidArg");
        const validArgs = event3.filter(isValidArg);
        if (validArgs.length > 0) {
          callback(...validArgs);
        }
      } else {
        let isNotNullOrUndefined = /* @__PURE__ */ __name(function(value2) {
          return value2 !== null && value2 !== void 0;
        }, "isNotNullOrUndefined");
        if (isNotNullOrUndefined(event3)) {
          callback(event3);
        }
      }
    }, "platformCallback");
    const result = this.foundryHooksPort.registerListener(hookName, platformCallback);
    if (!result.ok) {
      return result;
    }
    const registrationId = result.value;
    this.registrations.set(registrationId, () => {
      this.foundryHooksPort.unregisterListener(registrationId);
    });
    return { ok: true, value: registrationId };
  }
  extractId(foundryEntry) {
    if (typeof foundryEntry === "object" && foundryEntry !== null && "id" in foundryEntry) {
      const entry = castToRecord(foundryEntry);
      if (typeof entry.id === "string") {
        return entry.id;
      }
    }
    return "";
  }
  normalizeChanges(foundryChanges) {
    if (!foundryChanges || typeof foundryChanges !== "object") {
      return {};
    }
    const changes = normalizeToRecord(foundryChanges);
    const result = { ...changes };
    if (changes.flags !== void 0 && typeof changes.flags === "object" && changes.flags !== null) {
      result.flags = normalizeToRecord(changes.flags);
    }
    if (changes.name !== void 0 && typeof changes.name === "string") {
      result.name = changes.name;
    }
    return result;
  }
};
__name(_FoundryJournalEventAdapter, "FoundryJournalEventAdapter");
let FoundryJournalEventAdapter = _FoundryJournalEventAdapter;
const _DIFoundryJournalEventAdapter = class _DIFoundryJournalEventAdapter extends FoundryJournalEventAdapter {
  constructor(foundryHooksPort) {
    super(foundryHooksPort);
  }
};
__name(_DIFoundryJournalEventAdapter, "DIFoundryJournalEventAdapter");
_DIFoundryJournalEventAdapter.dependencies = [foundryHooksToken];
let DIFoundryJournalEventAdapter = _DIFoundryJournalEventAdapter;
const _FoundryJournalUiEventAdapter = class _FoundryJournalUiEventAdapter {
  constructor(foundryHooksPort) {
    this.foundryHooksPort = foundryHooksPort;
    this.registrations = /* @__PURE__ */ new Map();
    this.nextId = 1;
  }
  // ===== UI Event Methods =====
  onJournalDirectoryRendered(callback) {
    return this.registerFoundryHook("renderJournalDirectory", (app, html2) => {
      const directoryId = this.extractDirectoryId(app);
      if (!directoryId) {
        return;
      }
      const htmlElement3 = this.extractHtmlElement(html2);
      if (!htmlElement3) {
        return;
      }
      const event3 = {
        directoryId,
        timestamp: Date.now()
      };
      callback(event3);
    });
  }
  // ===== Generic Methods (from PlatformEventPort) =====
  registerListener(eventType, callback) {
    return this.registerFoundryHook(eventType, (...args2) => {
      if (args2.length > 0 && typeof args2[0] === "object" && args2[0] !== null) {
        const candidate = args2[0];
        const event3 = this.toJournalUiEvent(candidate);
        if (event3) {
          callback(event3);
        }
      }
    });
  }
  /**
   * Type guard function to convert unknown to JournalUiEvent without type assertion.
   *
   * NOTE: This method is only called from registerListener, which already ensures
   * that candidate is an object and not null. The redundant check was removed
   * to achieve 100% code coverage.
   */
  toJournalUiEvent(candidate) {
    const record2 = castToRecord(candidate);
    if ("directoryId" in record2 && typeof record2.directoryId === "string") {
      return {
        directoryId: record2.directoryId,
        timestamp: typeof record2.timestamp === "number" ? record2.timestamp : Date.now()
      };
    }
    if ("journalId" in record2 && typeof record2.journalId === "string" && "options" in record2 && Array.isArray(record2.options)) {
      const options2 = [];
      const typedRecord = {
        journalId: record2.journalId,
        /* type-coverage:ignore-next-line -- Runtime type check: record.options validated as array above */
        options: record2.options,
        timestamp: typeof record2.timestamp === "number" ? record2.timestamp : void 0
      };
      for (const item of typedRecord.options) {
        if (typeof item === "object" && item !== null && "name" in item && typeof item.name === "string" && "icon" in item && typeof item.icon === "string" && "callback" in item && typeof item.callback === "function") {
          const typedItem = {
            name: item.name,
            icon: item.icon,
            /* type-coverage:ignore-next-line -- Runtime type check: item.callback validated as function above */
            callback: item.callback
          };
          options2.push({
            name: typedItem.name,
            icon: typedItem.icon,
            callback: typedItem.callback
          });
        }
      }
      return {
        journalId: typedRecord.journalId,
        options: options2,
        timestamp: typeof typedRecord.timestamp === "number" ? typedRecord.timestamp : Date.now()
      };
    }
    return null;
  }
  unregisterListener(registrationId) {
    const cleanup = this.registrations.get(registrationId);
    if (!cleanup) {
      return {
        ok: false,
        error: {
          code: "EVENT_UNREGISTRATION_FAILED",
          message: `No registration found for ID ${registrationId}`
        }
      };
    }
    cleanup();
    this.registrations.delete(registrationId);
    return { ok: true, value: void 0 };
  }
  // ===== Lifecycle =====
  /**
   * Cleanup all registered listeners.
   * Should be called during module shutdown.
   */
  dispose() {
    for (const cleanup of this.registrations.values()) {
      cleanup();
    }
    this.registrations.clear();
  }
  // ===== Private Helpers =====
  registerFoundryHook(hookName, callback) {
    const platformCallback = /* @__PURE__ */ __name((event3) => {
      function isArrayOfUnknown(value2) {
        return Array.isArray(value2);
      }
      __name(isArrayOfUnknown, "isArrayOfUnknown");
      if (isArrayOfUnknown(event3)) {
        let isValidArg = /* @__PURE__ */ __name(function(arg) {
          return arg !== null && arg !== void 0;
        }, "isValidArg");
        const validArgs = event3.filter(isValidArg);
        if (validArgs.length > 0) {
          callback(...validArgs);
        }
      } else {
        let isNotNullOrUndefined = /* @__PURE__ */ __name(function(value2) {
          return value2 !== null && value2 !== void 0;
        }, "isNotNullOrUndefined");
        if (isNotNullOrUndefined(event3)) {
          callback(event3);
        }
      }
    }, "platformCallback");
    const result = this.foundryHooksPort.registerListener(hookName, platformCallback);
    if (!result.ok) {
      return result;
    }
    const registrationId = result.value;
    this.registrations.set(registrationId, () => {
      this.foundryHooksPort.unregisterListener(registrationId);
    });
    return { ok: true, value: registrationId };
  }
  extractDirectoryId(app) {
    if (typeof app === "object" && app !== null) {
      if ("id" in app && typeof app.id === "string") {
        return app.id;
      }
      if ("tabName" in app && typeof app.tabName === "string") {
        return app.tabName;
      }
    }
    return "journal";
  }
  extractHtmlElement(htmlInput) {
    if (htmlInput instanceof HTMLElement) return htmlInput;
    return getFirstElementIfArray(htmlInput, (el) => el instanceof HTMLElement);
  }
};
__name(_FoundryJournalUiEventAdapter, "FoundryJournalUiEventAdapter");
let FoundryJournalUiEventAdapter = _FoundryJournalUiEventAdapter;
const _DIFoundryJournalUiEventAdapter = class _DIFoundryJournalUiEventAdapter extends FoundryJournalUiEventAdapter {
  constructor(foundryHooksPort) {
    super(foundryHooksPort);
  }
};
__name(_DIFoundryJournalUiEventAdapter, "DIFoundryJournalUiEventAdapter");
_DIFoundryJournalUiEventAdapter.dependencies = [foundryHooksToken];
let DIFoundryJournalUiEventAdapter = _DIFoundryJournalUiEventAdapter;
const _InvalidateJournalCacheOnChangeUseCase = class _InvalidateJournalCacheOnChangeUseCase {
  constructor(journalEvents, cache3, notifications2) {
    this.journalEvents = journalEvents;
    this.cache = cache3;
    this.notifications = notifications2;
    this.registrationIds = [];
  }
  /**
   * Register event listeners for journal change events.
   */
  register() {
    const results = [
      this.journalEvents.onJournalCreated((event3) => {
        this.invalidateCache("created", event3.journalId);
      }),
      this.journalEvents.onJournalUpdated((event3) => {
        this.invalidateCache("updated", event3.journalId);
        if (event3.changes.flags?.["hidden"] !== void 0) {
          this.triggerUIUpdate(event3.journalId);
        }
      }),
      this.journalEvents.onJournalDeleted((event3) => {
        this.invalidateCache("deleted", event3.journalId);
      })
    ];
    const errors = [];
    for (const result of results) {
      if (result.ok) {
        this.registrationIds.push(result.value);
      } else {
        const error3 = new Error(
          `Failed to register journal event listener: ${result.error.message}`
        );
        errors.push(error3);
        this.notifications.error(
          "Failed to register journal event listener",
          {
            code: result.error.code,
            message: result.error.message,
            details: result.error.details
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (errors.length > 0) {
      this.dispose();
      return err(getFirstArrayElement(errors));
    }
    return ok(void 0);
  }
  /**
   * Invalidate cache entries related to journals.
   */
  invalidateCache(reason, journalId) {
    const removed = this.cache.invalidateWhere((meta3) => meta3.tags.includes("journal:hidden"));
    if (removed > 0) {
      this.notifications.debug(
        `Invalidated ${removed} journal cache entries (${reason})`,
        { journalId },
        { channels: ["ConsoleChannel"] }
      );
    }
  }
  /**
   * Trigger UI update when journal visibility changes.
   */
  triggerUIUpdate(journalId) {
    this.notifications.debug(
      "Journal hidden flag changed, UI update needed",
      { journalId },
      { channels: ["ConsoleChannel"] }
    );
  }
  /**
   * Cleanup: Unregister all event listeners.
   */
  dispose() {
    for (const id2 of this.registrationIds) {
      this.journalEvents.unregisterListener(id2);
    }
    this.registrationIds = [];
  }
};
__name(_InvalidateJournalCacheOnChangeUseCase, "InvalidateJournalCacheOnChangeUseCase");
let InvalidateJournalCacheOnChangeUseCase = _InvalidateJournalCacheOnChangeUseCase;
const _DIInvalidateJournalCacheOnChangeUseCase = class _DIInvalidateJournalCacheOnChangeUseCase extends InvalidateJournalCacheOnChangeUseCase {
  constructor(journalEvents, cache3, notifications2) {
    super(journalEvents, cache3, notifications2);
  }
};
__name(_DIInvalidateJournalCacheOnChangeUseCase, "DIInvalidateJournalCacheOnChangeUseCase");
_DIInvalidateJournalCacheOnChangeUseCase.dependencies = [
  platformJournalEventPortToken,
  cacheInvalidationPortToken,
  notificationPublisherPortToken
];
let DIInvalidateJournalCacheOnChangeUseCase = _DIInvalidateJournalCacheOnChangeUseCase;
const _ProcessJournalDirectoryOnRenderUseCase = class _ProcessJournalDirectoryOnRenderUseCase {
  constructor(journalUiEvents, journalDirectoryUI, journalVisibility, directoryProcessor, notifications2) {
    this.journalUiEvents = journalUiEvents;
    this.journalDirectoryUI = journalDirectoryUI;
    this.journalVisibility = journalVisibility;
    this.directoryProcessor = directoryProcessor;
    this.notifications = notifications2;
  }
  /**
   * Register event listener for directory render events.
   */
  register() {
    const result = this.journalUiEvents.onJournalDirectoryRendered((event3) => {
      this.notifications.debug(
        "Journal directory rendered, processing visibility",
        { timestamp: event3.timestamp, directoryId: event3.directoryId },
        { channels: ["ConsoleChannel"] }
      );
      const hiddenResult = this.journalVisibility.getHiddenJournalEntries();
      if (!hiddenResult.ok) {
        this.notifications.error("Failed to get hidden entries", hiddenResult.error, {
          channels: ["ConsoleChannel"]
        });
        return;
      }
      const processResult = this.directoryProcessor.processDirectory(
        event3.directoryId,
        hiddenResult.value
      );
      if (!processResult.ok) {
        this.notifications.error("Failed to process directory", processResult.error, {
          channels: ["ConsoleChannel"]
        });
      }
    });
    if (result.ok) {
      this.registrationId = result.value;
      return ok(void 0);
    } else {
      return err(new Error(result.error.message));
    }
  }
  /**
   * Cleanup: Unregister event listener.
   */
  dispose() {
    if (this.registrationId !== void 0) {
      this.journalUiEvents.unregisterListener(this.registrationId);
      this.registrationId = void 0;
    }
  }
};
__name(_ProcessJournalDirectoryOnRenderUseCase, "ProcessJournalDirectoryOnRenderUseCase");
let ProcessJournalDirectoryOnRenderUseCase = _ProcessJournalDirectoryOnRenderUseCase;
const _DIProcessJournalDirectoryOnRenderUseCase = class _DIProcessJournalDirectoryOnRenderUseCase extends ProcessJournalDirectoryOnRenderUseCase {
  constructor(journalUiEvents, journalDirectoryUI, journalVisibility, directoryProcessor, notifications2) {
    super(
      journalUiEvents,
      journalDirectoryUI,
      journalVisibility,
      directoryProcessor,
      notifications2
    );
  }
};
__name(_DIProcessJournalDirectoryOnRenderUseCase, "DIProcessJournalDirectoryOnRenderUseCase");
_DIProcessJournalDirectoryOnRenderUseCase.dependencies = [
  platformJournalUiEventPortToken,
  platformJournalDirectoryUiPortToken,
  journalVisibilityServiceToken,
  journalDirectoryProcessorToken,
  notificationPublisherPortToken
];
let DIProcessJournalDirectoryOnRenderUseCase = _DIProcessJournalDirectoryOnRenderUseCase;
const DOMAIN_FLAGS = {
  /** Flag key für versteckte Journal-Einträge */
  HIDDEN: "hidden"
};
const DOMAIN_EVENTS = {
  /** Event: Journal Directory wird gerendert */
  RENDER_JOURNAL_DIRECTORY: "renderJournalDirectory",
  /** Event: System-Initialisierung */
  INIT: "init",
  /** Event: System ist bereit */
  READY: "ready",
  /** Event: Journal Entry wird erstellt */
  CREATE_JOURNAL_ENTRY: "createJournalEntry",
  /** Event: Journal Entry wird aktualisiert */
  UPDATE_JOURNAL_ENTRY: "updateJournalEntry",
  /** Event: Journal Entry wird gelöscht */
  DELETE_JOURNAL_ENTRY: "deleteJournalEntry"
};
Object.freeze(DOMAIN_FLAGS);
Object.freeze(DOMAIN_EVENTS);
const _TriggerJournalDirectoryReRenderUseCase = class _TriggerJournalDirectoryReRenderUseCase {
  constructor(journalEvents, scheduler, notifications2) {
    this.journalEvents = journalEvents;
    this.scheduler = scheduler;
    this.notifications = notifications2;
  }
  /**
   * Register event listener for journal update events.
   */
  register() {
    const result = this.journalEvents.onJournalUpdated((event3) => {
      const moduleId = MODULE_METADATA.ID;
      const flagKey = DOMAIN_FLAGS.HIDDEN;
      const moduleFlags = event3.changes.flags?.[moduleId];
      if (moduleFlags && typeof moduleFlags === "object" && flagKey in moduleFlags) {
        this.scheduler.requestRerender();
      }
    });
    if (result.ok) {
      this.registrationId = result.value;
      return ok(void 0);
    } else {
      return err(new Error(result.error.message));
    }
  }
  /**
   * Cleanup: Unregister event listener.
   */
  dispose() {
    if (this.registrationId !== void 0) {
      this.journalEvents.unregisterListener(this.registrationId);
      this.registrationId = void 0;
    }
  }
};
__name(_TriggerJournalDirectoryReRenderUseCase, "TriggerJournalDirectoryReRenderUseCase");
let TriggerJournalDirectoryReRenderUseCase = _TriggerJournalDirectoryReRenderUseCase;
const _DITriggerJournalDirectoryReRenderUseCase = class _DITriggerJournalDirectoryReRenderUseCase extends TriggerJournalDirectoryReRenderUseCase {
  constructor(journalEvents, scheduler, notifications2) {
    super(journalEvents, scheduler, notifications2);
  }
};
__name(_DITriggerJournalDirectoryReRenderUseCase, "DITriggerJournalDirectoryReRenderUseCase");
_DITriggerJournalDirectoryReRenderUseCase.dependencies = [
  platformJournalEventPortToken,
  journalDirectoryRerenderSchedulerToken,
  notificationPublisherPortToken
];
let DITriggerJournalDirectoryReRenderUseCase = _DITriggerJournalDirectoryReRenderUseCase;
const _RegisterContextMenuUseCase = class _RegisterContextMenuUseCase {
  constructor(contextMenuRegistration, handlers2, logger) {
    this.contextMenuRegistration = contextMenuRegistration;
    this.handlers = handlers2;
    this.logger = logger;
  }
  /**
   * Register callback for context menu events.
   * All handlers are called for each context menu event.
   * Errors in individual handlers are caught and logged, but don't stop other handlers.
   */
  register() {
    this.callback = (event3) => {
      for (const handler of this.handlers) {
        try {
          handler.handle(event3);
        } catch (error3) {
          const handlerError = error3 instanceof Error ? error3 : new Error(String(error3));
          this.logger.warn(`Context menu handler failed: ${handlerError.message}`, {
            error: handlerError,
            handler: handler.constructor.name
          });
        }
      }
    };
    this.contextMenuRegistration.addCallback(this.callback);
    return ok(void 0);
  }
  /**
   * Cleanup: Unregister callback.
   */
  dispose() {
    if (this.callback !== void 0) {
      this.contextMenuRegistration.removeCallback(this.callback);
      this.callback = void 0;
    }
  }
};
__name(_RegisterContextMenuUseCase, "RegisterContextMenuUseCase");
let RegisterContextMenuUseCase = _RegisterContextMenuUseCase;
const _DIRegisterContextMenuUseCase = class _DIRegisterContextMenuUseCase extends RegisterContextMenuUseCase {
  constructor(contextMenuRegistration, handlers2, logger) {
    super(contextMenuRegistration, handlers2, logger);
  }
};
__name(_DIRegisterContextMenuUseCase, "DIRegisterContextMenuUseCase");
_DIRegisterContextMenuUseCase.dependencies = [
  platformContextMenuRegistrationPortToken,
  journalContextMenuHandlersToken,
  platformLoggingPortToken
];
let DIRegisterContextMenuUseCase = _DIRegisterContextMenuUseCase;
const _ShowAllHiddenJournalsUseCase = class _ShowAllHiddenJournalsUseCase {
  constructor(journalCollection, journalRepository, scheduler, notifications2, config2) {
    this.journalCollection = journalCollection;
    this.journalRepository = journalRepository;
    this.scheduler = scheduler;
    this.notifications = notifications2;
    this.config = config2;
  }
  /**
   * Execute the use-case: Show all hidden journals.
   *
   * @returns Result with number of journals that were unhidden, or error
   */
  async execute() {
    const allJournalsResult = this.journalCollection.getAll();
    if (!allJournalsResult.ok) {
      return err(new Error(`Failed to get all journals: ${allJournalsResult.error.message}`));
    }
    const allJournals = allJournalsResult.value;
    const journalsToUpdate = [];
    for (const journal of allJournals) {
      try {
        const flagResult = this.journalRepository.getFlag(
          journal.id,
          this.config.moduleNamespace,
          this.config.hiddenFlagKey
        );
        if (!flagResult.ok) {
          this.notifications.warn(
            `Failed to read hidden flag for journal "${journal.name ?? journal.id}"`,
            {
              errorCode: flagResult.error.code,
              errorMessage: flagResult.error.message,
              journalId: journal.id
            },
            { channels: ["ConsoleChannel"] }
          );
          continue;
        }
        const currentFlag = flagResult.value;
        if (currentFlag !== false) {
          journalsToUpdate.push({ journal, journalId: journal.id });
        }
      } catch (error3) {
        const errorMessage = error3 instanceof Error ? error3.message : String(error3);
        this.notifications.warn(
          `Unexpected error checking journal "${journal.name ?? journal.id}"`,
          {
            error: errorMessage,
            journalId: journal.id
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    let changedCount = 0;
    const errors = [];
    for (const { journal, journalId } of journalsToUpdate) {
      try {
        const setFlagResult = await this.journalRepository.setFlag(
          journalId,
          this.config.moduleNamespace,
          this.config.hiddenFlagKey,
          false
        );
        if (!setFlagResult.ok) {
          errors.push({
            journalId,
            error: `Failed to set flag: ${setFlagResult.error.message}`
          });
          this.notifications.warn(
            `Failed to set hidden flag for journal "${journal.name ?? journalId}"`,
            {
              errorCode: setFlagResult.error.code,
              errorMessage: setFlagResult.error.message,
              journalId
            },
            { channels: ["ConsoleChannel"] }
          );
          continue;
        }
        changedCount++;
      } catch (error3) {
        const errorMessage = error3 instanceof Error ? error3.message : String(error3);
        errors.push({
          journalId,
          error: errorMessage
        });
        this.notifications.warn(
          `Unexpected error processing journal "${journal.name ?? journalId}"`,
          {
            error: errorMessage,
            journalId
          },
          { channels: ["ConsoleChannel"] }
        );
      }
    }
    if (changedCount > 0) {
      this.notifications.info(
        `${changedCount} ${changedCount === 1 ? "Journal" : "Journale"} wieder eingeblendet`,
        {
          count: changedCount
        }
      );
    } else {
      this.notifications.info("Keine versteckten Journale gefunden", {});
    }
    if (errors.length > 0) {
      this.notifications.warn(
        `${errors.length} Fehler beim Verarbeiten von Journals`,
        {
          errorCount: errors.length,
          errors: errors.slice(0, 5)
          // Only show first 5 errors
        },
        { channels: ["ConsoleChannel"] }
      );
    }
    if (changedCount > 0) {
      this.scheduler.requestRerender();
    }
    return ok(changedCount);
  }
};
__name(_ShowAllHiddenJournalsUseCase, "ShowAllHiddenJournalsUseCase");
let ShowAllHiddenJournalsUseCase = _ShowAllHiddenJournalsUseCase;
const _DIShowAllHiddenJournalsUseCase = class _DIShowAllHiddenJournalsUseCase extends ShowAllHiddenJournalsUseCase {
  constructor(journalCollection, journalRepository, scheduler, notifications2, config2) {
    super(journalCollection, journalRepository, scheduler, notifications2, config2);
  }
};
__name(_DIShowAllHiddenJournalsUseCase, "DIShowAllHiddenJournalsUseCase");
_DIShowAllHiddenJournalsUseCase.dependencies = [
  platformJournalCollectionPortToken,
  platformJournalRepositoryToken,
  journalDirectoryRerenderSchedulerToken,
  notificationPublisherPortToken,
  journalVisibilityConfigToken
];
let DIShowAllHiddenJournalsUseCase = _DIShowAllHiddenJournalsUseCase;
const _JournalOverviewService = class _JournalOverviewService {
  constructor(journalCollection, journalVisibility, journalPermission, notifications2) {
    this.journalCollection = journalCollection;
    this.journalVisibility = journalVisibility;
    this.journalPermission = journalPermission;
    this.notifications = notifications2;
  }
  /**
   * Gets all journals with their visibility status.
   *
   * @returns Result with array of journals and their visibility status, or error
   */
  getAllJournalsWithVisibilityStatus() {
    const allJournalsResult = this.journalCollection.getAll();
    if (!allJournalsResult.ok) {
      return {
        ok: false,
        error: new Error(`Failed to get all journals: ${allJournalsResult.error.message}`)
      };
    }
    let allJournals = allJournalsResult.value;
    const accessibleJournals = [];
    for (const journal of allJournals) {
      const permissionResult = this.journalPermission.canUserViewJournal(journal.id);
      if (!permissionResult.ok) {
        this.notifications.warn(
          `Failed to check permission for journal "${journal.name ?? journal.id}", showing it anyway`,
          {
            errorCode: permissionResult.error.code,
            errorMessage: permissionResult.error.message,
            journalId: journal.id
          },
          { channels: ["ConsoleChannel"] }
        );
        accessibleJournals.push(journal);
      } else if (permissionResult.value) {
        accessibleJournals.push(journal);
      }
    }
    allJournals = accessibleJournals;
    const hiddenJournalsResult = this.journalVisibility.getHiddenJournalEntries();
    if (!hiddenJournalsResult.ok) {
      this.notifications.warn(
        "Failed to get hidden journals, showing all as visible",
        {
          errorCode: hiddenJournalsResult.error.code,
          errorMessage: hiddenJournalsResult.error.message
        },
        { channels: ["ConsoleChannel"] }
      );
    }
    const hiddenJournals = hiddenJournalsResult.ok ? hiddenJournalsResult.value : [];
    const hiddenJournalIds = new Set(hiddenJournals.map((j) => j.id));
    const journalsWithVisibility = allJournals.map((journal) => ({
      id: journal.id,
      name: journal.name,
      isHidden: hiddenJournalIds.has(journal.id)
    }));
    this.notifications.debug(
      `Retrieved ${journalsWithVisibility.length} journals with visibility status`,
      {
        total: journalsWithVisibility.length,
        hidden: hiddenJournalIds.size,
        visible: journalsWithVisibility.length - hiddenJournalIds.size
      },
      { channels: ["ConsoleChannel"] }
    );
    return {
      ok: true,
      value: journalsWithVisibility
    };
  }
};
__name(_JournalOverviewService, "JournalOverviewService");
let JournalOverviewService = _JournalOverviewService;
const _DIJournalOverviewService = class _DIJournalOverviewService extends JournalOverviewService {
  constructor(journalCollection, journalVisibility, journalPermission, notifications2) {
    super(journalCollection, journalVisibility, journalPermission, notifications2);
  }
};
__name(_DIJournalOverviewService, "DIJournalOverviewService");
_DIJournalOverviewService.dependencies = [
  platformJournalCollectionPortToken,
  journalVisibilityServiceToken,
  platformJournalPermissionPortToken,
  notificationPublisherPortToken
];
let DIJournalOverviewService = _DIJournalOverviewService;
const _HideJournalContextMenuHandler = class _HideJournalContextMenuHandler {
  constructor(journalRepository, platformUI, notifications2) {
    this.journalRepository = journalRepository;
    this.platformUI = platformUI;
    this.notifications = notifications2;
  }
  handle(event3) {
    const journalId = event3.journalId;
    if (!journalId) {
      return;
    }
    const flagResult = this.journalRepository.getFlag(
      journalId,
      MODULE_METADATA.ID,
      DOMAIN_FLAGS.HIDDEN
    );
    if (flagResult.ok && flagResult.value !== true) {
      const eventJournalId = journalId;
      event3.options.push({
        name: "Journal ausblenden",
        icon: '<i class="fas fa-eye-slash"></i>',
        callback: /* @__PURE__ */ __name(async (journalIdParam) => {
          if (journalIdParam !== eventJournalId) {
            this.notifications.error(
              `Journal ID mismatch in context menu callback: expected ${eventJournalId}, got ${journalIdParam}`,
              {
                code: "JOURNAL_ID_MISMATCH",
                message: `Expected journalId ${eventJournalId} but received ${journalIdParam}`,
                details: {
                  expectedJournalId: eventJournalId,
                  receivedJournalId: journalIdParam
                }
              },
              { channels: ["ConsoleChannel"] }
            );
            return;
          }
          const hideResult = await this.journalRepository.setFlag(
            journalIdParam,
            MODULE_METADATA.ID,
            DOMAIN_FLAGS.HIDDEN,
            true
          );
          if (hideResult.ok) {
            const journalEntryResult = this.journalRepository.getById(journalIdParam);
            const journalName = journalEntryResult.ok && journalEntryResult.value ? journalEntryResult.value.name ?? journalIdParam : journalIdParam;
            const notifyResult = this.platformUI.notify(
              `Journal "${journalName}" wurde ausgeblendet`,
              "info"
            );
            if (!notifyResult.ok) {
              this.notifications.warn(
                "Failed to show notification after hiding journal",
                notifyResult.error,
                { channels: ["ConsoleChannel"] }
              );
            }
            this.notifications.debug(
              `Journal ${journalIdParam} (${journalName}) hidden via context menu`,
              { journalId: journalIdParam, journalName },
              { channels: ["ConsoleChannel"] }
            );
          } else {
            this.notifications.error(
              `Failed to hide journal ${journalIdParam}`,
              { code: hideResult.error.code, message: hideResult.error.message },
              {
                channels: ["ConsoleChannel", "UINotificationChannel"]
              }
            );
          }
        }, "callback")
      });
    }
  }
};
__name(_HideJournalContextMenuHandler, "HideJournalContextMenuHandler");
let HideJournalContextMenuHandler = _HideJournalContextMenuHandler;
const _DIHideJournalContextMenuHandler = class _DIHideJournalContextMenuHandler extends HideJournalContextMenuHandler {
  constructor(journalRepository, platformUI, notifications2) {
    super(journalRepository, platformUI, notifications2);
  }
};
__name(_DIHideJournalContextMenuHandler, "DIHideJournalContextMenuHandler");
_DIHideJournalContextMenuHandler.dependencies = [
  platformJournalRepositoryToken,
  platformUIPortToken,
  notificationPublisherPortToken
];
let DIHideJournalContextMenuHandler = _DIHideJournalContextMenuHandler;
function disposeHooks(hooks) {
  for (const hook2 of hooks) {
    hook2.dispose();
  }
}
__name(disposeHooks, "disposeHooks");
const _ModuleEventRegistrar = class _ModuleEventRegistrar {
  constructor(registry, notifications2) {
    this.registry = registry;
    this.notifications = notifications2;
    this.eventRegistrars = registry.getAll();
  }
  /**
   * Registers all event listeners.
   *
   * NOTE: Container parameter removed - event listeners receive all dependencies via constructor injection.
   */
  registerAll() {
    const errors = [];
    for (const registrar of this.eventRegistrars) {
      const result = registrar.register();
      if (!result.ok) {
        const error3 = {
          code: "EVENT_REGISTRATION_FAILED",
          message: result.error.message
        };
        this.notifications.error("Failed to register event listener", error3, {
          channels: ["ConsoleChannel"]
        });
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      return err(errors);
    }
    return ok(void 0);
  }
  /**
   * Dispose all event listeners.
   * Called when the module is disabled or reloaded.
   */
  disposeAll() {
    disposeHooks(this.eventRegistrars);
  }
};
__name(_ModuleEventRegistrar, "ModuleEventRegistrar");
let ModuleEventRegistrar = _ModuleEventRegistrar;
const _DIModuleEventRegistrar = class _DIModuleEventRegistrar extends ModuleEventRegistrar {
  constructor(registry, notifications2) {
    super(registry, notifications2);
  }
};
__name(_DIModuleEventRegistrar, "DIModuleEventRegistrar");
_DIModuleEventRegistrar.dependencies = [eventRegistrarRegistryToken, notificationPublisherPortToken];
let DIModuleEventRegistrar = _DIModuleEventRegistrar;
function debounce$1(fn3, delayMs) {
  let timeoutId = null;
  const debounced = /* @__PURE__ */ __name(function(...args2) {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn3(...args2);
      timeoutId = null;
    }, delayMs);
  }, "debounced");
  debounced.cancel = function() {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  return debounced;
}
__name(debounce$1, "debounce$1");
const _JournalDirectoryRerenderScheduler = class _JournalDirectoryRerenderScheduler {
  // 100ms debounce delay
  constructor(journalDirectoryUI, notifications2) {
    this.journalDirectoryUI = journalDirectoryUI;
    this.notifications = notifications2;
    this.delayMs = 100;
    this.debouncedRerender = debounce$1(() => {
      this.executeRerender();
    }, this.delayMs);
  }
  /**
   * Request a journal directory re-render.
   *
   * Multiple rapid calls will be coalesced into a single re-render
   * after the debounce delay (100ms).
   */
  requestRerender() {
    this.debouncedRerender();
  }
  /**
   * Execute the actual re-render.
   */
  executeRerender() {
    const result = this.journalDirectoryUI.rerenderJournalDirectory();
    if (!result.ok) {
      this.notifications.warn("Failed to re-render journal directory", result.error, {
        channels: ["ConsoleChannel"]
      });
      return;
    }
    if (result.value) {
      this.notifications.debug(
        "Triggered journal directory re-render (debounced)",
        {},
        { channels: ["ConsoleChannel"] }
      );
    }
  }
  /**
   * Cancel any pending re-render.
   *
   * Useful for cleanup or when re-render is no longer needed.
   */
  cancelPending() {
    this.debouncedRerender.cancel();
  }
};
__name(_JournalDirectoryRerenderScheduler, "JournalDirectoryRerenderScheduler");
let JournalDirectoryRerenderScheduler = _JournalDirectoryRerenderScheduler;
const _DIJournalDirectoryRerenderScheduler = class _DIJournalDirectoryRerenderScheduler extends JournalDirectoryRerenderScheduler {
  constructor(journalDirectoryUI, notifications2) {
    super(journalDirectoryUI, notifications2);
  }
};
__name(_DIJournalDirectoryRerenderScheduler, "DIJournalDirectoryRerenderScheduler");
_DIJournalDirectoryRerenderScheduler.dependencies = [
  platformJournalDirectoryUiPortToken,
  notificationPublisherPortToken
];
let DIJournalDirectoryRerenderScheduler = _DIJournalDirectoryRerenderScheduler;
const _DefaultEventRegistrarRegistry = class _DefaultEventRegistrarRegistry {
  constructor(eventRegistrars) {
    this.eventRegistrars = eventRegistrars;
  }
  getAll() {
    return this.eventRegistrars;
  }
};
__name(_DefaultEventRegistrarRegistry, "DefaultEventRegistrarRegistry");
let DefaultEventRegistrarRegistry = _DefaultEventRegistrarRegistry;
function resolveMultipleServices(container2, tokens2) {
  const results = [];
  for (const { token, name } of tokens2) {
    const result = container2.resolveWithError(token);
    if (!result.ok) {
      throw new Error(`Failed to resolve ${name}: ${result.error.message}`);
    }
    results.push(castResolvedService$1(result.value));
  }
  return results;
}
__name(resolveMultipleServices, "resolveMultipleServices");
function registerEventPorts(container2) {
  const eventPortResult = container2.registerClass(
    platformJournalEventPortToken,
    DIFoundryJournalEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventPortResult)) {
    return err(`Failed to register PlatformJournalEventPort: ${eventPortResult.error.message}`);
  }
  const uiEventPortResult = container2.registerClass(
    platformJournalUiEventPortToken,
    DIFoundryJournalUiEventAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(uiEventPortResult)) {
    return err(`Failed to register PlatformJournalUiEventPort: ${uiEventPortResult.error.message}`);
  }
  const cacheInvalidationUseCaseResult = container2.registerClass(
    invalidateJournalCacheOnChangeUseCaseToken,
    DIInvalidateJournalCacheOnChangeUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(cacheInvalidationUseCaseResult)) {
    return err(
      `Failed to register InvalidateJournalCacheOnChangeUseCase: ${cacheInvalidationUseCaseResult.error.message}`
    );
  }
  const directoryRenderUseCaseResult = container2.registerClass(
    processJournalDirectoryOnRenderUseCaseToken,
    DIProcessJournalDirectoryOnRenderUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(directoryRenderUseCaseResult)) {
    return err(
      `Failed to register ProcessJournalDirectoryOnRenderUseCase: ${directoryRenderUseCaseResult.error.message}`
    );
  }
  const schedulerResult = container2.registerClass(
    journalDirectoryRerenderSchedulerToken,
    DIJournalDirectoryRerenderScheduler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(schedulerResult)) {
    return err(
      `Failed to register JournalDirectoryRerenderScheduler: ${schedulerResult.error.message}`
    );
  }
  const reRenderUseCaseResult = container2.registerClass(
    triggerJournalDirectoryReRenderUseCaseToken,
    DITriggerJournalDirectoryReRenderUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(reRenderUseCaseResult)) {
    return err(
      `Failed to register TriggerJournalDirectoryReRenderUseCase: ${reRenderUseCaseResult.error.message}`
    );
  }
  const hideJournalHandlerResult = container2.registerClass(
    hideJournalContextMenuHandlerToken,
    DIHideJournalContextMenuHandler,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(hideJournalHandlerResult)) {
    return err(
      `Failed to register HideJournalContextMenuHandler: ${hideJournalHandlerResult.error.message}`
    );
  }
  const handlersArrayResult = container2.registerFactory(
    journalContextMenuHandlersToken,
    () => {
      return resolveMultipleServices(container2, [
        { token: hideJournalContextMenuHandlerToken, name: "HideJournalContextMenuHandler" }
      ]);
    },
    ServiceLifecycle.SINGLETON,
    [hideJournalContextMenuHandlerToken]
  );
  if (isErr(handlersArrayResult)) {
    return err(
      `Failed to register JournalContextMenuHandlers array: ${handlersArrayResult.error.message}`
    );
  }
  const contextMenuUseCaseResult = container2.registerClass(
    registerContextMenuUseCaseToken,
    DIRegisterContextMenuUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(contextMenuUseCaseResult)) {
    return err(
      `Failed to register RegisterContextMenuUseCase: ${contextMenuUseCaseResult.error.message}`
    );
  }
  const showAllHiddenJournalsUseCaseResult = container2.registerClass(
    showAllHiddenJournalsUseCaseToken,
    DIShowAllHiddenJournalsUseCase,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(showAllHiddenJournalsUseCaseResult)) {
    return err(
      `Failed to register ShowAllHiddenJournalsUseCase: ${showAllHiddenJournalsUseCaseResult.error.message}`
    );
  }
  const journalOverviewServiceResult = container2.registerClass(
    journalOverviewServiceToken,
    DIJournalOverviewService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(journalOverviewServiceResult)) {
    return err(
      `Failed to register JournalOverviewService: ${journalOverviewServiceResult.error.message}`
    );
  }
  const eventRegistrarRegistryResult = container2.registerFactory(
    eventRegistrarRegistryToken,
    () => {
      const eventRegistrars = resolveMultipleServices(container2, [
        {
          token: processJournalDirectoryOnRenderUseCaseToken,
          name: "ProcessJournalDirectoryOnRenderUseCase"
        },
        {
          token: invalidateJournalCacheOnChangeUseCaseToken,
          name: "InvalidateJournalCacheOnChangeUseCase"
        },
        {
          token: triggerJournalDirectoryReRenderUseCaseToken,
          name: "TriggerJournalDirectoryReRenderUseCase"
        }
      ]);
      return new DefaultEventRegistrarRegistry(eventRegistrars);
    },
    ServiceLifecycle.SINGLETON,
    [
      processJournalDirectoryOnRenderUseCaseToken,
      invalidateJournalCacheOnChangeUseCaseToken,
      triggerJournalDirectoryReRenderUseCaseToken
    ]
  );
  if (isErr(eventRegistrarRegistryResult)) {
    return err(
      `Failed to register EventRegistrarRegistry: ${eventRegistrarRegistryResult.error.message}`
    );
  }
  const eventRegistrarResult = container2.registerClass(
    moduleEventRegistrarToken,
    DIModuleEventRegistrar,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventRegistrarResult)) {
    return err(`Failed to register ModuleEventRegistrar: ${eventRegistrarResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerEventPorts, "registerEventPorts");
registerDependencyStep({
  name: "EventPorts",
  priority: 140,
  execute: registerEventPorts
});
const _JournalMapperRegistry = class _JournalMapperRegistry {
  constructor() {
    this.mappers = [];
  }
  /**
   * Registers a mapper with the registry.
   *
   * Mappers are checked in registration order (first registered = highest priority).
   * The first mapper that returns true for `supports()` will be used.
   *
   * @param mapper - The mapper to register
   * @throws Error if the mapper is already registered
   */
  register(mapper) {
    if (this.mappers.includes(mapper)) {
      throw new Error("Mapper is already registered");
    }
    this.mappers.push(mapper);
  }
  /**
   * Unregisters a mapper from the registry.
   *
   * @param mapper - The mapper to unregister
   */
  unregister(mapper) {
    const index2 = this.mappers.indexOf(mapper);
    if (index2 !== -1) {
      this.mappers.splice(index2, 1);
    }
  }
  /**
   * Returns all registered mappers in priority order.
   *
   * @returns Array of mappers (first = highest priority)
   */
  getAll() {
    return [...this.mappers];
  }
  /**
   * Finds the first mapper that supports the given entity.
   *
   * @param entity - The Foundry entity to find a mapper for
   * @returns The first matching mapper, or undefined if none found
   */
  findMapper(entity) {
    return this.mappers.find((mapper) => mapper.supports(entity));
  }
  /**
   * Maps a Foundry journal entry to a domain journal entry using the first matching mapper.
   *
   * @param entity - The Foundry journal entry to map
   * @returns The domain journal entry
   * @throws Error if no mapper supports the entity
   */
  mapToDomain(entity) {
    const mapper = this.findMapper(entity);
    if (!mapper) {
      throw new Error(`No mapper found for entity: ${JSON.stringify(entity).substring(0, 100)}`);
    }
    if (!mapper.supports(entity)) {
      throw new Error(
        `Mapper supports() returned false after findMapper() returned it: ${mapper.constructor.name}`
      );
    }
    return mapper.toDomain(entity);
  }
  /**
   * Validates that no two mappers have overlapping support.
   *
   * This is useful for detecting configuration errors during development.
   * Note: This is a best-effort check and may not catch all overlaps.
   *
   * @param testEntities - Optional array of test entities to check against
   * @returns Array of conflicts (empty if none)
   */
  validateNoOverlaps(testEntities = []) {
    const conflicts = [];
    for (const entity of testEntities) {
      const matchingMappers = this.mappers.filter((mapper) => mapper.supports(entity));
      if (matchingMappers.length > 1) {
        conflicts.push({
          entity,
          mappers: matchingMappers
        });
      }
    }
    return conflicts;
  }
};
__name(_JournalMapperRegistry, "JournalMapperRegistry");
let JournalMapperRegistry = _JournalMapperRegistry;
const _DefaultJournalMapper = class _DefaultJournalMapper {
  /**
   * Type guard: checks if entity is a Foundry journal entry.
   *
   * Supports any object with an `id` property (basic check).
   * More specific mappers should be registered before this one.
   *
   * @param entity - The entity to check
   * @returns True if entity has id property
   */
  supports(entity) {
    return typeof entity === "object" && entity !== null && "id" in entity && typeof entity.id === "string";
  }
  /**
   * Maps a Foundry journal entry to a domain journal entry.
   *
   * @param entity - The Foundry journal entry
   * @returns The domain journal entry
   */
  toDomain(entity) {
    return {
      id: entity.id,
      name: entity.name ?? null
    };
  }
};
__name(_DefaultJournalMapper, "DefaultJournalMapper");
let DefaultJournalMapper = _DefaultJournalMapper;
const _FilterOperatorRegistry = class _FilterOperatorRegistry {
  constructor() {
    this.operators = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a filter operator.
   *
   * @param operator - The operator to register
   * @throws Error if an operator with the same name is already registered
   */
  register(operator) {
    if (this.operators.has(operator.name)) {
      throw new Error(
        `Filter operator "${operator.name}" is already registered. Use unregister() first to replace an existing operator.`
      );
    }
    this.operators.set(operator.name, operator);
  }
  /**
   * Unregisters a filter operator.
   *
   * @param name - The name of the operator to unregister
   * @returns true if the operator was unregistered, false if it wasn't registered
   */
  unregister(name) {
    return this.operators.delete(name);
  }
  /**
   * Gets a filter operator by name.
   *
   * @param name - The name of the operator
   * @returns The operator if found, undefined otherwise
   */
  get(name) {
    return this.operators.get(name);
  }
  /**
   * Checks if an operator is registered.
   *
   * @param name - The name of the operator
   * @returns true if registered, false otherwise
   */
  has(name) {
    return this.operators.has(name);
  }
  /**
   * Gets all registered operator names.
   *
   * @returns Array of operator names
   */
  getOperatorNames() {
    return Array.from(this.operators.keys());
  }
};
__name(_FilterOperatorRegistry, "FilterOperatorRegistry");
let FilterOperatorRegistry = _FilterOperatorRegistry;
const _EqualsOperator = class _EqualsOperator {
  constructor() {
    this.name = "equals";
  }
  matches(fieldValue, filterValue) {
    return fieldValue === filterValue;
  }
};
__name(_EqualsOperator, "EqualsOperator");
let EqualsOperator = _EqualsOperator;
const _NotEqualsOperator = class _NotEqualsOperator {
  constructor() {
    this.name = "notEquals";
  }
  matches(fieldValue, filterValue) {
    return fieldValue !== filterValue;
  }
};
__name(_NotEqualsOperator, "NotEqualsOperator");
let NotEqualsOperator = _NotEqualsOperator;
const _ContainsOperator = class _ContainsOperator {
  constructor() {
    this.name = "contains";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().includes(String(filterValue).toLowerCase());
  }
};
__name(_ContainsOperator, "ContainsOperator");
let ContainsOperator = _ContainsOperator;
const _StartsWithOperator = class _StartsWithOperator {
  constructor() {
    this.name = "startsWith";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().startsWith(String(filterValue).toLowerCase());
  }
};
__name(_StartsWithOperator, "StartsWithOperator");
let StartsWithOperator = _StartsWithOperator;
const _EndsWithOperator = class _EndsWithOperator {
  constructor() {
    this.name = "endsWith";
  }
  matches(fieldValue, filterValue) {
    return String(fieldValue).toLowerCase().endsWith(String(filterValue).toLowerCase());
  }
};
__name(_EndsWithOperator, "EndsWithOperator");
let EndsWithOperator = _EndsWithOperator;
const _InOperator = class _InOperator {
  constructor() {
    this.name = "in";
  }
  matches(fieldValue, filterValue) {
    if (!Array.isArray(filterValue)) {
      return false;
    }
    const filterArray = filterValue;
    return filterArray.includes(fieldValue);
  }
};
__name(_InOperator, "InOperator");
let InOperator = _InOperator;
const _NotInOperator = class _NotInOperator {
  constructor() {
    this.name = "notIn";
  }
  matches(fieldValue, filterValue) {
    if (!Array.isArray(filterValue)) {
      return false;
    }
    const filterArray = filterValue;
    return !filterArray.includes(fieldValue);
  }
};
__name(_NotInOperator, "NotInOperator");
let NotInOperator = _NotInOperator;
const _GreaterThanOperator = class _GreaterThanOperator {
  constructor() {
    this.name = "greaterThan";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) > Number(filterValue);
  }
};
__name(_GreaterThanOperator, "GreaterThanOperator");
let GreaterThanOperator = _GreaterThanOperator;
const _LessThanOperator = class _LessThanOperator {
  constructor() {
    this.name = "lessThan";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) < Number(filterValue);
  }
};
__name(_LessThanOperator, "LessThanOperator");
let LessThanOperator = _LessThanOperator;
const _GreaterThanOrEqualOperator = class _GreaterThanOrEqualOperator {
  constructor() {
    this.name = "greaterThanOrEqual";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) >= Number(filterValue);
  }
};
__name(_GreaterThanOrEqualOperator, "GreaterThanOrEqualOperator");
let GreaterThanOrEqualOperator = _GreaterThanOrEqualOperator;
const _LessThanOrEqualOperator = class _LessThanOrEqualOperator {
  constructor() {
    this.name = "lessThanOrEqual";
  }
  matches(fieldValue, filterValue) {
    return Number(fieldValue) <= Number(filterValue);
  }
};
__name(_LessThanOrEqualOperator, "LessThanOrEqualOperator");
let LessThanOrEqualOperator = _LessThanOrEqualOperator;
function createDefaultFilterOperators() {
  const registry = new FilterOperatorRegistry();
  registry.register(new EqualsOperator());
  registry.register(new NotEqualsOperator());
  registry.register(new ContainsOperator());
  registry.register(new StartsWithOperator());
  registry.register(new EndsWithOperator());
  registry.register(new InOperator());
  registry.register(new NotInOperator());
  registry.register(new GreaterThanOperator());
  registry.register(new LessThanOperator());
  registry.register(new GreaterThanOrEqualOperator());
  registry.register(new LessThanOrEqualOperator());
  return registry;
}
__name(createDefaultFilterOperators, "createDefaultFilterOperators");
const _FoundryJournalCollectionAdapter = class _FoundryJournalCollectionAdapter {
  constructor(foundryGame, mapperRegistry, operatorRegistry = createDefaultFilterOperators()) {
    this.foundryGame = foundryGame;
    this.mapperRegistry = mapperRegistry;
    this.operatorRegistry = operatorRegistry;
  }
  getAll() {
    const result = this.foundryGame.getJournalEntries();
    if (!result.ok) {
      return {
        ok: false,
        error: {
          code: "COLLECTION_NOT_AVAILABLE",
          message: `Failed to get journals from Foundry: ${result.error.message}`,
          details: result.error
        }
      };
    }
    const entries2 = [];
    for (const foundryEntry of result.value) {
      try {
        entries2.push(this.mapperRegistry.mapToDomain(foundryEntry));
      } catch (error3) {
        return err({
          code: "PLATFORM_ERROR",
          message: `Failed to map journal entry to domain: ${error3 instanceof Error ? error3.message : String(error3)}`,
          details: error3
        });
      }
    }
    return ok(entries2);
  }
  getById(id2) {
    const result = this.foundryGame.getJournalEntryById(id2);
    if (!result.ok) {
      return {
        ok: false,
        error: {
          code: "PLATFORM_ERROR",
          message: `Failed to get journal ${id2} from Foundry: ${result.error.message}`,
          details: result.error
        }
      };
    }
    if (!result.value) {
      return ok(null);
    }
    try {
      const entry = this.mapperRegistry.mapToDomain(result.value);
      return ok(entry);
    } catch (error3) {
      return err({
        code: "PLATFORM_ERROR",
        message: `Failed to map journal entry to domain: ${error3 instanceof Error ? error3.message : String(error3)}`,
        details: error3
      });
    }
  }
  getByIds(ids) {
    const results = [];
    const errors = [];
    for (const id2 of ids) {
      const result = this.getById(id2);
      if (!result.ok) {
        errors.push(result.error);
      } else if (result.value) {
        results.push(result.value);
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return err(firstError);
    }
    return ok(results);
  }
  exists(id2) {
    const result = this.getById(id2);
    if (!result.ok) {
      return result;
    }
    return ok(result.value !== null);
  }
  count() {
    const result = this.getAll();
    if (!result.ok) {
      return {
        ok: false,
        error: result.error
      };
    }
    return ok(result.value.length);
  }
  search(query) {
    const allResult = this.getAll();
    if (!allResult.ok) {
      return allResult;
    }
    let results = allResult.value;
    if (query.filters && query.filters.length > 0) {
      const filters = query.filters;
      results = results.filter((entity) => {
        return filters.every((filter4) => {
          const fieldValue = entity[filter4.field];
          return this.matchesFilter(fieldValue, filter4.operator, filter4.value);
        });
      });
    }
    if (query.filterGroups && query.filterGroups.length > 0) {
      const filterGroups = query.filterGroups;
      results = results.filter((entity) => {
        return filterGroups.every((group2) => {
          if (group2.filters.length === 0) return true;
          if (group2.logic === "OR") {
            return group2.filters.some((filter4) => {
              const fieldValue = entity[filter4.field];
              return this.matchesFilter(fieldValue, filter4.operator, filter4.value);
            });
          } else {
            return group2.filters.every((filter4) => {
              const fieldValue = entity[filter4.field];
              return this.matchesFilter(fieldValue, filter4.operator, filter4.value);
            });
          }
        });
      });
    }
    if (query.sortBy) {
      const sortBy = query.sortBy;
      results.sort((a, b) => {
        const aValue = a[sortBy];
        const bValue = b[sortBy];
        if (aValue === bValue) return 0;
        if (aValue === null || aValue === void 0) return 1;
        if (bValue === null || bValue === void 0) return -1;
        const comparison = aValue < bValue ? -1 : 1;
        return query.sortOrder === "desc" ? -comparison : comparison;
      });
    }
    if (query.offset) {
      results = results.slice(query.offset);
    }
    if (query.limit) {
      results = results.slice(0, query.limit);
    }
    return ok(results);
  }
  query() {
    return new FoundryJournalQueryBuilder(this);
  }
  /**
   * Checks if a field value matches a filter using the registered operator.
   *
   * Uses FilterOperatorRegistry (Strategy Pattern) for OCP-compliant extensibility.
   * New operators can be added without modifying this method.
   *
   * @param fieldValue - The value from the entity field
   * @param operator - The operator name (e.g., "equals", "contains")
   * @param filterValue - The value from the filter
   * @returns true if the field value matches the filter, false otherwise
   */
  matchesFilter(fieldValue, operator, filterValue) {
    const op = this.operatorRegistry.get(operator);
    if (!op) {
      return false;
    }
    return op.matches(fieldValue, filterValue);
  }
};
__name(_FoundryJournalCollectionAdapter, "FoundryJournalCollectionAdapter");
let FoundryJournalCollectionAdapter = _FoundryJournalCollectionAdapter;
const _FoundryJournalQueryBuilder = class _FoundryJournalQueryBuilder {
  constructor(adapter) {
    this.adapter = adapter;
    this.query = {};
    this.currentOrGroup = null;
  }
  where(field, operator, value2) {
    if (this.currentOrGroup !== null) {
      this.currentOrGroup.push({ field, operator, value: value2 });
      return this;
    }
    this.closeOrGroup();
    if (!this.query.filters) {
      this.query.filters = [];
    }
    this.query.filters.push({ field, operator, value: value2 });
    return this;
  }
  orWhere(field, operator, value2) {
    if (this.currentOrGroup === null) {
      this.currentOrGroup = [];
      if (this.query.filters && this.query.filters.length > 0) {
        const lastFilter = this.query.filters.pop();
        this.currentOrGroup.push({
          field: lastFilter.field,
          operator: lastFilter.operator,
          value: lastFilter.value
        });
      }
    }
    this.currentOrGroup.push({ field, operator, value: value2 });
    return this;
  }
  or(callback) {
    this.closeOrGroup();
    const orGroup = [];
    if (this.query.filters && this.query.filters.length > 0) {
      const lastFilter = this.query.filters.pop();
      orGroup.push({
        field: lastFilter.field,
        operator: lastFilter.operator,
        value: lastFilter.value
      });
    }
    const originalOrGroup = this.currentOrGroup;
    this.currentOrGroup = orGroup;
    callback(this);
    this.currentOrGroup = originalOrGroup;
    if (orGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "OR",
        filters: orGroup.map((f) => ({ field: f.field, operator: f.operator, value: f.value }))
      });
    }
    return this;
  }
  and(callback) {
    this.closeOrGroup();
    const andGroup = [];
    const originalFilters = this.query.filters;
    this.query.filters = andGroup;
    callback(this);
    if (originalFilters !== void 0) {
      this.query.filters = originalFilters;
    } else {
      delete this.query.filters;
    }
    if (andGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "AND",
        filters: andGroup.map((f) => ({ field: f.field, operator: f.operator, value: f.value }))
      });
    }
    return this;
  }
  limit(count) {
    this.closeOrGroup();
    this.query.limit = count;
    return this;
  }
  offset(count) {
    this.closeOrGroup();
    this.query.offset = count;
    return this;
  }
  sortBy(field, order) {
    this.closeOrGroup();
    this.query.sortBy = field;
    this.query.sortOrder = order;
    return this;
  }
  execute() {
    this.closeOrGroup();
    return this.adapter.search(this.query);
  }
  /**
   * Closes the current OR group and adds it to filterGroups.
   * Called automatically before where(), limit(), offset(), sortBy(), execute().
   */
  closeOrGroup() {
    if (this.currentOrGroup && this.currentOrGroup.length > 0) {
      if (!this.query.filterGroups) {
        this.query.filterGroups = [];
      }
      this.query.filterGroups.push({
        logic: "OR",
        filters: this.currentOrGroup.map((f) => ({
          field: f.field,
          operator: f.operator,
          value: f.value
        }))
      });
      this.currentOrGroup = null;
    }
  }
};
__name(_FoundryJournalQueryBuilder, "FoundryJournalQueryBuilder");
let FoundryJournalQueryBuilder = _FoundryJournalQueryBuilder;
const _DIFoundryJournalCollectionAdapter = class _DIFoundryJournalCollectionAdapter extends FoundryJournalCollectionAdapter {
  // foundryGameToken → FoundryGamePort (version-agnostisch)
  constructor(foundryGame) {
    const mapperRegistry = new JournalMapperRegistry();
    mapperRegistry.register(new DefaultJournalMapper());
    super(foundryGame, mapperRegistry);
  }
};
__name(_DIFoundryJournalCollectionAdapter, "DIFoundryJournalCollectionAdapter");
_DIFoundryJournalCollectionAdapter.dependencies = [foundryGameToken];
let DIFoundryJournalCollectionAdapter = _DIFoundryJournalCollectionAdapter;
const _FoundryJournalRepositoryAdapter = class _FoundryJournalRepositoryAdapter {
  constructor(collection4, foundryGame, foundryDocument, mapperRegistry) {
    this.collection = collection4;
    this.foundryGame = foundryGame;
    this.foundryDocument = foundryDocument;
    this.mapperRegistry = mapperRegistry;
  }
  // ===== Collection Methods (delegate to collection adapter) =====
  getAll() {
    return this.collection.getAll();
  }
  getById(id2) {
    return this.collection.getById(id2);
  }
  getByIds(ids) {
    return this.collection.getByIds(ids);
  }
  exists(id2) {
    return this.collection.exists(id2);
  }
  count() {
    return this.collection.count();
  }
  search(query) {
    return this.collection.search(query);
  }
  query() {
    return this.collection.query();
  }
  // ===== CREATE Operations =====
  async create(data4) {
    const journalEntryClassResult = castFoundryJournalEntryClass();
    if (!journalEntryClassResult.ok) {
      return err({
        code: "PLATFORM_ERROR",
        message: `Foundry JournalEntry class not available: ${journalEntryClassResult.error.message}`,
        details: journalEntryClassResult.error
      });
    }
    const JournalEntryClass = journalEntryClassResult.value;
    try {
      const createResult = await this.foundryDocument.create(JournalEntryClass, data4);
      if (!createResult.ok) {
        return err({
          code: "OPERATION_FAILED",
          message: `Failed to create journal: ${createResult.error.message}`,
          details: createResult.error
        });
      }
      const foundryEntry = castCreatedJournalEntry(createResult.value);
      try {
        const createdEntry = this.mapperRegistry.mapToDomain(foundryEntry);
        return ok(createdEntry);
      } catch (error3) {
        return err({
          code: "OPERATION_FAILED",
          message: `Failed to map journal to domain: ${error3 instanceof Error ? error3.message : String(error3)}`,
          details: error3
        });
      }
    } catch (error3) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create journal: ${error3 instanceof Error ? error3.message : String(error3)}`,
        details: error3
      });
    }
  }
  async createMany(data4) {
    const results = [];
    const errors = [];
    for (const item of data4) {
      const result = await this.create(item);
      if (result.ok) {
        results.push(result.value);
      } else {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return err(firstError);
    }
    return ok(results);
  }
  // ===== UPDATE Operations =====
  async update(id2, changes) {
    const currentResult = this.getById(id2);
    if (!currentResult.ok) {
      return {
        ok: false,
        error: {
          code: "ENTITY_NOT_FOUND",
          message: `Journal ${id2} not found`,
          details: currentResult.error
        }
      };
    }
    if (!currentResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found`
      });
    }
    const foundryResult = this.foundryGame.getJournalEntryById(id2);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found in Foundry`
      });
    }
    const foundryEntry = foundryResult.value;
    const updateData = {};
    if (changes.name !== void 0) {
      if (changes.name === null) {
        updateData["name.-="] = null;
      } else {
        updateData.name = changes.name;
      }
    }
    const docWithUpdateResult = castFoundryDocumentWithUpdate(
      foundryEntry
    );
    if (!docWithUpdateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support update: ${docWithUpdateResult.error.message}`,
        details: docWithUpdateResult.error
      });
    }
    const updateResult = await this.foundryDocument.update(docWithUpdateResult.value, updateData);
    if (!updateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to update journal ${id2}: ${updateResult.error.message}`,
        details: updateResult.error
      });
    }
    const updatedResult = this.getById(id2);
    if (!updatedResult.ok || !updatedResult.value) {
      return err({
        code: "OPERATION_FAILED",
        message: "Failed to retrieve updated journal"
      });
    }
    return ok(updatedResult.value);
  }
  async updateMany(updates) {
    const results = [];
    const errors = [];
    for (const update2 of updates) {
      const result = await this.update(update2.id, update2.changes);
      if (result.ok) {
        results.push(result.value);
      } else {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return err(firstError);
    }
    return ok(results);
  }
  async patch(id2, partial2) {
    return this.update(id2, partial2);
  }
  async upsert(id2, data4) {
    const existsResult = this.exists(id2);
    if (!existsResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to check if journal ${id2} exists`,
        details: existsResult.error
      });
    }
    if (existsResult.value) {
      return this.update(id2, data4);
    } else {
      const createData = createEntityDataWithId(data4, id2);
      return this.create(createData);
    }
  }
  // ===== DELETE Operations =====
  async delete(id2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id2);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found`
      });
    }
    const deleteResult = await this.foundryDocument.delete(foundryResult.value);
    if (!deleteResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to delete journal ${id2}: ${deleteResult.error.message}`,
        details: deleteResult.error
      });
    }
    return ok(void 0);
  }
  async deleteMany(ids) {
    const errors = [];
    for (const id2 of ids) {
      const result = await this.delete(id2);
      if (!result.ok) {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      const firstError = getFirstArrayElement(errors);
      return err(firstError);
    }
    return ok(void 0);
  }
  // ===== Flag Convenience Methods =====
  getFlag(id2, scope, key2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id2);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = this.foundryDocument.getFlag(documentResult.value, scope, key2, /* @__PURE__ */ unknown());
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to get flag ${scope}.${key2}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(flagResult.value);
  }
  async setFlag(id2, scope, key2, value2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id2);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = await this.foundryDocument.setFlag(documentResult.value, scope, key2, value2);
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to set flag ${scope}.${key2}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(void 0);
  }
  async unsetFlag(id2, scope, key2) {
    const foundryResult = this.foundryGame.getJournalEntryById(id2);
    if (!foundryResult.ok || !foundryResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal ${id2} not found`
      });
    }
    const foundryEntry = foundryResult.value;
    const documentResult = castFoundryDocumentForFlag(foundryEntry);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Document does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const unsetResult = await this.foundryDocument.unsetFlag(documentResult.value, scope, key2);
    if (!unsetResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to unset flag ${scope}.${key2}: ${unsetResult.error.message}`,
        details: unsetResult.error
      });
    }
    return ok(void 0);
  }
};
__name(_FoundryJournalRepositoryAdapter, "FoundryJournalRepositoryAdapter");
let FoundryJournalRepositoryAdapter = _FoundryJournalRepositoryAdapter;
const _DIFoundryJournalRepositoryAdapter = class _DIFoundryJournalRepositoryAdapter extends FoundryJournalRepositoryAdapter {
  constructor(foundryGame, foundryDocument) {
    const mapperRegistry = new JournalMapperRegistry();
    mapperRegistry.register(new DefaultJournalMapper());
    const collection4 = new FoundryJournalCollectionAdapter(foundryGame, mapperRegistry);
    super(collection4, foundryGame, foundryDocument, mapperRegistry);
  }
};
__name(_DIFoundryJournalRepositoryAdapter, "DIFoundryJournalRepositoryAdapter");
_DIFoundryJournalRepositoryAdapter.dependencies = [foundryGameToken, foundryDocumentToken];
let DIFoundryJournalRepositoryAdapter = _DIFoundryJournalRepositoryAdapter;
const _FoundryJournalPermissionAdapter = class _FoundryJournalPermissionAdapter {
  /**
   * Checks if the current user has permission to view a journal entry.
   *
   * Uses Foundry's journal.testUserPermission(game.user, "OBSERVER") API.
   *
   * @param journalId - The ID of the journal entry to check
   * @returns Result indicating whether the user can view the journal
   */
  canUserViewJournal(journalId) {
    if (typeof game === "undefined" || !game?.journal) {
      return ok(true);
    }
    if (!game.user) {
      return ok(true);
    }
    const journalResult = tryCatch(
      () => game.journal.get(journalId),
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to get journal entry for permission check: ${error3 instanceof Error ? error3.message : String(error3)}`,
        { journalId },
        error3
      )
    );
    if (!journalResult.ok) {
      return ok(false);
    }
    const journal = journalResult.value;
    if (!journal) {
      return ok(false);
    }
    const permissionResult = tryCatch(
      () => {
        return journal.testUserPermission(game.user, "OBSERVER");
      },
      (error3) => createFoundryError(
        "OPERATION_FAILED",
        `Failed to check journal permission: ${error3 instanceof Error ? error3.message : String(error3)}`,
        { journalId },
        error3
      )
    );
    if (!permissionResult.ok) {
      return ok(true);
    }
    return ok(permissionResult.value);
  }
};
__name(_FoundryJournalPermissionAdapter, "FoundryJournalPermissionAdapter");
let FoundryJournalPermissionAdapter = _FoundryJournalPermissionAdapter;
function registerEntityPorts(container2) {
  const collectionResult = container2.registerClass(
    platformJournalCollectionPortToken,
    DIFoundryJournalCollectionAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(collectionResult)) {
    return err(
      `Failed to register PlatformJournalCollectionPort: ${collectionResult.error.message}`
    );
  }
  const repositoryResult = container2.registerClass(
    platformJournalRepositoryToken,
    DIFoundryJournalRepositoryAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(repositoryResult)) {
    return err(`Failed to register PlatformJournalRepository: ${repositoryResult.error.message}`);
  }
  const permissionResult = container2.registerClass(
    platformJournalPermissionPortToken,
    FoundryJournalPermissionAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(permissionResult)) {
    return err(
      `Failed to register PlatformJournalPermissionPort: ${permissionResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerEntityPorts, "registerEntityPorts");
registerDependencyStep({
  name: "EntityPorts",
  priority: 100,
  execute: registerEntityPorts
});
const settingTypeMapperToken = createInjectionToken("SettingTypeMapper");
const settingsErrorMapperToken = createInjectionToken("SettingsErrorMapper");
function mapDomainErrorToSettingsError(error3) {
  let code;
  switch (error3.code) {
    case "SETTING_REGISTRATION_FAILED":
      code = "SETTING_REGISTRATION_FAILED";
      break;
    case "SETTING_NOT_FOUND":
      code = "SETTING_NOT_REGISTERED";
      break;
    case "INVALID_SETTING_VALUE":
      code = "SETTING_VALIDATION_FAILED";
      break;
    case "SETTING_READ_FAILED":
    case "SETTING_WRITE_FAILED":
      if (error3.message.toLowerCase().includes("not found") || error3.message.toLowerCase().includes("not registered")) {
        code = "SETTING_NOT_REGISTERED";
      } else {
        code = "SETTING_VALIDATION_FAILED";
      }
      break;
    case "PLATFORM_NOT_AVAILABLE":
      code = "PLATFORM_NOT_AVAILABLE";
      break;
    default:
      code = "SETTING_REGISTRATION_FAILED";
  }
  return {
    code,
    message: error3.message,
    details: error3.details
  };
}
__name(mapDomainErrorToSettingsError, "mapDomainErrorToSettingsError");
const _FoundrySettingsAdapter = class _FoundrySettingsAdapter {
  constructor(foundrySettings, typeMapper, errorMapper) {
    this.foundrySettings = foundrySettings;
    this.typeMapper = typeMapper;
    this.errorMapper = errorMapper;
  }
  /**
   * Register a setting in Foundry.
   *
   * Maps platform config → Foundry config.
   */
  register(namespace, key2, config2) {
    const typeResult = this.typeMapper.map(config2.type);
    if (!typeResult.ok) {
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(typeResult.error)
      };
    }
    const foundryConfig = {
      name: config2.name,
      ...config2.hint !== void 0 && { hint: config2.hint },
      scope: config2.scope,
      config: config2.config,
      type: typeResult.value,
      ...config2.choices !== void 0 && { choices: config2.choices },
      default: config2.default,
      ...config2.onChange !== void 0 && { onChange: config2.onChange }
    };
    const result = this.foundrySettings.register(namespace, key2, foundryConfig);
    if (!result.ok) {
      const domainError = this.errorMapper.map(result.error, {
        operation: "register",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    return { ok: true, value: void 0 };
  }
  /**
   * Get setting value from Foundry with validation.
   *
   * Uses a permissive valibot schema (v.unknown()) to retrieve the raw value,
   * then validates it using the provided ValidationSchema. This allows any
   * ValidationSchema implementation to be used, not just ValibotValidationSchema.
   */
  get(namespace, key2, schema) {
    const rawResult = this.foundrySettings.get(namespace, key2, /* @__PURE__ */ unknown());
    if (!rawResult.ok) {
      const domainError = this.errorMapper.map(rawResult.error, {
        operation: "get",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    const validationResult = schema.validate(rawResult.value);
    if (!validationResult.ok) {
      return validationResult;
    }
    return validationResult;
  }
  /**
   * Set setting value in Foundry.
   *
   * Persists to Foundry's database and triggers onChange.
   */
  async set(namespace, key2, value2) {
    const result = await this.foundrySettings.set(namespace, key2, value2);
    if (!result.ok) {
      const domainError = this.errorMapper.map(result.error, {
        operation: "set",
        namespace,
        key: key2
      });
      return {
        ok: false,
        error: mapDomainErrorToSettingsError(domainError)
      };
    }
    return { ok: true, value: void 0 };
  }
};
__name(_FoundrySettingsAdapter, "FoundrySettingsAdapter");
let FoundrySettingsAdapter = _FoundrySettingsAdapter;
const _DIFoundrySettingsAdapter = class _DIFoundrySettingsAdapter extends FoundrySettingsAdapter {
  constructor(foundrySettings, typeMapper, errorMapper) {
    super(foundrySettings, typeMapper, errorMapper);
  }
};
__name(_DIFoundrySettingsAdapter, "DIFoundrySettingsAdapter");
_DIFoundrySettingsAdapter.dependencies = [
  foundrySettingsToken,
  settingTypeMapperToken,
  settingsErrorMapperToken
];
let DIFoundrySettingsAdapter = _DIFoundrySettingsAdapter;
const _FoundrySettingTypeMapper = class _FoundrySettingTypeMapper {
  /**
   * Maps a platform-agnostic SettingType to Foundry-specific type constructor.
   *
   * @param type - The setting type to map
   * @returns Result containing the Foundry type constructor or a SettingsError
   */
  map(type) {
    if (type === "String" || type === String) {
      return { ok: true, value: String };
    }
    if (type === "Number" || type === Number) {
      return { ok: true, value: Number };
    }
    if (type === "Boolean" || type === Boolean) {
      return { ok: true, value: Boolean };
    }
    return {
      ok: false,
      error: {
        code: "SETTING_REGISTRATION_FAILED",
        message: `Unknown setting type: ${type}. Supported types are: String, Number, Boolean`,
        details: { type }
      }
    };
  }
};
__name(_FoundrySettingTypeMapper, "FoundrySettingTypeMapper");
let FoundrySettingTypeMapper = _FoundrySettingTypeMapper;
const _FoundrySettingsErrorMapper = class _FoundrySettingsErrorMapper {
  /**
   * Maps a FoundryError to a platform-agnostic SettingsError.
   *
   * @param foundryError - The Foundry-specific error to map
   * @param context - Context information about the operation and setting
   * @returns Platform-agnostic SettingsError
   */
  map(foundryError, context) {
    let code;
    switch (foundryError.code) {
      case "API_NOT_AVAILABLE":
        code = "PLATFORM_NOT_AVAILABLE";
        break;
      case "VALIDATION_FAILED":
        code = "INVALID_SETTING_VALUE";
        break;
      case "OPERATION_FAILED":
        if (context.operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else {
          const message2 = foundryError.message.toLowerCase();
          if (message2.includes("not registered") || message2.includes("not found")) {
            code = "SETTING_NOT_FOUND";
          } else if (context.operation === "get") {
            code = "SETTING_READ_FAILED";
          } else {
            code = "SETTING_WRITE_FAILED";
          }
        }
        break;
      default:
        if (context.operation === "register") {
          code = "SETTING_REGISTRATION_FAILED";
        } else if (context.operation === "get") {
          code = "SETTING_READ_FAILED";
        } else {
          code = "SETTING_WRITE_FAILED";
        }
    }
    return {
      code,
      message: `Failed to ${context.operation} setting "${context.namespace}.${context.key}": ${foundryError.message}`,
      details: foundryError
    };
  }
};
__name(_FoundrySettingsErrorMapper, "FoundrySettingsErrorMapper");
let FoundrySettingsErrorMapper = _FoundrySettingsErrorMapper;
function registerSettingsPorts(container2) {
  const typeMapperResult = container2.registerClass(
    settingTypeMapperToken,
    FoundrySettingTypeMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(typeMapperResult)) {
    return err(`Failed to register SettingTypeMapper: ${typeMapperResult.error.message}`);
  }
  const errorMapperResult = container2.registerClass(
    settingsErrorMapperToken,
    FoundrySettingsErrorMapper,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(errorMapperResult)) {
    return err(`Failed to register SettingsErrorMapper: ${errorMapperResult.error.message}`);
  }
  const settingsPortResult = container2.registerClass(
    platformSettingsPortToken,
    DIFoundrySettingsAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(settingsPortResult)) {
    return err(`Failed to register PlatformSettingsPort: ${settingsPortResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerSettingsPorts, "registerSettingsPorts");
registerDependencyStep({
  name: "SettingsPorts",
  priority: 90,
  execute: registerSettingsPorts
});
const KEY_SEPARATOR = ":";
function normalizeSegment(segment) {
  return segment.trim().replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "").toLowerCase();
}
__name(normalizeSegment, "normalizeSegment");
function createCacheKey(parts, moduleId) {
  const { namespace, resource, identifier } = parts;
  const payload = [moduleId, namespace, resource];
  if (identifier !== null && identifier !== void 0) {
    payload.push(String(identifier));
  }
  return assertCacheKey(payload.map(normalizeSegment).join(KEY_SEPARATOR));
}
__name(createCacheKey, "createCacheKey");
function createCacheNamespace(namespace, moduleId) {
  const normalizedNamespace = normalizeSegment(namespace);
  return (resource, identifier) => identifier === void 0 ? createCacheKey({ namespace: normalizedNamespace, resource }, moduleId) : createCacheKey({ namespace: normalizedNamespace, resource, identifier }, moduleId);
}
__name(createCacheNamespace, "createCacheNamespace");
function registerJournalVisibilityConfig(container2) {
  const buildCacheKey = createCacheNamespace("journal-visibility", MODULE_METADATA.ID);
  const cacheKeyFactory = /* @__PURE__ */ __name((resource) => {
    return buildCacheKey(resource);
  }, "cacheKeyFactory");
  const config2 = {
    moduleNamespace: MODULE_METADATA.ID,
    hiddenFlagKey: DOMAIN_FLAGS.HIDDEN,
    unknownName: APP_DEFAULTS.UNKNOWN_NAME,
    cacheKeyFactory
  };
  const configResult = container2.registerValue(journalVisibilityConfigToken, config2);
  if (isErr(configResult)) {
    return err(`Failed to register JournalVisibilityConfig: ${configResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerJournalVisibilityConfig, "registerJournalVisibilityConfig");
registerDependencyStep({
  name: "JournalVisibilityConfig",
  priority: 110,
  execute: registerJournalVisibilityConfig
});
const _WindowRegistry = class _WindowRegistry {
  constructor() {
    this.definitions = /* @__PURE__ */ new Map();
    this.instances = /* @__PURE__ */ new Map();
  }
  registerDefinition(definition) {
    if (this.definitions.has(definition.definitionId)) {
      return err({
        code: "DefinitionAlreadyExists",
        message: `Definition ${definition.definitionId} already exists`
      });
    }
    this.definitions.set(definition.definitionId, definition);
    return ok(void 0);
  }
  getDefinition(definitionId) {
    const definition = this.definitions.get(definitionId);
    if (!definition) {
      return err({
        code: "DefinitionNotFound",
        message: `Definition ${definitionId} not found`
      });
    }
    return ok(definition);
  }
  registerInstance(instance2) {
    if (this.instances.has(instance2.instanceId)) {
      return err({
        code: "InstanceAlreadyExists",
        message: `Instance ${instance2.instanceId} already exists`
      });
    }
    this.instances.set(instance2.instanceId, instance2);
    return ok(void 0);
  }
  getInstance(instanceId) {
    const instance2 = this.instances.get(instanceId);
    if (!instance2) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    return ok(instance2);
  }
  unregisterInstance(instanceId) {
    if (!this.instances.has(instanceId)) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    this.instances.delete(instanceId);
    return ok(void 0);
  }
  listInstances() {
    return Array.from(this.instances.values());
  }
  listInstancesByDefinition(definitionId) {
    return Array.from(this.instances.values()).filter(
      (instance2) => instance2.definitionId === definitionId
    );
  }
};
__name(_WindowRegistry, "WindowRegistry");
let WindowRegistry = _WindowRegistry;
const _EventBus = class _EventBus {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  emit(event3, payload) {
    const eventListeners = this.listeners.get(event3);
    if (!eventListeners) return;
    for (const listener of eventListeners) {
      listener(payload);
    }
  }
  on(event3, handler) {
    const eventListeners = getMapValueOrCreate(
      this.listeners,
      event3,
      () => /* @__PURE__ */ new Set()
    );
    const castHandler = castEventHandlerForSet(handler);
    eventListeners.add(castHandler);
    return () => {
      eventListeners.delete(castHandler);
      if (eventListeners.size === 0) {
        this.listeners.delete(event3);
      }
    };
  }
  off(event3, handler) {
    const eventListeners = this.listeners.get(event3);
    if (!eventListeners) return;
    const castHandler = castEventHandlerForSet(handler);
    eventListeners.delete(castHandler);
    if (eventListeners.size === 0) {
      this.listeners.delete(event3);
    }
  }
  once(event3, handler) {
    const onceHandler = /* @__PURE__ */ __name((payload) => {
      handler(payload);
      this.off(event3, onceHandler);
    }, "onceHandler");
    this.on(event3, onceHandler);
  }
};
__name(_EventBus, "EventBus");
let EventBus = _EventBus;
const _StateStore = class _StateStore {
  constructor() {
    this.state = /* @__PURE__ */ new Map();
  }
  set(instanceId, key2, value2) {
    const instanceState = getMapValueOrCreate(
      this.state,
      instanceId,
      () => /* @__PURE__ */ new Map()
    );
    instanceState.set(key2, value2);
    return ok(void 0);
  }
  get(instanceId, key2) {
    const instanceState = this.state.get(instanceId);
    if (!instanceState) {
      return err({
        code: "InstanceNotFound",
        message: `Instance ${instanceId} not found`
      });
    }
    if (!instanceState.has(key2)) {
      return err({
        code: "KeyNotFound",
        message: `Key ${key2} not found for instance ${instanceId}`
      });
    }
    return ok(instanceState.get(key2));
  }
  getAll(instanceId) {
    const instanceState = this.state.get(instanceId);
    if (!instanceState) {
      return ok({});
    }
    const result = {};
    for (const [key2, value2] of instanceState.entries()) {
      result[key2] = value2;
    }
    return ok(result);
  }
  clear(instanceId) {
    this.state.delete(instanceId);
    return ok(void 0);
  }
};
__name(_StateStore, "StateStore");
let StateStore = _StateStore;
const _ActionDispatcher = class _ActionDispatcher {
  constructor(registry) {
    this.registry = registry;
  }
  async dispatch(actionId, context) {
    const instanceResult = this.registry.getInstance(context.windowInstanceId);
    if (!instanceResult.ok) {
      return err(instanceResult.error);
    }
    const definitionResult = this.registry.getDefinition(instanceResult.value.definitionId);
    if (!definitionResult.ok) {
      return err(definitionResult.error);
    }
    const definition = definitionResult.value;
    const action2 = definition.actions?.find((a) => a.id === actionId);
    if (!action2) {
      return err({
        code: "ActionNotFound",
        message: `Action ${actionId} not found`
      });
    }
    const permissionResult = this.checkPermissions(action2, context);
    if (!permissionResult.ok) {
      return err({
        code: "PermissionDenied",
        message: permissionResult.error.message
      });
    }
    const validationResult = this.validateAction(action2, context);
    if (!validationResult.ok) {
      return err({
        code: "ValidationFailed",
        message: validationResult.error.message
      });
    }
    if (action2.confirm) {
      const confirmed = await this.requestConfirmation(action2.confirm);
      if (!confirmed) {
        return err({
          code: "ActionCancelled",
          message: "Action was cancelled by user"
        });
      }
    }
    const result = await action2.handler(context);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(void 0);
  }
  /**
   * Checks if the user has permission to execute the action
   */
  checkPermissions(action2, context) {
    if (!action2.permissions || action2.permissions.length === 0) {
      return ok(void 0);
    }
    for (const permission of action2.permissions) {
      const checkResult = this.checkPermission(permission, context);
      if (!checkResult.ok) {
        return err(checkResult.error);
      }
    }
    return ok(void 0);
  }
  /**
   * Checks a single permission
   */
  checkPermission(permission, context) {
    switch (permission.type) {
      case "user":
        if (typeof game === "undefined" || !game.user?.id) {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        return ok(void 0);
      case "gm":
        if (typeof game === "undefined") {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        const user = game.user;
        if (!user) {
          return err({
            code: "NotAuthenticated",
            message: "User is not authenticated"
          });
        }
        const isGM = user.isGM === true || user.role >= 4;
        if (!isGM) {
          return err({
            code: "InsufficientPermissions",
            message: "This action requires Game Master permissions"
          });
        }
        return ok(void 0);
      case "custom":
        if (!permission.check) {
          return err({
            code: "InvalidPermission",
            message: "Custom permission check function is not defined"
          });
        }
        const hasPermission = permission.check(context);
        if (!hasPermission) {
          return err({
            code: "InsufficientPermissions",
            message: "Custom permission check failed"
          });
        }
        return ok(void 0);
      default:
        return err({
          code: "UnknownPermissionType",
          message: `Unknown permission type: ${permission.type}`
        });
    }
  }
  /**
   * Validates the action context against validation rules
   */
  validateAction(action2, context) {
    if (!action2.validation || action2.validation.length === 0) {
      return ok(void 0);
    }
    for (const rule of action2.validation) {
      const isValid = rule.validate(context);
      if (!isValid) {
        return err({
          code: "ValidationFailed",
          message: rule.message || "Action validation failed"
        });
      }
    }
    return ok(void 0);
  }
  /**
   * Requests user confirmation before executing the action
   */
  async requestConfirmation(confirm) {
    if (typeof foundry === "undefined" || !foundry.applications?.api?.DialogV2) {
      console.warn("Foundry DialogV2 not available, action confirmation cancelled");
      return false;
    }
    const result = await foundry.applications.api.DialogV2.confirm({
      content: confirm.message,
      rejectClose: false,
      modal: true
    });
    return result === true;
  }
};
__name(_ActionDispatcher, "ActionDispatcher");
_ActionDispatcher.dependencies = [windowRegistryToken];
let ActionDispatcher = _ActionDispatcher;
const _RendererRegistry = class _RendererRegistry {
  constructor() {
    this.renderers = /* @__PURE__ */ new Map();
  }
  register(type, renderer3) {
    this.renderers.set(type, renderer3);
  }
  get(type) {
    const renderer3 = this.renderers.get(type);
    if (!renderer3) {
      return err({
        code: "RendererNotFound",
        message: `Renderer for type ${type} not found`
      });
    }
    return ok(renderer3);
  }
};
__name(_RendererRegistry, "RendererRegistry");
let RendererRegistry = _RendererRegistry;
const _BindingEngine = class _BindingEngine {
  constructor(stateStore, persistAdapter, remoteSyncGate) {
    this.stateStore = stateStore;
    this.persistAdapter = persistAdapter;
    this.remoteSyncGate = remoteSyncGate;
    this.bindings = /* @__PURE__ */ new Map();
    this.debounceTimers = /* @__PURE__ */ new Map();
  }
  initialize(definition, instanceId) {
    const normalized = this.getNormalizedBindings(definition);
    const instanceBindings = getMapValueOrCreate(
      this.bindings,
      instanceId,
      () => /* @__PURE__ */ new Map()
    );
    for (const binding of normalized) {
      instanceBindings.set(binding.id || `${binding.source.key}-binding`, binding);
      this.loadBindingValue(binding.source, instanceId).then((valueResult) => {
        if (valueResult.ok && valueResult.value !== void 0) {
          this.stateStore.set(instanceId, binding.target.stateKey, valueResult.value);
        }
      });
    }
    return ok(void 0);
  }
  async sync(instanceId, policy = "immediate") {
    if (policy === "none") return ok(void 0);
    const instanceBindings = this.bindings.get(instanceId);
    if (!instanceBindings) return ok(void 0);
    for (const binding of instanceBindings.values()) {
      const bindingSyncPolicy = binding.syncPolicy === "manual" ? "none" : binding.syncPolicy;
      const bindingPolicy = bindingSyncPolicy ?? policy;
      if (bindingPolicy === "none") continue;
      if (binding.twoWay) {
        const stateResult = this.stateStore.get(instanceId, binding.target.stateKey);
        if (!stateResult.ok) continue;
        if (bindingPolicy === "debounced") {
          this.scheduleDebouncedSync(
            binding.id || `${binding.source.key}-binding`,
            instanceId,
            binding.source,
            stateResult.value
          );
        } else {
          const saveResult = await this.saveBindingValue(
            binding.source,
            instanceId,
            stateResult.value
          );
          if (!saveResult.ok) return err(saveResult.error);
        }
      }
    }
    return ok(void 0);
  }
  /**
   * Phase 2: Schedules a debounced sync for a binding
   */
  scheduleDebouncedSync(bindingId, instanceId, source2, value2) {
    const timerKey = `${instanceId}:${bindingId}`;
    const existingTimer = this.debounceTimers.get(timerKey);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const instanceBindings = this.bindings.get(instanceId);
    const binding = instanceBindings?.get(bindingId);
    const debounceMs = binding?.debounceMs ?? 300;
    const timer = setTimeout(async () => {
      this.debounceTimers.delete(timerKey);
      const saveResult = await this.saveBindingValue(source2, instanceId, value2);
      if (!saveResult.ok) {
        console.error(`Failed to save debounced binding ${bindingId}:`, saveResult.error);
      }
    }, debounceMs);
    this.debounceTimers.set(timerKey, timer);
  }
  getNormalizedBindings(definition) {
    const normalized = [];
    for (const control of definition.controls || []) {
      if (control.binding) {
        normalized.push({
          ...control.binding,
          id: control.binding.id || `${control.id}-binding`,
          isLocal: true
        });
      }
    }
    for (const binding of definition.bindings || []) {
      normalized.push({
        ...binding,
        isLocal: false
      });
    }
    return normalized;
  }
  /**
   * Phase 2: Loads a binding value from the source
   */
  async loadBindingValue(source2, instanceId) {
    switch (source2.type) {
      case "state":
        return this.stateStore.get(instanceId, source2.key);
      case "setting":
      case "flag":
        if (!this.persistAdapter) {
          return ok(void 0);
        }
        const persistConfig = this.bindingSourceToPersistConfig(source2);
        if (!persistConfig.ok) {
          return err(persistConfig.error);
        }
        const loadResult = await this.persistAdapter.load(persistConfig.value);
        if (!loadResult.ok) {
          return err({
            code: "BindingLoadFailed",
            message: `Failed to load ${source2.type} binding: ${loadResult.error.message}`
          });
        }
        const data4 = loadResult.value;
        if (source2.key.includes(".")) {
          const nestedValue = getNestedValue(data4, source2.key);
          return ok(nestedValue);
        }
        if (isRecord(data4)) {
          return ok(data4[source2.key] ?? data4);
        }
        return ok(data4);
      case "journal":
        return ok(void 0);
      default:
        return ok(void 0);
    }
  }
  /**
   * Phase 2: Saves a binding value to the source
   */
  async saveBindingValue(source2, instanceId, value2) {
    switch (source2.type) {
      case "state":
        this.stateStore.set(instanceId, source2.key, value2);
        return ok(void 0);
      case "setting":
      case "flag":
        if (!this.persistAdapter) {
          return ok(void 0);
        }
        const persistConfig = this.bindingSourceToPersistConfig(source2);
        if (!persistConfig.ok) {
          return err(persistConfig.error);
        }
        const data4 = createNestedObject(source2.key, value2);
        const meta3 = this.remoteSyncGate?.makePersistMeta(instanceId);
        const saveResult = await this.persistAdapter.save(persistConfig.value, data4, meta3);
        if (!saveResult.ok) {
          return err({
            code: "BindingSaveFailed",
            message: `Failed to save ${source2.type} binding: ${saveResult.error.message}`
          });
        }
        return ok(void 0);
      case "journal":
        return ok(void 0);
      default:
        return ok(void 0);
    }
  }
  /**
   * Phase 2: Converts BindingSource to PersistConfig
   */
  bindingSourceToPersistConfig(source2) {
    if (source2.type === "setting") {
      if (!source2.namespace) {
        return err({
          code: "InvalidBindingSource",
          message: "Setting binding requires namespace"
        });
      }
      return ok({
        type: "setting",
        key: source2.key,
        namespace: source2.namespace
      });
    }
    if (source2.type === "flag") {
      if (!source2.namespace || !source2.documentId) {
        return err({
          code: "InvalidBindingSource",
          message: "Flag binding requires namespace and documentId"
        });
      }
      return ok({
        type: "flag",
        key: source2.key,
        namespace: source2.namespace,
        documentId: source2.documentId
      });
    }
    return err({
      code: "InvalidBindingSource",
      message: `Cannot convert ${source2.type} to PersistConfig`
    });
  }
};
__name(_BindingEngine, "BindingEngine");
_BindingEngine.dependencies = [stateStoreToken, persistAdapterToken, remoteSyncGateToken];
let BindingEngine = _BindingEngine;
const _RemoteSyncGate = class _RemoteSyncGate {
  constructor() {
    this.OPT_KEY = "windowFrameworkOrigin";
    this.clientId = typeof game !== "undefined" && game.userId ? game.userId : `client-${Date.now()}`;
  }
  makePersistMeta(instanceId) {
    return {
      originClientId: this.clientId,
      originWindowInstanceId: instanceId,
      render: false
      // Kein Foundry-window rerender
    };
  }
  isFromWindow(options2, instanceId) {
    const meta3 = extractPersistMeta(options2, this.OPT_KEY);
    return meta3?.originWindowInstanceId === instanceId;
  }
  getClientId() {
    return this.clientId;
  }
};
__name(_RemoteSyncGate, "RemoteSyncGate");
let RemoteSyncGate = _RemoteSyncGate;
const _ViewModelBuilder = class _ViewModelBuilder {
  build(definition, state2, actions) {
    const computed = {};
    return {
      state: state2,
      // StatePort (kann reaktiv sein, z.B. RuneState)
      computed,
      actions
      // i18n und logger werden optional über DI injiziert (später)
    };
  }
};
__name(_ViewModelBuilder, "ViewModelBuilder");
let ViewModelBuilder = _ViewModelBuilder;
function buildPositionObject(position3) {
  if (!position3) return void 0;
  const result = {};
  if (position3.top !== void 0) result.top = position3.top;
  if (position3.left !== void 0) result.left = position3.left;
  if (position3.width !== void 0) result.width = position3.width;
  if (position3.height !== void 0) result.height = position3.height;
  return Object.keys(result).length > 0 ? result : void 0;
}
__name(buildPositionObject, "buildPositionObject");
const _FoundryApplicationWrapper2 = class _FoundryApplicationWrapper2 {
  static build(definition, controller, instanceId) {
    var _a2;
    const controllerMap = /* @__PURE__ */ new WeakMap();
    const mountedMap = /* @__PURE__ */ new WeakMap();
    const foundryApi = foundry;
    const applicationBase = foundryApi.applications.api.ApplicationV2 ?? class {
    };
    const handlebarsMixin = foundryApi.applications.api.HandlebarsApplicationMixin ?? ((cls) => cls);
    const positionObj = buildPositionObject(definition.position);
    const appClass = (_a2 = class extends handlebarsMixin(applicationBase) {
      // Kein static template - wir rendern direkt in _renderFrame
      // static template wird nicht verwendet, da _renderHTML "" zurückgibt
      // Override title getter (wie in Referenz-Implementierung)
      get title() {
        return definition.title ?? "";
      }
      constructor(...args2) {
        super(...args2);
        const appInstance = this;
        controllerMap.set(appInstance, controller);
        mountedMap.set(appInstance, false);
        if (typeof process !== "undefined" && false) {
          _FoundryApplicationWrapper._testControllerMaps.set(appInstance, controllerMap);
          _FoundryApplicationWrapper._testMountedMaps.set(appInstance, mountedMap);
        }
      }
      // Überschreibt _renderHTML um kein Handlebars-Template zu rendern
      // (wie in SvelteApplicationMixin - gibt leeren String zurück)
      async _renderHTML(_context, _options2) {
        return {};
      }
      // Verwendet _renderFrame lifecycle method (wie SvelteApplicationMixin)
      // Wird während des Rendering-Prozesses aufgerufen und gibt den Frame zurück
      // Dies ermöglicht es, die Svelte-Komponente in .window-content zu mounten
      async _renderFrame(options2) {
        const frame = await super._renderFrame(options2);
        const hasFrame = this.hasFrame ?? true;
        const target = hasFrame ? frame.querySelector(".window-content") : frame;
        if (!target) {
          return frame;
        }
        target.innerHTML = '<div id="svelte-mount-point"></div>';
        const ctrl = controllerMap.get(this);
        const isMounted = mountedMap.get(this) ?? false;
        if (ctrl) {
          if (!isMounted) {
            await ctrl.onFoundryRender(target);
            mountedMap.set(this, true);
          } else {
            await ctrl.onFoundryUpdate(target);
          }
        }
        return frame;
      }
      async close(options2) {
        const ctrl = controllerMap.get(this);
        if (ctrl) {
          await ctrl.onFoundryClose();
        }
        mountedMap.set(this, false);
        await super.close(options2);
        return this;
      }
    }, __name(_a2, "appClass"), _a2.DEFAULT_OPTIONS = {
      id: instanceId,
      // WICHTIG: instanceId, nicht definitionId!
      title: definition.title,
      classes: definition.classes || [],
      window: {
        resizable: definition.features?.resizable ?? true,
        minimizable: definition.features?.minimizable ?? true,
        draggable: definition.features?.draggable ?? true
      },
      ...positionObj && { position: positionObj }
    }, _a2);
    return appClass;
  }
};
__name(_FoundryApplicationWrapper2, "FoundryApplicationWrapper");
_FoundryApplicationWrapper2._testControllerMaps = /* @__PURE__ */ new Map();
_FoundryApplicationWrapper2._testMountedMaps = /* @__PURE__ */ new Map();
let FoundryApplicationWrapper = _FoundryApplicationWrapper2;
const _FoundryWindowAdapter = class _FoundryWindowAdapter {
  buildApplicationWrapper(definition, controller, instanceId) {
    try {
      const appClass = FoundryApplicationWrapper.build(definition, controller, instanceId);
      return ok(appClass);
    } catch (error3) {
      return err({
        code: "BuildApplicationFailed",
        message: `Failed to build application wrapper: ${String(error3)}`,
        cause: error3
      });
    }
  }
  async renderWindow(instance2, force) {
    if (!instance2.foundryApp) {
      return err({
        code: "NoFoundryApp",
        message: "FoundryApp not set on instance"
      });
    }
    try {
      await instance2.foundryApp.render({ force: force ?? false });
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "RenderFailed",
        message: `Failed to render window: ${String(error3)}`,
        cause: error3
      });
    }
  }
  async closeWindow(instance2) {
    if (!instance2.foundryApp) {
      return err({
        code: "NoFoundryApp",
        message: "FoundryApp not set on instance"
      });
    }
    try {
      await instance2.foundryApp.close();
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "CloseFailed",
        message: `Failed to close window: ${String(error3)}`,
        cause: error3
      });
    }
  }
};
__name(_FoundryWindowAdapter, "FoundryWindowAdapter");
let FoundryWindowAdapter = _FoundryWindowAdapter;
const _RuneState = class _RuneState {
  constructor(initial) {
    __privateAdd(this, _runeState);
    __privateSet(this, _runeState, /* @__PURE__ */ state(proxy(initial)));
  }
  get runeState() {
    return get$2(__privateGet(this, _runeState));
  }
  set runeState(value2) {
    set$1(__privateGet(this, _runeState), value2, true);
  }
  get() {
    return this.runeState;
  }
  patch(updates) {
    for (const [key2, value2] of Object.entries(updates)) {
      const currentValue = this.runeState[key2];
      if (currentValue !== value2) {
        this.runeState[key2] = value2;
      }
    }
  }
  subscribe(_fn) {
    return () => {
    };
  }
  snapshot() {
    return { ...this.runeState };
  }
};
_runeState = new WeakMap();
__name(_RuneState, "RuneState");
let RuneState = _RuneState;
const _RuneStateFactory = class _RuneStateFactory {
  create(instanceId, initial) {
    return new RuneState(initial);
  }
};
__name(_RuneStateFactory, "RuneStateFactory");
let RuneStateFactory = _RuneStateFactory;
const _GlobalDocumentCache = class _GlobalDocumentCache {
  constructor() {
    __privateAdd(this, _actorsById);
    __privateAdd(this, _itemsById);
    __privateAdd(this, _itemsByActorId);
    __privateSet(this, _actorsById, /* @__PURE__ */ state(proxy(/* @__PURE__ */ new Map())));
    __privateSet(this, _itemsById, /* @__PURE__ */ state(proxy(/* @__PURE__ */ new Map())));
    __privateSet(this, _itemsByActorId, /* @__PURE__ */ state(proxy(/* @__PURE__ */ new Map())));
  }
  get actorsById() {
    return get$2(__privateGet(this, _actorsById));
  }
  set actorsById(value2) {
    set$1(__privateGet(this, _actorsById), value2, true);
  }
  get itemsById() {
    return get$2(__privateGet(this, _itemsById));
  }
  set itemsById(value2) {
    set$1(__privateGet(this, _itemsById), value2, true);
  }
  get itemsByActorId() {
    return get$2(__privateGet(this, _itemsByActorId));
  }
  set itemsByActorId(value2) {
    set$1(__privateGet(this, _itemsByActorId), value2, true);
  }
  static getInstance() {
    if (!_GlobalDocumentCache.instance) {
      _GlobalDocumentCache.instance = new _GlobalDocumentCache();
    }
    return _GlobalDocumentCache.instance;
  }
  // Idempotent Patch: nur ändern wenn value differs
  patchActor(actorId, updates) {
    const actor = this.actorsById.get(actorId);
    if (!actor) {
      this.actorsById.set(actorId, { ...updates, id: actorId });
      return;
    }
    let hasChanges = false;
    for (const [key2, value2] of Object.entries(updates)) {
      const typedKey = key2;
      if (actor[typedKey] !== value2) {
        actor[key2] = value2;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      this.actorsById.set(actorId, actor);
    }
  }
  patchItem(itemId, updates) {
    const item = this.itemsById.get(itemId);
    if (!item) {
      this.itemsById.set(itemId, { ...updates, id: itemId });
      if (updates.actorId) {
        const actorItems = this.itemsByActorId.get(updates.actorId) || [];
        if (!actorItems.includes(itemId)) {
          this.itemsByActorId.set(updates.actorId, [...actorItems, itemId]);
        }
      }
      return;
    }
    const oldActorId = item.actorId;
    let hasChanges = false;
    for (const [key2, value2] of Object.entries(updates)) {
      const typedKey = key2;
      if (item[typedKey] !== value2) {
        item[key2] = value2;
        hasChanges = true;
      }
    }
    if (updates.actorId && updates.actorId !== oldActorId) {
      if (oldActorId) {
        const oldActorItems = this.itemsByActorId.get(oldActorId) || [];
        this.itemsByActorId.set(oldActorId, oldActorItems.filter((id2) => id2 !== itemId));
      }
      const newActorItems = this.itemsByActorId.get(updates.actorId) || [];
      if (!newActorItems.includes(itemId)) {
        this.itemsByActorId.set(updates.actorId, [...newActorItems, itemId]);
      }
    }
    if (hasChanges) {
      this.itemsById.set(itemId, item);
    }
  }
  getActor(actorId) {
    return this.actorsById.get(actorId);
  }
  getItem(itemId) {
    return this.itemsById.get(itemId);
  }
  getItemsByActorId(actorId) {
    return this.itemsByActorId.get(actorId) || [];
  }
};
_actorsById = new WeakMap();
_itemsById = new WeakMap();
_itemsByActorId = new WeakMap();
__name(_GlobalDocumentCache, "GlobalDocumentCache");
_GlobalDocumentCache.instance = null;
let GlobalDocumentCache = _GlobalDocumentCache;
const _FlagsPersistAdapter = class _FlagsPersistAdapter {
  async save(config2, data4, meta3) {
    if (config2.type !== "flag") {
      return err({ code: "InvalidType", message: "Not a flag persist config" });
    }
    if (!config2.documentId || !config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Flag config requires documentId, namespace, and key"
      });
    }
    try {
      if (typeof game === "undefined") {
        return err({ code: "GameNotAvailable", message: "Foundry game object not available" });
      }
      const documentType = config2.documentId.split(".")[0];
      if (!documentType) {
        return err({ code: "InvalidConfig", message: "Invalid document ID format" });
      }
      const collectionResult = castFoundryDocumentCollection(game.collections, documentType);
      if (!collectionResult.ok) {
        return err({
          code: "DocumentNotFound",
          message: `Document collection not found: ${collectionResult.error.message}`
        });
      }
      const collection4 = collectionResult.value;
      const doc = collection4.get(config2.documentId);
      if (!doc) {
        return err({
          code: "DocumentNotFound",
          message: `Document ${config2.documentId} not found`
        });
      }
      const documentWithUpdateResult = castFoundryDocumentWithUpdate(doc);
      if (!documentWithUpdateResult.ok) {
        return err({
          code: "OPERATION_FAILED",
          message: `Document does not support update: ${documentWithUpdateResult.error.message}`,
          cause: documentWithUpdateResult.error
        });
      }
      const documentWithUpdate = documentWithUpdateResult.value;
      const changes = {
        [`flags.${config2.namespace}.${config2.key}`]: data4
      };
      const options2 = {
        render: meta3?.render ?? false,
        // Kein Rerender (in options, nicht in changes!)
        windowFrameworkOrigin: meta3
        // Origin-Meta für Hook-Bridge
      };
      await documentWithUpdate.update(changes, options2);
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "SaveFailed",
        message: `Failed to save flag: ${String(error3)}`,
        cause: error3
      });
    }
  }
  async load(config2) {
    if (config2.type !== "flag") {
      return err({ code: "InvalidType", message: "Not a flag persist config" });
    }
    if (!config2.documentId || !config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Flag config requires documentId, namespace, and key"
      });
    }
    try {
      if (typeof game === "undefined") {
        return err({ code: "GameNotAvailable", message: "Foundry game object not available" });
      }
      const documentType = config2.documentId.split(".")[0];
      if (!documentType) {
        return err({ code: "InvalidConfig", message: "Invalid document ID format" });
      }
      const collectionResult = castFoundryDocumentCollection(game.collections, documentType);
      if (!collectionResult.ok) {
        return err({
          code: "DocumentNotFound",
          message: `Document collection not found: ${collectionResult.error.message}`
        });
      }
      const collection4 = collectionResult.value;
      const doc = collection4.get(config2.documentId);
      if (!doc) {
        return err({
          code: "DocumentNotFound",
          message: `Document ${config2.documentId} not found`
        });
      }
      const documentResult = castFoundryDocumentForFlag(doc);
      let flags2;
      if (documentResult.ok) {
        try {
          const flagValue = documentResult.value.getFlag(config2.namespace, config2.key);
          if (isRecord$1(flagValue)) {
            flags2 = flagValue;
          }
        } catch {
          flags2 = void 0;
        }
      }
      if (!flags2) {
        const typedDoc = doc;
        const docFlags = typedDoc.flags?.[config2.namespace];
        if (docFlags && config2.key in docFlags) {
          const flagValue = docFlags[config2.key];
          if (isRecord$1(flagValue)) {
            flags2 = flagValue;
          }
        }
      }
      return ok(flags2 || {});
    } catch (error3) {
      return err({
        code: "LoadFailed",
        message: `Failed to load flag: ${String(error3)}`,
        cause: error3
      });
    }
  }
};
__name(_FlagsPersistAdapter, "FlagsPersistAdapter");
let FlagsPersistAdapter = _FlagsPersistAdapter;
const recordSchema = {
  validate(value2) {
    if (isRecord$1(value2)) {
      return ok(value2);
    }
    return err({
      code: "SETTING_VALIDATION_FAILED",
      message: "Value is not a valid object"
    });
  }
};
const _SettingsPersistAdapter = class _SettingsPersistAdapter {
  constructor(settingsPort) {
    this.settingsPort = settingsPort;
  }
  async save(config2, data4, _meta) {
    if (config2.type !== "setting") {
      return err({ code: "InvalidType", message: "Not a setting persist config" });
    }
    if (!config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Setting config requires namespace and key"
      });
    }
    const result = await this.settingsPort.set(config2.namespace, config2.key, data4);
    if (!result.ok) {
      return err({
        code: "SaveFailed",
        message: result.error.message,
        cause: result.error
      });
    }
    return ok(void 0);
  }
  async load(config2) {
    if (config2.type !== "setting") {
      return err({ code: "InvalidType", message: "Not a setting persist config" });
    }
    if (!config2.namespace || !config2.key) {
      return err({
        code: "InvalidConfig",
        message: "Setting config requires namespace and key"
      });
    }
    const result = this.settingsPort.get(config2.namespace, config2.key, recordSchema);
    if (!result.ok) {
      return err({
        code: "LoadFailed",
        message: result.error.message,
        cause: result.error
      });
    }
    return ok(result.value || {});
  }
};
__name(_SettingsPersistAdapter, "SettingsPersistAdapter");
let SettingsPersistAdapter = _SettingsPersistAdapter;
const _CompositePersistAdapter = class _CompositePersistAdapter {
  constructor(settingsPort) {
    this.flagsAdapter = new FlagsPersistAdapter();
    this.settingsAdapter = new SettingsPersistAdapter(settingsPort);
  }
  async save(config2, data4, meta3) {
    const adapter = this.getAdapter(config2.type);
    return adapter.save(config2, data4, meta3);
  }
  async load(config2) {
    const adapter = this.getAdapter(config2.type);
    return adapter.load(config2);
  }
  getAdapter(type) {
    switch (type) {
      case "flag":
        return this.flagsAdapter;
      case "setting":
        return this.settingsAdapter;
      default:
        return this.flagsAdapter;
    }
  }
};
__name(_CompositePersistAdapter, "CompositePersistAdapter");
_CompositePersistAdapter.dependencies = [platformSettingsPortToken];
let CompositePersistAdapter = _CompositePersistAdapter;
function castResolvedService(value2) {
  return value2;
}
__name(castResolvedService, "castResolvedService");
const _WindowController = class _WindowController {
  constructor(instanceId, definitionId, definition, registry, stateStore, statePortFactory, actionDispatcher, bindingEngine, viewModelBuilder, eventBus, remoteSyncGate, stateInitializer, rendererCoordinator, persistenceCoordinator, container2) {
    this.registry = registry;
    this.stateStore = stateStore;
    this.statePortFactory = statePortFactory;
    this.actionDispatcher = actionDispatcher;
    this.bindingEngine = bindingEngine;
    this.viewModelBuilder = viewModelBuilder;
    this.eventBus = eventBus;
    this.remoteSyncGate = remoteSyncGate;
    this.stateInitializer = stateInitializer;
    this.rendererCoordinator = rendererCoordinator;
    this.persistenceCoordinator = persistenceCoordinator;
    this.container = container2;
    this.componentInstance = null;
    this.isMounted = false;
    this.instanceId = instanceId;
    this.definitionId = definitionId;
    this.definition = definition;
    this.statePort = this.createStatePort();
  }
  get state() {
    return this.statePort.get();
  }
  async onFoundryRender(element3) {
    if (this.isMounted) {
      return ok(void 0);
    }
    this.element = element3;
    const currentState = this.stateStore.getAll(this.instanceId);
    if (currentState.ok && Object.keys(currentState.value).length === 0) {
      const defaultState = this.stateInitializer.buildInitialState(this.definitionId);
      this.statePort.patch(defaultState);
    }
    const bindResult = this.bindingEngine.initialize(this.definition, this.instanceId);
    if (!bindResult.ok) return err(bindResult.error);
    const viewModel = this.viewModelBuilder.build(
      this.definition,
      this.statePort,
      // StatePort statt Plain Object
      this.createActions()
    );
    this.cachedViewModel = viewModel;
    const mountPoint = element3.querySelector("#svelte-mount-point");
    if (!mountPoint) {
      return err({
        code: "MountPointNotFound",
        message: "Mount point #svelte-mount-point not found"
      });
    }
    const mountResult = this.rendererCoordinator.mount(
      this.definition.component,
      mountPoint,
      viewModel
    );
    if (!mountResult.ok) return err(mountResult.error);
    this.componentInstance = mountResult.value;
    this.isMounted = true;
    this.registerEventListeners();
    this.eventBus.emit("window:rendered", { instanceId: this.instanceId });
    const onOpenAction = this.definition.actions?.find((a) => a.id === "onOpen");
    if (onOpenAction) {
      this.dispatchAction("onOpen").catch((error3) => {
        console.error("Failed to execute onOpen action:", error3);
      });
    }
    return ok(void 0);
  }
  async onFoundryUpdate(_element) {
    return ok(void 0);
  }
  async onFoundryClose() {
    if (this.journalEventRegistrationId && this.container) {
      const journalEventsResult = this.container.resolveWithError(platformJournalEventPortToken);
      if (journalEventsResult.ok) {
        const journalEvents = castResolvedService(
          journalEventsResult.value
        );
        journalEvents.unregisterListener(this.journalEventRegistrationId);
        delete this.journalEventRegistrationId;
      }
    }
    if (this.componentInstance !== null) {
      const unmountResult = this.rendererCoordinator.unmount(
        this.definition.component,
        this.componentInstance
      );
      if (!unmountResult.ok) {
        console.error("Failed to unmount component:", unmountResult.error);
      }
      this.componentInstance = null;
    }
    this.isMounted = false;
    if (this.definition.persist) {
      const meta3 = this.remoteSyncGate.makePersistMeta(this.instanceId);
      const state2 = this.statePort.get();
      await this.persistenceCoordinator.persist(this.definition.persist, state2, meta3);
    }
    this.eventBus.emit("window:closed", { instanceId: this.instanceId });
    return ok(void 0);
  }
  async updateStateLocal(updates, options2) {
    const { persist = false, sync = "none" } = options2 ?? {};
    this.statePort.patch(updates);
    if (persist && this.definition.persist) {
      const meta3 = this.remoteSyncGate.makePersistMeta(this.instanceId);
      const state2 = this.statePort.get();
      const persistResult = await this.persistenceCoordinator.persist(
        this.definition.persist,
        state2,
        meta3
      );
      if (!persistResult.ok) return err(persistResult.error);
    }
    if (sync !== "none") {
      const syncResult = await this.bindingEngine.sync(this.instanceId, sync);
      if (!syncResult.ok) return err(syncResult.error);
    }
    for (const [key2, value2] of Object.entries(updates)) {
      this.eventBus.emit("state:updated", { instanceId: this.instanceId, key: key2, value: value2 });
    }
    return ok(void 0);
  }
  async applyRemotePatch(updates) {
    this.statePort.patch(updates);
    for (const [key2, value2] of Object.entries(updates)) {
      this.eventBus.emit("state:updated", { instanceId: this.instanceId, key: key2, value: value2 });
    }
    return ok(void 0);
  }
  async dispatchAction(actionId, controlId, event3, additionalMetadata) {
    const context = {
      windowInstanceId: this.instanceId,
      ...controlId !== void 0 && { controlId },
      state: this.state,
      ...event3 !== void 0 && { event: event3 },
      metadata: {
        controller: this,
        ...this.container !== void 0 && { container: this.container },
        ...additionalMetadata !== void 0 && additionalMetadata
      }
    };
    const result = await this.actionDispatcher.dispatch(actionId, context);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(void 0);
  }
  async persist(meta3) {
    if (!this.definition.persist) {
      return err({
        code: "NoPersistConfig",
        message: "No persist configuration found"
      });
    }
    const state2 = this.statePort.get();
    const persistMeta = meta3 ?? this.remoteSyncGate.makePersistMeta(this.instanceId);
    return await this.persistenceCoordinator.persist(this.definition.persist, state2, persistMeta);
  }
  async restore() {
    if (!this.definition.persist?.restoreOnOpen) {
      return ok(void 0);
    }
    const result = await this.persistenceCoordinator.restore(this.definition.persist);
    if (!result.ok) return err(result.error);
    await this.applyRemotePatch(result.value);
    return ok(void 0);
  }
  getViewModel() {
    if (this.cachedViewModel) {
      return this.cachedViewModel;
    }
    return this.viewModelBuilder.build(this.definition, this.statePort, this.createActions());
  }
  createStatePort() {
    const initialStateResult = this.stateStore.getAll(this.instanceId);
    const initialState = initialStateResult.ok ? initialStateResult.value : {};
    return this.statePortFactory.create(this.instanceId, initialState);
  }
  createActions() {
    const actions = {};
    for (const actionDef of this.definition.actions || []) {
      if (this.definitionId === "journal-overview") {
        if (actionDef.id === "toggleJournalVisibility") {
          actions[actionDef.id] = (journalId) => {
            this.dispatchAction(actionDef.id, void 0, void 0, { journalId });
          };
          continue;
        } else if (actionDef.id === "setSort") {
          actions[actionDef.id] = (column) => {
            this.dispatchAction(actionDef.id, void 0, void 0, { column });
          };
          continue;
        } else if (actionDef.id === "setColumnFilter") {
          actions[actionDef.id] = (column, value2) => {
            this.dispatchAction(actionDef.id, void 0, void 0, { column, value: value2 });
          };
          continue;
        } else if (actionDef.id === "setGlobalSearch") {
          actions[actionDef.id] = (value2) => {
            this.dispatchAction(actionDef.id, void 0, void 0, { value: value2 });
          };
          continue;
        }
      }
      actions[actionDef.id] = () => {
        this.dispatchAction(actionDef.id);
      };
    }
    return actions;
  }
  registerEventListeners() {
    this.eventBus.on("control:action", (payload) => {
      if (payload.instanceId === this.instanceId) {
        this.dispatchAction(payload.actionId, payload.controlId, payload.event);
      }
    });
    if (this.definitionId === "journal-overview" && this.container) {
      const journalEventsResult = this.container.resolveWithError(platformJournalEventPortToken);
      if (journalEventsResult.ok) {
        const journalEvents = castResolvedService(
          journalEventsResult.value
        );
        const registrationResult = journalEvents.onJournalUpdated((event3) => {
          const moduleId = MODULE_METADATA.ID;
          const flagKey = DOMAIN_FLAGS.HIDDEN;
          const moduleFlags = event3.changes.flags?.[moduleId];
          if (moduleFlags && typeof moduleFlags === "object" && flagKey in moduleFlags) {
            this.reloadJournalOverviewData();
          }
        });
        if (registrationResult.ok) {
          this.journalEventRegistrationId = registrationResult.value;
        }
      }
    }
  }
  /**
   * Lädt die Journal-Übersichtsdaten neu und aktualisiert den State.
   * Wird aufgerufen, wenn sich die Visibility eines Journals ändert.
   */
  async reloadJournalOverviewData() {
    if (!this.container) return;
    const serviceResult = this.container.resolveWithError(journalOverviewServiceToken);
    if (!serviceResult.ok) return;
    const service = castResolvedService(serviceResult.value);
    const result = service.getAllJournalsWithVisibilityStatus();
    if (result.ok) {
      await this.updateStateLocal({
        journals: result.value
      });
    }
  }
};
__name(_WindowController, "WindowController");
let WindowController = _WindowController;
const _WindowFactory = class _WindowFactory {
  constructor(registry, foundryWindowAdapter, container2) {
    this.registry = registry;
    this.foundryWindowAdapter = foundryWindowAdapter;
    this.container = container2;
  }
  async createWindow(definitionId, instanceKey, overrides) {
    const definitionResult = this.registry.getDefinition(definitionId);
    if (!definitionResult.ok) {
      return err(definitionResult.error);
    }
    let definition = definitionResult.value;
    if (overrides) {
      definition = { ...definition, ...overrides };
    }
    const instanceId = instanceKey ? `${definitionId}:${instanceKey}` : `${definitionId}:${Date.now()}-${Math.random()}`;
    const controller = this.createController(instanceId, definitionId, definition);
    const appClassResult = this.foundryWindowAdapter.buildApplicationWrapper(
      definition,
      controller,
      instanceId
    );
    if (!appClassResult.ok) {
      return err(appClassResult.error);
    }
    const appClass = appClassResult.value;
    const app = new appClass();
    const instance2 = {
      instanceId,
      definitionId,
      foundryApp: app,
      controller
      // Für Hook-Bridge Zugriff
    };
    const registerResult = this.registry.registerInstance(instance2);
    if (!registerResult.ok) return err(registerResult.error);
    const registry = this.registry;
    const handle = {
      instanceId,
      definitionId,
      controller,
      definition,
      async show() {
        await app.render({ force: true });
        return ok(void 0);
      },
      async hide() {
        await app.render({ force: false });
        return ok(void 0);
      },
      async close() {
        await app.close();
        const unregisterResult = registry.unregisterInstance(instanceId);
        return unregisterResult;
      },
      async update(state2) {
        return controller.updateStateLocal(state2);
      },
      async persist() {
        return controller.persist();
      },
      async restore() {
        return controller.restore();
      }
    };
    return ok(handle);
  }
  createController(instanceId, definitionId, definition) {
    const registryResult = this.container.resolveWithError(windowRegistryToken);
    if (!registryResult.ok) {
      throw new Error(`Failed to resolve WindowRegistry: ${registryResult.error.message}`);
    }
    const registry = castResolvedService(registryResult.value);
    const stateStoreResult = this.container.resolveWithError(stateStoreToken);
    if (!stateStoreResult.ok) {
      throw new Error(`Failed to resolve StateStore: ${stateStoreResult.error.message}`);
    }
    const stateStore = castResolvedService(stateStoreResult.value);
    const statePortFactoryResult = this.container.resolveWithError(statePortFactoryToken);
    if (!statePortFactoryResult.ok) {
      throw new Error(
        `Failed to resolve StatePortFactory: ${statePortFactoryResult.error.message}`
      );
    }
    const statePortFactory = castResolvedService(statePortFactoryResult.value);
    const actionDispatcherResult = this.container.resolveWithError(actionDispatcherToken);
    if (!actionDispatcherResult.ok) {
      throw new Error(
        `Failed to resolve ActionDispatcher: ${actionDispatcherResult.error.message}`
      );
    }
    const actionDispatcher = castResolvedService(actionDispatcherResult.value);
    const bindingEngineResult = this.container.resolveWithError(bindingEngineToken);
    if (!bindingEngineResult.ok) {
      throw new Error(`Failed to resolve BindingEngine: ${bindingEngineResult.error.message}`);
    }
    const bindingEngine = castResolvedService(bindingEngineResult.value);
    const viewModelBuilderResult = this.container.resolveWithError(viewModelBuilderToken);
    if (!viewModelBuilderResult.ok) {
      throw new Error(
        `Failed to resolve ViewModelBuilder: ${viewModelBuilderResult.error.message}`
      );
    }
    const viewModelBuilder = castResolvedService(viewModelBuilderResult.value);
    const eventBusResult = this.container.resolveWithError(eventBusToken);
    if (!eventBusResult.ok) {
      throw new Error(`Failed to resolve EventBus: ${eventBusResult.error.message}`);
    }
    const eventBus = castResolvedService(eventBusResult.value);
    const remoteSyncGateResult = this.container.resolveWithError(remoteSyncGateToken);
    if (!remoteSyncGateResult.ok) {
      throw new Error(`Failed to resolve RemoteSyncGate: ${remoteSyncGateResult.error.message}`);
    }
    const remoteSyncGate = castResolvedService(remoteSyncGateResult.value);
    const stateInitializerResult = this.container.resolveWithError(windowStateInitializerToken);
    if (!stateInitializerResult.ok) {
      throw new Error(
        `Failed to resolve WindowStateInitializer: ${stateInitializerResult.error.message}`
      );
    }
    const stateInitializer = castResolvedService(stateInitializerResult.value);
    const rendererCoordinatorResult = this.container.resolveWithError(
      windowRendererCoordinatorToken
    );
    if (!rendererCoordinatorResult.ok) {
      throw new Error(
        `Failed to resolve WindowRendererCoordinator: ${rendererCoordinatorResult.error.message}`
      );
    }
    const rendererCoordinator = castResolvedService(rendererCoordinatorResult.value);
    const persistenceCoordinatorResult = this.container.resolveWithError(
      windowPersistenceCoordinatorToken
    );
    if (!persistenceCoordinatorResult.ok) {
      throw new Error(
        `Failed to resolve WindowPersistenceCoordinator: ${persistenceCoordinatorResult.error.message}`
      );
    }
    const persistenceCoordinator = castResolvedService(persistenceCoordinatorResult.value);
    return new WindowController(
      instanceId,
      definitionId,
      definition,
      registry,
      stateStore,
      statePortFactory,
      actionDispatcher,
      bindingEngine,
      viewModelBuilder,
      eventBus,
      remoteSyncGate,
      stateInitializer,
      rendererCoordinator,
      persistenceCoordinator,
      this.container
      // Pass container for action handlers
    );
  }
};
__name(_WindowFactory, "WindowFactory");
let WindowFactory = _WindowFactory;
const _WindowHooksService = class _WindowHooksService {
  constructor(bridge) {
    this.bridge = bridge;
  }
  /**
   * Registriert die WindowHooksBridge.
   * Muss nach erfolgreichem Bootstrap aufgerufen werden.
   */
  register() {
    this.bridge.register();
  }
  /**
   * Entfernt die Hook-Registrierungen.
   * Sollte bei Shutdown aufgerufen werden.
   */
  unregister() {
    this.bridge.unregister();
  }
};
__name(_WindowHooksService, "WindowHooksService");
_WindowHooksService.dependencies = [windowHooksBridgeToken];
let WindowHooksService = _WindowHooksService;
const _WindowPositionManager = class _WindowPositionManager {
  constructor() {
    this.STORAGE_KEY_PREFIX = "windowPosition:";
  }
  loadPosition(instanceId) {
    try {
      const key2 = this.getStorageKey(instanceId);
      const stored = localStorage.getItem(key2);
      if (!stored) {
        return ok(void 0);
      }
      const position3 = JSON.parse(stored);
      return ok(position3);
    } catch (error3) {
      return err({
        code: "PositionLoadFailed",
        message: `Failed to load position for ${instanceId}: ${String(error3)}`
      });
    }
  }
  savePosition(instanceId, position3) {
    try {
      const key2 = this.getStorageKey(instanceId);
      localStorage.setItem(key2, JSON.stringify(position3));
      return ok(void 0);
    } catch (error3) {
      return err({
        code: "PositionSaveFailed",
        message: `Failed to save position for ${instanceId}: ${String(error3)}`
      });
    }
  }
  getEffectivePosition(instanceId, initialPosition) {
    const savedResult = this.loadPosition(instanceId);
    if (!savedResult.ok) {
      return err(savedResult.error);
    }
    const saved = savedResult.value;
    if (!saved && !initialPosition) {
      return ok(void 0);
    }
    if (!saved) {
      return ok(initialPosition);
    }
    if (!initialPosition) {
      return ok(saved);
    }
    return ok({
      ...initialPosition,
      ...saved
    });
  }
  getStorageKey(instanceId) {
    return `${this.STORAGE_KEY_PREFIX}${instanceId}`;
  }
};
__name(_WindowPositionManager, "WindowPositionManager");
let WindowPositionManager = _WindowPositionManager;
const _WindowHooksBridge = class _WindowHooksBridge {
  constructor(registry, remoteSyncGate, sharedDocumentCache) {
    this.registry = registry;
    this.remoteSyncGate = remoteSyncGate;
    this.sharedDocumentCache = sharedDocumentCache;
  }
  register() {
    if (typeof Hooks !== "undefined") {
      const hooksApi = Hooks;
      hooksApi.on("updateDocument", (...args2) => {
        const [document2, _update, options2] = args2;
        this.handleDocumentUpdate(document2, _update, options2);
      });
      hooksApi.on("settingChange", (...args2) => {
        const [namespace, key2, value2, options2] = args2;
        this.handleSettingChange(
          // type-coverage:ignore-next-line
          namespace,
          // type-coverage:ignore-next-line
          key2,
          value2,
          options2
        );
      });
    }
  }
  handleDocumentUpdate(document2, update2, options2) {
    const optionsRecord = options2;
    const instances = this.registry.listInstances();
    for (const instance2 of instances) {
      if (this.remoteSyncGate.isFromWindow(optionsRecord, instance2.instanceId)) {
        continue;
      }
      const instanceResult = this.registry.getInstance(instance2.instanceId);
      if (!instanceResult.ok) continue;
      const definitionResult = this.registry.getDefinition(instance2.definitionId);
      if (!definitionResult.ok) continue;
      const definition = definitionResult.value;
      if (this.isRelevant(definition, document2, update2)) {
        const controller = instanceResult.value.controller;
        if (controller) {
          const patch = this.extractPatch(document2, update2);
          controller.applyRemotePatch(patch);
        }
      }
    }
    this.updateSharedCache(document2, update2);
  }
  handleSettingChange(namespace, key2, value2, options2) {
    const instances = this.registry.listInstances();
    const optionsRecord = options2;
    for (const instance2 of instances) {
      if (this.remoteSyncGate.isFromWindow(optionsRecord, instance2.instanceId)) {
        continue;
      }
      const definitionResult = this.registry.getDefinition(instance2.definitionId);
      if (!definitionResult.ok) continue;
      const definition = definitionResult.value;
      if (this.isRelevantForSetting(definition, namespace, key2)) {
      }
    }
  }
  isRelevantForSetting(definition, namespace, key2) {
    if (definition.persist?.type === "setting" && definition.persist.namespace === namespace && definition.persist.key === key2) {
      return true;
    }
    if (definition.dependencies) {
      for (const dep of definition.dependencies) {
        if (dep.type === "setting" && dep.namespace === namespace && dep.key === key2) {
          return true;
        }
      }
    }
    return false;
  }
  isRelevant(definition, document2, _update) {
    if (definition.persist) {
      if (definition.persist.type === "flag" && definition.persist.documentId === document2.id) {
        return true;
      }
      if (definition.persist.type === "journal" && definition.persist.documentId === document2.id) {
        return true;
      }
    }
    if (definition.dependencies) {
      for (const dep of definition.dependencies) {
        if (dep.type === "document" && dep.documentId === document2.id) {
          return true;
        }
        if (dep.type === "document" && dep.documentType) {
          const docType = document2.constructor?.name;
          if (docType === dep.documentType) {
            return true;
          }
        }
      }
    }
    return false;
  }
  extractPatch(document2, update2) {
    const updateRecord = update2;
    return updateRecord || {};
  }
  updateSharedCache(document2, update2) {
    const documentType = document2.constructor?.name || "";
    const updateRecord = update2 || {};
    const docRecord = document2;
    if (documentType === "Actor" || document2.id.startsWith("Actor.")) {
      const actorSnapshot = {
        id: document2.id,
        // type-coverage:ignore-next-line
        name: docRecord.name || "",
        system: (
          // type-coverage:ignore-next-line
          updateRecord.system || // type-coverage:ignore-next-line
          docRecord.system || {}
        ),
        flags: (
          // type-coverage:ignore-next-line
          updateRecord.flags || // type-coverage:ignore-next-line
          docRecord.flags || {}
        )
      };
      this.sharedDocumentCache.patchActor(document2.id, actorSnapshot);
    } else if (documentType === "Item" || document2.id.startsWith("Item.")) {
      const itemSnapshot = {
        id: document2.id,
        // type-coverage:ignore-next-line
        name: docRecord.name || "",
        system: (
          // type-coverage:ignore-next-line
          updateRecord.system || // type-coverage:ignore-next-line
          docRecord.system || {}
        ),
        flags: (
          // type-coverage:ignore-next-line
          updateRecord.flags || // type-coverage:ignore-next-line
          docRecord.flags || {}
        ),
        // type-coverage:ignore-next-line
        actorId: updateRecord.actorId || docRecord.actorId
      };
      this.sharedDocumentCache.patchItem(document2.id, itemSnapshot);
    }
  }
  /**
   * Entfernt die Hook-Registrierungen.
   * Sollte bei Shutdown aufgerufen werden.
   */
  unregister() {
  }
};
__name(_WindowHooksBridge, "WindowHooksBridge");
let WindowHooksBridge = _WindowHooksBridge;
const _DefaultWindowStateInitializer = class _DefaultWindowStateInitializer {
  buildInitialState(_definitionId) {
    return {
      journals: [],
      isLoading: false,
      error: null
    };
  }
};
__name(_DefaultWindowStateInitializer, "DefaultWindowStateInitializer");
let DefaultWindowStateInitializer = _DefaultWindowStateInitializer;
const _WindowStateInitializer = class _WindowStateInitializer {
  constructor(providerRegistry) {
    this.providerRegistry = providerRegistry;
    this.defaultInitializer = new DefaultWindowStateInitializer();
  }
  buildInitialState(definitionId) {
    const provider = this.providerRegistry.get(definitionId);
    if (provider) {
      return provider.buildInitialState(definitionId);
    }
    return this.defaultInitializer.buildInitialState(definitionId);
  }
};
__name(_WindowStateInitializer, "WindowStateInitializer");
_WindowStateInitializer.dependencies = [windowDefaultStateProviderRegistryToken];
let WindowStateInitializer = _WindowStateInitializer;
const _WindowRendererCoordinator = class _WindowRendererCoordinator {
  constructor(rendererRegistry) {
    this.rendererRegistry = rendererRegistry;
  }
  mount(descriptor, mountPoint, viewModel) {
    const rendererResult = this.rendererRegistry.get(descriptor.type);
    if (!rendererResult.ok) {
      return err({
        code: "RendererNotFound",
        message: `Renderer for type "${descriptor.type}" not found: ${rendererResult.error.message}`
      });
    }
    const mountResult = rendererResult.value.mount(descriptor, mountPoint, viewModel);
    if (!mountResult.ok) {
      return err({
        code: "MountFailed",
        message: `Failed to mount component: ${mountResult.error.message}`
      });
    }
    return mountResult;
  }
  unmount(descriptor, instance2) {
    const rendererResult = this.rendererRegistry.get(descriptor.type);
    if (!rendererResult.ok) {
      return err({
        code: "RendererNotFound",
        message: `Renderer for type "${descriptor.type}" not found: ${rendererResult.error.message}`
      });
    }
    const unmountResult = rendererResult.value.unmount(instance2);
    if (!unmountResult.ok) {
      return err({
        code: "UnmountFailed",
        message: `Failed to unmount component: ${unmountResult.error.message}`
      });
    }
    return unmountResult;
  }
  update(descriptor, instance2, viewModel) {
    const rendererResult = this.rendererRegistry.get(descriptor.type);
    if (!rendererResult.ok) {
      return err({
        code: "RendererNotFound",
        message: `Renderer for type "${descriptor.type}" not found: ${rendererResult.error.message}`
      });
    }
    const updateResult = rendererResult.value.update(instance2, viewModel);
    if (!updateResult.ok) {
      return err({
        code: "UpdateFailed",
        message: `Failed to update component: ${updateResult.error.message}`
      });
    }
    return updateResult;
  }
};
__name(_WindowRendererCoordinator, "WindowRendererCoordinator");
_WindowRendererCoordinator.dependencies = [rendererRegistryToken];
let WindowRendererCoordinator = _WindowRendererCoordinator;
const _WindowPersistenceCoordinator = class _WindowPersistenceCoordinator {
  constructor(persistAdapter) {
    this.persistAdapter = persistAdapter;
  }
  async persist(config2, state2, meta3) {
    if (!this.persistAdapter) {
      return err({
        code: "NoPersistAdapter",
        message: "No persist adapter available"
      });
    }
    const result = await this.persistAdapter.save(config2, state2, meta3);
    if (!result.ok) {
      return err({
        code: "PersistFailed",
        message: `Failed to persist state: ${result.error.message}`
      });
    }
    return result;
  }
  async restore(config2) {
    if (!this.persistAdapter) {
      return err({
        code: "NoPersistAdapter",
        message: "No persist adapter available"
      });
    }
    const result = await this.persistAdapter.load(config2);
    if (!result.ok) {
      return err({
        code: "RestoreFailed",
        message: `Failed to restore state: ${result.error.message}`
      });
    }
    return result;
  }
};
__name(_WindowPersistenceCoordinator, "WindowPersistenceCoordinator");
_WindowPersistenceCoordinator.dependencies = [persistAdapterToken];
let WindowPersistenceCoordinator = _WindowPersistenceCoordinator;
const _WindowDefaultStateProviderRegistry = class _WindowDefaultStateProviderRegistry {
  constructor() {
    this.providers = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a default state provider for a window definition.
   *
   * @param definitionId - The window definition ID
   * @param provider - The state initializer provider
   * @throws Error if a provider for the definitionId already exists
   */
  register(definitionId, provider) {
    if (this.providers.has(definitionId)) {
      throw new Error(
        `Window default state provider for definitionId "${definitionId}" already exists. Use a different definitionId or remove the existing provider first.`
      );
    }
    this.providers.set(definitionId, provider);
  }
  /**
   * Gets a default state provider by definitionId.
   *
   * @param definitionId - The window definition ID
   * @returns The state initializer provider or undefined if not found
   */
  get(definitionId) {
    return this.providers.get(definitionId);
  }
  /**
   * Checks if a provider exists for a definitionId.
   *
   * @param definitionId - The window definition ID
   * @returns True if a provider exists
   */
  has(definitionId) {
    return this.providers.has(definitionId);
  }
};
__name(_WindowDefaultStateProviderRegistry, "WindowDefaultStateProviderRegistry");
let WindowDefaultStateProviderRegistry = _WindowDefaultStateProviderRegistry;
const _JournalOverviewStateInitializer = class _JournalOverviewStateInitializer {
  buildInitialState(definitionId) {
    if (definitionId !== "journal-overview") {
      throw new Error(
        `JournalOverviewStateInitializer can only handle "journal-overview" definition, got: ${definitionId}`
      );
    }
    return {
      journals: [],
      isLoading: false,
      error: null,
      sortColumn: null,
      sortDirection: "asc",
      columnFilters: {},
      globalSearch: "",
      filteredJournals: []
    };
  }
};
__name(_JournalOverviewStateInitializer, "JournalOverviewStateInitializer");
let JournalOverviewStateInitializer = _JournalOverviewStateInitializer;
function registerWindowServices(container2) {
  const eventBusResult = container2.registerClass(
    eventBusToken,
    EventBus,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(eventBusResult)) {
    return err(`Failed to register EventBus: ${eventBusResult.error.message}`);
  }
  const stateStoreResult = container2.registerClass(
    stateStoreToken,
    StateStore,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(stateStoreResult)) {
    return err(`Failed to register StateStore: ${stateStoreResult.error.message}`);
  }
  const windowRegistryResult = container2.registerClass(
    windowRegistryToken,
    WindowRegistry,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowRegistryResult)) {
    return err(`Failed to register WindowRegistry: ${windowRegistryResult.error.message}`);
  }
  const remoteSyncGateResult = container2.registerClass(
    remoteSyncGateToken,
    RemoteSyncGate,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(remoteSyncGateResult)) {
    return err(`Failed to register RemoteSyncGate: ${remoteSyncGateResult.error.message}`);
  }
  const rendererRegistry = new RendererRegistry();
  const rendererRegistryResult = container2.registerValue(rendererRegistryToken, rendererRegistry);
  if (isErr(rendererRegistryResult)) {
    return err(`Failed to register RendererRegistry: ${rendererRegistryResult.error.message}`);
  }
  const svelteRenderer = new SvelteRenderer();
  rendererRegistry.register("svelte", svelteRenderer);
  const statePortFactoryResult = container2.registerClass(
    statePortFactoryToken,
    RuneStateFactory,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(statePortFactoryResult)) {
    return err(`Failed to register StatePortFactory: ${statePortFactoryResult.error.message}`);
  }
  const sharedCache = GlobalDocumentCache.getInstance();
  const sharedCacheResult = container2.registerValue(sharedDocumentCacheToken, sharedCache);
  if (isErr(sharedCacheResult)) {
    return err(`Failed to register SharedDocumentCache: ${sharedCacheResult.error.message}`);
  }
  const persistAdapterResult = container2.registerClass(
    persistAdapterToken,
    CompositePersistAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(persistAdapterResult)) {
    return err(`Failed to register PersistAdapter: ${persistAdapterResult.error.message}`);
  }
  const foundryAdapterResult = container2.registerClass(
    foundryWindowAdapterToken,
    FoundryWindowAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(foundryAdapterResult)) {
    return err(`Failed to register FoundryWindowAdapter: ${foundryAdapterResult.error.message}`);
  }
  const actionDispatcherResult = container2.registerClass(
    actionDispatcherToken,
    ActionDispatcher,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(actionDispatcherResult)) {
    return err(`Failed to register ActionDispatcher: ${actionDispatcherResult.error.message}`);
  }
  const bindingEngineResult = container2.registerClass(
    bindingEngineToken,
    BindingEngine,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(bindingEngineResult)) {
    return err(`Failed to register BindingEngine: ${bindingEngineResult.error.message}`);
  }
  const viewModelBuilderResult = container2.registerClass(
    viewModelBuilderToken,
    ViewModelBuilder,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(viewModelBuilderResult)) {
    return err(`Failed to register ViewModelBuilder: ${viewModelBuilderResult.error.message}`);
  }
  const providerRegistry = new WindowDefaultStateProviderRegistry();
  providerRegistry.register("journal-overview", new JournalOverviewStateInitializer());
  const providerRegistryResult = container2.registerValue(
    windowDefaultStateProviderRegistryToken,
    providerRegistry
  );
  if (isErr(providerRegistryResult)) {
    return err(
      `Failed to register WindowDefaultStateProviderRegistry: ${providerRegistryResult.error.message}`
    );
  }
  const stateInitializerResult = container2.registerClass(
    windowStateInitializerToken,
    WindowStateInitializer,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(stateInitializerResult)) {
    return err(
      `Failed to register WindowStateInitializer: ${stateInitializerResult.error.message}`
    );
  }
  const rendererCoordinatorResult = container2.registerClass(
    windowRendererCoordinatorToken,
    WindowRendererCoordinator,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(rendererCoordinatorResult)) {
    return err(
      `Failed to register WindowRendererCoordinator: ${rendererCoordinatorResult.error.message}`
    );
  }
  const persistenceCoordinatorResult = container2.registerClass(
    windowPersistenceCoordinatorToken,
    WindowPersistenceCoordinator,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(persistenceCoordinatorResult)) {
    return err(
      `Failed to register WindowPersistenceCoordinator: ${persistenceCoordinatorResult.error.message}`
    );
  }
  const windowFactoryFactoryResult = container2.registerFactory(
    windowFactoryToken,
    () => {
      const registryResult = container2.resolveWithError(windowRegistryToken);
      if (!registryResult.ok) {
        throw new Error(`Failed to resolve WindowRegistry: ${registryResult.error.message}`);
      }
      const registry = castResolvedService$1(registryResult.value);
      const foundryAdapterResult2 = container2.resolveWithError(foundryWindowAdapterToken);
      if (!foundryAdapterResult2.ok) {
        throw new Error(
          `Failed to resolve FoundryWindowAdapter: ${foundryAdapterResult2.error.message}`
        );
      }
      const foundryAdapter = castResolvedService$1(foundryAdapterResult2.value);
      const containerPortResult = container2.resolveWithError(platformContainerPortToken);
      if (!containerPortResult.ok) {
        throw new Error(
          `Failed to resolve PlatformContainerPort: ${containerPortResult.error.message}`
        );
      }
      const containerPort = castResolvedService$1(containerPortResult.value);
      return new WindowFactory(registry, foundryAdapter, containerPort);
    },
    ServiceLifecycle.SINGLETON,
    [windowRegistryToken, foundryWindowAdapterToken, platformContainerPortToken]
  );
  if (isErr(windowFactoryFactoryResult)) {
    return err(`Failed to register WindowFactory: ${windowFactoryFactoryResult.error.message}`);
  }
  const windowPositionManagerResult = container2.registerClass(
    windowPositionManagerToken,
    WindowPositionManager,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowPositionManagerResult)) {
    return err(
      `Failed to register WindowPositionManager: ${windowPositionManagerResult.error.message}`
    );
  }
  const windowHooksBridgeResult = container2.registerClass(
    windowHooksBridgeToken,
    WindowHooksBridge,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowHooksBridgeResult)) {
    return err(`Failed to register WindowHooksBridge: ${windowHooksBridgeResult.error.message}`);
  }
  const windowHooksServiceResult = container2.registerClass(
    windowHooksServiceToken,
    WindowHooksService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(windowHooksServiceResult)) {
    return err(`Failed to register WindowHooksService: ${windowHooksServiceResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerWindowServices, "registerWindowServices");
dependencyRegistry.register({
  name: "WindowServices",
  priority: 150,
  // After core services (140), before validation (170)
  execute: registerWindowServices
});
function getControllerFromContext(context) {
  return context.metadata?.controller;
}
__name(getControllerFromContext, "getControllerFromContext");
function getContainerFromContext(context) {
  return context.metadata?.container;
}
__name(getContainerFromContext, "getContainerFromContext");
function createJournalSortComparator(sortColumn, sortDirection) {
  return (a, b) => {
    let aVal;
    let bVal;
    if (sortColumn === "name") {
      aVal = (a.name || a.id).toLowerCase();
      bVal = (b.name || b.id).toLowerCase();
    } else if (sortColumn === "status") {
      aVal = a.isHidden ? 1 : 0;
      bVal = b.isHidden ? 1 : 0;
    } else {
      return 0;
    }
    if (aVal < bVal) {
      if (sortDirection === "asc") {
        return -1;
      } else {
        return 1;
      }
    }
    if (aVal > bVal) {
      if (sortDirection === "asc") {
        return 1;
      } else {
        return -1;
      }
    }
    return 0;
  };
}
__name(createJournalSortComparator, "createJournalSortComparator");
function createJournalOverviewWindowDefinition(component3) {
  return {
    definitionId: "journal-overview",
    title: "Journal-Übersicht",
    icon: "fas fa-list",
    component: {
      type: "svelte",
      component: component3,
      props: {}
    },
    features: {
      resizable: true,
      minimizable: true,
      draggable: true,
      closable: true
    },
    position: {
      width: 800,
      height: 600,
      centered: true
    },
    actions: [
      {
        id: "onOpen",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            const container2 = getContainerFromContext(context);
            if (!controller) {
              return err({
                code: "InvalidContext",
                message: "Controller not found in context"
              });
            }
            if (!container2) {
              return err({
                code: "InvalidContext",
                message: "Container not found in context"
              });
            }
            await controller.updateStateLocal({
              isLoading: true,
              error: null
            });
            const serviceResult = container2.resolveWithError(journalOverviewServiceToken);
            if (!serviceResult.ok) {
              await controller.updateStateLocal({
                isLoading: false,
                error: `Failed to resolve JournalOverviewService: ${serviceResult.error.message}`
              });
              return err({
                code: "ServiceNotFound",
                message: `Failed to resolve JournalOverviewService: ${serviceResult.error.message}`
              });
            }
            const service = castResolvedService(serviceResult.value);
            const result = service.getAllJournalsWithVisibilityStatus();
            if (!result.ok) {
              await controller.updateStateLocal({
                isLoading: false,
                error: result.error.message
              });
              return err({
                code: "LoadFailed",
                message: result.error.message
              });
            }
            await controller.updateStateLocal({
              isLoading: false,
              error: null,
              journals: result.value,
              sortColumn: null,
              sortDirection: "asc",
              columnFilters: {},
              globalSearch: ""
            });
            await controller.dispatchAction("applyFilters");
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "toggleJournalVisibility",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            const container2 = getContainerFromContext(context);
            if (!controller || !container2) {
              return err({
                code: "InvalidContext",
                message: "Controller or container not found in context"
              });
            }
            const journalId = context.metadata && typeof context.metadata.journalId === "string" ? context.metadata.journalId : void 0;
            if (!journalId) {
              return err({
                code: "InvalidParameter",
                message: "journalId not provided in metadata"
              });
            }
            const currentState = controller.state;
            const journals = Array.isArray(currentState.journals) ? currentState.journals : [];
            const journal = journals.find((j) => j.id === journalId);
            if (!journal) {
              return err({
                code: "JournalNotFound",
                message: `Journal ${journalId} not found`
              });
            }
            const repoResult = container2.resolveWithError(platformJournalRepositoryToken);
            if (!repoResult.ok) {
              return err({
                code: "ServiceNotFound",
                message: `Failed to resolve PlatformJournalRepository: ${repoResult.error.message}`
              });
            }
            const repository = castResolvedService(repoResult.value);
            const newVisibility = !journal.isHidden;
            let flagResult;
            if (newVisibility) {
              flagResult = await repository.setFlag(
                journalId,
                MODULE_METADATA.ID,
                DOMAIN_FLAGS.HIDDEN,
                true
              );
            } else {
              flagResult = await repository.setFlag(
                journalId,
                MODULE_METADATA.ID,
                DOMAIN_FLAGS.HIDDEN,
                false
              );
            }
            if (!flagResult.ok) {
              return err({
                code: "ToggleFailed",
                message: flagResult.error.message
              });
            }
            const cacheResult = container2.resolveWithError(cacheInvalidationPortToken);
            if (cacheResult.ok) {
              const cache3 = castResolvedService(cacheResult.value);
              cache3.invalidateWhere((meta3) => meta3.tags.includes(HIDDEN_JOURNAL_CACHE_TAG));
            }
            const schedulerResult = container2.resolveWithError(
              journalDirectoryRerenderSchedulerToken
            );
            if (schedulerResult.ok) {
              const scheduler = castResolvedService(
                schedulerResult.value
              );
              scheduler.requestRerender();
            }
            const serviceResult = container2.resolveWithError(journalOverviewServiceToken);
            if (serviceResult.ok) {
              const service = castResolvedService(serviceResult.value);
              const reloadResult = service.getAllJournalsWithVisibilityStatus();
              if (reloadResult.ok) {
                await controller.updateStateLocal({
                  journals: reloadResult.value
                });
                await controller.dispatchAction("applyFilters");
              }
            }
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "setAllVisible",
        handler: /* @__PURE__ */ __name(async (context) => {
          return handleBulkVisibilityChange(context, false);
        }, "handler")
      },
      {
        id: "setAllHidden",
        handler: /* @__PURE__ */ __name(async (context) => {
          return handleBulkVisibilityChange(context, true);
        }, "handler")
      },
      {
        id: "toggleAll",
        handler: /* @__PURE__ */ __name(async (context) => {
          return handleBulkVisibilityChange(context, null);
        }, "handler")
      },
      {
        id: "setSort",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            if (!controller) {
              return err({
                code: "InvalidContext",
                message: "Controller not found in context"
              });
            }
            const column = context.metadata && typeof context.metadata.column === "string" ? context.metadata.column : void 0;
            if (!column) {
              return err({
                code: "InvalidParameter",
                message: "column not provided in metadata"
              });
            }
            const currentState = controller.state;
            const currentSortColumn = currentState.sortColumn ?? null;
            const currentSortDirection = currentState.sortDirection || "asc";
            const newSortColumn = column;
            let newSortDirection = "asc";
            if (currentSortColumn === column) {
              if (currentSortDirection === "asc") {
                newSortDirection = "desc";
              } else {
                newSortDirection = "asc";
              }
            }
            await controller.updateStateLocal({
              sortColumn: newSortColumn,
              sortDirection: newSortDirection
            });
            await controller.dispatchAction("applyFilters");
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "setColumnFilter",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            if (!controller) {
              return err({
                code: "InvalidContext",
                message: "Controller not found in context"
              });
            }
            const column = context.metadata && typeof context.metadata.column === "string" ? context.metadata.column : void 0;
            const value2 = context.metadata && typeof context.metadata.value === "string" ? context.metadata.value : void 0;
            if (!column) {
              return err({
                code: "InvalidParameter",
                message: "column not provided in metadata"
              });
            }
            const currentState = controller.state;
            const currentFilters = currentState.columnFilters || {};
            const newFilters = { ...currentFilters };
            if (value2 === void 0 || value2 === "") {
              delete newFilters[column];
            } else {
              newFilters[column] = value2;
            }
            await controller.updateStateLocal({
              columnFilters: newFilters
            });
            await controller.dispatchAction("applyFilters");
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "setGlobalSearch",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            if (!controller) {
              return err({
                code: "InvalidContext",
                message: "Controller not found in context"
              });
            }
            const value2 = context.metadata && typeof context.metadata.value === "string" ? context.metadata.value : void 0;
            await controller.updateStateLocal({
              globalSearch: value2 ?? ""
            });
            await controller.dispatchAction("applyFilters");
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "applyFilters",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            if (!controller) {
              return err({
                code: "InvalidContext",
                message: "Controller not found in context"
              });
            }
            const currentState = controller.state;
            const journals = Array.isArray(currentState.journals) ? currentState.journals : [];
            const globalSearch = currentState.globalSearch || "";
            const columnFilters = currentState.columnFilters || {};
            const sortColumn = currentState.sortColumn ?? null;
            const sortDirection = currentState.sortDirection || "asc";
            let filtered = [...journals];
            if (globalSearch) {
              const searchLower = globalSearch.toLowerCase();
              filtered = filtered.filter((journal) => {
                const name = (journal.name || journal.id).toLowerCase();
                const status = journal.isHidden ? "versteckt" : "sichtbar";
                return name.includes(searchLower) || status.includes(searchLower);
              });
            }
            if (columnFilters.name) {
              const filterLower = columnFilters.name.toLowerCase();
              filtered = filtered.filter((journal) => {
                const name = (journal.name || journal.id).toLowerCase();
                return name.includes(filterLower);
              });
            }
            if (columnFilters.status) {
              const filterLower = columnFilters.status.toLowerCase();
              filtered = filtered.filter((journal) => {
                const status = journal.isHidden ? "versteckt" : "sichtbar";
                return status.includes(filterLower);
              });
            }
            if (sortColumn && (sortColumn === "name" || sortColumn === "status")) {
              filtered.sort(createJournalSortComparator(sortColumn, sortDirection));
            }
            await controller.updateStateLocal({
              filteredJournals: filtered
            });
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      },
      {
        id: "refreshData",
        handler: /* @__PURE__ */ __name(async (context) => {
          try {
            const controller = getControllerFromContext(context);
            const container2 = getContainerFromContext(context);
            if (!controller || !container2) {
              return err({
                code: "InvalidContext",
                message: "Controller or container not found in context"
              });
            }
            const serviceResult = container2.resolveWithError(journalOverviewServiceToken);
            if (!serviceResult.ok) {
              return err({
                code: "ServiceNotFound",
                message: `Failed to resolve JournalOverviewService: ${serviceResult.error.message}`
              });
            }
            const service = castResolvedService(serviceResult.value);
            const result = service.getAllJournalsWithVisibilityStatus();
            if (!result.ok) {
              return err({
                code: "LoadFailed",
                message: result.error.message
              });
            }
            await controller.updateStateLocal({
              journals: result.value
            });
            await controller.dispatchAction("applyFilters");
            return ok(void 0);
          } catch (error3) {
            const errorMessage = error3 instanceof Error ? error3.message : String(error3);
            return err({
              code: "UnexpectedError",
              message: errorMessage
            });
          }
        }, "handler")
      }
    ]
  };
}
__name(createJournalOverviewWindowDefinition, "createJournalOverviewWindowDefinition");
async function handleBulkVisibilityChange(context, targetVisibility) {
  try {
    const controller = getControllerFromContext(context);
    const container2 = getContainerFromContext(context);
    if (!controller || !container2) {
      return err({
        code: "InvalidContext",
        message: "Controller or container not found in context"
      });
    }
    const currentState = controller.state;
    const filteredJournals = Array.isArray(currentState.filteredJournals) ? currentState.filteredJournals : [];
    if (filteredJournals.length === 0) {
      return ok(void 0);
    }
    const repoResult = container2.resolveWithError(platformJournalRepositoryToken);
    if (!repoResult.ok) {
      return err({
        code: "ServiceNotFound",
        message: `Failed to resolve PlatformJournalRepository: ${repoResult.error.message}`
      });
    }
    const repository = castResolvedService(repoResult.value);
    const uiResult = container2.resolveWithError(platformUIPortToken);
    const notificationsResult = container2.resolveWithError(notificationPublisherPortToken);
    const ui2 = uiResult.ok ? castResolvedService(uiResult.value) : null;
    const notifications2 = notificationsResult.ok ? castResolvedService(notificationsResult.value) : null;
    let successCount = 0;
    let errorCount = 0;
    for (const journal of filteredJournals) {
      const shouldBeHidden = targetVisibility === null ? !journal.isHidden : targetVisibility;
      const flagResult = shouldBeHidden ? await repository.setFlag(journal.id, MODULE_METADATA.ID, DOMAIN_FLAGS.HIDDEN, true) : await repository.setFlag(journal.id, MODULE_METADATA.ID, DOMAIN_FLAGS.HIDDEN, false);
      if (flagResult.ok) {
        successCount++;
      } else {
        errorCount++;
        if (notifications2) {
          notifications2.warn(
            `Failed to change visibility for journal "${journal.name || journal.id}"`,
            { error: flagResult.error },
            { channels: ["ConsoleChannel"] }
          );
        }
      }
    }
    const cacheResult = container2.resolveWithError(cacheInvalidationPortToken);
    if (cacheResult.ok) {
      const cache3 = castResolvedService(cacheResult.value);
      cache3.invalidateWhere((meta3) => meta3.tags.includes(HIDDEN_JOURNAL_CACHE_TAG));
    }
    const schedulerResult = container2.resolveWithError(journalDirectoryRerenderSchedulerToken);
    if (schedulerResult.ok) {
      const scheduler = castResolvedService(
        schedulerResult.value
      );
      scheduler.requestRerender();
    }
    if (ui2) {
      const actionName = targetVisibility === null ? "umschalten" : targetVisibility ? "verstecken" : "anzeigen";
      const message2 = errorCount > 0 ? `${successCount} Journals ${actionName}, ${errorCount} Fehler` : `${successCount} Journals ${actionName}`;
      ui2.notify(message2, "info");
    }
    const serviceResult = container2.resolveWithError(journalOverviewServiceToken);
    if (serviceResult.ok) {
      const service = castResolvedService(serviceResult.value);
      const reloadResult = service.getAllJournalsWithVisibilityStatus();
      if (reloadResult.ok) {
        await controller.updateStateLocal({
          journals: reloadResult.value
        });
        await controller.dispatchAction("applyFilters");
      }
    }
    return ok(void 0);
  } catch (error3) {
    const errorMessage = error3 instanceof Error ? error3.message : String(error3);
    return err({
      code: "UnexpectedError",
      message: errorMessage
    });
  }
}
__name(handleBulkVisibilityChange, "handleBulkVisibilityChange");
var root_1 = /* @__PURE__ */ from_html(`<div class="loading svelte-10sgack"><i class="fas fa-spinner fa-spin"></i> Lade Journale...</div>`);
var root_3 = /* @__PURE__ */ from_html(`<div class="error svelte-10sgack"><i class="fas fa-exclamation-triangle"></i> </div>`);
var root_5 = /* @__PURE__ */ from_html(`<div class="empty svelte-10sgack"><i class="fas fa-inbox"></i> Keine Journale gefunden</div>`);
var root_7 = /* @__PURE__ */ from_html(`<tr class="svelte-10sgack"><td class="journal-name svelte-10sgack"> </td><td class="journal-status svelte-10sgack"><span><i></i> </span></td><td class="journal-actions svelte-10sgack"><button class="toggle-button svelte-10sgack" type="button"><i></i></button></td></tr>`);
var root_6 = /* @__PURE__ */ from_html(`<div class="filter-section svelte-10sgack"><div class="filter-row svelte-10sgack"><div class="filter-group global-search svelte-10sgack"><label for="global-search" class="svelte-10sgack"><i class="fas fa-search"></i> Volltextsuche</label> <input id="global-search" type="text" placeholder="Alle Spalten durchsuchen..." class="svelte-10sgack"/></div></div></div> <table class="journal-table svelte-10sgack"><thead class="svelte-10sgack"><tr><th class="sortable svelte-10sgack"><div class="th-content svelte-10sgack"><button type="button" class="th-header svelte-10sgack"><span>Name</span> <i></i></button> <input id="name-filter" type="text" class="column-filter-input svelte-10sgack" placeholder="Filtern..."/></div></th><th class="sortable svelte-10sgack"><div class="th-content svelte-10sgack"><button type="button" class="th-header svelte-10sgack"><span>Sichtbarkeitsstatus</span> <i></i></button> <input id="status-filter" type="text" class="column-filter-input svelte-10sgack" placeholder="Filtern..."/></div></th><th class="action-column svelte-10sgack"><div class="th-content svelte-10sgack"><div class="th-header svelte-10sgack">Aktionen</div> <div class="column-filter-spacer svelte-10sgack"></div></div></th></tr></thead><tbody class="svelte-10sgack"></tbody></table> <div class="footer-section svelte-10sgack"><div class="info-text svelte-10sgack"> </div> <div class="bulk-actions svelte-10sgack" style="display: flex; flex-direction: row; gap: 0.5rem; flex-wrap: nowrap; align-items: center;"><button class="bulk-action-button svelte-10sgack" type="button"><i class="fas fa-eye"></i> Alle sichtbar</button> <button class="bulk-action-button svelte-10sgack" type="button"><i class="fas fa-eye-slash"></i> Alle unsichtbar</button> <button class="bulk-action-button svelte-10sgack" type="button"><i class="fas fa-exchange-alt"></i> Alle umschalten</button></div></div>`, 1);
var root$1 = /* @__PURE__ */ from_html(`<div class="journal-overview-window svelte-10sgack"><!></div>`);
const $$css = {
  hash: "svelte-10sgack",
  code: ".journal-overview-window.svelte-10sgack {padding:1rem;min-height:400px;}.loading.svelte-10sgack,\r\n  .error.svelte-10sgack,\r\n  .empty.svelte-10sgack {display:flex;align-items:center;justify-content:center;gap:0.5rem;padding:2rem;text-align:center;color:var(--color-text-secondary);}.error.svelte-10sgack {color:var(--color-error);}.journal-table.svelte-10sgack {width:100%;border-collapse:collapse;font-size:0.9rem;}.journal-table.svelte-10sgack thead:where(.svelte-10sgack) {background-color:var(--color-bg-secondary);border-bottom:2px solid var(--color-border);}.journal-table.svelte-10sgack th:where(.svelte-10sgack) {padding:0.75rem;text-align:left;font-weight:600;color:var(--color-text-primary);}.journal-table.svelte-10sgack tbody:where(.svelte-10sgack) tr:where(.svelte-10sgack) {border-bottom:1px solid var(--color-border);}.journal-table.svelte-10sgack tbody:where(.svelte-10sgack) tr:where(.svelte-10sgack):hover {background-color:var(--color-bg-hover);}.journal-table.svelte-10sgack td:where(.svelte-10sgack) {padding:0.75rem;vertical-align:middle;}.journal-name.svelte-10sgack {font-weight:500;color:var(--color-text-primary);}.journal-status.svelte-10sgack {text-align:right;}.status-badge.svelte-10sgack {display:inline-flex;align-items:center;gap:0.5rem;padding:0.25rem 0.75rem;border-radius:0.25rem;font-size:0.85rem;font-weight:500;}.status-visible.svelte-10sgack {background-color:var(--color-success-bg);color:var(--color-success-text);}.status-hidden.svelte-10sgack {background-color:var(--color-warning-bg);color:var(--color-warning-text);}.filter-section.svelte-10sgack {margin-bottom:1rem;padding:1rem;background-color:var(--color-bg-secondary);border-radius:0.25rem;}.filter-row.svelte-10sgack {display:flex;gap:1rem;margin-bottom:0.75rem;}.filter-row.svelte-10sgack:last-child {margin-bottom:0;}.filter-group.svelte-10sgack {flex:1;display:flex;flex-direction:column;gap:0.25rem;}.filter-group.global-search.svelte-10sgack {flex:1;}.filter-group.svelte-10sgack label:where(.svelte-10sgack) {font-size:0.85rem;font-weight:500;color:var(--color-text-secondary);display:flex;align-items:center;gap:0.5rem;}.filter-group.svelte-10sgack input:where(.svelte-10sgack) {padding:0.5rem;border:1px solid var(--color-border);border-radius:0.25rem;font-size:0.9rem;}.filter-group.svelte-10sgack input:where(.svelte-10sgack):focus {outline:none;border-color:var(--color-primary);box-shadow:0 0 0 2px color-mix(in srgb, var(--color-primary) 10%, transparent);}.journal-table.svelte-10sgack th.sortable:where(.svelte-10sgack) {-webkit-user-select:none;-moz-user-select:none;user-select:none;}.th-content.svelte-10sgack {display:flex;flex-direction:column;gap:0.5rem;}.th-header.svelte-10sgack {display:flex;align-items:center;justify-content:space-between;gap:0.5rem;cursor:pointer;background:none;border:none;padding:0;margin:0;font:inherit;color:inherit;text-align:left;width:100%;}.th-header.svelte-10sgack:hover {color:var(--color-primary);}.th-header.svelte-10sgack:focus {outline:2px solid var(--color-primary);outline-offset:2px;}.th-content.svelte-10sgack i:where(.svelte-10sgack) {font-size:0.85rem;color:var(--color-text-secondary);}.column-filter-input.svelte-10sgack {width:100%;padding:0.375rem 0.5rem;border:1px solid var(--color-border);border-radius:0.25rem;font-size:0.85rem;background-color:var(--color-bg-primary);}.column-filter-input.svelte-10sgack:focus {outline:none;border-color:var(--color-primary);box-shadow:0 0 0 2px color-mix(in srgb, var(--color-primary) 10%, transparent);}.action-column.svelte-10sgack {width:80px;text-align:center;}.action-column.svelte-10sgack .th-header:where(.svelte-10sgack) {justify-content:center;}.column-filter-spacer.svelte-10sgack {height:1.875rem; /* Gleiche Höhe wie column-filter-input (padding + border + line-height) */visibility:hidden;}.journal-actions.svelte-10sgack {text-align:center;}.toggle-button.svelte-10sgack {background:none;border:1px solid var(--color-border);border-radius:0.25rem;padding:0.5rem;cursor:pointer;color:var(--color-text-primary);transition:all 0.2s;}.toggle-button.svelte-10sgack:hover {background-color:var(--color-bg-hover);border-color:var(--color-primary);}.toggle-button.svelte-10sgack:active {transform:scale(0.95);}.footer-section.svelte-10sgack {margin-top:1rem;padding-top:1rem;border-top:1px solid var(--color-border);display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;}.info-text.svelte-10sgack {font-size:0.9rem;color:var(--color-text-secondary);}.footer-section.svelte-10sgack .bulk-actions:where(.svelte-10sgack) {display:flex !important;flex-direction:row !important;gap:0.5rem;flex-wrap:nowrap !important;align-items:center;width:auto;min-width:0;}.bulk-action-button.svelte-10sgack {padding:0.5rem 1rem;border:1px solid var(--color-border);border-radius:0.25rem;background-color:var(--color-bg-primary);color:var(--color-text-primary);cursor:pointer;font-size:0.9rem;display:inline-flex !important;align-items:center;gap:0.5rem;transition:all 0.2s;white-space:nowrap;flex-shrink:0;width:auto;min-width:-moz-fit-content;min-width:fit-content;}.bulk-action-button.svelte-10sgack:hover:not(:disabled) {background-color:var(--color-bg-hover);border-color:var(--color-primary);}.bulk-action-button.svelte-10sgack:disabled {opacity:0.5;cursor:not-allowed;}.bulk-action-button.svelte-10sgack:active:not(:disabled) {transform:scale(0.98);}"
};
function JournalOverviewWindow($$anchor, $$props) {
  push$1($$props, true);
  append_styles$1($$anchor, $$css);
  const viewModelState = /* @__PURE__ */ user_derived(() => $$props.viewModel.state.get());
  let globalSearchValue = /* @__PURE__ */ state("");
  let nameFilterValue = /* @__PURE__ */ state("");
  let statusFilterValue = /* @__PURE__ */ state("");
  user_effect(() => {
    set$1(globalSearchValue, get$2(viewModelState).globalSearch || "", true);
    set$1(nameFilterValue, get$2(viewModelState).columnFilters?.name || "", true);
    set$1(statusFilterValue, get$2(viewModelState).columnFilters?.status || "", true);
  });
  const getSortIcon = /* @__PURE__ */ __name((column) => {
    const sortColumn = get$2(viewModelState).sortColumn;
    const sortDirection = get$2(viewModelState).sortDirection;
    if (sortColumn !== column) {
      return "fas fa-sort";
    }
    return sortDirection === "asc" ? "fas fa-sort-up" : "fas fa-sort-down";
  }, "getSortIcon");
  const nameSortIcon = /* @__PURE__ */ user_derived(() => getSortIcon("name"));
  const statusSortIcon = /* @__PURE__ */ user_derived(() => getSortIcon("status"));
  function handleSortClick(column) {
    const action2 = $$props.viewModel.actions.setSort;
    if (action2) {
      action2(column);
    }
  }
  __name(handleSortClick, "handleSortClick");
  function handleGlobalSearchChange() {
    const action2 = $$props.viewModel.actions.setGlobalSearch;
    if (action2) {
      action2(get$2(globalSearchValue));
    }
  }
  __name(handleGlobalSearchChange, "handleGlobalSearchChange");
  function handleColumnFilterChange(column, value2) {
    const action2 = $$props.viewModel.actions.setColumnFilter;
    if (action2) {
      action2(column, value2);
    }
  }
  __name(handleColumnFilterChange, "handleColumnFilterChange");
  function handleToggleVisibility(journalId) {
    const action2 = $$props.viewModel.actions.toggleJournalVisibility;
    if (action2) {
      action2(journalId);
    }
  }
  __name(handleToggleVisibility, "handleToggleVisibility");
  function getStatusText(isHidden, i18n) {
    if (i18n) {
      return isHidden ? i18n.translate("journalOverview.status.hidden", "Versteckt") : i18n.translate("journalOverview.status.visible", "Sichtbar");
    }
    return isHidden ? "Versteckt" : "Sichtbar";
  }
  __name(getStatusText, "getStatusText");
  function getStatusIcon(isHidden) {
    return isHidden ? "fas fa-eye-slash" : "fas fa-eye";
  }
  __name(getStatusIcon, "getStatusIcon");
  function getStatusClass(isHidden) {
    return isHidden ? "status-hidden" : "status-visible";
  }
  __name(getStatusClass, "getStatusClass");
  var div = root$1();
  var node = child(div);
  {
    var consequent = /* @__PURE__ */ __name(($$anchor2) => {
      var div_1 = root_1();
      append($$anchor2, div_1);
    }, "consequent");
    var alternate_2 = /* @__PURE__ */ __name(($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        var consequent_1 = /* @__PURE__ */ __name(($$anchor3) => {
          var div_2 = root_3();
          var text2 = sibling(child(div_2));
          reset(div_2);
          template_effect(() => set_text(text2, ` ${get$2(viewModelState).error ?? ""}`));
          append($$anchor3, div_2);
        }, "consequent_1");
        var alternate_1 = /* @__PURE__ */ __name(($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent_2 = /* @__PURE__ */ __name(($$anchor4) => {
              var div_3 = root_5();
              append($$anchor4, div_3);
            }, "consequent_2");
            var alternate = /* @__PURE__ */ __name(($$anchor4) => {
              var fragment_2 = root_6();
              var div_4 = first_child(fragment_2);
              var div_5 = child(div_4);
              var div_6 = child(div_5);
              var input = sibling(child(div_6), 2);
              remove_input_defaults(input);
              input.__input = handleGlobalSearchChange;
              reset(div_6);
              reset(div_5);
              reset(div_4);
              var table = sibling(div_4, 2);
              var thead = child(table);
              var tr = child(thead);
              var th = child(tr);
              var div_7 = child(th);
              var button = child(div_7);
              button.__click = () => handleSortClick("name");
              var i = sibling(child(button), 2);
              reset(button);
              var input_1 = sibling(button, 2);
              remove_input_defaults(input_1);
              input_1.__input = () => handleColumnFilterChange("name", get$2(nameFilterValue));
              input_1.__click = (e) => e.stopPropagation();
              reset(div_7);
              reset(th);
              var th_1 = sibling(th);
              var div_8 = child(th_1);
              var button_1 = child(div_8);
              button_1.__click = () => handleSortClick("status");
              var i_1 = sibling(child(button_1), 2);
              reset(button_1);
              var input_2 = sibling(button_1, 2);
              remove_input_defaults(input_2);
              input_2.__input = () => handleColumnFilterChange("status", get$2(statusFilterValue));
              input_2.__click = (e) => e.stopPropagation();
              reset(div_8);
              reset(th_1);
              next();
              reset(tr);
              reset(thead);
              var tbody = sibling(thead);
              each(tbody, 21, () => get$2(viewModelState).filteredJournals || [], (journal) => journal.id, ($$anchor5, journal) => {
                var tr_1 = root_7();
                var td = child(tr_1);
                var text_1 = child(td, true);
                reset(td);
                var td_1 = sibling(td);
                var span = child(td_1);
                var i_2 = child(span);
                var text_2 = sibling(i_2);
                reset(span);
                reset(td_1);
                var td_2 = sibling(td_1);
                var button_2 = child(td_2);
                button_2.__click = () => handleToggleVisibility(get$2(journal).id);
                var i_3 = child(button_2);
                reset(button_2);
                reset(td_2);
                reset(tr_1);
                template_effect(
                  ($0, $1, $2, $3) => {
                    set_text(text_1, get$2(journal).name || get$2(journal).id);
                    set_class(span, 1, `status-badge ${$0 ?? ""}`, "svelte-10sgack");
                    set_class(i_2, 1, $1, "svelte-10sgack");
                    set_text(text_2, ` ${$2 ?? ""}`);
                    set_attribute(button_2, "title", get$2(journal).isHidden ? "Journal anzeigen" : "Journal verstecken");
                    set_class(i_3, 1, $3, "svelte-10sgack");
                  },
                  [
                    () => getStatusClass(get$2(journal).isHidden),
                    () => clsx(getStatusIcon(get$2(journal).isHidden)),
                    () => getStatusText(get$2(journal).isHidden, $$props.viewModel.i18n),
                    () => clsx(getStatusIcon(get$2(journal).isHidden))
                  ]
                );
                append($$anchor5, tr_1);
              });
              reset(tbody);
              reset(table);
              var div_9 = sibling(table, 2);
              var div_10 = child(div_9);
              var text_3 = child(div_10);
              reset(div_10);
              var div_11 = sibling(div_10, 2);
              var button_3 = child(div_11);
              button_3.__click = () => {
                const action2 = $$props.viewModel.actions.setAllVisible;
                if (action2) action2();
              };
              var button_4 = sibling(button_3, 2);
              button_4.__click = () => {
                const action2 = $$props.viewModel.actions.setAllHidden;
                if (action2) action2();
              };
              var button_5 = sibling(button_4, 2);
              button_5.__click = () => {
                const action2 = $$props.viewModel.actions.toggleAll;
                if (action2) action2();
              };
              reset(div_11);
              reset(div_9);
              template_effect(() => {
                set_class(i, 1, clsx(get$2(nameSortIcon)), "svelte-10sgack");
                set_class(i_1, 1, clsx(get$2(statusSortIcon)), "svelte-10sgack");
                set_text(text_3, `${(get$2(viewModelState).filteredJournals || []).length ?? ""} von ${(get$2(viewModelState).journals || []).length ?? ""} Journals angezeigt`);
                button_3.disabled = (get$2(viewModelState).filteredJournals || []).length === 0;
                button_4.disabled = (get$2(viewModelState).filteredJournals || []).length === 0;
                button_5.disabled = (get$2(viewModelState).filteredJournals || []).length === 0;
              });
              bind_value(input, () => get$2(globalSearchValue), ($$value) => set$1(globalSearchValue, $$value));
              bind_value(input_1, () => get$2(nameFilterValue), ($$value) => set$1(nameFilterValue, $$value));
              bind_value(input_2, () => get$2(statusFilterValue), ($$value) => set$1(statusFilterValue, $$value));
              append($$anchor4, fragment_2);
            }, "alternate");
            if_block(
              node_2,
              ($$render) => {
                if (get$2(viewModelState).journals.length === 0) $$render(consequent_2);
                else $$render(alternate, false);
              },
              true
            );
          }
          append($$anchor3, fragment_1);
        }, "alternate_1");
        if_block(
          node_1,
          ($$render) => {
            if (get$2(viewModelState).error) $$render(consequent_1);
            else $$render(alternate_1, false);
          },
          true
        );
      }
      append($$anchor2, fragment);
    }, "alternate_2");
    if_block(node, ($$render) => {
      if (get$2(viewModelState).isLoading) $$render(consequent);
      else $$render(alternate_2, false);
    });
  }
  reset(div);
  append($$anchor, div);
  pop();
}
__name(JournalOverviewWindow, "JournalOverviewWindow");
delegate(["input", "click"]);
function registerJournalOverviewWindow(container2) {
  const registryResult = container2.resolveWithError(windowRegistryToken);
  if (!registryResult.ok) {
    return err(`Failed to resolve WindowRegistry: ${registryResult.error.message}`);
  }
  const registry = castResolvedService$1(registryResult.value);
  const definition = createJournalOverviewWindowDefinition(JournalOverviewWindow);
  const registerResult = registry.registerDefinition(definition);
  if (isErr(registerResult)) {
    return err(
      `Failed to register Journal Overview Window Definition: ${registerResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerJournalOverviewWindow, "registerJournalOverviewWindow");
dependencyRegistry.register({
  name: "JournalOverviewWindow",
  priority: 180,
  // After validation (170), same as Loop Prevention Init
  execute: registerJournalOverviewWindow
});
const relationshipPageCollectionAdapterToken = createInjectionToken("RelationshipPageCollectionAdapter");
function findPageById(journal, pageId) {
  const pages = (
    // type-coverage:ignore-next-line - Runtime cast required for Foundry EmbeddedCollection
    journal.pages
  );
  if (!pages) {
    return null;
  }
  if (typeof pages.get === "function") {
    const page = pages.get(pageId);
    return page ?? null;
  }
  if (Array.isArray(pages)) {
    return (
      // type-coverage:ignore-next-line - Runtime cast required for Foundry page array find
      pages.find((p2) => p2?.id === pageId) ?? null
    );
  }
  return null;
}
__name(findPageById, "findPageById");
function extractFlagKey(fullFlagPath) {
  if (fullFlagPath.includes(".")) {
    const parts = fullFlagPath.split(".");
    const lastPart = parts.pop();
    if (lastPart === void 0) {
      return "";
    }
    return lastPart;
  }
  return fullFlagPath;
}
__name(extractFlagKey, "extractFlagKey");
const _FoundryRelationshipPageRepositoryAdapter = class _FoundryRelationshipPageRepositoryAdapter {
  constructor(foundryGame, foundryDocument) {
    this.foundryGame = foundryGame;
    this.foundryDocument = foundryDocument;
  }
  async getNodePageContent(pageId) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      let errorCode;
      if (pageResult.error.code === "ENTITY_NOT_FOUND") {
        errorCode = "ENTITY_NOT_FOUND";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return err({
        code: errorCode,
        message: `Failed to find page ${pageId}: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const castResult = castRelationshipNodePage(page);
    if (!castResult.ok) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Page ${pageId} is not a relationship node page: ${castResult.error.message}`,
        details: castResult.error
      });
    }
    const pageWithSystem = page;
    const systemData = pageWithSystem.system;
    if (!systemData) {
      return err({
        code: "INVALID_ENTITY_DATA",
        message: `Page ${pageId} has no system data`
      });
    }
    return ok(systemData);
  }
  async updateNodePageContent(pageId, data4) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      let errorCode;
      if (pageResult.error.code === "ENTITY_NOT_FOUND") {
        errorCode = "ENTITY_NOT_FOUND";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return err({
        code: errorCode,
        message: `Failed to find page ${pageId}: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const castResult = castRelationshipNodePage(page);
    if (!castResult.ok) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Page ${pageId} is not a relationship node page: ${castResult.error.message}`,
        details: castResult.error
      });
    }
    const pageForUpdate = (
      // type-coverage:ignore-next-line - Runtime cast required for Foundry document update
      page
    );
    const updateResult = await this.foundryDocument.update(
      pageForUpdate,
      {
        system: data4
      },
      { render: false }
    );
    if (!updateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to update page ${pageId}: ${updateResult.error.message}`,
        details: updateResult.error
      });
    }
    return ok(void 0);
  }
  async getGraphPageContent(pageId) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      let errorCode;
      if (pageResult.error.code === "ENTITY_NOT_FOUND") {
        errorCode = "ENTITY_NOT_FOUND";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return err({
        code: errorCode,
        message: `Failed to find page ${pageId}: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const castResult = castRelationshipGraphPage(page);
    if (!castResult.ok) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Page ${pageId} is not a relationship graph page: ${castResult.error.message}`,
        details: castResult.error
      });
    }
    const pageWithSystem = page;
    const systemData = pageWithSystem.system;
    if (!systemData) {
      return err({
        code: "INVALID_ENTITY_DATA",
        message: `Page ${pageId} has no system data`
      });
    }
    return ok(systemData);
  }
  async updateGraphPageContent(pageId, data4) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      let errorCode;
      if (pageResult.error.code === "ENTITY_NOT_FOUND") {
        errorCode = "ENTITY_NOT_FOUND";
      } else {
        errorCode = "OPERATION_FAILED";
      }
      return err({
        code: errorCode,
        message: `Failed to find page ${pageId}: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const castResult = castRelationshipGraphPage(page);
    if (!castResult.ok) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Page ${pageId} is not a relationship graph page: ${castResult.error.message}`,
        details: castResult.error
      });
    }
    const pageForUpdate = (
      // type-coverage:ignore-next-line - Runtime cast required for Foundry document update
      page
    );
    const updateResult = await this.foundryDocument.update(
      pageForUpdate,
      {
        system: data4
      },
      { render: false }
    );
    if (!updateResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to update page ${pageId}: ${updateResult.error.message}`,
        details: updateResult.error
      });
    }
    return ok(void 0);
  }
  async setNodeMarker(pageId, hasNode) {
    return this.setPageFlag(
      pageId,
      extractFlagKey(JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_NODE),
      hasNode
    );
  }
  async setGraphMarker(pageId, hasGraph) {
    return this.setPageFlag(
      pageId,
      extractFlagKey(JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_GRAPH),
      hasGraph
    );
  }
  async getNodeMarker(pageId) {
    return this.getPageFlag(pageId, extractFlagKey(JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_NODE));
  }
  async getGraphMarker(pageId) {
    return this.getPageFlag(pageId, extractFlagKey(JOURNAL_ENTRY_PAGE_FLAGS.IS_RELATIONSHIP_GRAPH));
  }
  /**
   * Helper method to find a page by ID across all journal entries.
   *
   * @param pageId - The page ID to find
   * @returns Result with the page or error
   */
  async findPageById(pageId) {
    const journalsResult = this.foundryGame.getJournalEntries();
    if (!journalsResult.ok) {
      return err({
        code: "PLATFORM_ERROR",
        message: `Failed to get journal entries: ${journalsResult.error.message}`,
        details: journalsResult.error
      });
    }
    for (const journal of journalsResult.value) {
      const page = findPageById(journal, pageId);
      if (page) {
        return ok(page);
      }
    }
    return err({
      code: "ENTITY_NOT_FOUND",
      message: `Page ${pageId} not found in any journal entry`
    });
  }
  /**
   * Helper method to set a flag on a page.
   *
   * @param pageId - The page ID
   * @param flagKey - The flag key (without scope)
   * @param value - The flag value
   * @returns Result indicating success or error
   */
  async setPageFlag(pageId, flagKey, value2) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Page ${pageId} not found: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const documentResult = castFoundryDocumentForFlag(page);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Page does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = await this.foundryDocument.setFlag(
      documentResult.value,
      RELATIONSHIP_FLAGS_MODULE_ID,
      flagKey,
      value2
    );
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to set flag ${RELATIONSHIP_FLAGS_MODULE_ID}.${flagKey}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(void 0);
  }
  /**
   * Helper method to get a flag from a page.
   *
   * @param pageId - The page ID
   * @param flagKey - The flag key (without scope)
   * @returns Result with flag value or error
   */
  async getPageFlag(pageId, flagKey) {
    const pageResult = await this.findPageById(pageId);
    if (!pageResult.ok) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Page ${pageId} not found: ${pageResult.error.message}`,
        details: pageResult.error
      });
    }
    const page = pageResult.value;
    const documentResult = castFoundryDocumentForFlag(page);
    if (!documentResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Page does not support flags: ${documentResult.error.message}`,
        details: documentResult.error
      });
    }
    const flagResult = this.foundryDocument.getFlag(
      documentResult.value,
      RELATIONSHIP_FLAGS_MODULE_ID,
      flagKey,
      /* @__PURE__ */ boolean()
    );
    if (!flagResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to get flag ${RELATIONSHIP_FLAGS_MODULE_ID}.${flagKey}: ${flagResult.error.message}`,
        details: flagResult.error
      });
    }
    return ok(flagResult.value ?? false);
  }
};
__name(_FoundryRelationshipPageRepositoryAdapter, "FoundryRelationshipPageRepositoryAdapter");
let FoundryRelationshipPageRepositoryAdapter = _FoundryRelationshipPageRepositoryAdapter;
const _DIRelationshipPageRepositoryAdapter = class _DIRelationshipPageRepositoryAdapter extends FoundryRelationshipPageRepositoryAdapter {
  constructor(foundryGame, foundryDocument) {
    super(foundryGame, foundryDocument);
  }
};
__name(_DIRelationshipPageRepositoryAdapter, "DIRelationshipPageRepositoryAdapter");
_DIRelationshipPageRepositoryAdapter.dependencies = [foundryGameToken, foundryDocumentToken];
let DIRelationshipPageRepositoryAdapter = _DIRelationshipPageRepositoryAdapter;
function extractPagesFromJournal(journal) {
  const journalWithPages = journal;
  const pages = journalWithPages.pages;
  if (!pages) {
    return [];
  }
  if (Array.isArray(pages)) {
    return pages;
  }
  if (typeof pages === "object" && "contents" in pages && Array.isArray(pages.contents)) {
    return pages.contents;
  }
  return [];
}
__name(extractPagesFromJournal, "extractPagesFromJournal");
const _FoundryRelationshipPageCollectionAdapter = class _FoundryRelationshipPageCollectionAdapter {
  constructor(foundryGame) {
    this.foundryGame = foundryGame;
  }
  async findPagesByType(type) {
    if (type === "node") {
      return this.findNodePages();
    }
    return this.findGraphPages();
  }
  async findNodePages() {
    const journalsResult = this.foundryGame.getJournalEntries();
    if (!journalsResult.ok) {
      return err({
        code: "COLLECTION_NOT_AVAILABLE",
        message: `Failed to get journal entries: ${journalsResult.error.message}`,
        details: journalsResult.error
      });
    }
    const nodePages = [];
    for (const journal of journalsResult.value) {
      const pages = extractPagesFromJournal(journal);
      for (const page of pages) {
        if (isRelationshipNodePage(page)) {
          nodePages.push(page);
        }
      }
    }
    return ok(nodePages);
  }
  async findGraphPages() {
    const journalsResult = this.foundryGame.getJournalEntries();
    if (!journalsResult.ok) {
      return err({
        code: "COLLECTION_NOT_AVAILABLE",
        message: `Failed to get journal entries: ${journalsResult.error.message}`,
        details: journalsResult.error
      });
    }
    const graphPages = [];
    for (const journal of journalsResult.value) {
      const pages = extractPagesFromJournal(journal);
      for (const page of pages) {
        if (isRelationshipGraphPage(page)) {
          graphPages.push(page);
        }
      }
    }
    return ok(graphPages);
  }
  async findPagesByJournalEntry(journalId) {
    const journalResult = this.foundryGame.getJournalEntryById(journalId);
    if (!journalResult.ok) {
      return err({
        code: "COLLECTION_NOT_AVAILABLE",
        message: `Failed to get journal entry ${journalId}: ${journalResult.error.message}`,
        details: journalResult.error
      });
    }
    if (!journalResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal entry ${journalId} not found`
      });
    }
    const pages = extractPagesFromJournal(journalResult.value);
    return ok(pages);
  }
  async findNodePagesByJournalEntry(journalId) {
    const pagesResult = await this.findPagesByJournalEntry(journalId);
    if (!pagesResult.ok) {
      return pagesResult;
    }
    const nodePages = pagesResult.value.filter((page) => isRelationshipNodePage(page));
    return ok(nodePages);
  }
  async findGraphPagesByJournalEntry(journalId) {
    const pagesResult = await this.findPagesByJournalEntry(journalId);
    if (!pagesResult.ok) {
      return pagesResult;
    }
    const graphPages = pagesResult.value.filter((page) => isRelationshipGraphPage(page));
    return ok(graphPages);
  }
};
__name(_FoundryRelationshipPageCollectionAdapter, "FoundryRelationshipPageCollectionAdapter");
let FoundryRelationshipPageCollectionAdapter = _FoundryRelationshipPageCollectionAdapter;
const _DIRelationshipPageCollectionAdapter = class _DIRelationshipPageCollectionAdapter extends FoundryRelationshipPageCollectionAdapter {
  constructor(foundryGame) {
    super(foundryGame);
  }
};
__name(_DIRelationshipPageCollectionAdapter, "DIRelationshipPageCollectionAdapter");
_DIRelationshipPageCollectionAdapter.dependencies = [foundryGameToken];
let DIRelationshipPageCollectionAdapter = _DIRelationshipPageCollectionAdapter;
const _FoundryPageCreationAdapter = class _FoundryPageCreationAdapter {
  constructor(foundryGame) {
    this.foundryGame = foundryGame;
  }
  /**
   * Creates a new relationship node page in a journal entry.
   */
  async createNodePage(journalEntryId, initialData) {
    const journalResult = this.foundryGame.getJournalEntryById(journalEntryId);
    if (!journalResult.ok) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal entry ${journalEntryId} not found: ${journalResult.error.message}`,
        details: journalResult.error
      });
    }
    if (!journalResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal entry ${journalEntryId} not found`
      });
    }
    const journalEntry = journalResult.value;
    const pageData = createRelationshipNodePageData(initialData.name, initialData);
    const createResult = await fromPromise(
      journalEntry.createEmbeddedDocuments(
        "JournalEntryPage",
        castPageDataForCreateEmbeddedDocuments([pageData])
      ),
      (error3) => {
        if (error3 instanceof Error) {
          return error3;
        }
        return new Error(String(error3));
      }
    );
    if (createResult.ok === false) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create node page: ${createResult.error.message}`,
        details: createResult.error
      });
    }
    const createdPages = createResult.value;
    if (!createdPages || createdPages.length === 0) {
      return err({
        code: "OPERATION_FAILED",
        message: "createEmbeddedDocuments returned empty array"
      });
    }
    const createdPage = createdPages[0];
    if (!createdPage) {
      return err({
        code: "OPERATION_FAILED",
        message: "Created pages array is empty"
      });
    }
    const pageId = createdPage.uuid ?? createdPage.id ?? createdPage._id;
    if (!pageId) {
      return err({
        code: "OPERATION_FAILED",
        message: "Created page has no ID (uuid, id, or _id)",
        details: { createdPage }
      });
    }
    return ok(pageId);
  }
  /**
   * Creates a new relationship graph page in a journal entry.
   */
  async createGraphPage(journalEntryId, initialData) {
    const journalResult = this.foundryGame.getJournalEntryById(journalEntryId);
    if (!journalResult.ok) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal entry ${journalEntryId} not found: ${journalResult.error.message}`,
        details: journalResult.error
      });
    }
    if (!journalResult.value) {
      return err({
        code: "ENTITY_NOT_FOUND",
        message: `Journal entry ${journalEntryId} not found`
      });
    }
    const journalEntry = journalResult.value;
    const pageName = initialData.graphKey || "Graph Page";
    const pageData = createRelationshipGraphPageData(pageName, initialData);
    const createResult = await fromPromise(
      journalEntry.createEmbeddedDocuments(
        "JournalEntryPage",
        castPageDataForCreateEmbeddedDocuments([pageData])
      ),
      (error3) => {
        if (error3 instanceof Error) {
          return error3;
        }
        return new Error(String(error3));
      }
    );
    if (createResult.ok === false) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create graph page: ${createResult.error.message}`,
        details: createResult.error
      });
    }
    const createdPages = createResult.value;
    if (!createdPages || createdPages.length === 0) {
      return err({
        code: "OPERATION_FAILED",
        message: "createEmbeddedDocuments returned empty array"
      });
    }
    const createdPage = createdPages[0];
    if (!createdPage) {
      return err({
        code: "OPERATION_FAILED",
        message: "Created pages array is empty"
      });
    }
    const pageId = createdPage.uuid ?? createdPage.id ?? createdPage._id;
    if (!pageId) {
      return err({
        code: "OPERATION_FAILED",
        message: "Created page has no ID (uuid, id, or _id)",
        details: { createdPage }
      });
    }
    return ok(pageId);
  }
};
__name(_FoundryPageCreationAdapter, "FoundryPageCreationAdapter");
let FoundryPageCreationAdapter = _FoundryPageCreationAdapter;
const _DIFoundryPageCreationAdapter = class _DIFoundryPageCreationAdapter extends FoundryPageCreationAdapter {
  constructor(foundryGame) {
    super(foundryGame);
  }
};
__name(_DIFoundryPageCreationAdapter, "DIFoundryPageCreationAdapter");
_DIFoundryPageCreationAdapter.dependencies = [foundryGameToken];
let DIFoundryPageCreationAdapter = _DIFoundryPageCreationAdapter;
function registerRelationshipPageServices(container2) {
  const repositoryResult = container2.registerClass(
    platformRelationshipPageRepositoryPortToken,
    DIRelationshipPageRepositoryAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(repositoryResult)) {
    return err(
      `Failed to register RelationshipPageRepositoryAdapter: ${repositoryResult.error.message}`
    );
  }
  const collectionResult = container2.registerClass(
    relationshipPageCollectionAdapterToken,
    DIRelationshipPageCollectionAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(collectionResult)) {
    return err(
      `Failed to register RelationshipPageCollectionAdapter: ${collectionResult.error.message}`
    );
  }
  const pageCreationResult = container2.registerClass(
    platformPageCreationPortToken,
    DIFoundryPageCreationAdapter,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(pageCreationResult)) {
    return err(
      `Failed to register FoundryPageCreationAdapter: ${pageCreationResult.error.message}`
    );
  }
  return ok(void 0);
}
__name(registerRelationshipPageServices, "registerRelationshipPageServices");
registerDependencyStep({
  name: "RelationshipPageServices",
  priority: 85,
  // After FoundryServices (80) since we depend on FoundryGame/FoundryDocument
  execute: registerRelationshipPageServices
});
const nodeDataMigrations = [];
const graphDataMigrations = [];
const nodeRevealSchema = /* @__PURE__ */ object$1({
  public: /* @__PURE__ */ boolean(),
  hidden: /* @__PURE__ */ boolean()
});
const nodeDescriptionsSchema = /* @__PURE__ */ object$1({
  public: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  hidden: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  gm: /* @__PURE__ */ optional(/* @__PURE__ */ string$1())
});
const nodeEffectsSchema = /* @__PURE__ */ optional(
  /* @__PURE__ */ object$1({
    friend: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
    enemy: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
    neutral: /* @__PURE__ */ optional(/* @__PURE__ */ string$1())
  })
);
const nodeDataLastVersionSchema = /* @__PURE__ */ optional(
  /* @__PURE__ */ object$1({
    schemaVersion: /* @__PURE__ */ number()
  })
);
const relationshipNodeDataSchema = /* @__PURE__ */ object$1({
  schemaVersion: /* @__PURE__ */ literal(RELATIONSHIP_NODE_SCHEMA_VERSION),
  nodeKey: /* @__PURE__ */ string$1(),
  name: /* @__PURE__ */ string$1(),
  kind: /* @__PURE__ */ picklist(["person", "place", "object"]),
  factionId: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  relation: /* @__PURE__ */ picklist(["friend", "enemy", "neutral"]),
  icon: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  descriptions: nodeDescriptionsSchema,
  reveal: nodeRevealSchema,
  effects: nodeEffectsSchema,
  linkedEntityUuid: /* @__PURE__ */ optional(/* @__PURE__ */ string$1()),
  lastVersion: nodeDataLastVersionSchema
});
function parseRelationshipNodeData(data4) {
  return parse$2(relationshipNodeDataSchema, data4);
}
__name(parseRelationshipNodeData, "parseRelationshipNodeData");
function safeParseRelationshipNodeData(data4) {
  return /* @__PURE__ */ safeParse(relationshipNodeDataSchema, data4);
}
__name(safeParseRelationshipNodeData, "safeParseRelationshipNodeData");
const positionSchema = /* @__PURE__ */ object$1({
  x: /* @__PURE__ */ number(),
  y: /* @__PURE__ */ number()
});
const panSchema = /* @__PURE__ */ object$1({
  x: /* @__PURE__ */ number(),
  y: /* @__PURE__ */ number()
});
const graphLayoutSchema = /* @__PURE__ */ optional(
  /* @__PURE__ */ object$1({
    positions: /* @__PURE__ */ optional(/* @__PURE__ */ record(/* @__PURE__ */ string$1(), positionSchema)),
    zoom: /* @__PURE__ */ optional(/* @__PURE__ */ number()),
    pan: /* @__PURE__ */ optional(panSchema)
  })
);
const relationshipEdgeSchema = /* @__PURE__ */ object$1({
  id: /* @__PURE__ */ string$1(),
  source: /* @__PURE__ */ string$1(),
  target: /* @__PURE__ */ string$1(),
  knowledge: /* @__PURE__ */ picklist(["public", "hidden", "secret"]),
  label: /* @__PURE__ */ optional(/* @__PURE__ */ string$1())
});
const graphDataLastVersionSchema = /* @__PURE__ */ optional(
  /* @__PURE__ */ object$1({
    schemaVersion: /* @__PURE__ */ number()
  })
);
const relationshipGraphDataSchema = /* @__PURE__ */ object$1({
  schemaVersion: /* @__PURE__ */ literal(RELATIONSHIP_GRAPH_SCHEMA_VERSION),
  graphKey: /* @__PURE__ */ string$1(),
  nodeKeys: /* @__PURE__ */ array$1(/* @__PURE__ */ string$1()),
  edges: /* @__PURE__ */ array$1(relationshipEdgeSchema),
  layout: graphLayoutSchema,
  lastVersion: graphDataLastVersionSchema
});
function parseRelationshipGraphData(data4) {
  return parse$2(relationshipGraphDataSchema, data4);
}
__name(parseRelationshipGraphData, "parseRelationshipGraphData");
function safeParseRelationshipGraphData(data4) {
  return /* @__PURE__ */ safeParse(relationshipGraphDataSchema, data4);
}
__name(safeParseRelationshipGraphData, "safeParseRelationshipGraphData");
function isRelationshipNodeData$1(data4) {
  const result = safeParseRelationshipNodeData(data4);
  return result.success;
}
__name(isRelationshipNodeData$1, "isRelationshipNodeData$1");
function isRelationshipGraphData$1(data4) {
  const result = safeParseRelationshipGraphData(data4);
  return result.success;
}
__name(isRelationshipGraphData$1, "isRelationshipGraphData$1");
const _MigrationService = class _MigrationService {
  constructor(notifications2) {
    this.notifications = notifications2;
  }
  /**
   * Gets the current schema version from data.
   */
  getCurrentSchemaVersion(data4) {
    if (typeof data4 !== "object" || data4 === null) {
      return 0;
    }
    const dataWithVersion = data4;
    const version2 = dataWithVersion.schemaVersion;
    if (typeof version2 === "number" && version2 > 0) {
      return version2;
    }
    return 0;
  }
  /**
   * Checks if data needs migration.
   */
  needsMigration(data4, schemaType) {
    const currentVersion = this.getCurrentSchemaVersion(data4);
    const latestVersion = schemaType === "node" ? RELATIONSHIP_NODE_SCHEMA_VERSION : RELATIONSHIP_GRAPH_SCHEMA_VERSION;
    return currentVersion > 0 && currentVersion < latestVersion;
  }
  /**
   * Migrates data to the latest schema version.
   *
   * Performs sequential migration: Version 1 → 2 → 3...
   * Returns data as-is if already at latest version or no migrations available.
   */
  async migrateToLatest(data4, schemaType) {
    const currentVersion = this.getCurrentSchemaVersion(data4);
    const latestVersion = schemaType === "node" ? RELATIONSHIP_NODE_SCHEMA_VERSION : RELATIONSHIP_GRAPH_SCHEMA_VERSION;
    if (currentVersion === latestVersion) {
      if (schemaType === "node") {
        if (!isRelationshipNodeData$1(data4)) {
          return err({
            code: "MIGRATION_FAILED",
            message: "Data at latest version does not match RelationshipNodeData schema",
            details: { data: data4, schemaType }
          });
        }
        return ok(data4);
      } else {
        if (!isRelationshipGraphData$1(data4)) {
          return err({
            code: "MIGRATION_FAILED",
            message: "Data at latest version does not match RelationshipGraphData schema",
            details: { data: data4, schemaType }
          });
        }
        return ok(data4);
      }
    }
    if (currentVersion === 0) {
      return err({
        code: "MIGRATION_VERSION_UNSUPPORTED",
        message: `Cannot migrate: data has no valid schema version`,
        details: { data: data4, schemaType }
      });
    }
    if (currentVersion > latestVersion) {
      this.notifications.warn(
        `Data schema version (${currentVersion}) is higher than latest supported version (${latestVersion}). Using data as-is.`,
        { data: data4, schemaType, currentVersion, latestVersion },
        { channels: ["ConsoleChannel"] }
      );
      if (schemaType === "node") {
        if (!isRelationshipNodeData$1(data4)) {
          return err({
            code: "MIGRATION_FAILED",
            message: "Data with higher version does not match RelationshipNodeData schema",
            details: { data: data4, schemaType, currentVersion, latestVersion }
          });
        }
        return ok(data4);
      } else {
        if (!isRelationshipGraphData$1(data4)) {
          return err({
            code: "MIGRATION_FAILED",
            message: "Data with higher version does not match RelationshipGraphData schema",
            details: { data: data4, schemaType, currentVersion, latestVersion }
          });
        }
        return ok(data4);
      }
    }
    const migrations = schemaType === "node" ? nodeDataMigrations : graphDataMigrations;
    const applicableMigrations = migrations.filter(
      (migration) => migration.fromVersion >= currentVersion && migration.toVersion <= latestVersion
    );
    applicableMigrations.sort((a, b) => a.fromVersion - b.fromVersion);
    let migratedData = data4;
    let lastVersion = currentVersion;
    for (const migration of applicableMigrations) {
      if (lastVersion !== migration.fromVersion) {
        return err({
          code: "MIGRATION_FAILED",
          message: `Migration chain broken: expected version ${migration.fromVersion}, but data is at version ${lastVersion}`,
          details: {
            data: migratedData,
            schemaType,
            lastVersion,
            expectedVersion: migration.fromVersion
          }
        });
      }
      try {
        migratedData = await migration.migrate(migratedData);
        lastVersion = migration.toVersion;
      } catch (error3) {
        return err({
          code: "MIGRATION_FAILED",
          message: `Migration from version ${migration.fromVersion} to ${migration.toVersion} failed: ${error3 instanceof Error ? error3.message : String(error3)}`,
          details: { data: migratedData, schemaType, migration },
          originalError: error3
        });
      }
    }
    const finalVersion = this.getCurrentSchemaVersion(migratedData);
    if (finalVersion !== latestVersion) {
      return err({
        code: "MIGRATION_FAILED",
        message: `Migration completed but final version (${finalVersion}) does not match expected version (${latestVersion})`,
        details: { data: migratedData, schemaType, finalVersion, expectedVersion: latestVersion }
      });
    }
    if (schemaType === "node") {
      if (!isRelationshipNodeData$1(migratedData)) {
        return err({
          code: "MIGRATION_FAILED",
          message: "Migrated data does not match RelationshipNodeData schema",
          details: { data: migratedData, schemaType, finalVersion }
        });
      }
      return ok(migratedData);
    } else {
      if (!isRelationshipGraphData$1(migratedData)) {
        return err({
          code: "MIGRATION_FAILED",
          message: "Migrated data does not match RelationshipGraphData schema",
          details: { data: migratedData, schemaType, finalVersion }
        });
      }
      return ok(migratedData);
    }
  }
};
__name(_MigrationService, "MigrationService");
let MigrationService = _MigrationService;
const _DIMigrationService = class _DIMigrationService extends MigrationService {
  constructor(notifications2) {
    super(notifications2);
  }
};
__name(_DIMigrationService, "DIMigrationService");
_DIMigrationService.dependencies = [notificationPublisherPortToken];
let DIMigrationService = _DIMigrationService;
function isRelationshipNodeData(data4) {
  const result = safeParseRelationshipNodeData(data4);
  return result.success;
}
__name(isRelationshipNodeData, "isRelationshipNodeData");
const _NodeDataService = class _NodeDataService {
  constructor(repository, migrationService, notifications2) {
    this.repository = repository;
    this.migrationService = migrationService;
    this.notifications = notifications2;
  }
  /**
   * Validates node data against the schema.
   */
  validateNodeData(data4) {
    const validationResult = safeParseRelationshipNodeData(data4);
    if (!validationResult.success) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Node data validation failed: ${validationResult.issues.map((i) => i.message).join(", ")}`,
        details: validationResult.issues
      });
    }
    return ok(void 0);
  }
  /**
   * Loads node data from a page.
   *
   * Performs migration if needed before returning data.
   */
  async loadNodeData(pageId) {
    const loadResult = await this.repository.getNodePageContent(pageId);
    if (!loadResult.ok) {
      return this.mapRepositoryError(loadResult.error);
    }
    const rawData = loadResult.value;
    if (this.migrationService.needsMigration(rawData, "node")) {
      this.notifications.debug(
        `Node data at page ${pageId} needs migration`,
        { pageId, currentVersion: this.migrationService.getCurrentSchemaVersion(rawData) },
        { channels: ["ConsoleChannel"] }
      );
      const backup = {
        ...rawData
      };
      const migrationResult = await this.migrationService.migrateToLatest(rawData, "node");
      if (!migrationResult.ok) {
        this.notifications.error(
          `Failed to migrate node data at page ${pageId}`,
          migrationResult.error,
          { channels: ["ConsoleChannel"] }
        );
        return migrationResult;
      }
      if (!isRelationshipNodeData(migrationResult.value)) {
        return err({
          code: "VALIDATION_FAILED",
          message: "Migrated node data does not match RelationshipNodeData schema",
          details: { pageId, migratedData: migrationResult.value }
        });
      }
      const migratedNodeData = {
        ...migrationResult.value,
        lastVersion: backup
      };
      const saveResult = await this.saveNodeData(pageId, migratedNodeData);
      if (!saveResult.ok) {
        this.notifications.error(
          `Node data migrated but failed to save at page ${pageId}`,
          saveResult.error,
          { channels: ["ConsoleChannel"] }
        );
        return saveResult;
      }
      return ok(migratedNodeData);
    }
    const validationResult = this.validateNodeData(rawData);
    if (!validationResult.ok) {
      return validationResult;
    }
    return ok(rawData);
  }
  /**
   * Saves node data to a page.
   *
   * Validates data before saving.
   */
  async saveNodeData(pageId, data4) {
    const validationResult = this.validateNodeData(data4);
    if (!validationResult.ok) {
      return validationResult;
    }
    const saveResult = await this.repository.updateNodePageContent(pageId, data4);
    if (!saveResult.ok) {
      return this.mapRepositoryError(saveResult.error);
    }
    return ok(void 0);
  }
  /**
   * Maps repository errors to service errors.
   */
  mapRepositoryError(error3) {
    return err({
      code: "REPOSITORY_ERROR",
      message: error3.message,
      details: error3
    });
  }
};
__name(_NodeDataService, "NodeDataService");
let NodeDataService = _NodeDataService;
const _DINodeDataService = class _DINodeDataService extends NodeDataService {
  constructor(repository, migrationService, notifications2) {
    super(repository, migrationService, notifications2);
  }
};
__name(_DINodeDataService, "DINodeDataService");
_DINodeDataService.dependencies = [
  platformRelationshipPageRepositoryPortToken,
  migrationServiceToken,
  notificationPublisherPortToken
];
let DINodeDataService = _DINodeDataService;
function isRelationshipGraphData(data4) {
  const result = safeParseRelationshipGraphData(data4);
  return result.success;
}
__name(isRelationshipGraphData, "isRelationshipGraphData");
const _GraphDataService = class _GraphDataService {
  constructor(repository, migrationService, notifications2) {
    this.repository = repository;
    this.migrationService = migrationService;
    this.notifications = notifications2;
  }
  /**
   * Validates graph data against the schema.
   */
  validateGraphData(data4) {
    const validationResult = safeParseRelationshipGraphData(data4);
    if (!validationResult.success) {
      return err({
        code: "VALIDATION_FAILED",
        message: `Graph data validation failed: ${validationResult.issues.map((i) => i.message).join(", ")}`,
        details: validationResult.issues
      });
    }
    return ok(void 0);
  }
  /**
   * Loads graph data from a page.
   *
   * Performs migration if needed before returning data.
   */
  async loadGraphData(pageId) {
    const loadResult = await this.repository.getGraphPageContent(pageId);
    if (!loadResult.ok) {
      return this.mapRepositoryError(loadResult.error);
    }
    const rawData = loadResult.value;
    if (this.migrationService.needsMigration(rawData, "graph")) {
      this.notifications.debug(
        `Graph data at page ${pageId} needs migration`,
        { pageId, currentVersion: this.migrationService.getCurrentSchemaVersion(rawData) },
        { channels: ["ConsoleChannel"] }
      );
      const backup = {
        ...rawData
      };
      const migrationResult = await this.migrationService.migrateToLatest(rawData, "graph");
      if (!migrationResult.ok) {
        this.notifications.error(
          `Failed to migrate graph data at page ${pageId}`,
          migrationResult.error,
          { channels: ["ConsoleChannel"] }
        );
        return migrationResult;
      }
      if (!isRelationshipGraphData(migrationResult.value)) {
        return err({
          code: "VALIDATION_FAILED",
          message: "Migrated graph data does not match RelationshipGraphData schema",
          details: { pageId, migratedData: migrationResult.value }
        });
      }
      const migratedGraphData = {
        ...migrationResult.value,
        lastVersion: backup
      };
      const saveResult = await this.saveGraphData(pageId, migratedGraphData);
      if (!saveResult.ok) {
        this.notifications.error(
          `Graph data migrated but failed to save at page ${pageId}`,
          saveResult.error,
          { channels: ["ConsoleChannel"] }
        );
        return saveResult;
      }
      return ok(migratedGraphData);
    }
    const validationResult = this.validateGraphData(rawData);
    if (!validationResult.ok) {
      return validationResult;
    }
    return ok(rawData);
  }
  /**
   * Saves graph data to a page.
   *
   * Validates data before saving.
   * Implements MVP Conflict Policy: Last-write-wins + Warning Banner.
   */
  async saveGraphData(pageId, data4) {
    const validationResult = this.validateGraphData(data4);
    if (!validationResult.ok) {
      return validationResult;
    }
    const currentDataResult = await this.repository.getGraphPageContent(pageId);
    if (currentDataResult.ok && currentDataResult.value.lastVersion) {
      this.notifications.warn(
        `Graph data at page ${pageId} has been modified since last load. Using last-write-wins strategy.`,
        { pageId },
        { channels: ["ConsoleChannel"] }
      );
    }
    const saveResult = await this.repository.updateGraphPageContent(pageId, data4);
    if (!saveResult.ok) {
      return this.mapRepositoryError(saveResult.error);
    }
    return ok(void 0);
  }
  /**
   * Maps repository errors to service errors.
   */
  mapRepositoryError(error3) {
    return err({
      code: "REPOSITORY_ERROR",
      message: error3.message,
      details: error3
    });
  }
};
__name(_GraphDataService, "GraphDataService");
let GraphDataService = _GraphDataService;
const _DIGraphDataService = class _DIGraphDataService extends GraphDataService {
  constructor(repository, migrationService, notifications2) {
    super(repository, migrationService, notifications2);
  }
};
__name(_DIGraphDataService, "DIGraphDataService");
_DIGraphDataService.dependencies = [
  platformRelationshipPageRepositoryPortToken,
  migrationServiceToken,
  notificationPublisherPortToken
];
let DIGraphDataService = _DIGraphDataService;
const _CreateNodePageUseCase = class _CreateNodePageUseCase {
  constructor(journalRepository, nodeDataService, pageRepository, pageCreationPort, notifications2) {
    this.journalRepository = journalRepository;
    this.nodeDataService = nodeDataService;
    this.pageRepository = pageRepository;
    this.pageCreationPort = pageCreationPort;
    this.notifications = notifications2;
  }
  /**
   * Creates a new node page.
   *
   * Steps:
   * 1. Validate journal entry exists
   * 2. Validate node data
   * 3. Create page (via Foundry API - requires infrastructure access)
   * 4. Save node data to page
   * 5. Set marker flag
   * 6. Return created page
   */
  async execute(input) {
    const journalResult = await this.journalRepository.getById(input.journalEntryId);
    if (!journalResult.ok) {
      return err({
        code: "JOURNAL_NOT_FOUND",
        message: `Journal entry ${input.journalEntryId} not found: ${journalResult.error.message}`,
        details: journalResult.error
      });
    }
    const validationResult = this.nodeDataService.validateNodeData(input.nodeData);
    if (!validationResult.ok) {
      return validationResult;
    }
    const pageCreationResult = await this.pageCreationPort.createNodePage(
      input.journalEntryId,
      input.nodeData
    );
    if (!pageCreationResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create node page: ${pageCreationResult.error.message}`,
        details: pageCreationResult.error
      });
    }
    const pageId = pageCreationResult.value;
    const saveResult = await this.nodeDataService.saveNodeData(pageId, input.nodeData);
    if (!saveResult.ok) {
      this.notifications.error(`Failed to save node data to page ${pageId}`, saveResult.error, {
        channels: ["ConsoleChannel"]
      });
      return saveResult;
    }
    const flagResult = await this.pageRepository.setNodeMarker(pageId, true);
    if (!flagResult.ok) {
      this.notifications.warn(
        `Failed to set node marker flag for page ${pageId}`,
        flagResult.error,
        { channels: ["ConsoleChannel"] }
      );
    }
    return ok(pageId);
  }
};
__name(_CreateNodePageUseCase, "CreateNodePageUseCase");
let CreateNodePageUseCase = _CreateNodePageUseCase;
const _DICreateNodePageUseCase = class _DICreateNodePageUseCase extends CreateNodePageUseCase {
  constructor(journalRepository, nodeDataService, pageRepository, pageCreationPort, notifications2) {
    super(journalRepository, nodeDataService, pageRepository, pageCreationPort, notifications2);
  }
};
__name(_DICreateNodePageUseCase, "DICreateNodePageUseCase");
_DICreateNodePageUseCase.dependencies = [
  platformJournalRepositoryToken,
  nodeDataServiceToken,
  platformRelationshipPageRepositoryPortToken,
  platformPageCreationPortToken,
  notificationPublisherPortToken
];
let DICreateNodePageUseCase = _DICreateNodePageUseCase;
const _CreateGraphPageUseCase = class _CreateGraphPageUseCase {
  constructor(journalRepository, graphDataService, pageRepository, pageCreationPort, notifications2) {
    this.journalRepository = journalRepository;
    this.graphDataService = graphDataService;
    this.pageRepository = pageRepository;
    this.pageCreationPort = pageCreationPort;
    this.notifications = notifications2;
  }
  /**
   * Creates a new graph page.
   *
   * Steps:
   * 1. Validate journal entry exists
   * 2. Validate graph data
   * 3. Create page (via Foundry API - requires infrastructure access)
   * 4. Save graph data to page (lastVersion initial empty)
   * 5. Set marker flag
   * 6. Return created page
   */
  async execute(input) {
    const journalResult = await this.journalRepository.getById(input.journalEntryId);
    if (!journalResult.ok) {
      return err({
        code: "JOURNAL_NOT_FOUND",
        message: `Journal entry ${input.journalEntryId} not found: ${journalResult.error.message}`,
        details: journalResult.error
      });
    }
    const validationResult = this.graphDataService.validateGraphData(input.graphData);
    if (!validationResult.ok) {
      return validationResult;
    }
    const pageCreationResult = await this.pageCreationPort.createGraphPage(
      input.journalEntryId,
      input.graphData
    );
    if (!pageCreationResult.ok) {
      return err({
        code: "OPERATION_FAILED",
        message: `Failed to create graph page: ${pageCreationResult.error.message}`,
        details: pageCreationResult.error
      });
    }
    const pageId = pageCreationResult.value;
    const saveResult = await this.graphDataService.saveGraphData(pageId, input.graphData);
    if (!saveResult.ok) {
      this.notifications.error(`Failed to save graph data to page ${pageId}`, saveResult.error, {
        channels: ["ConsoleChannel"]
      });
      return saveResult;
    }
    const flagResult = await this.pageRepository.setGraphMarker(pageId, true);
    if (!flagResult.ok) {
      this.notifications.warn(
        `Failed to set graph marker flag for page ${pageId}`,
        flagResult.error,
        { channels: ["ConsoleChannel"] }
      );
    }
    return ok(pageId);
  }
};
__name(_CreateGraphPageUseCase, "CreateGraphPageUseCase");
let CreateGraphPageUseCase = _CreateGraphPageUseCase;
const _DICreateGraphPageUseCase = class _DICreateGraphPageUseCase extends CreateGraphPageUseCase {
  constructor(journalRepository, graphDataService, pageRepository, pageCreationPort, notifications2) {
    super(journalRepository, graphDataService, pageRepository, pageCreationPort, notifications2);
  }
};
__name(_DICreateGraphPageUseCase, "DICreateGraphPageUseCase");
_DICreateGraphPageUseCase.dependencies = [
  platformJournalRepositoryToken,
  graphDataServiceToken,
  platformRelationshipPageRepositoryPortToken,
  platformPageCreationPortToken,
  notificationPublisherPortToken
];
let DICreateGraphPageUseCase = _DICreateGraphPageUseCase;
const _AddNodeToGraphUseCase = class _AddNodeToGraphUseCase {
  constructor(graphDataService, nodeDataService, pageRepository, notifications2) {
    this.graphDataService = graphDataService;
    this.nodeDataService = nodeDataService;
    this.pageRepository = pageRepository;
    this.notifications = notifications2;
  }
  /**
   * Adds a node to a graph.
   *
   * Steps:
   * 1. Load graph data (with migration if needed)
   * 2. Validate node page exists and is a node type
   * 3. Add nodeKey to nodeKeys array (if not already present)
   * 4. Save graph data
   */
  async execute(input) {
    const graphDataResult = await this.graphDataService.loadGraphData(input.graphPageId);
    if (!graphDataResult.ok) {
      return graphDataResult;
    }
    const graphData = graphDataResult.value;
    const nodeDataResult = await this.nodeDataService.loadNodeData(input.nodePageId);
    if (!nodeDataResult.ok) {
      return err({
        code: "NODE_NOT_FOUND",
        message: `Node page ${input.nodePageId} not found or invalid: ${nodeDataResult.error.message}`,
        details: nodeDataResult.error
      });
    }
    const nodeKey = input.nodePageId;
    if (graphData.nodeKeys.includes(nodeKey)) {
      return ok(void 0);
    }
    graphData.nodeKeys.push(nodeKey);
    const saveResult = await this.graphDataService.saveGraphData(input.graphPageId, graphData);
    if (!saveResult.ok) {
      return saveResult;
    }
    return ok(void 0);
  }
};
__name(_AddNodeToGraphUseCase, "AddNodeToGraphUseCase");
let AddNodeToGraphUseCase = _AddNodeToGraphUseCase;
const _DIAddNodeToGraphUseCase = class _DIAddNodeToGraphUseCase extends AddNodeToGraphUseCase {
  constructor(graphDataService, nodeDataService, pageRepository, notifications2) {
    super(graphDataService, nodeDataService, pageRepository, notifications2);
  }
};
__name(_DIAddNodeToGraphUseCase, "DIAddNodeToGraphUseCase");
_DIAddNodeToGraphUseCase.dependencies = [
  graphDataServiceToken,
  nodeDataServiceToken,
  platformRelationshipPageRepositoryPortToken,
  notificationPublisherPortToken
];
let DIAddNodeToGraphUseCase = _DIAddNodeToGraphUseCase;
const _RemoveNodeFromGraphUseCase = class _RemoveNodeFromGraphUseCase {
  constructor(graphDataService, notifications2) {
    this.graphDataService = graphDataService;
    this.notifications = notifications2;
  }
  /**
   * Removes a node from a graph.
   *
   * Steps:
   * 1. Load graph data (with migration if needed)
   * 2. Remove nodeKey from nodeKeys array
   * 3. Remove all edges involving this nodeKey (cleanup)
   * 4. Save graph data
   */
  async execute(input) {
    const graphDataResult = await this.graphDataService.loadGraphData(input.graphPageId);
    if (!graphDataResult.ok) {
      return graphDataResult;
    }
    const graphData = graphDataResult.value;
    const nodeKey = input.nodePageId;
    const nodeKeyIndex = graphData.nodeKeys.indexOf(nodeKey);
    if (nodeKeyIndex === -1) {
      return ok(void 0);
    }
    graphData.nodeKeys.splice(nodeKeyIndex, 1);
    graphData.edges = graphData.edges.filter(
      (edge) => edge.source !== nodeKey && edge.target !== nodeKey
    );
    const saveResult = await this.graphDataService.saveGraphData(input.graphPageId, graphData);
    if (!saveResult.ok) {
      return saveResult;
    }
    return ok(void 0);
  }
};
__name(_RemoveNodeFromGraphUseCase, "RemoveNodeFromGraphUseCase");
let RemoveNodeFromGraphUseCase = _RemoveNodeFromGraphUseCase;
const _DIRemoveNodeFromGraphUseCase = class _DIRemoveNodeFromGraphUseCase extends RemoveNodeFromGraphUseCase {
  constructor(graphDataService, notifications2) {
    super(graphDataService, notifications2);
  }
};
__name(_DIRemoveNodeFromGraphUseCase, "DIRemoveNodeFromGraphUseCase");
_DIRemoveNodeFromGraphUseCase.dependencies = [graphDataServiceToken, notificationPublisherPortToken];
let DIRemoveNodeFromGraphUseCase = _DIRemoveNodeFromGraphUseCase;
const _UpsertEdgeUseCase = class _UpsertEdgeUseCase {
  constructor(graphDataService, notifications2) {
    this.graphDataService = graphDataService;
    this.notifications = notifications2;
  }
  /**
   * Upserts an edge in a graph.
   *
   * Steps:
   * 1. Load graph data (with migration if needed)
   * 2. Find existing edge by ID, update or insert
   * 3. Save graph data
   */
  async execute(input) {
    const graphDataResult = await this.graphDataService.loadGraphData(input.graphPageId);
    if (!graphDataResult.ok) {
      return graphDataResult;
    }
    const graphData = graphDataResult.value;
    const existingEdgeIndex = graphData.edges.findIndex((edge) => edge.id === input.edge.id);
    if (existingEdgeIndex !== -1) {
      graphData.edges[existingEdgeIndex] = input.edge;
    } else {
      graphData.edges.push(input.edge);
    }
    const saveResult = await this.graphDataService.saveGraphData(input.graphPageId, graphData);
    if (!saveResult.ok) {
      return saveResult;
    }
    return ok(void 0);
  }
};
__name(_UpsertEdgeUseCase, "UpsertEdgeUseCase");
let UpsertEdgeUseCase = _UpsertEdgeUseCase;
const _DIUpsertEdgeUseCase = class _DIUpsertEdgeUseCase extends UpsertEdgeUseCase {
  constructor(graphDataService, notifications2) {
    super(graphDataService, notifications2);
  }
};
__name(_DIUpsertEdgeUseCase, "DIUpsertEdgeUseCase");
_DIUpsertEdgeUseCase.dependencies = [graphDataServiceToken, notificationPublisherPortToken];
let DIUpsertEdgeUseCase = _DIUpsertEdgeUseCase;
const _RemoveEdgeUseCase = class _RemoveEdgeUseCase {
  constructor(graphDataService, notifications2) {
    this.graphDataService = graphDataService;
    this.notifications = notifications2;
  }
  /**
   * Removes an edge from a graph.
   *
   * Steps:
   * 1. Load graph data (with migration if needed)
   * 2. Remove edge from edges array
   * 3. Save graph data
   */
  async execute(input) {
    const graphDataResult = await this.graphDataService.loadGraphData(input.graphPageId);
    if (!graphDataResult.ok) {
      return graphDataResult;
    }
    const graphData = graphDataResult.value;
    const edgeIndex = graphData.edges.findIndex((edge) => edge.id === input.edgeId);
    if (edgeIndex === -1) {
      return ok(void 0);
    }
    graphData.edges.splice(edgeIndex, 1);
    const saveResult = await this.graphDataService.saveGraphData(input.graphPageId, graphData);
    if (!saveResult.ok) {
      return saveResult;
    }
    return ok(void 0);
  }
};
__name(_RemoveEdgeUseCase, "RemoveEdgeUseCase");
let RemoveEdgeUseCase = _RemoveEdgeUseCase;
const _DIRemoveEdgeUseCase = class _DIRemoveEdgeUseCase extends RemoveEdgeUseCase {
  constructor(graphDataService, notifications2) {
    super(graphDataService, notifications2);
  }
};
__name(_DIRemoveEdgeUseCase, "DIRemoveEdgeUseCase");
_DIRemoveEdgeUseCase.dependencies = [graphDataServiceToken, notificationPublisherPortToken];
let DIRemoveEdgeUseCase = _DIRemoveEdgeUseCase;
function registerRelationshipAppServices(container2) {
  const migrationServiceResult = container2.registerClass(
    migrationServiceToken,
    DIMigrationService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(migrationServiceResult)) {
    return err(`Failed to register MigrationService: ${migrationServiceResult.error.message}`);
  }
  const nodeDataServiceResult = container2.registerClass(
    nodeDataServiceToken,
    DINodeDataService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(nodeDataServiceResult)) {
    return err(`Failed to register NodeDataService: ${nodeDataServiceResult.error.message}`);
  }
  const graphDataServiceResult = container2.registerClass(
    graphDataServiceToken,
    DIGraphDataService,
    ServiceLifecycle.SINGLETON
  );
  if (isErr(graphDataServiceResult)) {
    return err(`Failed to register GraphDataService: ${graphDataServiceResult.error.message}`);
  }
  const createNodePageResult = container2.registerClass(
    createNodePageUseCaseToken,
    DICreateNodePageUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(createNodePageResult)) {
    return err(`Failed to register CreateNodePageUseCase: ${createNodePageResult.error.message}`);
  }
  const createGraphPageResult = container2.registerClass(
    createGraphPageUseCaseToken,
    DICreateGraphPageUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(createGraphPageResult)) {
    return err(`Failed to register CreateGraphPageUseCase: ${createGraphPageResult.error.message}`);
  }
  const addNodeToGraphResult = container2.registerClass(
    addNodeToGraphUseCaseToken,
    DIAddNodeToGraphUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(addNodeToGraphResult)) {
    return err(`Failed to register AddNodeToGraphUseCase: ${addNodeToGraphResult.error.message}`);
  }
  const removeNodeFromGraphResult = container2.registerClass(
    removeNodeFromGraphUseCaseToken,
    DIRemoveNodeFromGraphUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(removeNodeFromGraphResult)) {
    return err(
      `Failed to register RemoveNodeFromGraphUseCase: ${removeNodeFromGraphResult.error.message}`
    );
  }
  const upsertEdgeResult = container2.registerClass(
    upsertEdgeUseCaseToken,
    DIUpsertEdgeUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(upsertEdgeResult)) {
    return err(`Failed to register UpsertEdgeUseCase: ${upsertEdgeResult.error.message}`);
  }
  const removeEdgeResult = container2.registerClass(
    removeEdgeUseCaseToken,
    DIRemoveEdgeUseCase,
    ServiceLifecycle.TRANSIENT
  );
  if (isErr(removeEdgeResult)) {
    return err(`Failed to register RemoveEdgeUseCase: ${removeEdgeResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerRelationshipAppServices, "registerRelationshipAppServices");
registerDependencyStep({
  name: "RelationshipAppServices",
  priority: 90,
  // After RelationshipPageServices (85) since we depend on RelationshipPageRepositoryAdapter
  execute: registerRelationshipAppServices
});
let internalStepsRegistered = false;
function createDependencyRegistrationRegistry() {
  if (!internalStepsRegistered) {
    dependencyRegistry.register({
      name: "StaticValues",
      priority: 10,
      execute: registerStaticValues
    });
    dependencyRegistry.register({
      name: "SubcontainerValues",
      priority: 70,
      execute: registerSubcontainerValues
    });
    dependencyRegistry.register({
      name: "LoopPreventionServices",
      priority: 160,
      execute: registerLoopPreventionServices
    });
    dependencyRegistry.register({ name: "Validation", priority: 170, execute: validateContainer });
    dependencyRegistry.register({
      name: "LoopPreventionInit",
      priority: 180,
      execute: initializeLoopPreventionValues
    });
    dependencyRegistry.register({
      name: "CacheConfigSyncInit",
      priority: 190,
      execute: initializeCacheConfigSync
    });
    internalStepsRegistered = true;
  }
  return dependencyRegistry;
}
__name(createDependencyRegistrationRegistry, "createDependencyRegistrationRegistry");
function resetDependencyRegistry() {
  dependencyRegistry.reset();
  internalStepsRegistered = false;
}
__name(resetDependencyRegistry, "resetDependencyRegistry");
function registerEnvironmentConfig(container2) {
  const envResult = container2.registerValue(environmentConfigToken, ENV);
  if (isErr(envResult)) {
    return err(`Failed to register EnvironmentConfig: ${envResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerEnvironmentConfig, "registerEnvironmentConfig");
function registerRuntimeConfig(container2) {
  const runtimeConfigAdapter = createRuntimeConfigAdapter(ENV);
  const runtimeConfigResult = container2.registerValue(runtimeConfigToken, runtimeConfigAdapter);
  if (isErr(runtimeConfigResult)) {
    return err(`Failed to register RuntimeConfigAdapter: ${runtimeConfigResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerRuntimeConfig, "registerRuntimeConfig");
function registerServiceContainer(container2) {
  const containerResult = container2.registerValue(serviceContainerToken, container2);
  if (isErr(containerResult)) {
    return err(`Failed to register ServiceContainer: ${containerResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerServiceContainer, "registerServiceContainer");
function registerPlatformContainerPortAlias(container2) {
  const aliasResult = container2.registerAlias(
    platformContainerPortToken,
    castContainerTokenToPlatformContainerPortToken(serviceContainerToken)
  );
  if (isErr(aliasResult)) {
    return err(`Failed to register PlatformContainerPort alias: ${aliasResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerPlatformContainerPortAlias, "registerPlatformContainerPortAlias");
function registerModuleId(container2) {
  const moduleIdResult = container2.registerValue(moduleIdToken, MODULE_METADATA.ID);
  if (isErr(moduleIdResult)) {
    return err(`Failed to register ModuleId: ${moduleIdResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerModuleId, "registerModuleId");
function registerStaticValues(container2) {
  const results = [
    registerEnvironmentConfig(container2),
    registerRuntimeConfig(container2),
    registerServiceContainer(container2),
    registerPlatformContainerPortAlias(container2),
    registerModuleId(container2)
  ];
  for (const result of results) {
    if (isErr(result)) return result;
  }
  return ok(void 0);
}
__name(registerStaticValues, "registerStaticValues");
function registerSubcontainerValues(container2) {
  return registerPortRegistries(container2);
}
__name(registerSubcontainerValues, "registerSubcontainerValues");
function registerLoopPreventionServices(container2) {
  const containerCheckResult = container2.registerClass(
    containerHealthCheckToken,
    getDIContainerHealthCheckClass(),
    ServiceLifecycle.SINGLETON
  );
  if (isErr(containerCheckResult)) {
    return err(`Failed to register ContainerHealthCheck: ${containerCheckResult.error.message}`);
  }
  const metricsCheckResult = container2.registerClass(
    metricsHealthCheckToken,
    getDIMetricsHealthCheckClass(),
    ServiceLifecycle.SINGLETON
  );
  if (isErr(metricsCheckResult)) {
    return err(`Failed to register MetricsHealthCheck: ${metricsCheckResult.error.message}`);
  }
  return ok(void 0);
}
__name(registerLoopPreventionServices, "registerLoopPreventionServices");
function initializeLoopPreventionValues(container2) {
  const registryRes = container2.resolveWithError(healthCheckRegistryToken);
  const metricsRes = container2.resolveWithError(metricsCollectorToken);
  if (!registryRes.ok) {
    return err(`Failed to resolve HealthCheckRegistry: ${registryRes.error.message}`);
  }
  if (!metricsRes.ok) {
    return err(`Failed to resolve MetricsCollector: ${metricsRes.error.message}`);
  }
  const containerCheckResult = container2.resolveWithError(containerHealthCheckToken);
  if (!containerCheckResult.ok) {
    return err(`Failed to resolve ContainerHealthCheck: ${containerCheckResult.error.message}`);
  }
  const metricsCheckResult = container2.resolveWithError(metricsHealthCheckToken);
  if (!metricsCheckResult.ok) {
    return err(`Failed to resolve MetricsHealthCheck: ${metricsCheckResult.error.message}`);
  }
  return ok(void 0);
}
__name(initializeLoopPreventionValues, "initializeLoopPreventionValues");
function validateContainer(container2) {
  const validateResult = container2.validate();
  if (isErr(validateResult)) {
    const errorMessages = validateResult.error.map((e) => e.message).join(", ");
    return err(`Validation failed: ${errorMessages}`);
  }
  return ok(void 0);
}
__name(validateContainer, "validateContainer");
function configureDependencies(container2) {
  const registry = createDependencyRegistrationRegistry();
  return registry.configure(container2);
}
__name(configureDependencies, "configureDependencies");
const _DependencyConfigurator = class _DependencyConfigurator {
  /**
   * Configures all dependencies in the given container.
   *
   * @param container - The service container to configure
   * @returns Result indicating success or configuration errors
   */
  configure(container2) {
    return configureDependencies(container2);
  }
};
__name(_DependencyConfigurator, "DependencyConfigurator");
let DependencyConfigurator = _DependencyConfigurator;
const _CompositionRoot = class _CompositionRoot {
  /**
   * Creates a new CompositionRoot instance.
   *
   * @param containerFactory - Factory for creating containers (defaults to ContainerFactory)
   * @param dependencyConfigurator - Configurator for setting up dependencies (defaults to DependencyConfigurator)
   * @param performanceTracker - Optional performance tracker (created internally if not provided)
   * @param errorHandler - Optional error handler (defaults to BootstrapErrorHandler)
   */
  constructor(containerFactory, dependencyConfigurator, performanceTracker, errorHandler) {
    this.container = null;
    this.containerFactory = containerFactory ?? new ContainerFactory();
    this.dependencyConfigurator = dependencyConfigurator ?? new DependencyConfigurator();
    this.performanceTracker = performanceTracker ?? new BootstrapPerformanceTracker(new RuntimeConfigAdapter(ENV), null);
    this.errorHandler = errorHandler ?? BootstrapErrorHandler;
  }
  /**
   * Attempts to log bootstrap completion message.
   * Extracted to separate method for better testability.
   *
   * @param container - The service container to resolve logger from
   * @param duration - The bootstrap duration in milliseconds
   * @internal For testing purposes - public to allow direct testing
   */
  tryLogBootstrapCompletion(container2, duration) {
    const loggerResult = container2.resolveWithError(loggerToken);
    if (loggerResult.ok) {
      const logger = castResolvedService$1(loggerResult.value);
      logger.debug(`Bootstrap completed in ${duration.toFixed(2)}ms`);
    } else {
    }
  }
  /**
   * Erstellt den ServiceContainer und führt Basis-Registrierungen aus.
   * Misst Performance für Diagnose-Zwecke.
   *
   * **Coordination Flow:**
   * 1. ContainerFactory creates container
   * 2. BootstrapPerformanceTracker tracks performance
   * 3. DependencyConfigurator configures dependencies
   * 4. BootstrapErrorHandler handles errors if needed
   *
   * **Performance Tracking:**
   * Uses BootstrapPerformanceTracker with ENV (direct import) and null MetricsCollector.
   * MetricsCollector is not yet available during bootstrap phase.
   *
   * @returns Result mit initialisiertem Container oder Fehlermeldung
   */
  bootstrap() {
    const container2 = this.containerFactory.createRoot(ENV);
    const configured = this.performanceTracker.track(
      () => this.dependencyConfigurator.configure(container2),
      (duration) => {
        this.tryLogBootstrapCompletion(container2, duration);
      }
    );
    if (configured.ok) {
      this.container = container2;
      return { ok: true, value: container2 };
    }
    this.errorHandler.logError(configured.error, {
      phase: "bootstrap",
      component: "CompositionRoot",
      metadata: { error: configured.error }
    });
    return { ok: false, error: configured.error };
  }
  /**
   * Liefert den initialisierten Container als Result.
   * @returns Result mit Container oder Fehlermeldung
   */
  getContainer() {
    if (!this.container) {
      return { ok: false, error: `${LOG_PREFIX} Container not initialized` };
    }
    return { ok: true, value: this.container };
  }
};
__name(_CompositionRoot, "CompositionRoot");
let CompositionRoot = _CompositionRoot;
function initializeFoundryModule() {
  const containerResult = root.getContainer();
  if (!containerResult.ok) {
    console.error(`${LOG_PREFIX} ${containerResult.error}`);
    return;
  }
  const loggerResult = containerResult.value.resolveWithError(loggerToken);
  if (!loggerResult.ok) {
    console.error(`${LOG_PREFIX} Failed to resolve logger: ${loggerResult.error.message}`);
    return;
  }
  const logger = castResolvedService$1(loggerResult.value);
  const initHookServiceResult = containerResult.value.resolveWithError(
    bootstrapInitHookServiceToken
  );
  if (!initHookServiceResult.ok) {
    logger.error(
      `Failed to resolve BootstrapInitHookService: ${initHookServiceResult.error.message}`
    );
    return;
  }
  const initHookService = castResolvedService$1(
    initHookServiceResult.value
  );
  initHookService.register();
  const readyHookServiceResult = containerResult.value.resolveWithError(
    bootstrapReadyHookServiceToken
  );
  if (!readyHookServiceResult.ok) {
    logger.error(
      `Failed to resolve BootstrapReadyHookService: ${readyHookServiceResult.error.message}`
    );
    return;
  }
  const readyHookService = castResolvedService$1(
    readyHookServiceResult.value
  );
  readyHookService.register();
}
__name(initializeFoundryModule, "initializeFoundryModule");
const root = new CompositionRoot();
const bootstrapResult = root.bootstrap();
const bootstrapOk = isOk(bootstrapResult);
function getRootContainer() {
  return root.getContainer();
}
__name(getRootContainer, "getRootContainer");
if (!bootstrapOk) {
  const foundryVersion = tryGetFoundryVersion();
  BootstrapErrorHandler.logError(bootstrapResult.error, {
    phase: "bootstrap",
    component: "CompositionRoot",
    metadata: {
      foundryVersion
    }
  });
  let isOldFoundryVersion = false;
  if (typeof bootstrapResult.error === "string" && bootstrapResult.error.includes("PORT_SELECTION_FAILED")) {
    if (foundryVersion !== void 0 && foundryVersion < 13) {
      isOldFoundryVersion = true;
      if (typeof ui !== "undefined" && ui?.notifications) {
        ui.notifications.error(
          `${MODULE_METADATA.NAME} benötigt mindestens Foundry VTT Version 13. Ihre Version: ${foundryVersion}. Bitte aktualisieren Sie Foundry VTT.`,
          { permanent: true }
        );
      }
    }
  }
  if (!isOldFoundryVersion && typeof ui !== "undefined" && ui?.notifications) {
    ui.notifications?.error(
      `${MODULE_METADATA.NAME} failed to initialize. Check console for details.`,
      { permanent: true }
    );
  }
} else {
  initializeFoundryModule();
}
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r2[e];
  return n;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(e, r2) {
  for (var t = 0; t < r2.length; t++) {
    var o = r2[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(e, r2, t) {
  return r2 && _defineProperties(e.prototype, r2), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
__name(_createClass, "_createClass");
function _createForOfIteratorHelper(r2, e) {
  var t = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t) {
    if (Array.isArray(r2) || (t = _unsupportedIterableToArray(r2)) || e) {
      t && (r2 = t);
      var n = 0, F = /* @__PURE__ */ __name(function() {
      }, "F");
      return {
        s: F,
        n: /* @__PURE__ */ __name(function() {
          return n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n++]
          };
        }, "n"),
        e: /* @__PURE__ */ __name(function(r22) {
          throw r22;
        }, "e"),
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return {
    s: /* @__PURE__ */ __name(function() {
      t = t.call(r2);
    }, "s"),
    n: /* @__PURE__ */ __name(function() {
      var r22 = t.next();
      return a = r22.done, r22;
    }, "n"),
    e: /* @__PURE__ */ __name(function(r22) {
      u = true, o = r22;
    }, "e"),
    f: /* @__PURE__ */ __name(function() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }, "f")
  };
}
__name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
function _defineProperty$1(e, r2, t) {
  return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}
__name(_defineProperty$1, "_defineProperty$1");
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
__name(_iterableToArray, "_iterableToArray");
function _iterableToArrayLimit(r2, l) {
  var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r2)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r22) {
      o = true, n = r22;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest, "_nonIterableRest");
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _slicedToArray(r2, e) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e) || _unsupportedIterableToArray(r2, e) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function _toPrimitive(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
__name(_toPrimitive, "_toPrimitive");
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
    var t = {}.toString.call(r2).slice(8, -1);
    return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
var _window = typeof window === "undefined" ? null : window;
var navigator$1 = _window ? _window.navigator : null;
_window ? _window.document : null;
var typeofstr = _typeof("");
var typeofobj = _typeof({});
var typeoffn = _typeof(function() {
});
var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);
var instanceStr = /* @__PURE__ */ __name(function instanceStr2(obj) {
  return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;
}, "instanceStr2");
var string = /* @__PURE__ */ __name(function string2(obj) {
  return obj != null && _typeof(obj) == typeofstr;
}, "string2");
var fn$6 = /* @__PURE__ */ __name(function fn(obj) {
  return obj != null && _typeof(obj) === typeoffn;
}, "fn");
var array = /* @__PURE__ */ __name(function array2(obj) {
  return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);
}, "array2");
var plainObject = /* @__PURE__ */ __name(function plainObject2(obj) {
  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
}, "plainObject2");
var object = /* @__PURE__ */ __name(function object2(obj) {
  return obj != null && _typeof(obj) === typeofobj;
}, "object2");
var number$1 = /* @__PURE__ */ __name(function number2(obj) {
  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
}, "number");
var integer = /* @__PURE__ */ __name(function integer2(obj) {
  return number$1(obj) && Math.floor(obj) === obj;
}, "integer2");
var htmlElement = /* @__PURE__ */ __name(function htmlElement2(obj) {
  if ("undefined" === typeofhtmlele) {
    return void 0;
  } else {
    return null != obj && obj instanceof HTMLElement;
  }
}, "htmlElement2");
var elementOrCollection = /* @__PURE__ */ __name(function elementOrCollection2(obj) {
  return element(obj) || collection(obj);
}, "elementOrCollection2");
var element = /* @__PURE__ */ __name(function element2(obj) {
  return instanceStr(obj) === "collection" && obj._private.single;
}, "element2");
var collection = /* @__PURE__ */ __name(function collection2(obj) {
  return instanceStr(obj) === "collection" && !obj._private.single;
}, "collection2");
var core = /* @__PURE__ */ __name(function core2(obj) {
  return instanceStr(obj) === "core";
}, "core2");
var stylesheet = /* @__PURE__ */ __name(function stylesheet2(obj) {
  return instanceStr(obj) === "stylesheet";
}, "stylesheet2");
var event = /* @__PURE__ */ __name(function event2(obj) {
  return instanceStr(obj) === "event";
}, "event2");
var emptyString = /* @__PURE__ */ __name(function emptyString2(obj) {
  if (obj === void 0 || obj === null) {
    return true;
  } else if (obj === "" || obj.match(/^\s+$/)) {
    return true;
  }
  return false;
}, "emptyString2");
var domElement = /* @__PURE__ */ __name(function domElement2(obj) {
  if (typeof HTMLElement === "undefined") {
    return false;
  } else {
    return obj instanceof HTMLElement;
  }
}, "domElement2");
var boundingBox = /* @__PURE__ */ __name(function boundingBox2(obj) {
  return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);
}, "boundingBox2");
var promise = /* @__PURE__ */ __name(function promise2(obj) {
  return object(obj) && fn$6(obj.then);
}, "promise2");
var ms = /* @__PURE__ */ __name(function ms2() {
  return navigator$1 && navigator$1.userAgent.match(/msie|trident|edge/i);
}, "ms2");
var memoize = /* @__PURE__ */ __name(function memoize2(fn3, keyFn) {
  if (!keyFn) {
    keyFn = /* @__PURE__ */ __name(function keyFn2() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return "undefined";
      }
      var args2 = [];
      for (var i = 0; i < arguments.length; i++) {
        args2.push(arguments[i]);
      }
      return args2.join("$");
    }, "keyFn2");
  }
  var _memoizedFn = /* @__PURE__ */ __name(function memoizedFn() {
    var self2 = this;
    var args2 = arguments;
    var ret;
    var k = keyFn.apply(self2, args2);
    var cache3 = _memoizedFn.cache;
    if (!(ret = cache3[k])) {
      ret = cache3[k] = fn3.apply(self2, args2);
    }
    return ret;
  }, "memoizedFn");
  _memoizedFn.cache = {};
  return _memoizedFn;
}, "memoize2");
var camel2dash = memoize(function(str) {
  return str.replace(/([A-Z])/g, function(v) {
    return "-" + v.toLowerCase();
  });
});
var dash2camel = memoize(function(str) {
  return str.replace(/(-\w)/g, function(v) {
    return v[1].toUpperCase();
  });
});
var prependCamel = memoize(function(prefix, str) {
  return prefix + str[0].toUpperCase() + str.substring(1);
}, function(prefix, str) {
  return prefix + "$" + str;
});
var capitalize = /* @__PURE__ */ __name(function capitalize2(str) {
  if (emptyString(str)) {
    return str;
  }
  return str.charAt(0).toUpperCase() + str.substring(1);
}, "capitalize2");
var endsWith = /* @__PURE__ */ __name(function endsWith2(string3, suffix) {
  return string3.slice(-1 * suffix.length) === suffix;
}, "endsWith2");
var number22 = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";
var rgba = "rgb[a]?\\((" + number22 + "[%]?)\\s*,\\s*(" + number22 + "[%]?)\\s*,\\s*(" + number22 + "[%]?)(?:\\s*,\\s*(" + number22 + "))?\\)";
var rgbaNoBackRefs = "rgb[a]?\\((?:" + number22 + "[%]?)\\s*,\\s*(?:" + number22 + "[%]?)\\s*,\\s*(?:" + number22 + "[%]?)(?:\\s*,\\s*(?:" + number22 + "))?\\)";
var hsla = "hsl[a]?\\((" + number22 + ")\\s*,\\s*(" + number22 + "[%])\\s*,\\s*(" + number22 + "[%])(?:\\s*,\\s*(" + number22 + "))?\\)";
var hslaNoBackRefs = "hsl[a]?\\((?:" + number22 + ")\\s*,\\s*(?:" + number22 + "[%])\\s*,\\s*(?:" + number22 + "[%])(?:\\s*,\\s*(?:" + number22 + "))?\\)";
var hex3 = "\\#[0-9a-fA-F]{3}";
var hex6 = "\\#[0-9a-fA-F]{6}";
var ascending = /* @__PURE__ */ __name(function ascending2(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}, "ascending2");
var descending = /* @__PURE__ */ __name(function descending2(a, b) {
  return -1 * ascending(a, b);
}, "descending2");
var extend = /* @__PURE__ */ __name(function(tgt) {
  var args2 = arguments;
  for (var i = 1; i < args2.length; i++) {
    var obj = args2[i];
    if (obj == null) continue;
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];
      if (k === "equals") continue;
      try {
        tgt[k] = obj[k];
      } catch (e) {
      }
    }
  }
  return tgt;
}, "extend");
var hex2tuple = /* @__PURE__ */ __name(function hex2tuple2(hex) {
  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== "#") {
    return;
  }
  var shortHex = hex.length === 4;
  var r2, g, b;
  var base = 16;
  if (shortHex) {
    r2 = parseInt(hex[1] + hex[1], base);
    g = parseInt(hex[2] + hex[2], base);
    b = parseInt(hex[3] + hex[3], base);
  } else {
    r2 = parseInt(hex[1] + hex[2], base);
    g = parseInt(hex[3] + hex[4], base);
    b = parseInt(hex[5] + hex[6], base);
  }
  return [r2, g, b];
}, "hex2tuple2");
var hsl2tuple = /* @__PURE__ */ __name(function hsl2tuple2(hsl) {
  var ret;
  var h, s, l, a, r2, g, b;
  function hue2rgb(p3, q2, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p3 + (q2 - p3) * 6 * t;
    if (t < 1 / 2) return q2;
    if (t < 2 / 3) return p3 + (q2 - p3) * (2 / 3 - t) * 6;
    return p3;
  }
  __name(hue2rgb, "hue2rgb");
  var m = new RegExp("^" + hsla + "$").exec(hsl);
  if (m) {
    h = parseInt(m[1]);
    if (h < 0) {
      h = (360 - -1 * h % 360) % 360;
    } else if (h > 360) {
      h = h % 360;
    }
    h /= 360;
    s = parseFloat(m[2]);
    if (s < 0 || s > 100) {
      return;
    }
    s = s / 100;
    l = parseFloat(m[3]);
    if (l < 0 || l > 100) {
      return;
    }
    l = l / 100;
    a = m[4];
    if (a !== void 0) {
      a = parseFloat(a);
      if (a < 0 || a > 1) {
        return;
      }
    }
    if (s === 0) {
      r2 = g = b = Math.round(l * 255);
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p2 = 2 * l - q;
      r2 = Math.round(255 * hue2rgb(p2, q, h + 1 / 3));
      g = Math.round(255 * hue2rgb(p2, q, h));
      b = Math.round(255 * hue2rgb(p2, q, h - 1 / 3));
    }
    ret = [r2, g, b, a];
  }
  return ret;
}, "hsl2tuple2");
var rgb2tuple = /* @__PURE__ */ __name(function rgb2tuple2(rgb) {
  var ret;
  var m = new RegExp("^" + rgba + "$").exec(rgb);
  if (m) {
    ret = [];
    var isPct = [];
    for (var i = 1; i <= 3; i++) {
      var channel = m[i];
      if (channel[channel.length - 1] === "%") {
        isPct[i] = true;
      }
      channel = parseFloat(channel);
      if (isPct[i]) {
        channel = channel / 100 * 255;
      }
      if (channel < 0 || channel > 255) {
        return;
      }
      ret.push(Math.floor(channel));
    }
    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
    var allArePct = isPct[1] && isPct[2] && isPct[3];
    if (atLeastOneIsPct && !allArePct) {
      return;
    }
    var alpha = m[4];
    if (alpha !== void 0) {
      alpha = parseFloat(alpha);
      if (alpha < 0 || alpha > 1) {
        return;
      }
      ret.push(alpha);
    }
  }
  return ret;
}, "rgb2tuple2");
var colorname2tuple = /* @__PURE__ */ __name(function colorname2tuple2(color) {
  return colors[color.toLowerCase()];
}, "colorname2tuple2");
var color2tuple = /* @__PURE__ */ __name(function color2tuple2(color) {
  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
}, "color2tuple2");
var colors = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var setMap = /* @__PURE__ */ __name(function setMap2(options2) {
  var obj = options2.map;
  var keys = options2.keys;
  var l = keys.length;
  for (var i = 0; i < l; i++) {
    var key2 = keys[i];
    if (plainObject(key2)) {
      throw Error("Tried to set map with object key");
    }
    if (i < keys.length - 1) {
      if (obj[key2] == null) {
        obj[key2] = {};
      }
      obj = obj[key2];
    } else {
      obj[key2] = options2.value;
    }
  }
}, "setMap2");
var getMap = /* @__PURE__ */ __name(function getMap2(options2) {
  var obj = options2.map;
  var keys = options2.keys;
  var l = keys.length;
  for (var i = 0; i < l; i++) {
    var key2 = keys[i];
    if (plainObject(key2)) {
      throw Error("Tried to get map with object key");
    }
    obj = obj[key2];
    if (obj == null) {
      return obj;
    }
  }
  return obj;
}, "getMap2");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value2) {
    var type = typeof value2;
    return value2 != null && (type == "object" || type == "function");
  }
  __name(isObject, "isObject");
  isObject_1 = isObject;
  return isObject_1;
}
__name(requireIsObject, "requireIsObject");
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
__name(require_freeGlobal, "require_freeGlobal");
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  _root = root2;
  return _root;
}
__name(require_root, "require_root");
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var root2 = require_root();
  var now2 = /* @__PURE__ */ __name(function() {
    return root2.Date.now();
  }, "now");
  now_1 = now2;
  return now_1;
}
__name(requireNow, "requireNow");
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string3) {
    var index2 = string3.length;
    while (index2-- && reWhitespace.test(string3.charAt(index2))) {
    }
    return index2;
  }
  __name(trimmedEndIndex, "trimmedEndIndex");
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
__name(require_trimmedEndIndex, "require_trimmedEndIndex");
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string3) {
    return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
  }
  __name(baseTrim, "baseTrim");
  _baseTrim = baseTrim;
  return _baseTrim;
}
__name(require_baseTrim, "require_baseTrim");
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root2 = require_root();
  var Symbol2 = root2.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
__name(require_Symbol, "require_Symbol");
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value2) {
    var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag2 = value2[symToStringTag];
    try {
      value2[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value2);
    if (unmasked) {
      if (isOwn) {
        value2[symToStringTag] = tag2;
      } else {
        delete value2[symToStringTag];
      }
    }
    return result;
  }
  __name(getRawTag, "getRawTag");
  _getRawTag = getRawTag;
  return _getRawTag;
}
__name(require_getRawTag, "require_getRawTag");
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value2) {
    return nativeObjectToString.call(value2);
  }
  __name(objectToString, "objectToString");
  _objectToString = objectToString;
  return _objectToString;
}
__name(require_objectToString, "require_objectToString");
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value2) {
    if (value2 == null) {
      return value2 === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
  }
  __name(baseGetTag, "baseGetTag");
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
__name(require_baseGetTag, "require_baseGetTag");
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value2) {
    return value2 != null && typeof value2 == "object";
  }
  __name(isObjectLike, "isObjectLike");
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
__name(requireIsObjectLike, "requireIsObjectLike");
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
  }
  __name(isSymbol, "isSymbol");
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
__name(requireIsSymbol, "requireIsSymbol");
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber2(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol(value2)) {
      return NAN;
    }
    if (isObject(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = baseTrim(value2);
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  __name(toNumber2, "toNumber");
  toNumber_1 = toNumber2;
  return toNumber_1;
}
__name(requireToNumber, "requireToNumber");
var debounce_1;
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce_1;
  hasRequiredDebounce = 1;
  var isObject = requireIsObject(), now2 = requireNow(), toNumber2 = requireToNumber();
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce2(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber2(wait) || 0;
    if (isObject(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax(toNumber2(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time2) {
      var args2 = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time2;
      result = func.apply(thisArg, args2);
      return result;
    }
    __name(invokeFunc, "invokeFunc");
    function leadingEdge(time2) {
      lastInvokeTime = time2;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time2) : result;
    }
    __name(leadingEdge, "leadingEdge");
    function remainingWait(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    __name(remainingWait, "remainingWait");
    function shouldInvoke(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    __name(shouldInvoke, "shouldInvoke");
    function timerExpired() {
      var time2 = now2();
      if (shouldInvoke(time2)) {
        return trailingEdge(time2);
      }
      timerId = setTimeout(timerExpired, remainingWait(time2));
    }
    __name(timerExpired, "timerExpired");
    function trailingEdge(time2) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time2);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    __name(trailingEdge, "trailingEdge");
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    __name(cancel, "cancel");
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now2());
    }
    __name(flush, "flush");
    function debounced() {
      var time2 = now2(), isInvoking = shouldInvoke(time2);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time2;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    __name(debounced, "debounced");
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  __name(debounce2, "debounce2");
  debounce_1 = debounce2;
  return debounce_1;
}
__name(requireDebounce, "requireDebounce");
var debounceExports = requireDebounce();
var debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
var performance$1 = _window ? _window.performance : null;
var pnow = performance$1 && performance$1.now ? function() {
  return performance$1.now();
} : function() {
  return Date.now();
};
var raf = (function() {
  if (_window) {
    if (_window.requestAnimationFrame) {
      return function(fn3) {
        _window.requestAnimationFrame(fn3);
      };
    } else if (_window.mozRequestAnimationFrame) {
      return function(fn3) {
        _window.mozRequestAnimationFrame(fn3);
      };
    } else if (_window.webkitRequestAnimationFrame) {
      return function(fn3) {
        _window.webkitRequestAnimationFrame(fn3);
      };
    } else if (_window.msRequestAnimationFrame) {
      return function(fn3) {
        _window.msRequestAnimationFrame(fn3);
      };
    }
  }
  return function(fn3) {
    if (fn3) {
      setTimeout(function() {
        fn3(pnow());
      }, 1e3 / 60);
    }
  };
})();
var requestAnimationFrame$1 = /* @__PURE__ */ __name(function requestAnimationFrame2(fn3) {
  return raf(fn3);
}, "requestAnimationFrame2");
var performanceNow = pnow;
var DEFAULT_HASH_SEED = 9261;
var K = 65599;
var DEFAULT_HASH_SEED_ALT = 5381;
var hashIterableInts = /* @__PURE__ */ __name(function hashIterableInts2(iterator) {
  var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED;
  var hash2 = seed;
  var entry;
  for (; ; ) {
    entry = iterator.next();
    if (entry.done) {
      break;
    }
    hash2 = hash2 * K + entry.value | 0;
  }
  return hash2;
}, "hashIterableInts2");
var hashInt = /* @__PURE__ */ __name(function hashInt2(num) {
  var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED;
  return seed * K + num | 0;
}, "hashInt2");
var hashIntAlt = /* @__PURE__ */ __name(function hashIntAlt2(num) {
  var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED_ALT;
  return (seed << 5) + seed + num | 0;
}, "hashIntAlt2");
var combineHashes = /* @__PURE__ */ __name(function combineHashes2(hash1, hash2) {
  return hash1 * 2097152 + hash2;
}, "combineHashes2");
var combineHashesArray = /* @__PURE__ */ __name(function combineHashesArray2(hashes) {
  return hashes[0] * 2097152 + hashes[1];
}, "combineHashesArray2");
var hashArrays = /* @__PURE__ */ __name(function hashArrays2(hashes1, hashes2) {
  return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];
}, "hashArrays2");
var hashIntsArray = /* @__PURE__ */ __name(function hashIntsArray2(ints, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length2 = ints.length;
  var iterator = {
    next: /* @__PURE__ */ __name(function next2() {
      if (i < length2) {
        entry.value = ints[i++];
      } else {
        entry.done = true;
      }
      return entry;
    }, "next")
  };
  return hashIterableInts(iterator, seed);
}, "hashIntsArray2");
var hashString = /* @__PURE__ */ __name(function hashString2(str, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length2 = str.length;
  var iterator = {
    next: /* @__PURE__ */ __name(function next2() {
      if (i < length2) {
        entry.value = str.charCodeAt(i++);
      } else {
        entry.done = true;
      }
      return entry;
    }, "next")
  };
  return hashIterableInts(iterator, seed);
}, "hashString2");
var hashStrings = /* @__PURE__ */ __name(function hashStrings2() {
  return hashStringsArray(arguments);
}, "hashStrings2");
var hashStringsArray = /* @__PURE__ */ __name(function hashStringsArray2(strs) {
  var hash2;
  for (var i = 0; i < strs.length; i++) {
    var str = strs[i];
    if (i === 0) {
      hash2 = hashString(str);
    } else {
      hash2 = hashString(str, hash2);
    }
  }
  return hash2;
}, "hashStringsArray2");
function rotatePoint(x2, y2, centerX, centerY, angleDegrees) {
  var angleRadians = angleDegrees * Math.PI / 180;
  var rotatedX = Math.cos(angleRadians) * (x2 - centerX) - Math.sin(angleRadians) * (y2 - centerY) + centerX;
  var rotatedY = Math.sin(angleRadians) * (x2 - centerX) + Math.cos(angleRadians) * (y2 - centerY) + centerY;
  return {
    x: rotatedX,
    y: rotatedY
  };
}
__name(rotatePoint, "rotatePoint");
var movePointByBoxAspect = /* @__PURE__ */ __name(function movePointByBoxAspect2(x2, y2, boxX, boxY, skewX, skewY) {
  return {
    x: (x2 - boxX) * skewX + boxX,
    y: (y2 - boxY) * skewY + boxY
  };
}, "movePointByBoxAspect2");
function rotatePosAndSkewByBox(pos, box, angleDegrees) {
  if (angleDegrees === 0) return pos;
  var centerX = (box.x1 + box.x2) / 2;
  var centerY = (box.y1 + box.y2) / 2;
  var skewX = box.w / box.h;
  var skewY = 1 / skewX;
  var rotated = rotatePoint(pos.x, pos.y, centerX, centerY, angleDegrees);
  var skewed = movePointByBoxAspect(rotated.x, rotated.y, centerX, centerY, skewX, skewY);
  return {
    x: skewed.x,
    y: skewed.y
  };
}
__name(rotatePosAndSkewByBox, "rotatePosAndSkewByBox");
var warningsEnabled = true;
var warnSupported = console.warn != null;
var traceSupported = console.trace != null;
var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var trueify = /* @__PURE__ */ __name(function trueify2() {
  return true;
}, "trueify2");
var falsify = /* @__PURE__ */ __name(function falsify2() {
  return false;
}, "falsify2");
var zeroify = /* @__PURE__ */ __name(function zeroify2() {
  return 0;
}, "zeroify2");
var noop$1 = /* @__PURE__ */ __name(function noop2() {
}, "noop");
var error = /* @__PURE__ */ __name(function error2(msg) {
  throw new Error(msg);
}, "error2");
var warnings = /* @__PURE__ */ __name(function warnings2(enabled) {
  if (enabled !== void 0) {
    warningsEnabled = !!enabled;
  } else {
    return warningsEnabled;
  }
}, "warnings2");
var warn = /* @__PURE__ */ __name(function warn2(msg) {
  if (!warnings()) {
    return;
  }
  if (warnSupported) {
    console.warn(msg);
  } else {
    console.log(msg);
    if (traceSupported) {
      console.trace();
    }
  }
}, "warn2");
var clone = /* @__PURE__ */ __name(function clone2(obj) {
  return extend({}, obj);
}, "clone2");
var copy = /* @__PURE__ */ __name(function copy2(obj) {
  if (obj == null) {
    return obj;
  }
  if (array(obj)) {
    return obj.slice();
  } else if (plainObject(obj)) {
    return clone(obj);
  } else {
    return obj;
  }
}, "copy2");
var copyArray = /* @__PURE__ */ __name(function copyArray2(arr) {
  return arr.slice();
}, "copyArray2");
var uuid = /* @__PURE__ */ __name(function uuid2(a, b) {
  for (
    // loop :)
    b = a = "";
    // b - result , a - numeric letiable
    a++ < 36;
    //
    b += a * 51 & 52 ? (
      //  return a random number or 4
      (a ^ 15 ? (
        // generate a random number from 0 to 15
        8 ^ Math.random() * (a ^ 20 ? 16 : 4)
      ) : 4).toString(16)
    ) : "-"
  ) ;
  return b;
}, "uuid2");
var _staticEmptyObject = {};
var staticEmptyObject = /* @__PURE__ */ __name(function staticEmptyObject2() {
  return _staticEmptyObject;
}, "staticEmptyObject2");
var defaults$g = /* @__PURE__ */ __name(function defaults(_defaults) {
  var keys = Object.keys(_defaults);
  return function(opts) {
    var filledOpts = {};
    for (var i = 0; i < keys.length; i++) {
      var key2 = keys[i];
      var optVal = opts == null ? void 0 : opts[key2];
      filledOpts[key2] = optVal === void 0 ? _defaults[key2] : optVal;
    }
    return filledOpts;
  };
}, "defaults");
var removeFromArray = /* @__PURE__ */ __name(function removeFromArray2(arr, ele, oneCopy) {
  for (var i = arr.length - 1; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);
    }
  }
}, "removeFromArray2");
var clearArray = /* @__PURE__ */ __name(function clearArray2(arr) {
  arr.splice(0, arr.length);
}, "clearArray2");
var push = /* @__PURE__ */ __name(function push2(arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];
    arr.push(el);
  }
}, "push2");
var getPrefixedProperty = /* @__PURE__ */ __name(function getPrefixedProperty2(obj, propName, prefix) {
  if (prefix) {
    propName = prependCamel(prefix, propName);
  }
  return obj[propName];
}, "getPrefixedProperty2");
var setPrefixedProperty = /* @__PURE__ */ __name(function setPrefixedProperty2(obj, propName, prefix, value2) {
  if (prefix) {
    propName = prependCamel(prefix, propName);
  }
  obj[propName] = value2;
}, "setPrefixedProperty2");
var ObjectMap = /* @__PURE__ */ (function() {
  function ObjectMap2() {
    _classCallCheck(this, ObjectMap2);
    this._obj = {};
  }
  __name(ObjectMap2, "ObjectMap2");
  return _createClass(ObjectMap2, [{
    key: "set",
    value: /* @__PURE__ */ __name(function set2(key2, val) {
      this._obj[key2] = val;
      return this;
    }, "set2")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(key2) {
      this._obj[key2] = void 0;
      return this;
    }, "_delete")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear2() {
      this._obj = {};
    }, "clear")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function has(key2) {
      return this._obj[key2] !== void 0;
    }, "has")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(key2) {
      return this._obj[key2];
    }, "get2")
  }]);
})();
var Map$1 = typeof Map !== "undefined" ? Map : ObjectMap;
var undef = "undefined";
var ObjectSet = /* @__PURE__ */ (function() {
  function ObjectSet2(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet2);
    this._obj = /* @__PURE__ */ Object.create(null);
    this.size = 0;
    if (arrayOrObjectSet != null) {
      var arr;
      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }
      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }
  __name(ObjectSet2, "ObjectSet2");
  return _createClass(ObjectSet2, [{
    key: "instanceString",
    value: /* @__PURE__ */ __name(function instanceString4() {
      return "set";
    }, "instanceString4")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function add3(val) {
      var o = this._obj;
      if (o[val] !== 1) {
        o[val] = 1;
        this.size++;
      }
    }, "add3")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(val) {
      var o = this._obj;
      if (o[val] === 1) {
        o[val] = 0;
        this.size--;
      }
    }, "_delete")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear2() {
      this._obj = /* @__PURE__ */ Object.create(null);
    }, "clear")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function has(val) {
      return this._obj[val] === 1;
    }, "has")
  }, {
    key: "toArray",
    value: /* @__PURE__ */ __name(function toArray2() {
      var _this = this;
      return Object.keys(this._obj).filter(function(key2) {
        return _this.has(key2);
      });
    }, "toArray2")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ __name(function forEach2(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }, "forEach2")
  }]);
})();
var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;
var Element$1 = /* @__PURE__ */ __name(function Element2(cy, params) {
  var restore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (cy === void 0 || params === void 0 || !core(cy)) {
    error("An element must have a core reference and parameters set");
    return;
  }
  var group2 = params.group;
  if (group2 == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group2 = "edges";
    } else {
      group2 = "nodes";
    }
  }
  if (group2 !== "nodes" && group2 !== "edges") {
    error("An element must be of type `nodes` or `edges`; you specified `" + group2 + "`");
    return;
  }
  this.length = 1;
  this[0] = this;
  var _p = this._private = {
    cy,
    single: true,
    // indicates this is an element
    data: params.data || {},
    // data object
    position: params.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: void 0,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: void 0,
    autoPadding: void 0,
    compoundBoundsClean: false,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: group2,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: true,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false,
    // whether it's selected
    selectable: params.selectable === void 0 ? true : params.selectable ? true : false,
    // whether it's selectable
    locked: params.locked ? true : false,
    // whether the element is locked (cannot be moved)
    grabbed: false,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === void 0 ? true : params.grabbable ? true : false,
    // whether the element can be grabbed
    pannable: params.pannable === void 0 ? group2 === "edges" ? true : false : params.pannable ? true : false,
    // whether the element has passthrough panning enabled
    active: false,
    // whether the element is active from user interaction
    classes: new Set$1(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: params.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: params.parent && params.parent.isNode() ? params.parent : null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: false,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      "mid-source": null,
      "mid-target": null
    }
  };
  if (_p.position.x == null) {
    _p.position.x = 0;
  }
  if (_p.position.y == null) {
    _p.position.y = 0;
  }
  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan2 = cy.pan();
    var zoom2 = cy.zoom();
    _p.position = {
      x: (rpos.x - pan2.x) / zoom2,
      y: (rpos.y - pan2.y) / zoom2
    };
  }
  var classes2 = [];
  if (array(params.classes)) {
    classes2 = params.classes;
  } else if (string(params.classes)) {
    classes2 = params.classes.split(/\s+/);
  }
  for (var i = 0, l = classes2.length; i < l; i++) {
    var cls = classes2[i];
    if (!cls || cls === "") {
      continue;
    }
    _p.classes.add(cls);
  }
  this.createEmitter();
  if (restore === void 0 || restore) {
    this.restore();
  }
  var bypass = params.style || params.css;
  if (bypass) {
    warn("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.");
    this.style(bypass);
  }
}, "Element2");
var defineSearch = /* @__PURE__ */ __name(function defineSearch2(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };
  return /* @__PURE__ */ __name(function searchFn(roots, fn3, directed) {
    var options2;
    if (plainObject(roots) && !elementOrCollection(roots)) {
      options2 = roots;
      roots = options2.roots || options2.root;
      fn3 = options2.visit;
      directed = options2.directed;
    }
    directed = arguments.length === 2 && !fn$6(fn3) ? fn3 : directed;
    fn3 = fn$6(fn3) ? fn3 : function() {
    };
    var cy = this._private.cy;
    var v = roots = string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    for (var i = 0; i < v.length; i++) {
      var vi = v[i];
      var viId = vi.id();
      if (vi.isNode()) {
        Q.unshift(vi);
        if (params.bfs) {
          V[viId] = true;
          connectedNodes.push(vi);
        }
        id2depth[viId] = 0;
      }
    }
    var _loop = /* @__PURE__ */ __name(function _loop2() {
      var v3 = params.bfs ? Q.shift() : Q.pop();
      var vId = v3.id();
      if (params.dfs) {
        if (V[vId]) {
          return 0;
        }
        V[vId] = true;
        connectedNodes.push(v3);
      }
      var depth = id2depth[vId];
      var prevEdge = connectedBy[vId];
      var src = prevEdge != null ? prevEdge.source() : null;
      var tgt = prevEdge != null ? prevEdge.target() : null;
      var prevNode = prevEdge == null ? void 0 : v3.same(src) ? tgt[0] : src[0];
      var ret;
      ret = fn3(v3, prevEdge, prevNode, j++, depth);
      if (ret === true) {
        found = v3;
        return 1;
      }
      if (ret === false) {
        return 1;
      }
      var vwEdges = v3.connectedEdges().filter(function(e2) {
        return (!directed || e2.source().same(v3)) && edges3.has(e2);
      });
      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
        var e = vwEdges[_i2];
        var w = e.connectedNodes().filter(function(n) {
          return !n.same(v3) && nodes3.has(n);
        });
        var wId = w.id();
        if (w.length !== 0 && !V[wId]) {
          w = w[0];
          Q.push(w);
          if (params.bfs) {
            V[wId] = true;
            connectedNodes.push(w);
          }
          connectedBy[wId] = e;
          id2depth[wId] = id2depth[vId] + 1;
        }
      }
    }, "_loop2"), _ret;
    while (Q.length !== 0) {
      _ret = _loop();
      if (_ret === 0) continue;
      if (_ret === 1) break;
    }
    var connectedEles = cy.collection();
    for (var _i = 0; _i < connectedNodes.length; _i++) {
      var node = connectedNodes[_i];
      var edge = connectedBy[node.id()];
      if (edge != null) {
        connectedEles.push(edge);
      }
      connectedEles.push(node);
    }
    return {
      path: cy.collection(connectedEles),
      found: cy.collection(found)
    };
  }, "searchFn");
}, "defineSearch2");
var elesfn$v = {
  breadthFirstSearch: defineSearch({
    bfs: true
  }),
  depthFirstSearch: defineSearch({
    dfs: true
  })
};
elesfn$v.bfs = elesfn$v.breadthFirstSearch;
elesfn$v.dfs = elesfn$v.depthFirstSearch;
var heap$2 = { exports: {} };
var heap$1 = heap$2.exports;
var hasRequiredHeap$1;
function requireHeap$1() {
  if (hasRequiredHeap$1) return heap$2.exports;
  hasRequiredHeap$1 = 1;
  (function(module, exports$1) {
    (function() {
      var Heap2, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min4, nlargest, nsmallest, updateItem, _siftdown, _siftup;
      floor = Math.floor, min4 = Math.min;
      defaultCmp = /* @__PURE__ */ __name(function(x2, y2) {
        if (x2 < y2) {
          return -1;
        }
        if (x2 > y2) {
          return 1;
        }
        return 0;
      }, "defaultCmp");
      insort = /* @__PURE__ */ __name(function(a, x2, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error("lo must be non-negative");
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x2, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return [].splice.apply(a, [lo, lo - lo].concat(x2)), x2;
      }, "insort");
      heappush = /* @__PURE__ */ __name(function(array3, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array3.push(item);
        return _siftdown(array3, 0, array3.length - 1, cmp);
      }, "heappush");
      heappop = /* @__PURE__ */ __name(function(array3, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array3.pop();
        if (array3.length) {
          returnitem = array3[0];
          array3[0] = lastelt;
          _siftup(array3, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      }, "heappop");
      heapreplace = /* @__PURE__ */ __name(function(array3, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array3[0];
        array3[0] = item;
        _siftup(array3, 0, cmp);
        return returnitem;
      }, "heapreplace");
      heappushpop = /* @__PURE__ */ __name(function(array3, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array3.length && cmp(array3[0], item) < 0) {
          _ref = [array3[0], item], item = _ref[0], array3[0] = _ref[1];
          _siftup(array3, 0, cmp);
        }
        return item;
      }, "heappushpop");
      heapify = /* @__PURE__ */ __name(function(array3, cmp) {
        var i, _i, _len, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = (function() {
          _results1 = [];
          for (var _j = 0, _ref = floor(array3.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
            _results1.push(_j);
          }
          return _results1;
        }).apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array3, i, cmp));
        }
        return _results;
      }, "heapify");
      updateItem = /* @__PURE__ */ __name(function(array3, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array3.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array3, 0, pos, cmp);
        return _siftup(array3, pos, cmp);
      }, "updateItem");
      nlargest = /* @__PURE__ */ __name(function(array3, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array3.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array3.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      }, "nlargest");
      nsmallest = /* @__PURE__ */ __name(function(array3, n, cmp) {
        var elem, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array3.length) {
          result = array3.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array3.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array3, cmp);
        _results = [];
        for (_j = 0, _ref1 = min4(n, array3.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array3, cmp));
        }
        return _results;
      }, "nsmallest");
      _siftdown = /* @__PURE__ */ __name(function(array3, startpos, pos, cmp) {
        var newitem, parent4, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array3[pos];
        while (pos > startpos) {
          parentpos = pos - 1 >> 1;
          parent4 = array3[parentpos];
          if (cmp(newitem, parent4) < 0) {
            array3[pos] = parent4;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array3[pos] = newitem;
      }, "_siftdown");
      _siftup = /* @__PURE__ */ __name(function(array3, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array3.length;
        startpos = pos;
        newitem = array3[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array3[childpos], array3[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array3[pos] = array3[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array3[pos] = newitem;
        return _siftdown(array3, startpos, pos, cmp);
      }, "_siftup");
      Heap2 = (function() {
        Heap3.push = heappush;
        Heap3.pop = heappop;
        Heap3.replace = heapreplace;
        Heap3.pushpop = heappushpop;
        Heap3.heapify = heapify;
        Heap3.updateItem = updateItem;
        Heap3.nlargest = nlargest;
        Heap3.nsmallest = nsmallest;
        function Heap3(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
        __name(Heap3, "Heap3");
        Heap3.prototype.push = function(x2) {
          return heappush(this.nodes, x2, this.cmp);
        };
        Heap3.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
        Heap3.prototype.peek = function() {
          return this.nodes[0];
        };
        Heap3.prototype.contains = function(x2) {
          return this.nodes.indexOf(x2) !== -1;
        };
        Heap3.prototype.replace = function(x2) {
          return heapreplace(this.nodes, x2, this.cmp);
        };
        Heap3.prototype.pushpop = function(x2) {
          return heappushpop(this.nodes, x2, this.cmp);
        };
        Heap3.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
        Heap3.prototype.updateItem = function(x2) {
          return updateItem(this.nodes, x2, this.cmp);
        };
        Heap3.prototype.clear = function() {
          return this.nodes = [];
        };
        Heap3.prototype.empty = function() {
          return this.nodes.length === 0;
        };
        Heap3.prototype.size = function() {
          return this.nodes.length;
        };
        Heap3.prototype.clone = function() {
          var heap2;
          heap2 = new Heap3();
          heap2.nodes = this.nodes.slice(0);
          return heap2;
        };
        Heap3.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
        Heap3.prototype.insert = Heap3.prototype.push;
        Heap3.prototype.top = Heap3.prototype.peek;
        Heap3.prototype.front = Heap3.prototype.peek;
        Heap3.prototype.has = Heap3.prototype.contains;
        Heap3.prototype.copy = Heap3.prototype.clone;
        return Heap3;
      })();
      (function(root2, factory) {
        {
          return module.exports = factory();
        }
      })(this, function() {
        return Heap2;
      });
    }).call(heap$1);
  })(heap$2);
  return heap$2.exports;
}
__name(requireHeap$1, "requireHeap$1");
var heap;
var hasRequiredHeap;
function requireHeap() {
  if (hasRequiredHeap) return heap;
  hasRequiredHeap = 1;
  heap = requireHeap$1();
  return heap;
}
__name(requireHeap, "requireHeap");
var heapExports = requireHeap();
var Heap = /* @__PURE__ */ getDefaultExportFromCjs(heapExports);
var dijkstraDefaults = defaults$g({
  root: null,
  weight: /* @__PURE__ */ __name(function weight(edge) {
    return 1;
  }, "weight"),
  directed: false
});
var elesfn$u = {
  dijkstra: /* @__PURE__ */ __name(function dijkstra(options2) {
    if (!plainObject(options2)) {
      var args2 = arguments;
      options2 = {
        root: args2[0],
        weight: args2[1],
        directed: args2[2]
      };
    }
    var _dijkstraDefaults = dijkstraDefaults(options2), root2 = _dijkstraDefaults.root, weight8 = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;
    var eles = this;
    var weightFn = weight8;
    var source2 = string(root2) ? this.filter(root2)[0] : root2[0];
    var dist3 = {};
    var prev = {};
    var knownDist = {};
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    edges3.unmergeBy(function(ele) {
      return ele.isLoop();
    });
    var getDist3 = /* @__PURE__ */ __name(function getDist4(node2) {
      return dist3[node2.id()];
    }, "getDist4");
    var setDist = /* @__PURE__ */ __name(function setDist2(node2, d) {
      dist3[node2.id()] = d;
      Q.updateItem(node2);
    }, "setDist2");
    var Q = new Heap(function(a, b) {
      return getDist3(a) - getDist3(b);
    });
    for (var i = 0; i < nodes3.length; i++) {
      var node = nodes3[i];
      dist3[node.id()] = node.same(source2) ? 0 : Infinity;
      Q.push(node);
    }
    var distBetween = /* @__PURE__ */ __name(function distBetween2(u2, v3) {
      var uvs = (directed ? u2.edgesTo(v3) : u2.edgesWith(v3)).intersect(edges3);
      var smallestDistance = Infinity;
      var smallestEdge;
      for (var _i = 0; _i < uvs.length; _i++) {
        var edge = uvs[_i];
        var _weight = weightFn(edge);
        if (_weight < smallestDistance || !smallestEdge) {
          smallestDistance = _weight;
          smallestEdge = edge;
        }
      }
      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    }, "distBetween2");
    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist3(u);
      var uid = u.id();
      knownDist[uid] = smalletsDist;
      if (smalletsDist === Infinity) {
        continue;
      }
      var neighbors = u.neighborhood().intersect(nodes3);
      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
        var v = neighbors[_i2];
        var vid = v.id();
        var vDist = distBetween(u, v);
        var alt = smalletsDist + vDist.dist;
        if (alt < getDist3(v)) {
          setDist(v, alt);
          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      }
    }
    return {
      distanceTo: /* @__PURE__ */ __name(function distanceTo(node2) {
        var target = string(node2) ? nodes3.filter(node2)[0] : node2[0];
        return knownDist[target.id()];
      }, "distanceTo"),
      pathTo: /* @__PURE__ */ __name(function pathTo(node2) {
        var target = string(node2) ? nodes3.filter(node2)[0] : node2[0];
        var S = [];
        var u2 = target;
        var uid2 = u2.id();
        if (target.length > 0) {
          S.unshift(target);
          while (prev[uid2]) {
            var p2 = prev[uid2];
            S.unshift(p2.edge);
            S.unshift(p2.node);
            u2 = p2.node;
            uid2 = u2.id();
          }
        }
        return eles.spawn(S);
      }, "pathTo")
    };
  }, "dijkstra")
};
var elesfn$t = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: /* @__PURE__ */ __name(function kruskal(weightFn) {
    weightFn = weightFn || function(edge2) {
      return 1;
    };
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    var numNodes = nodes3.length;
    var forest = new Array(numNodes);
    var A = nodes3;
    var findSetIndex = /* @__PURE__ */ __name(function findSetIndex2(ele) {
      for (var i2 = 0; i2 < forest.length; i2++) {
        var eles = forest[i2];
        if (eles.has(ele)) {
          return i2;
        }
      }
    }, "findSetIndex2");
    for (var i = 0; i < numNodes; i++) {
      forest[i] = this.spawn(nodes3[i]);
    }
    var S = edges3.sort(function(a, b) {
      return weightFn(a) - weightFn(b);
    });
    for (var _i = 0; _i < S.length; _i++) {
      var edge = S[_i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setUIndex = findSetIndex(u);
      var setVIndex = findSetIndex(v);
      var setU = forest[setUIndex];
      var setV = forest[setVIndex];
      if (setUIndex !== setVIndex) {
        A.merge(edge);
        setU.merge(setV);
        forest.splice(setVIndex, 1);
      }
    }
    return A;
  }, "kruskal")
};
var aStarDefaults = defaults$g({
  root: null,
  goal: null,
  weight: /* @__PURE__ */ __name(function weight2(edge) {
    return 1;
  }, "weight2"),
  heuristic: /* @__PURE__ */ __name(function heuristic(edge) {
    return 0;
  }, "heuristic"),
  directed: false
});
var elesfn$s = {
  // Implemented from pseudocode from wikipedia
  aStar: /* @__PURE__ */ __name(function aStar(options2) {
    var cy = this.cy();
    var _aStarDefaults = aStarDefaults(options2), root2 = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic2 = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight8 = _aStarDefaults.weight;
    root2 = cy.collection(root2)[0];
    goal = cy.collection(goal)[0];
    var sid = root2.id();
    var tid = goal.id();
    var gScore = {};
    var fScore = {};
    var closedSetIds = {};
    var openSet = new Heap(function(a, b) {
      return fScore[a.id()] - fScore[b.id()];
    });
    var openSetIds = new Set$1();
    var cameFrom = {};
    var cameFromEdge = {};
    var addToOpenSet = /* @__PURE__ */ __name(function addToOpenSet2(ele, id2) {
      openSet.push(ele);
      openSetIds.add(id2);
    }, "addToOpenSet2");
    var cMin, cMinId;
    var popFromOpenSet = /* @__PURE__ */ __name(function popFromOpenSet2() {
      cMin = openSet.pop();
      cMinId = cMin.id();
      openSetIds["delete"](cMinId);
    }, "popFromOpenSet2");
    var isInOpenSet = /* @__PURE__ */ __name(function isInOpenSet2(id2) {
      return openSetIds.has(id2);
    }, "isInOpenSet2");
    addToOpenSet(root2, sid);
    gScore[sid] = 0;
    fScore[sid] = heuristic2(root2);
    var steps = 0;
    while (openSet.size() > 0) {
      popFromOpenSet();
      steps++;
      if (cMinId === tid) {
        var path = [];
        var pathNode = goal;
        var pathNodeId = tid;
        var pathEdge = cameFromEdge[pathNodeId];
        for (; ; ) {
          path.unshift(pathNode);
          if (pathEdge != null) {
            path.unshift(pathEdge);
          }
          pathNode = cameFrom[pathNodeId];
          if (pathNode == null) {
            break;
          }
          pathNodeId = pathNode.id();
          pathEdge = cameFromEdge[pathNodeId];
        }
        return {
          found: true,
          distance: gScore[cMinId],
          path: this.spawn(path),
          steps
        };
      }
      closedSetIds[cMinId] = true;
      var vwEdges = cMin._private.edges;
      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];
        if (!this.hasElementWithId(e.id())) {
          continue;
        }
        if (directed && e.data("source") !== cMinId) {
          continue;
        }
        var wSrc = e.source();
        var wTgt = e.target();
        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id();
        if (!this.hasElementWithId(wid)) {
          continue;
        }
        if (closedSetIds[wid]) {
          continue;
        }
        var tempScore = gScore[cMinId] + weight8(e);
        if (!isInOpenSet(wid)) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic2(w);
          addToOpenSet(w, wid);
          cameFrom[wid] = cMin;
          cameFromEdge[wid] = e;
          continue;
        }
        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic2(w);
          cameFrom[wid] = cMin;
          cameFromEdge[wid] = e;
        }
      }
    }
    return {
      found: false,
      distance: void 0,
      path: void 0,
      steps
    };
  }, "aStar")
};
var floydWarshallDefaults = defaults$g({
  weight: /* @__PURE__ */ __name(function weight3(edge) {
    return 1;
  }, "weight3"),
  directed: false
});
var elesfn$r = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: /* @__PURE__ */ __name(function floydWarshall(options2) {
    var cy = this.cy();
    var _floydWarshallDefault = floydWarshallDefaults(options2), weight8 = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;
    var weightFn = weight8;
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    var N = nodes3.length;
    var Nsq = N * N;
    var indexOf = /* @__PURE__ */ __name(function indexOf2(node) {
      return nodes3.indexOf(node);
    }, "indexOf2");
    var atIndex = /* @__PURE__ */ __name(function atIndex2(i2) {
      return nodes3[i2];
    }, "atIndex2");
    var dist3 = new Array(Nsq);
    for (var n = 0; n < Nsq; n++) {
      var j = n % N;
      var i = (n - j) / N;
      if (i === j) {
        dist3[n] = 0;
      } else {
        dist3[n] = Infinity;
      }
    }
    var next2 = new Array(Nsq);
    var edgeNext = new Array(Nsq);
    for (var _i = 0; _i < edges3.length; _i++) {
      var edge = edges3[_i];
      var src = edge.source()[0];
      var tgt = edge.target()[0];
      if (src === tgt) {
        continue;
      }
      var s = indexOf(src);
      var t = indexOf(tgt);
      var st = s * N + t;
      var _weight = weightFn(edge);
      if (dist3[st] > _weight) {
        dist3[st] = _weight;
        next2[st] = t;
        edgeNext[st] = edge;
      }
      if (!directed) {
        var ts = t * N + s;
        if (!directed && dist3[ts] > _weight) {
          dist3[ts] = _weight;
          next2[ts] = s;
          edgeNext[ts] = edge;
        }
      }
    }
    for (var k = 0; k < N; k++) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        var ik = _i2 * N + k;
        for (var _j = 0; _j < N; _j++) {
          var ij = _i2 * N + _j;
          var kj = k * N + _j;
          if (dist3[ik] + dist3[kj] < dist3[ij]) {
            dist3[ij] = dist3[ik] + dist3[kj];
            next2[ij] = next2[ik];
          }
        }
      }
    }
    var getArgEle = /* @__PURE__ */ __name(function getArgEle2(ele) {
      return (string(ele) ? cy.filter(ele) : ele)[0];
    }, "getArgEle2");
    var indexOfArgEle = /* @__PURE__ */ __name(function indexOfArgEle2(ele) {
      return indexOf(getArgEle(ele));
    }, "indexOfArgEle2");
    var res = {
      distance: /* @__PURE__ */ __name(function distance(from, to) {
        var i2 = indexOfArgEle(from);
        var j2 = indexOfArgEle(to);
        return dist3[i2 * N + j2];
      }, "distance"),
      path: /* @__PURE__ */ __name(function path(from, to) {
        var i2 = indexOfArgEle(from);
        var j2 = indexOfArgEle(to);
        var fromNode = atIndex(i2);
        if (i2 === j2) {
          return fromNode.collection();
        }
        if (next2[i2 * N + j2] == null) {
          return cy.collection();
        }
        var path2 = cy.collection();
        var prev = i2;
        var edge2;
        path2.merge(fromNode);
        while (i2 !== j2) {
          prev = i2;
          i2 = next2[i2 * N + j2];
          edge2 = edgeNext[prev * N + i2];
          path2.merge(edge2);
          path2.merge(atIndex(i2));
        }
        return path2;
      }, "path")
    };
    return res;
  }, "floydWarshall")
  // floydWarshall
};
var bellmanFordDefaults = defaults$g({
  weight: /* @__PURE__ */ __name(function weight4(edge) {
    return 1;
  }, "weight4"),
  directed: false,
  root: null
});
var elesfn$q = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: /* @__PURE__ */ __name(function bellmanFord(options2) {
    var _this = this;
    var _bellmanFordDefaults = bellmanFordDefaults(options2), weight8 = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root2 = _bellmanFordDefaults.root;
    var weightFn = weight8;
    var eles = this;
    var cy = this.cy();
    var _this$byGroup = this.byGroup(), edges3 = _this$byGroup.edges, nodes3 = _this$byGroup.nodes;
    var numNodes = nodes3.length;
    var infoMap = new Map$1();
    var hasNegativeWeightCycle = false;
    var negativeWeightCycles = [];
    root2 = cy.collection(root2)[0];
    edges3.unmergeBy(function(edge2) {
      return edge2.isLoop();
    });
    var numEdges = edges3.length;
    var getInfo3 = /* @__PURE__ */ __name(function getInfo4(node2) {
      var obj = infoMap.get(node2.id());
      if (!obj) {
        obj = {};
        infoMap.set(node2.id(), obj);
      }
      return obj;
    }, "getInfo4");
    var getNodeFromTo = /* @__PURE__ */ __name(function getNodeFromTo2(to) {
      return (string(to) ? cy.$(to) : to)[0];
    }, "getNodeFromTo2");
    var distanceTo = /* @__PURE__ */ __name(function distanceTo2(to) {
      return getInfo3(getNodeFromTo(to)).dist;
    }, "distanceTo2");
    var pathTo = /* @__PURE__ */ __name(function pathTo2(to) {
      var thisStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : root2;
      var end = getNodeFromTo(to);
      var path = [];
      var node2 = end;
      for (; ; ) {
        if (node2 == null) {
          return _this.spawn();
        }
        var _getInfo = getInfo3(node2), edge2 = _getInfo.edge, pred = _getInfo.pred;
        path.unshift(node2[0]);
        if (node2.same(thisStart) && path.length > 0) {
          break;
        }
        if (edge2 != null) {
          path.unshift(edge2);
        }
        node2 = pred;
      }
      return eles.spawn(path);
    }, "pathTo2");
    for (var i = 0; i < numNodes; i++) {
      var node = nodes3[i];
      var info = getInfo3(node);
      if (node.same(root2)) {
        info.dist = 0;
      } else {
        info.dist = Infinity;
      }
      info.pred = null;
      info.edge = null;
    }
    var replacedEdge = false;
    var checkForEdgeReplacement = /* @__PURE__ */ __name(function checkForEdgeReplacement2(node1, node2, edge2, info1, info2, weight9) {
      var dist3 = info1.dist + weight9;
      if (dist3 < info2.dist && !edge2.same(info1.edge)) {
        info2.dist = dist3;
        info2.pred = node1;
        info2.edge = edge2;
        replacedEdge = true;
      }
    }, "checkForEdgeReplacement2");
    for (var _i = 1; _i < numNodes; _i++) {
      replacedEdge = false;
      for (var e = 0; e < numEdges; e++) {
        var edge = edges3[e];
        var src = edge.source();
        var tgt = edge.target();
        var _weight = weightFn(edge);
        var srcInfo = getInfo3(src);
        var tgtInfo = getInfo3(tgt);
        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);
        if (!directed) {
          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
        }
      }
      if (!replacedEdge) {
        break;
      }
    }
    if (replacedEdge) {
      var negativeWeightCycleIds = [];
      for (var _e = 0; _e < numEdges; _e++) {
        var _edge = edges3[_e];
        var _src = _edge.source();
        var _tgt = _edge.target();
        var _weight2 = weightFn(_edge);
        var srcDist = getInfo3(_src).dist;
        var tgtDist = getInfo3(_tgt).dist;
        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
          if (!hasNegativeWeightCycle) {
            warn("Graph contains a negative weight cycle for Bellman-Ford");
            hasNegativeWeightCycle = true;
          }
          if (options2.findNegativeWeightCycles !== false) {
            var negativeNodes = [];
            if (srcDist + _weight2 < tgtDist) {
              negativeNodes.push(_src);
            }
            if (!directed && tgtDist + _weight2 < srcDist) {
              negativeNodes.push(_tgt);
            }
            var numNegativeNodes = negativeNodes.length;
            for (var n = 0; n < numNegativeNodes; n++) {
              var start = negativeNodes[n];
              var cycle = [start];
              cycle.push(getInfo3(start).edge);
              var _node = getInfo3(start).pred;
              while (cycle.indexOf(_node) === -1) {
                cycle.push(_node);
                cycle.push(getInfo3(_node).edge);
                _node = getInfo3(_node).pred;
              }
              cycle = cycle.slice(cycle.indexOf(_node));
              var smallestId = cycle[0].id();
              var smallestIndex = 0;
              for (var c = 2; c < cycle.length; c += 2) {
                if (cycle[c].id() < smallestId) {
                  smallestId = cycle[c].id();
                  smallestIndex = c;
                }
              }
              cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));
              cycle.push(cycle[0]);
              var cycleId = cycle.map(function(el) {
                return el.id();
              }).join(",");
              if (negativeWeightCycleIds.indexOf(cycleId) === -1) {
                negativeWeightCycles.push(eles.spawn(cycle));
                negativeWeightCycleIds.push(cycleId);
              }
            }
          } else {
            break;
          }
        }
      }
    }
    return {
      distanceTo,
      pathTo,
      hasNegativeWeightCycle,
      negativeWeightCycles
    };
  }, "bellmanFord")
  // bellmanFord
};
var sqrt2 = Math.sqrt(2);
var collapse = /* @__PURE__ */ __name(function collapse2(edgeIndex, nodeMap, remainingEdges) {
  if (remainingEdges.length === 0) {
    error("Karger-Stein must be run on a connected (sub)graph");
  }
  var edgeInfo = remainingEdges[edgeIndex];
  var sourceIn = edgeInfo[1];
  var targetIn = edgeInfo[2];
  var partition1 = nodeMap[sourceIn];
  var partition2 = nodeMap[targetIn];
  var newEdges = remainingEdges;
  for (var i = newEdges.length - 1; i >= 0; i--) {
    var edge = newEdges[i];
    var src = edge[1];
    var tgt = edge[2];
    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
      newEdges.splice(i, 1);
    }
  }
  for (var _i = 0; _i < newEdges.length; _i++) {
    var _edge = newEdges[_i];
    if (_edge[1] === partition2) {
      newEdges[_i] = _edge.slice();
      newEdges[_i][1] = partition1;
    } else if (_edge[2] === partition2) {
      newEdges[_i] = _edge.slice();
      newEdges[_i][2] = partition1;
    }
  }
  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
    if (nodeMap[_i2] === partition2) {
      nodeMap[_i2] = partition1;
    }
  }
  return newEdges;
}, "collapse2");
var contractUntil = /* @__PURE__ */ __name(function contractUntil2(metaNodeMap, remainingEdges, size3, sizeLimit) {
  while (size3 > sizeLimit) {
    var edgeIndex = Math.floor(Math.random() * remainingEdges.length);
    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
    size3--;
  }
  return remainingEdges;
}, "contractUntil2");
var elesfn$p = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: /* @__PURE__ */ __name(function kargerStein() {
    var _this = this;
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    edges3.unmergeBy(function(edge) {
      return edge.isLoop();
    });
    var numNodes = nodes3.length;
    var numEdges = edges3.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / sqrt2);
    if (numNodes < 2) {
      error("At least 2 nodes are required for Karger-Stein algorithm");
      return void 0;
    }
    var edgeIndexes = [];
    for (var i = 0; i < numEdges; i++) {
      var e = edges3[i];
      edgeIndexes.push([i, nodes3.indexOf(e.source()), nodes3.indexOf(e.target())]);
    }
    var minCutSize = Infinity;
    var minCutEdgeIndexes = [];
    var minCutNodeMap = new Array(numNodes);
    var metaNodeMap = new Array(numNodes);
    var metaNodeMap2 = new Array(numNodes);
    var copyNodesMap = /* @__PURE__ */ __name(function copyNodesMap2(from, to) {
      for (var _i3 = 0; _i3 < numNodes; _i3++) {
        to[_i3] = from[_i3];
      }
    }, "copyNodesMap2");
    for (var iter = 0; iter <= numIter; iter++) {
      for (var _i4 = 0; _i4 < numNodes; _i4++) {
        metaNodeMap[_i4] = _i4;
      }
      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
      var edgesState2 = edgesState.slice();
      copyNodesMap(metaNodeMap, metaNodeMap2);
      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);
      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCutEdgeIndexes = res1;
        copyNodesMap(metaNodeMap, minCutNodeMap);
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCutEdgeIndexes = res2;
        copyNodesMap(metaNodeMap2, minCutNodeMap);
      }
    }
    var cut = this.spawn(minCutEdgeIndexes.map(function(e2) {
      return edges3[e2[0]];
    }));
    var partition1 = this.spawn();
    var partition2 = this.spawn();
    var witnessNodePartition = minCutNodeMap[0];
    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
      var partitionId = minCutNodeMap[_i5];
      var node = nodes3[_i5];
      if (partitionId === witnessNodePartition) {
        partition1.merge(node);
      } else {
        partition2.merge(node);
      }
    }
    var constructComponent = /* @__PURE__ */ __name(function constructComponent2(subset) {
      var component22 = _this.spawn();
      subset.forEach(function(node2) {
        component22.merge(node2);
        node2.connectedEdges().forEach(function(edge) {
          if (_this.contains(edge) && !cut.contains(edge)) {
            component22.merge(edge);
          }
        });
      });
      return component22;
    }, "constructComponent2");
    var components2 = [constructComponent(partition1), constructComponent(partition2)];
    var ret = {
      cut,
      components: components2,
      // n.b. partitions are included to be compatible with the old api spec
      // (could be removed in a future major version)
      partition1,
      partition2
    };
    return ret;
  }, "kargerStein")
};
var _Math$hypot;
var copyPosition = /* @__PURE__ */ __name(function copyPosition2(p2) {
  return {
    x: p2.x,
    y: p2.y
  };
}, "copyPosition2");
var modelToRenderedPosition$1 = /* @__PURE__ */ __name(function modelToRenderedPosition(p2, zoom2, pan2) {
  return {
    x: p2.x * zoom2 + pan2.x,
    y: p2.y * zoom2 + pan2.y
  };
}, "modelToRenderedPosition");
var renderedToModelPosition = /* @__PURE__ */ __name(function renderedToModelPosition2(p2, zoom2, pan2) {
  return {
    x: (p2.x - pan2.x) / zoom2,
    y: (p2.y - pan2.y) / zoom2
  };
}, "renderedToModelPosition2");
var array2point = /* @__PURE__ */ __name(function array2point2(arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
}, "array2point2");
var min = /* @__PURE__ */ __name(function min2(arr) {
  var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
  var min4 = Infinity;
  for (var i = begin; i < end; i++) {
    var val = arr[i];
    if (isFinite(val)) {
      min4 = Math.min(val, min4);
    }
  }
  return min4;
}, "min2");
var max = /* @__PURE__ */ __name(function max2(arr) {
  var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
  var max5 = -Infinity;
  for (var i = begin; i < end; i++) {
    var val = arr[i];
    if (isFinite(val)) {
      max5 = Math.max(val, max5);
    }
  }
  return max5;
}, "max2");
var mean = /* @__PURE__ */ __name(function mean2(arr) {
  var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
  var total = 0;
  var n = 0;
  for (var i = begin; i < end; i++) {
    var val = arr[i];
    if (isFinite(val)) {
      total += val;
      n++;
    }
  }
  return total / n;
}, "mean2");
var median = /* @__PURE__ */ __name(function median2(arr) {
  var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
  var copy3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var sort2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var includeHoles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  if (copy3) {
    arr = arr.slice(begin, end);
  } else {
    if (end < arr.length) {
      arr.splice(end, arr.length - end);
    }
    if (begin > 0) {
      arr.splice(0, begin);
    }
  }
  var off = 0;
  for (var i = arr.length - 1; i >= 0; i--) {
    var v = arr[i];
    if (includeHoles) {
      if (!isFinite(v)) {
        arr[i] = -Infinity;
        off++;
      }
    } else {
      arr.splice(i, 1);
    }
  }
  if (sort2) {
    arr.sort(function(a, b) {
      return a - b;
    });
  }
  var len = arr.length;
  var mid = Math.floor(len / 2);
  if (len % 2 !== 0) {
    return arr[mid + 1 + off];
  } else {
    return (arr[mid - 1 + off] + arr[mid + off]) / 2;
  }
}, "median2");
var deg2rad = /* @__PURE__ */ __name(function deg2rad2(deg) {
  return Math.PI * deg / 180;
}, "deg2rad2");
var getAngleFromDisp = /* @__PURE__ */ __name(function getAngleFromDisp2(dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
}, "getAngleFromDisp2");
var log2 = Math.log2 || function(n) {
  return Math.log(n) / Math.log(2);
};
var signum = /* @__PURE__ */ __name(function signum2(x2) {
  if (x2 > 0) {
    return 1;
  } else if (x2 < 0) {
    return -1;
  } else {
    return 0;
  }
}, "signum2");
var dist = /* @__PURE__ */ __name(function dist2(p1, p2) {
  return Math.sqrt(sqdist(p1, p2));
}, "dist2");
var sqdist = /* @__PURE__ */ __name(function sqdist2(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return dx * dx + dy * dy;
}, "sqdist2");
var inPlaceSumNormalize = /* @__PURE__ */ __name(function inPlaceSumNormalize2(v) {
  var length2 = v.length;
  var total = 0;
  for (var i = 0; i < length2; i++) {
    total += v[i];
  }
  for (var _i = 0; _i < length2; _i++) {
    v[_i] = v[_i] / total;
  }
  return v;
}, "inPlaceSumNormalize2");
var qbezierAt = /* @__PURE__ */ __name(function qbezierAt2(p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
}, "qbezierAt2");
var qbezierPtAt = /* @__PURE__ */ __name(function qbezierPtAt2(p0, p1, p2, t) {
  return {
    x: qbezierAt(p0.x, p1.x, p2.x, t),
    y: qbezierAt(p0.y, p1.y, p2.y, t)
  };
}, "qbezierPtAt2");
var lineAt = /* @__PURE__ */ __name(function lineAt2(p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var vecDist = dist(p0, p1);
  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };
  t = t == null ? 0 : t;
  d = d != null ? d : t * vecDist;
  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
}, "lineAt2");
var bound = /* @__PURE__ */ __name(function bound2(min4, val, max5) {
  return Math.max(min4, Math.min(max5, val));
}, "bound2");
var makeBoundingBox = /* @__PURE__ */ __name(function makeBoundingBox2(bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
}, "makeBoundingBox2");
var copyBoundingBox = /* @__PURE__ */ __name(function copyBoundingBox2(bb) {
  return {
    x1: bb.x1,
    x2: bb.x2,
    w: bb.w,
    y1: bb.y1,
    y2: bb.y2,
    h: bb.h
  };
}, "copyBoundingBox2");
var clearBoundingBox = /* @__PURE__ */ __name(function clearBoundingBox2(bb) {
  bb.x1 = Infinity;
  bb.y1 = Infinity;
  bb.x2 = -Infinity;
  bb.y2 = -Infinity;
  bb.w = 0;
  bb.h = 0;
}, "clearBoundingBox2");
var updateBoundingBox = /* @__PURE__ */ __name(function updateBoundingBox2(bb1, bb2) {
  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;
  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
}, "updateBoundingBox2");
var expandBoundingBoxByPoint = /* @__PURE__ */ __name(function expandBoundingBoxByPoint2(bb, x2, y2) {
  bb.x1 = Math.min(bb.x1, x2);
  bb.x2 = Math.max(bb.x2, x2);
  bb.w = bb.x2 - bb.x1;
  bb.y1 = Math.min(bb.y1, y2);
  bb.y2 = Math.max(bb.y2, y2);
  bb.h = bb.y2 - bb.y1;
}, "expandBoundingBoxByPoint2");
var expandBoundingBox = /* @__PURE__ */ __name(function expandBoundingBox2(bb) {
  var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
}, "expandBoundingBox2");
var expandBoundingBoxSides = /* @__PURE__ */ __name(function expandBoundingBoxSides2(bb) {
  var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0];
  var top, right, bottom, left;
  if (padding.length === 1) {
    top = right = bottom = left = padding[0];
  } else if (padding.length === 2) {
    top = bottom = padding[0];
    left = right = padding[1];
  } else if (padding.length === 4) {
    var _padding = _slicedToArray(padding, 4);
    top = _padding[0];
    right = _padding[1];
    bottom = _padding[2];
    left = _padding[3];
  }
  bb.x1 -= left;
  bb.x2 += right;
  bb.y1 -= top;
  bb.y2 += bottom;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
}, "expandBoundingBoxSides2");
var assignBoundingBox = /* @__PURE__ */ __name(function assignBoundingBox2(bb1, bb2) {
  bb1.x1 = bb2.x1;
  bb1.y1 = bb2.y1;
  bb1.x2 = bb2.x2;
  bb1.y2 = bb2.y2;
  bb1.w = bb1.x2 - bb1.x1;
  bb1.h = bb1.y2 - bb1.y1;
}, "assignBoundingBox2");
var boundingBoxesIntersect = /* @__PURE__ */ __name(function boundingBoxesIntersect2(bb1, bb2) {
  if (bb1.x1 > bb2.x2) {
    return false;
  }
  if (bb2.x1 > bb1.x2) {
    return false;
  }
  if (bb1.x2 < bb2.x1) {
    return false;
  }
  if (bb2.x2 < bb1.x1) {
    return false;
  }
  if (bb1.y2 < bb2.y1) {
    return false;
  }
  if (bb2.y2 < bb1.y1) {
    return false;
  }
  if (bb1.y1 > bb2.y2) {
    return false;
  }
  if (bb2.y1 > bb1.y2) {
    return false;
  }
  return true;
}, "boundingBoxesIntersect2");
var inBoundingBox = /* @__PURE__ */ __name(function inBoundingBox2(bb, x2, y2) {
  return bb.x1 <= x2 && x2 <= bb.x2 && bb.y1 <= y2 && y2 <= bb.y2;
}, "inBoundingBox2");
var pointInBoundingBox = /* @__PURE__ */ __name(function pointInBoundingBox2(bb, pt) {
  return inBoundingBox(bb, pt.x, pt.y);
}, "pointInBoundingBox2");
var boundingBoxInBoundingBox = /* @__PURE__ */ __name(function boundingBoxInBoundingBox2(bb1, bb2) {
  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
}, "boundingBoxInBoundingBox2");
var hypot = (_Math$hypot = Math.hypot) !== null && _Math$hypot !== void 0 ? _Math$hypot : function(x2, y2) {
  return Math.sqrt(x2 * x2 + y2 * y2);
};
function inflatePolygon(polygon2, d) {
  if (polygon2.length < 3) {
    throw new Error("Need at least 3 vertices");
  }
  var add3 = /* @__PURE__ */ __name(function add4(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }, "add4");
  var sub = /* @__PURE__ */ __name(function sub2(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }, "sub2");
  var scale2 = /* @__PURE__ */ __name(function scale3(v, s) {
    return {
      x: v.x * s,
      y: v.y * s
    };
  }, "scale3");
  var cross = /* @__PURE__ */ __name(function cross2(u, v) {
    return u.x * v.y - u.y * v.x;
  }, "cross2");
  var normalize3 = /* @__PURE__ */ __name(function normalize4(v) {
    var len = hypot(v.x, v.y);
    return len === 0 ? {
      x: 0,
      y: 0
    } : {
      x: v.x / len,
      y: v.y / len
    };
  }, "normalize4");
  var signedArea = /* @__PURE__ */ __name(function signedArea2(pts3) {
    var A = 0;
    for (var i2 = 0; i2 < pts3.length; i2++) {
      var p3 = pts3[i2], q2 = pts3[(i2 + 1) % pts3.length];
      A += p3.x * q2.y - q2.x * p3.y;
    }
    return A / 2;
  }, "signedArea2");
  var intersectLines = /* @__PURE__ */ __name(function intersectLines2(p1, p22, p3, p4) {
    var r2 = sub(p22, p1);
    var s = sub(p4, p3);
    var denom = cross(r2, s);
    if (Math.abs(denom) < 1e-9) {
      return add3(p1, scale2(r2, 0.5));
    }
    var t = cross(sub(p3, p1), s) / denom;
    return add3(p1, scale2(r2, t));
  }, "intersectLines2");
  var pts2 = polygon2.map(function(p3) {
    return {
      x: p3.x,
      y: p3.y
    };
  });
  if (signedArea(pts2) < 0) pts2.reverse();
  var n = pts2.length;
  var normals = [];
  for (var i = 0; i < n; i++) {
    var p2 = pts2[i], q = pts2[(i + 1) % n];
    var edge = sub(q, p2);
    var out = normalize3({
      x: edge.y,
      y: -edge.x
    });
    normals.push(out);
  }
  var offsetEdges = normals.map(function(nrm, i2) {
    var p1 = add3(pts2[i2], scale2(nrm, d));
    var p22 = add3(pts2[(i2 + 1) % n], scale2(nrm, d));
    return {
      p1,
      p2: p22
    };
  });
  var inflated = [];
  for (var _i2 = 0; _i2 < n; _i2++) {
    var prevEdge = offsetEdges[(_i2 - 1 + n) % n];
    var currEdge = offsetEdges[_i2];
    var ip2 = intersectLines(prevEdge.p1, prevEdge.p2, currEdge.p1, currEdge.p2);
    inflated.push(ip2);
  }
  return inflated;
}
__name(inflatePolygon, "inflatePolygon");
function miterBox(pts2, centerX, centerY, width2, height2, strokeWidth) {
  var tpts = transformPoints(pts2, centerX, centerY, width2, height2);
  var offsetPoints = inflatePolygon(tpts, strokeWidth);
  var bb = makeBoundingBox();
  offsetPoints.forEach(function(pt) {
    return expandBoundingBoxByPoint(bb, pt.x, pt.y);
  });
  return bb;
}
__name(miterBox, "miterBox");
var roundRectangleIntersectLine = /* @__PURE__ */ __name(function roundRectangleIntersectLine2(x2, y2, nodeX, nodeY, width2, height2, padding) {
  var radius2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "auto";
  var cornerRadius = radius2 === "auto" ? getRoundRectangleRadius(width2, height2) : radius2;
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);
  var doWidth = cornerRadius !== halfWidth, doHeight = cornerRadius !== halfHeight;
  var straightLineIntersections;
  if (doWidth) {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;
    straightLineIntersections = finiteLinesIntersect(x2, y2, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }
  if (doHeight) {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x2, y2, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }
  if (doWidth) {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;
    straightLineIntersections = finiteLinesIntersect(x2, y2, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }
  if (doHeight) {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x2, y2, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }
  var arcIntersections;
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x2, y2, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);
    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x2, y2, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);
    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x2, y2, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x2, y2, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  return [];
}, "roundRectangleIntersectLine2");
var inLineVicinity = /* @__PURE__ */ __name(function inLineVicinity2(x2, y2, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;
  var x1 = Math.min(lx1, lx2);
  var x22 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y22 = Math.max(ly1, ly2);
  return x1 - t <= x2 && x2 <= x22 + t && y1 - t <= y2 && y2 <= y22 + t;
}, "inLineVicinity2");
var inBezierVicinity = /* @__PURE__ */ __name(function inBezierVicinity2(x2, y2, x1, y1, x22, y22, x3, y3, tolerance) {
  var bb = {
    x1: Math.min(x1, x3, x22) - tolerance,
    x2: Math.max(x1, x3, x22) + tolerance,
    y1: Math.min(y1, y3, y22) - tolerance,
    y2: Math.max(y1, y3, y22) + tolerance
  };
  if (x2 < bb.x1 || x2 > bb.x2 || y2 < bb.y1 || y2 > bb.y2) {
    return false;
  } else {
    return true;
  }
}, "inBezierVicinity2");
var solveQuadratic = /* @__PURE__ */ __name(function solveQuadratic2(a, b, c, val) {
  c -= val;
  var r2 = b * b - 4 * a * c;
  if (r2 < 0) {
    return [];
  }
  var sqrtR = Math.sqrt(r2);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;
  return [root1, root2];
}, "solveQuadratic2");
var solveCubic = /* @__PURE__ */ __name(function solveCubic2(a, b, c, d, result) {
  var epsilon = 1e-5;
  if (a === 0) {
    a = epsilon;
  }
  b /= a;
  c /= a;
  d /= a;
  var discriminant, q, r2, dum1, s, t, term1, r13;
  q = (3 * c - b * b) / 9;
  r2 = -(27 * d) + b * (9 * c - 2 * (b * b));
  r2 /= 54;
  discriminant = q * q * q + r2 * r2;
  result[1] = 0;
  term1 = b / 3;
  if (discriminant > 0) {
    s = r2 + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1 / 3) : Math.pow(s, 1 / 3);
    t = r2 - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1 / 3) : Math.pow(t, 1 / 3);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }
  result[5] = result[3] = 0;
  if (discriminant === 0) {
    r13 = r2 < 0 ? -Math.pow(-r2, 1 / 3) : Math.pow(r2, 1 / 3);
    result[0] = -term1 + 2 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }
  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r2 / Math.sqrt(dum1));
  r13 = 2 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2 * Math.PI) / 3);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4 * Math.PI) / 3);
  return;
}, "solveCubic2");
var sqdistToQuadraticBezier = /* @__PURE__ */ __name(function sqdistToQuadraticBezier2(x2, y2, x1, y1, x22, y22, x3, y3) {
  var a = 1 * x1 * x1 - 4 * x1 * x22 + 2 * x1 * x3 + 4 * x22 * x22 - 4 * x22 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y22 + 2 * y1 * y3 + 4 * y22 * y22 - 4 * y22 * y3 + y3 * y3;
  var b = 1 * 9 * x1 * x22 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x22 * x22 + 3 * x22 * x3 + 9 * y1 * y22 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y22 * y22 + 3 * y22 * y3;
  var c = 1 * 3 * x1 * x1 - 6 * x1 * x22 + x1 * x3 - x1 * x2 + 2 * x22 * x22 + 2 * x22 * x2 - x3 * x2 + 3 * y1 * y1 - 6 * y1 * y22 + y1 * y3 - y1 * y2 + 2 * y22 * y22 + 2 * y22 * y2 - y3 * y2;
  var d = 1 * x1 * x22 - x1 * x1 + x1 * x2 - x22 * x2 + y1 * y22 - y1 * y1 + y1 * y2 - y22 * y2;
  var roots = [];
  solveCubic(a, b, c, d, roots);
  var zeroThreshold = 1e-7;
  var params = [];
  for (var index2 = 0; index2 < 6; index2 += 2) {
    if (Math.abs(roots[index2 + 1]) < zeroThreshold && roots[index2] >= 0 && roots[index2] <= 1) {
      params.push(roots[index2]);
    }
  }
  params.push(1);
  params.push(0);
  var minDistanceSquared = -1;
  var curX, curY, distSquared;
  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1 - params[i], 2) * x1 + 2 * (1 - params[i]) * params[i] * x22 + params[i] * params[i] * x3;
    curY = Math.pow(1 - params[i], 2) * y1 + 2 * (1 - params[i]) * params[i] * y22 + params[i] * params[i] * y3;
    distSquared = Math.pow(curX - x2, 2) + Math.pow(curY - y2, 2);
    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }
  return minDistanceSquared;
}, "sqdistToQuadraticBezier2");
var sqdistToFiniteLine = /* @__PURE__ */ __name(function sqdistToFiniteLine2(x2, y2, x1, y1, x22, y22) {
  var offset = [x2 - x1, y2 - y1];
  var line = [x22 - x1, y22 - y1];
  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;
  if (dotProduct < 0) {
    return hypSq;
  }
  if (adjSq > lineSq) {
    return (x2 - x22) * (x2 - x22) + (y2 - y22) * (y2 - y22);
  }
  return hypSq - adjSq;
}, "sqdistToFiniteLine2");
var pointInsidePolygonPoints = /* @__PURE__ */ __name(function pointInsidePolygonPoints2(x2, y2, points) {
  var x1, y1, x22, y22;
  var y3;
  var up = 0;
  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    if (i + 1 < points.length / 2) {
      x22 = points[(i + 1) * 2];
      y22 = points[(i + 1) * 2 + 1];
    } else {
      x22 = points[(i + 1 - points.length / 2) * 2];
      y22 = points[(i + 1 - points.length / 2) * 2 + 1];
    }
    if (x1 == x2 && x22 == x2) ;
    else if (x1 >= x2 && x2 >= x22 || x1 <= x2 && x2 <= x22) {
      y3 = (x2 - x1) / (x22 - x1) * (y22 - y1) + y1;
      if (y3 > y2) {
        up++;
      }
    } else {
      continue;
    }
  }
  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
}, "pointInsidePolygonPoints2");
var pointInsidePolygon = /* @__PURE__ */ __name(function pointInsidePolygon2(x2, y2, basePoints, centerX, centerY, width2, height2, direction, padding) {
  var transformedPoints = new Array(basePoints.length);
  var angle2;
  if (direction[0] != null) {
    angle2 = Math.atan(direction[1] / direction[0]);
    if (direction[0] < 0) {
      angle2 = angle2 + Math.PI / 2;
    } else {
      angle2 = -angle2 - Math.PI / 2;
    }
  } else {
    angle2 = direction;
  }
  var cos2 = Math.cos(-angle2);
  var sin2 = Math.sin(-angle2);
  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width2 / 2 * (basePoints[i * 2] * cos2 - basePoints[i * 2 + 1] * sin2);
    transformedPoints[i * 2 + 1] = height2 / 2 * (basePoints[i * 2 + 1] * cos2 + basePoints[i * 2] * sin2);
    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }
  var points;
  if (padding > 0) {
    var expandedLineSet = expandPolygon(transformedPoints, -padding);
    points = joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }
  return pointInsidePolygonPoints(x2, y2, points);
}, "pointInsidePolygon2");
var pointInsideRoundPolygon = /* @__PURE__ */ __name(function pointInsideRoundPolygon2(x2, y2, basePoints, centerX, centerY, width2, height2, corners) {
  var cutPolygonPoints = new Array(basePoints.length * 2);
  for (var i = 0; i < corners.length; i++) {
    var corner = corners[i];
    cutPolygonPoints[i * 4 + 0] = corner.startX;
    cutPolygonPoints[i * 4 + 1] = corner.startY;
    cutPolygonPoints[i * 4 + 2] = corner.stopX;
    cutPolygonPoints[i * 4 + 3] = corner.stopY;
    var squaredDistance = Math.pow(corner.cx - x2, 2) + Math.pow(corner.cy - y2, 2);
    if (squaredDistance <= Math.pow(corner.radius, 2)) {
      return true;
    }
  }
  return pointInsidePolygonPoints(x2, y2, cutPolygonPoints);
}, "pointInsideRoundPolygon2");
var joinLines = /* @__PURE__ */ __name(function joinLines2(lineSet) {
  var vertices = new Array(lineSet.length / 2);
  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];
    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }
    var intersection2 = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
    vertices[i * 2] = intersection2[0];
    vertices[i * 2 + 1] = intersection2[1];
  }
  return vertices;
}, "joinLines2");
var expandPolygon = /* @__PURE__ */ __name(function expandPolygon2(points, pad) {
  var expandedLineSet = new Array(points.length * 2);
  var currentPointX, currentPointY, nextPointX, nextPointY;
  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];
    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }
    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX);
    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;
    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }
  return expandedLineSet;
}, "expandPolygon2");
var intersectLineEllipse = /* @__PURE__ */ __name(function intersectLineEllipse2(x2, y2, centerX, centerY, ellipseWradius, ellipseHradius) {
  var dispX = centerX - x2;
  var dispY = centerY - y2;
  dispX /= ellipseWradius;
  dispY /= ellipseHradius;
  var len = Math.sqrt(dispX * dispX + dispY * dispY);
  var newLength = len - 1;
  if (newLength < 0) {
    return [];
  }
  var lenProportion = newLength / len;
  return [(centerX - x2) * lenProportion + x2, (centerY - y2) * lenProportion + y2];
}, "intersectLineEllipse2");
var checkInEllipse = /* @__PURE__ */ __name(function checkInEllipse2(x2, y2, width2, height2, centerX, centerY, padding) {
  x2 -= centerX;
  y2 -= centerY;
  x2 /= width2 / 2 + padding;
  y2 /= height2 / 2 + padding;
  return x2 * x2 + y2 * y2 <= 1;
}, "checkInEllipse2");
var intersectLineCircle = /* @__PURE__ */ __name(function intersectLineCircle2(x1, y1, x2, y2, centerX, centerY, radius2) {
  var d = [x2 - x1, y2 - y1];
  var f = [x1 - centerX, y1 - centerY];
  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius2 * radius2;
  var discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return [];
  }
  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];
  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }
  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }
  if (inRangeParams.length === 0) {
    return [];
  }
  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;
  if (inRangeParams.length > 1) {
    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {
      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;
      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
}, "intersectLineCircle2");
var midOfThree = /* @__PURE__ */ __name(function midOfThree2(a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
}, "midOfThree2");
var finiteLinesIntersect = /* @__PURE__ */ __name(function finiteLinesIntersect2(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;
  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;
  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;
  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;
    var flptThreshold = 1e-3;
    var _min = 0 - flptThreshold;
    var _max = 1 + flptThreshold;
    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {
      if (midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      }
      if (midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      }
      if (midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }
      return [];
    } else {
      return [];
    }
  }
}, "finiteLinesIntersect2");
var transformPoints = /* @__PURE__ */ __name(function transformPoints2(points, centerX, centerY, width2, height2) {
  var ret = [];
  var halfW = width2 / 2;
  var halfH = height2 / 2;
  var x2 = centerX;
  var y2 = centerY;
  ret.push({
    x: x2 + halfW * points[0],
    y: y2 + halfH * points[1]
  });
  for (var i = 1; i < points.length / 2; i++) {
    ret.push({
      x: x2 + halfW * points[i * 2],
      y: y2 + halfH * points[i * 2 + 1]
    });
  }
  return ret;
}, "transformPoints2");
var polygonIntersectLine = /* @__PURE__ */ __name(function polygonIntersectLine2(x2, y2, basePoints, centerX, centerY, width2, height2, padding) {
  var intersections = [];
  var intersection2;
  var transformedPoints = new Array(basePoints.length);
  var doTransform = true;
  if (width2 == null) {
    doTransform = false;
  }
  var points;
  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width2 + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height2 + centerY;
    }
    if (padding > 0) {
      var expandedLineSet = expandPolygon(transformedPoints, -padding);
      points = joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }
  var currentX, currentY, nextX, nextY;
  for (var _i3 = 0; _i3 < points.length / 2; _i3++) {
    currentX = points[_i3 * 2];
    currentY = points[_i3 * 2 + 1];
    if (_i3 < points.length / 2 - 1) {
      nextX = points[(_i3 + 1) * 2];
      nextY = points[(_i3 + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }
    intersection2 = finiteLinesIntersect(x2, y2, centerX, centerY, currentX, currentY, nextX, nextY);
    if (intersection2.length !== 0) {
      intersections.push(intersection2[0], intersection2[1]);
    }
  }
  return intersections;
}, "polygonIntersectLine2");
var roundPolygonIntersectLine = /* @__PURE__ */ __name(function roundPolygonIntersectLine2(x2, y2, basePoints, centerX, centerY, width2, height2, padding, corners) {
  var intersections = [];
  var intersection2;
  var lines = new Array(basePoints.length * 2);
  corners.forEach(function(corner, i2) {
    if (i2 === 0) {
      lines[lines.length - 2] = corner.startX;
      lines[lines.length - 1] = corner.startY;
    } else {
      lines[i2 * 4 - 2] = corner.startX;
      lines[i2 * 4 - 1] = corner.startY;
    }
    lines[i2 * 4] = corner.stopX;
    lines[i2 * 4 + 1] = corner.stopY;
    intersection2 = intersectLineCircle(x2, y2, centerX, centerY, corner.cx, corner.cy, corner.radius);
    if (intersection2.length !== 0) {
      intersections.push(intersection2[0], intersection2[1]);
    }
  });
  for (var i = 0; i < lines.length / 4; i++) {
    intersection2 = finiteLinesIntersect(x2, y2, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);
    if (intersection2.length !== 0) {
      intersections.push(intersection2[0], intersection2[1]);
    }
  }
  if (intersections.length > 2) {
    var lowestIntersection = [intersections[0], intersections[1]];
    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x2, 2) + Math.pow(lowestIntersection[1] - y2, 2);
    for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
      var squaredDistance = Math.pow(intersections[_i4 * 2] - x2, 2) + Math.pow(intersections[_i4 * 2 + 1] - y2, 2);
      if (squaredDistance <= lowestSquaredDistance) {
        lowestIntersection[0] = intersections[_i4 * 2];
        lowestIntersection[1] = intersections[_i4 * 2 + 1];
        lowestSquaredDistance = squaredDistance;
      }
    }
    return lowestIntersection;
  }
  return intersections;
}, "roundPolygonIntersectLine2");
var shortenIntersection = /* @__PURE__ */ __name(function shortenIntersection2(intersection2, offset, amount) {
  var disp = [intersection2[0] - offset[0], intersection2[1] - offset[1]];
  var length2 = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
  var lenRatio = (length2 - amount) / length2;
  if (lenRatio < 0) {
    lenRatio = 1e-5;
  }
  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
}, "shortenIntersection2");
var generateUnitNgonPointsFitToSquare = /* @__PURE__ */ __name(function generateUnitNgonPointsFitToSquare2(sides, rotationRadians) {
  var points = generateUnitNgonPoints(sides, rotationRadians);
  points = fitPolygonToSquare(points);
  return points;
}, "generateUnitNgonPointsFitToSquare2");
var fitPolygonToSquare = /* @__PURE__ */ __name(function fitPolygonToSquare2(points) {
  var x2, y2;
  var sides = points.length / 2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (var i = 0; i < sides; i++) {
    x2 = points[2 * i];
    y2 = points[2 * i + 1];
    minX = Math.min(minX, x2);
    maxX = Math.max(maxX, x2);
    minY = Math.min(minY, y2);
    maxY = Math.max(maxY, y2);
  }
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);
  for (var _i5 = 0; _i5 < sides; _i5++) {
    x2 = points[2 * _i5] = points[2 * _i5] * sx;
    y2 = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
    minX = Math.min(minX, x2);
    maxX = Math.max(maxX, x2);
    minY = Math.min(minY, y2);
    maxY = Math.max(maxY, y2);
  }
  if (minY < -1) {
    for (var _i6 = 0; _i6 < sides; _i6++) {
      y2 = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
    }
  }
  return points;
}, "fitPolygonToSquare2");
var generateUnitNgonPoints = /* @__PURE__ */ __name(function generateUnitNgonPoints2(sides, rotationRadians) {
  var increment2 = 1 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2 + increment2 / 2 : Math.PI / 2;
  startAngle += rotationRadians;
  var points = new Array(sides * 2);
  var currentAngle;
  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment2 + startAngle;
    points[2 * i] = Math.cos(currentAngle);
    points[2 * i + 1] = Math.sin(-currentAngle);
  }
  return points;
}, "generateUnitNgonPoints2");
var getRoundRectangleRadius = /* @__PURE__ */ __name(function getRoundRectangleRadius2(width2, height2) {
  return Math.min(width2 / 4, height2 / 4, 8);
}, "getRoundRectangleRadius2");
var getRoundPolygonRadius = /* @__PURE__ */ __name(function getRoundPolygonRadius2(width2, height2) {
  return Math.min(width2 / 10, height2 / 10, 8);
}, "getRoundPolygonRadius2");
var getCutRectangleCornerLength = /* @__PURE__ */ __name(function getCutRectangleCornerLength2() {
  return 8;
}, "getCutRectangleCornerLength2");
var bezierPtsToQuadCoeff = /* @__PURE__ */ __name(function bezierPtsToQuadCoeff2(p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
}, "bezierPtsToQuadCoeff2");
var getBarrelCurveConstants = /* @__PURE__ */ __name(function getBarrelCurveConstants2(width2, height2) {
  return {
    heightOffset: Math.min(15, 0.05 * height2),
    widthOffset: Math.min(100, 0.25 * width2),
    ctrlPtOffsetPct: 0.05
  };
}, "getBarrelCurveConstants2");
function satPolygonIntersection(poly1, poly2) {
  function getAxes(polygon2) {
    var axes2 = [];
    for (var i = 0; i < polygon2.length; i++) {
      var p1 = polygon2[i];
      var p2 = polygon2[(i + 1) % polygon2.length];
      var edge = {
        x: p2.x - p1.x,
        y: p2.y - p1.y
      };
      var normal2 = {
        x: -edge.y,
        y: edge.x
      };
      var length2 = Math.sqrt(normal2.x * normal2.x + normal2.y * normal2.y);
      axes2.push({
        x: normal2.x / length2,
        y: normal2.y / length2
      });
    }
    return axes2;
  }
  __name(getAxes, "getAxes");
  function project(polygon2, axis2) {
    var min4 = Infinity;
    var max5 = -Infinity;
    var _iterator = _createForOfIteratorHelper(polygon2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var point = _step.value;
        var projection2 = point.x * axis2.x + point.y * axis2.y;
        min4 = Math.min(min4, projection2);
        max5 = Math.max(max5, projection2);
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    return {
      min: min4,
      max: max5
    };
  }
  __name(project, "project");
  function overlaps(proj12, proj22) {
    return !(proj12.max < proj22.min || proj22.max < proj12.min);
  }
  __name(overlaps, "overlaps");
  var axes = [].concat(_toConsumableArray(getAxes(poly1)), _toConsumableArray(getAxes(poly2)));
  var _iterator2 = _createForOfIteratorHelper(axes), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var axis = _step2.value;
      var proj1 = project(poly1, axis);
      var proj2 = project(poly2, axis);
      if (!overlaps(proj1, proj2)) {
        return false;
      }
    }
  } catch (err2) {
    _iterator2.e(err2);
  } finally {
    _iterator2.f();
  }
  return true;
}
__name(satPolygonIntersection, "satPolygonIntersection");
var pageRankDefaults = defaults$g({
  dampingFactor: 0.8,
  precision: 1e-6,
  iterations: 200,
  weight: /* @__PURE__ */ __name(function weight5(edge) {
    return 1;
  }, "weight5")
});
var elesfn$o = {
  pageRank: /* @__PURE__ */ __name(function pageRank(options2) {
    var _pageRankDefaults = pageRankDefaults(options2), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight8 = _pageRankDefaults.weight;
    var cy = this._private.cy;
    var _this$byGroup = this.byGroup(), nodes3 = _this$byGroup.nodes, edges3 = _this$byGroup.edges;
    var numNodes = nodes3.length;
    var numNodesSqd = numNodes * numNodes;
    var numEdges = edges3.length;
    var matrix = new Array(numNodesSqd);
    var columnSum = new Array(numNodes);
    var additionalProb = (1 - dampingFactor) / numNodes;
    for (var i = 0; i < numNodes; i++) {
      for (var j = 0; j < numNodes; j++) {
        var n = i * numNodes + j;
        matrix[n] = 0;
      }
      columnSum[i] = 0;
    }
    for (var _i = 0; _i < numEdges; _i++) {
      var edge = edges3[_i];
      var srcId = edge.data("source");
      var tgtId = edge.data("target");
      if (srcId === tgtId) {
        continue;
      }
      var s = nodes3.indexOfId(srcId);
      var t = nodes3.indexOfId(tgtId);
      var w = weight8(edge);
      var _n = t * numNodes + s;
      matrix[_n] += w;
      columnSum[s] += w;
    }
    var p2 = 1 / numNodes + additionalProb;
    for (var _j = 0; _j < numNodes; _j++) {
      if (columnSum[_j] === 0) {
        for (var _i2 = 0; _i2 < numNodes; _i2++) {
          var _n2 = _i2 * numNodes + _j;
          matrix[_n2] = p2;
        }
      } else {
        for (var _i3 = 0; _i3 < numNodes; _i3++) {
          var _n3 = _i3 * numNodes + _j;
          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
        }
      }
    }
    var eigenvector = new Array(numNodes);
    var temp = new Array(numNodes);
    var previous;
    for (var _i4 = 0; _i4 < numNodes; _i4++) {
      eigenvector[_i4] = 1;
    }
    for (var iter = 0; iter < iterations; iter++) {
      for (var _i5 = 0; _i5 < numNodes; _i5++) {
        temp[_i5] = 0;
      }
      for (var _i6 = 0; _i6 < numNodes; _i6++) {
        for (var _j2 = 0; _j2 < numNodes; _j2++) {
          var _n4 = _i6 * numNodes + _j2;
          temp[_i6] += matrix[_n4] * eigenvector[_j2];
        }
      }
      inPlaceSumNormalize(temp);
      previous = eigenvector;
      eigenvector = temp;
      temp = previous;
      var diff2 = 0;
      for (var _i7 = 0; _i7 < numNodes; _i7++) {
        var delta = previous[_i7] - eigenvector[_i7];
        diff2 += delta * delta;
      }
      if (diff2 < precision) {
        break;
      }
    }
    var res = {
      rank: /* @__PURE__ */ __name(function rank(node) {
        node = cy.collection(node)[0];
        return eigenvector[nodes3.indexOf(node)];
      }, "rank")
    };
    return res;
  }, "pageRank")
  // pageRank
};
var defaults$f = defaults$g({
  root: null,
  weight: /* @__PURE__ */ __name(function weight6(edge) {
    return 1;
  }, "weight6"),
  directed: false,
  alpha: 0
});
var elesfn$n = {
  degreeCentralityNormalized: /* @__PURE__ */ __name(function degreeCentralityNormalized(options2) {
    options2 = defaults$f(options2);
    var cy = this.cy();
    var nodes3 = this.nodes();
    var numNodes = nodes3.length;
    if (!options2.directed) {
      var degrees = {};
      var maxDegree = 0;
      for (var i = 0; i < numNodes; i++) {
        var node = nodes3[i];
        options2.root = node;
        var currDegree = this.degreeCentrality(options2);
        if (maxDegree < currDegree.degree) {
          maxDegree = currDegree.degree;
        }
        degrees[node.id()] = currDegree.degree;
      }
      return {
        degree: /* @__PURE__ */ __name(function degree(node2) {
          if (maxDegree === 0) {
            return 0;
          }
          if (string(node2)) {
            node2 = cy.filter(node2);
          }
          return degrees[node2.id()] / maxDegree;
        }, "degree")
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;
      for (var _i = 0; _i < numNodes; _i++) {
        var _node = nodes3[_i];
        var id2 = _node.id();
        options2.root = _node;
        var _currDegree = this.degreeCentrality(options2);
        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
        indegrees[id2] = _currDegree.indegree;
        outdegrees[id2] = _currDegree.outdegree;
      }
      return {
        indegree: /* @__PURE__ */ __name(function indegree(node2) {
          if (maxIndegree == 0) {
            return 0;
          }
          if (string(node2)) {
            node2 = cy.filter(node2);
          }
          return indegrees[node2.id()] / maxIndegree;
        }, "indegree"),
        outdegree: /* @__PURE__ */ __name(function outdegree(node2) {
          if (maxOutdegree === 0) {
            return 0;
          }
          if (string(node2)) {
            node2 = cy.filter(node2);
          }
          return outdegrees[node2.id()] / maxOutdegree;
        }, "outdegree")
      };
    }
  }, "degreeCentralityNormalized"),
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: /* @__PURE__ */ __name(function degreeCentrality(options2) {
    options2 = defaults$f(options2);
    var cy = this.cy();
    var callingEles = this;
    var _options2 = options2, root2 = _options2.root, weight8 = _options2.weight, directed = _options2.directed, alpha = _options2.alpha;
    root2 = cy.collection(root2)[0];
    if (!directed) {
      var connEdges = root2.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0;
      for (var i = 0; i < connEdges.length; i++) {
        s += weight8(connEdges[i]);
      }
      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var edges3 = root2.connectedEdges();
      var incoming = edges3.filter(function(edge) {
        return edge.target().same(root2) && callingEles.has(edge);
      });
      var outgoing = edges3.filter(function(edge) {
        return edge.source().same(root2) && callingEles.has(edge);
      });
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;
      for (var _i2 = 0; _i2 < incoming.length; _i2++) {
        s_in += weight8(incoming[_i2]);
      }
      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
        s_out += weight8(outgoing[_i3]);
      }
      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  }, "degreeCentrality")
  // degreeCentrality
};
elesfn$n.dc = elesfn$n.degreeCentrality;
elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;
var defaults$e = defaults$g({
  harmonic: true,
  weight: /* @__PURE__ */ __name(function weight7() {
    return 1;
  }, "weight7"),
  directed: false,
  root: null
});
var elesfn$m = {
  closenessCentralityNormalized: /* @__PURE__ */ __name(function closenessCentralityNormalized(options2) {
    var _defaults = defaults$e(options2), harmonic = _defaults.harmonic, weight8 = _defaults.weight, directed = _defaults.directed;
    var cy = this.cy();
    var closenesses = {};
    var maxCloseness = 0;
    var nodes3 = this.nodes();
    var fw = this.floydWarshall({
      weight: weight8,
      directed
    });
    for (var i = 0; i < nodes3.length; i++) {
      var currCloseness = 0;
      var node_i = nodes3[i];
      for (var j = 0; j < nodes3.length; j++) {
        if (i !== j) {
          var d = fw.distance(node_i, nodes3[j]);
          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }
      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }
      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }
      closenesses[node_i.id()] = currCloseness;
    }
    return {
      closeness: /* @__PURE__ */ __name(function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }
        if (string(node)) {
          node = cy.filter(node)[0].id();
        } else {
          node = node.id();
        }
        return closenesses[node] / maxCloseness;
      }, "closeness")
    };
  }, "closenessCentralityNormalized"),
  // Implemented from pseudocode from wikipedia
  closenessCentrality: /* @__PURE__ */ __name(function closenessCentrality(options2) {
    var _defaults2 = defaults$e(options2), root2 = _defaults2.root, weight8 = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;
    root2 = this.filter(root2)[0];
    var dijkstra2 = this.dijkstra({
      root: root2,
      weight: weight8,
      directed
    });
    var totalDistance = 0;
    var nodes3 = this.nodes();
    for (var i = 0; i < nodes3.length; i++) {
      var n = nodes3[i];
      if (!n.same(root2)) {
        var d = dijkstra2.distanceTo(n);
        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }
    return harmonic ? totalDistance : 1 / totalDistance;
  }, "closenessCentrality")
  // closenessCentrality
};
elesfn$m.cc = elesfn$m.closenessCentrality;
elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;
var defaults$d = defaults$g({
  weight: null,
  directed: false
});
var elesfn$l = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: /* @__PURE__ */ __name(function betweennessCentrality(options2) {
    var _defaults = defaults$d(options2), directed = _defaults.directed, weight8 = _defaults.weight;
    var weighted = weight8 != null;
    var cy = this.cy();
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max5 = 0;
    var C = {
      set: /* @__PURE__ */ __name(function set2(key2, val) {
        _C[key2] = val;
        if (val > max5) {
          max5 = val;
        }
      }, "set2"),
      get: /* @__PURE__ */ __name(function get2(key2) {
        return _C[key2];
      }, "get2")
    };
    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();
      if (directed) {
        A[vid] = v.outgoers().nodes();
      } else {
        A[vid] = v.openNeighborhood().nodes();
      }
      C.set(vid, 0);
    }
    var _loop = /* @__PURE__ */ __name(function _loop2() {
      var sid = V[s].id();
      var S = [];
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function(a, b) {
        return d[a] - d[b];
      });
      for (var _i = 0; _i < V.length; _i++) {
        var _vid = V[_i].id();
        P[_vid] = [];
        g[_vid] = 0;
        d[_vid] = Infinity;
      }
      g[sid] = 1;
      d[sid] = 0;
      Q.push(sid);
      while (!Q.empty()) {
        var _v = Q.pop();
        S.push(_v);
        if (weighted) {
          for (var j = 0; j < A[_v].length; j++) {
            var w = A[_v][j];
            var vEle = cy.getElementById(_v);
            var edge = void 0;
            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }
            var edgeWeight = weight8(edge);
            w = w.id();
            if (d[w] > d[_v] + edgeWeight) {
              d[w] = d[_v] + edgeWeight;
              if (Q.nodes.indexOf(w) < 0) {
                Q.push(w);
              } else {
                Q.updateItem(w);
              }
              g[w] = 0;
              P[w] = [];
            }
            if (d[w] == d[_v] + edgeWeight) {
              g[w] = g[w] + g[_v];
              P[w].push(_v);
            }
          }
        } else {
          for (var _j = 0; _j < A[_v].length; _j++) {
            var _w = A[_v][_j].id();
            if (d[_w] == Infinity) {
              Q.push(_w);
              d[_w] = d[_v] + 1;
            }
            if (d[_w] == d[_v] + 1) {
              g[_w] = g[_w] + g[_v];
              P[_w].push(_v);
            }
          }
        }
      }
      var e = {};
      for (var _i2 = 0; _i2 < V.length; _i2++) {
        e[V[_i2].id()] = 0;
      }
      while (S.length > 0) {
        var _w2 = S.pop();
        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
          var _v2 = P[_w2][_j2];
          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);
        }
        if (_w2 != V[s].id()) {
          C.set(_w2, C.get(_w2) + e[_w2]);
        }
      }
    }, "_loop2");
    for (var s = 0; s < V.length; s++) {
      _loop();
    }
    var ret = {
      betweenness: /* @__PURE__ */ __name(function betweenness(node) {
        var id2 = cy.collection(node).id();
        return C.get(id2);
      }, "betweenness"),
      betweennessNormalized: /* @__PURE__ */ __name(function betweennessNormalized(node) {
        if (max5 == 0) {
          return 0;
        }
        var id2 = cy.collection(node).id();
        return C.get(id2) / max5;
      }, "betweennessNormalized")
    };
    ret.betweennessNormalised = ret.betweennessNormalized;
    return ret;
  }, "betweennessCentrality")
  // betweennessCentrality
};
elesfn$l.bc = elesfn$l.betweennessCentrality;
var defaults$c = defaults$g({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [
    // attributes/features used to group nodes, ie. similarity values between nodes
    function(edge) {
      return 1;
    }
  ]
});
var setOptions$3 = /* @__PURE__ */ __name(function setOptions(options2) {
  return defaults$c(options2);
}, "setOptions");
var getSimilarity$1 = /* @__PURE__ */ __name(function getSimilarity(edge, attributes) {
  var total = 0;
  for (var i = 0; i < attributes.length; i++) {
    total += attributes[i](edge);
  }
  return total;
}, "getSimilarity");
var addLoops = /* @__PURE__ */ __name(function addLoops2(M, n, val) {
  for (var i = 0; i < n; i++) {
    M[i * n + i] = val;
  }
}, "addLoops2");
var normalize = /* @__PURE__ */ __name(function normalize2(M, n) {
  var sum;
  for (var col = 0; col < n; col++) {
    sum = 0;
    for (var row = 0; row < n; row++) {
      sum += M[row * n + col];
    }
    for (var _row = 0; _row < n; _row++) {
      M[_row * n + col] = M[_row * n + col] / sum;
    }
  }
}, "normalize2");
var mmult = /* @__PURE__ */ __name(function mmult2(A, B, n) {
  var C = new Array(n * n);
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      C[i * n + j] = 0;
    }
    for (var k = 0; k < n; k++) {
      for (var _j = 0; _j < n; _j++) {
        C[i * n + _j] += A[i * n + k] * B[k * n + _j];
      }
    }
  }
  return C;
}, "mmult2");
var expand = /* @__PURE__ */ __name(function expand2(M, n, expandFactor) {
  var _M = M.slice(0);
  for (var p2 = 1; p2 < expandFactor; p2++) {
    M = mmult(M, _M, n);
  }
  return M;
}, "expand2");
var inflate = /* @__PURE__ */ __name(function inflate2(M, n, inflateFactor) {
  var _M = new Array(n * n);
  for (var i = 0; i < n * n; i++) {
    _M[i] = Math.pow(M[i], inflateFactor);
  }
  normalize(_M, n);
  return _M;
}, "inflate2");
var hasConverged = /* @__PURE__ */ __name(function hasConverged2(M, _M, n2, roundFactor) {
  for (var i = 0; i < n2; i++) {
    var v12 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
    var v22 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
    if (v12 !== v22) {
      return false;
    }
  }
  return true;
}, "hasConverged2");
var assign$2 = /* @__PURE__ */ __name(function assign2(M, n, nodes3, cy) {
  var clusters = [];
  for (var i = 0; i < n; i++) {
    var cluster = [];
    for (var j = 0; j < n; j++) {
      if (Math.round(M[i * n + j] * 1e3) / 1e3 > 0) {
        cluster.push(nodes3[j]);
      }
    }
    if (cluster.length !== 0) {
      clusters.push(cy.collection(cluster));
    }
  }
  return clusters;
}, "assign");
var isDuplicate = /* @__PURE__ */ __name(function isDuplicate2(c1, c2) {
  for (var i = 0; i < c1.length; i++) {
    if (!c2[i] || c1[i].id() !== c2[i].id()) {
      return false;
    }
  }
  return true;
}, "isDuplicate2");
var removeDuplicates = /* @__PURE__ */ __name(function removeDuplicates2(clusters) {
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j < clusters.length; j++) {
      if (i != j && isDuplicate(clusters[i], clusters[j])) {
        clusters.splice(j, 1);
      }
    }
  }
  return clusters;
}, "removeDuplicates2");
var markovClustering = /* @__PURE__ */ __name(function markovClustering2(options2) {
  var nodes3 = this.nodes();
  var edges3 = this.edges();
  var cy = this.cy();
  var opts = setOptions$3(options2);
  var id2position = {};
  for (var i = 0; i < nodes3.length; i++) {
    id2position[nodes3[i].id()] = i;
  }
  var n = nodes3.length, n2 = n * n;
  var M = new Array(n2), _M;
  for (var _i = 0; _i < n2; _i++) {
    M[_i] = 0;
  }
  for (var e = 0; e < edges3.length; e++) {
    var edge = edges3[e];
    var _i2 = id2position[edge.source().id()];
    var j = id2position[edge.target().id()];
    var sim = getSimilarity$1(edge, opts.attributes);
    M[_i2 * n + j] += sim;
    M[j * n + _i2] += sim;
  }
  addLoops(M, n, opts.multFactor);
  normalize(M, n);
  var isStillMoving = true;
  var iterations = 0;
  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false;
    _M = expand(M, n, opts.expandFactor);
    M = inflate(_M, n, opts.inflateFactor);
    if (!hasConverged(M, _M, n2, 4)) {
      isStillMoving = true;
    }
    iterations++;
  }
  var clusters = assign$2(M, n, nodes3, cy);
  clusters = removeDuplicates(clusters);
  return clusters;
}, "markovClustering2");
var markovClustering$1 = {
  markovClustering,
  mcl: markovClustering
};
var identity$1 = /* @__PURE__ */ __name(function identity(x2) {
  return x2;
}, "identity");
var absDiff = /* @__PURE__ */ __name(function absDiff2(p2, q) {
  return Math.abs(q - p2);
}, "absDiff2");
var addAbsDiff = /* @__PURE__ */ __name(function addAbsDiff2(total, p2, q) {
  return total + absDiff(p2, q);
}, "addAbsDiff2");
var addSquaredDiff = /* @__PURE__ */ __name(function addSquaredDiff2(total, p2, q) {
  return total + Math.pow(q - p2, 2);
}, "addSquaredDiff2");
var sqrt = /* @__PURE__ */ __name(function sqrt3(x2) {
  return Math.sqrt(x2);
}, "sqrt3");
var maxAbsDiff = /* @__PURE__ */ __name(function maxAbsDiff2(currentMax, p2, q) {
  return Math.max(currentMax, absDiff(p2, q));
}, "maxAbsDiff2");
var getDistance = /* @__PURE__ */ __name(function getDistance2(length2, getP, getQ, init2, visit) {
  var post = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : identity$1;
  var ret = init2;
  var p2, q;
  for (var dim = 0; dim < length2; dim++) {
    p2 = getP(dim);
    q = getQ(dim);
    ret = visit(ret, p2, q);
  }
  return post(ret);
}, "getDistance2");
var distances = {
  euclidean: /* @__PURE__ */ __name(function euclidean(length2, getP, getQ) {
    if (length2 >= 2) {
      return getDistance(length2, getP, getQ, 0, addSquaredDiff, sqrt);
    } else {
      return getDistance(length2, getP, getQ, 0, addAbsDiff);
    }
  }, "euclidean"),
  squaredEuclidean: /* @__PURE__ */ __name(function squaredEuclidean(length2, getP, getQ) {
    return getDistance(length2, getP, getQ, 0, addSquaredDiff);
  }, "squaredEuclidean"),
  manhattan: /* @__PURE__ */ __name(function manhattan(length2, getP, getQ) {
    return getDistance(length2, getP, getQ, 0, addAbsDiff);
  }, "manhattan"),
  max: /* @__PURE__ */ __name(function max3(length2, getP, getQ) {
    return getDistance(length2, getP, getQ, -Infinity, maxAbsDiff);
  }, "max3")
};
distances["squared-euclidean"] = distances["squaredEuclidean"];
distances["squaredeuclidean"] = distances["squaredEuclidean"];
function clusteringDistance(method, length2, getP, getQ, nodeP, nodeQ) {
  var impl2;
  if (fn$6(method)) {
    impl2 = method;
  } else {
    impl2 = distances[method] || distances.euclidean;
  }
  if (length2 === 0 && fn$6(method)) {
    return impl2(nodeP, nodeQ);
  } else {
    return impl2(length2, getP, getQ, nodeP, nodeQ);
  }
}
__name(clusteringDistance, "clusteringDistance");
var defaults$b = defaults$g({
  k: 2,
  m: 2,
  sensitivityThreshold: 1e-4,
  distance: "euclidean",
  maxIterations: 10,
  attributes: [],
  testMode: false,
  testCentroids: null
});
var setOptions$2 = /* @__PURE__ */ __name(function setOptions2(options2) {
  return defaults$b(options2);
}, "setOptions2");
var getDist = /* @__PURE__ */ __name(function getDist2(type, node, centroid, attributes, mode) {
  var noNodeP = mode !== "kMedoids";
  var getP = noNodeP ? function(i) {
    return centroid[i];
  } : function(i) {
    return attributes[i](centroid);
  };
  var getQ = /* @__PURE__ */ __name(function getQ2(i) {
    return attributes[i](node);
  }, "getQ2");
  var nodeP = centroid;
  var nodeQ = node;
  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
}, "getDist2");
var randomCentroids = /* @__PURE__ */ __name(function randomCentroids2(nodes3, k, attributes) {
  var ndim = attributes.length;
  var min4 = new Array(ndim);
  var max5 = new Array(ndim);
  var centroids = new Array(k);
  var centroid = null;
  for (var i = 0; i < ndim; i++) {
    min4[i] = nodes3.min(attributes[i]).value;
    max5[i] = nodes3.max(attributes[i]).value;
  }
  for (var c = 0; c < k; c++) {
    centroid = [];
    for (var _i = 0; _i < ndim; _i++) {
      centroid[_i] = Math.random() * (max5[_i] - min4[_i]) + min4[_i];
    }
    centroids[c] = centroid;
  }
  return centroids;
}, "randomCentroids2");
var classify = /* @__PURE__ */ __name(function classify2(node, centroids, distance, attributes, type) {
  var min4 = Infinity;
  var index2 = 0;
  for (var i = 0; i < centroids.length; i++) {
    var dist3 = getDist(distance, node, centroids[i], attributes, type);
    if (dist3 < min4) {
      min4 = dist3;
      index2 = i;
    }
  }
  return index2;
}, "classify2");
var buildCluster = /* @__PURE__ */ __name(function buildCluster2(centroid, nodes3, assignment) {
  var cluster = [];
  var node = null;
  for (var n = 0; n < nodes3.length; n++) {
    node = nodes3[n];
    if (assignment[node.id()] === centroid) {
      cluster.push(node);
    }
  }
  return cluster;
}, "buildCluster2");
var haveValuesConverged = /* @__PURE__ */ __name(function haveValuesConverged2(v12, v22, sensitivityThreshold) {
  return Math.abs(v22 - v12) <= sensitivityThreshold;
}, "haveValuesConverged2");
var haveMatricesConverged = /* @__PURE__ */ __name(function haveMatricesConverged2(v12, v22, sensitivityThreshold) {
  for (var i = 0; i < v12.length; i++) {
    for (var j = 0; j < v12[i].length; j++) {
      var diff2 = Math.abs(v12[i][j] - v22[i][j]);
      if (diff2 > sensitivityThreshold) {
        return false;
      }
    }
  }
  return true;
}, "haveMatricesConverged2");
var seenBefore = /* @__PURE__ */ __name(function seenBefore2(node, medoids, n) {
  for (var i = 0; i < n; i++) {
    if (node === medoids[i]) return true;
  }
  return false;
}, "seenBefore2");
var randomMedoids = /* @__PURE__ */ __name(function randomMedoids2(nodes3, k) {
  var medoids = new Array(k);
  if (nodes3.length < 50) {
    for (var i = 0; i < k; i++) {
      var node = nodes3[Math.floor(Math.random() * nodes3.length)];
      while (seenBefore(node, medoids, i)) {
        node = nodes3[Math.floor(Math.random() * nodes3.length)];
      }
      medoids[i] = node;
    }
  } else {
    for (var _i2 = 0; _i2 < k; _i2++) {
      medoids[_i2] = nodes3[Math.floor(Math.random() * nodes3.length)];
    }
  }
  return medoids;
}, "randomMedoids2");
var findCost = /* @__PURE__ */ __name(function findCost2(potentialNewMedoid, cluster, attributes) {
  var cost = 0;
  for (var n = 0; n < cluster.length; n++) {
    cost += getDist("manhattan", cluster[n], potentialNewMedoid, attributes, "kMedoids");
  }
  return cost;
}, "findCost2");
var kMeans = /* @__PURE__ */ __name(function kMeans2(options2) {
  var cy = this.cy();
  var nodes3 = this.nodes();
  var node = null;
  var opts = setOptions$2(options2);
  var clusters = new Array(opts.k);
  var assignment = {};
  var centroids;
  if (opts.testMode) {
    if (typeof opts.testCentroids === "number") {
      opts.testCentroids;
      centroids = randomCentroids(nodes3, opts.k, opts.attributes);
    } else if (_typeof(opts.testCentroids) === "object") {
      centroids = opts.testCentroids;
    } else {
      centroids = randomCentroids(nodes3, opts.k, opts.attributes);
    }
  } else {
    centroids = randomCentroids(nodes3, opts.k, opts.attributes);
  }
  var isStillMoving = true;
  var iterations = 0;
  while (isStillMoving && iterations < opts.maxIterations) {
    for (var n = 0; n < nodes3.length; n++) {
      node = nodes3[n];
      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, "kMeans");
    }
    isStillMoving = false;
    for (var c = 0; c < opts.k; c++) {
      var cluster = buildCluster(c, nodes3, assignment);
      if (cluster.length === 0) {
        continue;
      }
      var ndim = opts.attributes.length;
      var centroid = centroids[c];
      var newCentroid = new Array(ndim);
      var sum = new Array(ndim);
      for (var d = 0; d < ndim; d++) {
        sum[d] = 0;
        for (var i = 0; i < cluster.length; i++) {
          node = cluster[i];
          sum[d] += opts.attributes[d](node);
        }
        newCentroid[d] = sum[d] / cluster.length;
        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
          isStillMoving = true;
        }
      }
      centroids[c] = newCentroid;
      clusters[c] = cy.collection(cluster);
    }
    iterations++;
  }
  return clusters;
}, "kMeans2");
var kMedoids = /* @__PURE__ */ __name(function kMedoids2(options2) {
  var cy = this.cy();
  var nodes3 = this.nodes();
  var node = null;
  var opts = setOptions$2(options2);
  var clusters = new Array(opts.k);
  var medoids;
  var assignment = {};
  var curCost;
  var minCosts = new Array(opts.k);
  if (opts.testMode) {
    if (typeof opts.testCentroids === "number") ;
    else if (_typeof(opts.testCentroids) === "object") {
      medoids = opts.testCentroids;
    } else {
      medoids = randomMedoids(nodes3, opts.k);
    }
  } else {
    medoids = randomMedoids(nodes3, opts.k);
  }
  var isStillMoving = true;
  var iterations = 0;
  while (isStillMoving && iterations < opts.maxIterations) {
    for (var n = 0; n < nodes3.length; n++) {
      node = nodes3[n];
      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, "kMedoids");
    }
    isStillMoving = false;
    for (var m = 0; m < medoids.length; m++) {
      var cluster = buildCluster(m, nodes3, assignment);
      if (cluster.length === 0) {
        continue;
      }
      minCosts[m] = findCost(medoids[m], cluster, opts.attributes);
      for (var _n = 0; _n < cluster.length; _n++) {
        curCost = findCost(cluster[_n], cluster, opts.attributes);
        if (curCost < minCosts[m]) {
          minCosts[m] = curCost;
          medoids[m] = cluster[_n];
          isStillMoving = true;
        }
      }
      clusters[m] = cy.collection(cluster);
    }
    iterations++;
  }
  return clusters;
}, "kMedoids2");
var updateCentroids = /* @__PURE__ */ __name(function updateCentroids2(centroids, nodes3, U, weight8, opts) {
  var numerator, denominator;
  for (var n = 0; n < nodes3.length; n++) {
    for (var c = 0; c < centroids.length; c++) {
      weight8[n][c] = Math.pow(U[n][c], opts.m);
    }
  }
  for (var _c2 = 0; _c2 < centroids.length; _c2++) {
    for (var dim = 0; dim < opts.attributes.length; dim++) {
      numerator = 0;
      denominator = 0;
      for (var _n2 = 0; _n2 < nodes3.length; _n2++) {
        numerator += weight8[_n2][_c2] * opts.attributes[dim](nodes3[_n2]);
        denominator += weight8[_n2][_c2];
      }
      centroids[_c2][dim] = numerator / denominator;
    }
  }
}, "updateCentroids2");
var updateMembership = /* @__PURE__ */ __name(function updateMembership2(U, _U, centroids, nodes3, opts) {
  for (var i = 0; i < U.length; i++) {
    _U[i] = U[i].slice();
  }
  var sum, numerator, denominator;
  var pow = 2 / (opts.m - 1);
  for (var c = 0; c < centroids.length; c++) {
    for (var n = 0; n < nodes3.length; n++) {
      sum = 0;
      for (var k = 0; k < centroids.length; k++) {
        numerator = getDist(opts.distance, nodes3[n], centroids[c], opts.attributes, "cmeans");
        denominator = getDist(opts.distance, nodes3[n], centroids[k], opts.attributes, "cmeans");
        sum += Math.pow(numerator / denominator, pow);
      }
      U[n][c] = 1 / sum;
    }
  }
}, "updateMembership2");
var assign$1 = /* @__PURE__ */ __name(function assign22(nodes3, U, opts, cy) {
  var clusters = new Array(opts.k);
  for (var c = 0; c < clusters.length; c++) {
    clusters[c] = [];
  }
  var max5;
  var index2;
  for (var n = 0; n < U.length; n++) {
    max5 = -Infinity;
    index2 = -1;
    for (var _c2 = 0; _c2 < U[0].length; _c2++) {
      if (U[n][_c2] > max5) {
        max5 = U[n][_c2];
        index2 = _c2;
      }
    }
    clusters[index2].push(nodes3[n]);
  }
  for (var _c3 = 0; _c3 < clusters.length; _c3++) {
    clusters[_c3] = cy.collection(clusters[_c3]);
  }
  return clusters;
}, "assign2");
var fuzzyCMeans = /* @__PURE__ */ __name(function fuzzyCMeans2(options2) {
  var cy = this.cy();
  var nodes3 = this.nodes();
  var opts = setOptions$2(options2);
  var clusters;
  var centroids;
  var U;
  var _U;
  var weight8;
  _U = new Array(nodes3.length);
  for (var i = 0; i < nodes3.length; i++) {
    _U[i] = new Array(opts.k);
  }
  U = new Array(nodes3.length);
  for (var _i3 = 0; _i3 < nodes3.length; _i3++) {
    U[_i3] = new Array(opts.k);
  }
  for (var _i4 = 0; _i4 < nodes3.length; _i4++) {
    var total = 0;
    for (var j = 0; j < opts.k; j++) {
      U[_i4][j] = Math.random();
      total += U[_i4][j];
    }
    for (var _j = 0; _j < opts.k; _j++) {
      U[_i4][_j] = U[_i4][_j] / total;
    }
  }
  centroids = new Array(opts.k);
  for (var _i5 = 0; _i5 < opts.k; _i5++) {
    centroids[_i5] = new Array(opts.attributes.length);
  }
  weight8 = new Array(nodes3.length);
  for (var _i6 = 0; _i6 < nodes3.length; _i6++) {
    weight8[_i6] = new Array(opts.k);
  }
  var isStillMoving = true;
  var iterations = 0;
  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false;
    updateCentroids(centroids, nodes3, U, weight8, opts);
    updateMembership(U, _U, centroids, nodes3, opts);
    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
      isStillMoving = true;
    }
    iterations++;
  }
  clusters = assign$1(nodes3, U, opts, cy);
  return {
    clusters,
    degreeOfMembership: U
  };
}, "fuzzyCMeans2");
var kClustering = {
  kMeans,
  kMedoids,
  fuzzyCMeans,
  fcm: fuzzyCMeans
};
var defaults$a = defaults$g({
  distance: "euclidean",
  // distance metric to compare nodes
  linkage: "min",
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: "threshold",
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: Infinity,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: false,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: []
  // array of attr functions
});
var linkageAliases = {
  "single": "min",
  "complete": "max"
};
var setOptions$1 = /* @__PURE__ */ __name(function setOptions3(options2) {
  var opts = defaults$a(options2);
  var preferredAlias = linkageAliases[opts.linkage];
  if (preferredAlias != null) {
    opts.linkage = preferredAlias;
  }
  return opts;
}, "setOptions3");
var mergeClosest = /* @__PURE__ */ __name(function mergeClosest2(clusters, index2, dists, mins, opts) {
  var minKey = 0;
  var min4 = Infinity;
  var dist3;
  var attrs = opts.attributes;
  var getDist3 = /* @__PURE__ */ __name(function getDist4(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function(i2) {
      return attrs[i2](n1);
    }, function(i2) {
      return attrs[i2](n2);
    }, n1, n2);
  }, "getDist4");
  for (var i = 0; i < clusters.length; i++) {
    var key2 = clusters[i].key;
    var _dist = dists[key2][mins[key2]];
    if (_dist < min4) {
      minKey = key2;
      min4 = _dist;
    }
  }
  if (opts.mode === "threshold" && min4 >= opts.threshold || opts.mode === "dendrogram" && clusters.length === 1) {
    return false;
  }
  var c1 = index2[minKey];
  var c2 = index2[mins[minKey]];
  var merged;
  if (opts.mode === "dendrogram") {
    merged = {
      left: c1,
      right: c2,
      key: c1.key
    };
  } else {
    merged = {
      value: c1.value.concat(c2.value),
      key: c1.key
    };
  }
  clusters[c1.index] = merged;
  clusters.splice(c2.index, 1);
  index2[c1.key] = merged;
  for (var _i = 0; _i < clusters.length; _i++) {
    var cur = clusters[_i];
    if (c1.key === cur.key) {
      dist3 = Infinity;
    } else if (opts.linkage === "min") {
      dist3 = dists[c1.key][cur.key];
      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
        dist3 = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === "max") {
      dist3 = dists[c1.key][cur.key];
      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
        dist3 = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === "mean") {
      dist3 = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
    } else {
      if (opts.mode === "dendrogram") dist3 = getDist3(cur.value, c1.value);
      else dist3 = getDist3(cur.value[0], c1.value[0]);
    }
    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist3;
  }
  for (var _i2 = 0; _i2 < clusters.length; _i2++) {
    var key1 = clusters[_i2].key;
    if (mins[key1] === c1.key || mins[key1] === c2.key) {
      var _min = key1;
      for (var j = 0; j < clusters.length; j++) {
        var key22 = clusters[j].key;
        if (dists[key1][key22] < dists[key1][_min]) {
          _min = key22;
        }
      }
      mins[key1] = _min;
    }
    clusters[_i2].index = _i2;
  }
  c1.key = c2.key = c1.index = c2.index = null;
  return true;
}, "mergeClosest2");
var _getAllChildren = /* @__PURE__ */ __name(function getAllChildren(root2, arr, cy) {
  if (!root2) return;
  if (root2.value) {
    arr.push(root2.value);
  } else {
    if (root2.left) _getAllChildren(root2.left, arr);
    if (root2.right) _getAllChildren(root2.right, arr);
  }
}, "getAllChildren");
var _buildDendrogram = /* @__PURE__ */ __name(function buildDendrogram(root2, cy) {
  if (!root2) return "";
  if (root2.left && root2.right) {
    var leftStr = _buildDendrogram(root2.left, cy);
    var rightStr = _buildDendrogram(root2.right, cy);
    var node = cy.add({
      group: "nodes",
      data: {
        id: leftStr + "," + rightStr
      }
    });
    cy.add({
      group: "edges",
      data: {
        source: leftStr,
        target: node.id()
      }
    });
    cy.add({
      group: "edges",
      data: {
        source: rightStr,
        target: node.id()
      }
    });
    return node.id();
  } else if (root2.value) {
    return root2.value.id();
  }
}, "buildDendrogram");
var _buildClustersFromTree = /* @__PURE__ */ __name(function buildClustersFromTree(root2, k, cy) {
  if (!root2) return [];
  var left = [], right = [], leaves = [];
  if (k === 0) {
    if (root2.left) _getAllChildren(root2.left, left);
    if (root2.right) _getAllChildren(root2.right, right);
    leaves = left.concat(right);
    return [cy.collection(leaves)];
  } else if (k === 1) {
    if (root2.value) {
      return [cy.collection(root2.value)];
    } else {
      if (root2.left) _getAllChildren(root2.left, left);
      if (root2.right) _getAllChildren(root2.right, right);
      return [cy.collection(left), cy.collection(right)];
    }
  } else {
    if (root2.value) {
      return [cy.collection(root2.value)];
    } else {
      if (root2.left) left = _buildClustersFromTree(root2.left, k - 1, cy);
      if (root2.right) right = _buildClustersFromTree(root2.right, k - 1, cy);
      return left.concat(right);
    }
  }
}, "buildClustersFromTree");
var hierarchicalClustering = /* @__PURE__ */ __name(function hierarchicalClustering2(options2) {
  var cy = this.cy();
  var nodes3 = this.nodes();
  var opts = setOptions$1(options2);
  var attrs = opts.attributes;
  var getDist3 = /* @__PURE__ */ __name(function getDist4(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function(i2) {
      return attrs[i2](n1);
    }, function(i2) {
      return attrs[i2](n2);
    }, n1, n2);
  }, "getDist4");
  var clusters = [];
  var dists = [];
  var mins = [];
  var index2 = [];
  for (var n = 0; n < nodes3.length; n++) {
    var cluster = {
      value: opts.mode === "dendrogram" ? nodes3[n] : [nodes3[n]],
      key: n,
      index: n
    };
    clusters[n] = cluster;
    index2[n] = cluster;
    dists[n] = [];
    mins[n] = 0;
  }
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j <= i; j++) {
      var dist3 = void 0;
      if (opts.mode === "dendrogram") {
        dist3 = i === j ? Infinity : getDist3(clusters[i].value, clusters[j].value);
      } else {
        dist3 = i === j ? Infinity : getDist3(clusters[i].value[0], clusters[j].value[0]);
      }
      dists[i][j] = dist3;
      dists[j][i] = dist3;
      if (dist3 < dists[i][mins[i]]) {
        mins[i] = j;
      }
    }
  }
  var merged = mergeClosest(clusters, index2, dists, mins, opts);
  while (merged) {
    merged = mergeClosest(clusters, index2, dists, mins, opts);
  }
  var retClusters;
  if (opts.mode === "dendrogram") {
    retClusters = _buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
    if (opts.addDendrogram) _buildDendrogram(clusters[0], cy);
  } else {
    retClusters = new Array(clusters.length);
    clusters.forEach(function(cluster2, i2) {
      cluster2.key = cluster2.index = null;
      retClusters[i2] = cy.collection(cluster2.value);
    });
  }
  return retClusters;
}, "hierarchicalClustering2");
var hierarchicalClustering$1 = {
  hierarchicalClustering,
  hca: hierarchicalClustering
};
var defaults$9 = defaults$g({
  distance: "euclidean",
  // distance metric to compare attributes between two nodes
  preference: "median",
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1e3,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [
    // functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
});
var setOptions4 = /* @__PURE__ */ __name(function setOptions5(options2) {
  var dmp = options2.damping;
  var pref = options2.preference;
  if (!(0.5 <= dmp && dmp < 1)) {
    error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
  }
  var validPrefs = ["median", "mean", "min", "max"];
  if (!(validPrefs.some(function(v) {
    return v === pref;
  }) || number$1(pref))) {
    error("Preference must be one of [".concat(validPrefs.map(function(p2) {
      return "'".concat(p2, "'");
    }).join(", "), "] or a number.  Got: ").concat(pref));
  }
  return defaults$9(options2);
}, "setOptions5");
var getSimilarity2 = /* @__PURE__ */ __name(function getSimilarity3(type, n1, n2, attributes) {
  var attr2 = /* @__PURE__ */ __name(function attr22(n, i) {
    return attributes[i](n);
  }, "attr2");
  return -clusteringDistance(type, attributes.length, function(i) {
    return attr2(n1, i);
  }, function(i) {
    return attr2(n2, i);
  }, n1, n2);
}, "getSimilarity3");
var getPreference = /* @__PURE__ */ __name(function getPreference2(S, preference) {
  var p2 = null;
  if (preference === "median") {
    p2 = median(S);
  } else if (preference === "mean") {
    p2 = mean(S);
  } else if (preference === "min") {
    p2 = min(S);
  } else if (preference === "max") {
    p2 = max(S);
  } else {
    p2 = preference;
  }
  return p2;
}, "getPreference2");
var findExemplars = /* @__PURE__ */ __name(function findExemplars2(n, R, A) {
  var indices = [];
  for (var i = 0; i < n; i++) {
    if (R[i * n + i] + A[i * n + i] > 0) {
      indices.push(i);
    }
  }
  return indices;
}, "findExemplars2");
var assignClusters = /* @__PURE__ */ __name(function assignClusters2(n, S, exemplars) {
  var clusters = [];
  for (var i = 0; i < n; i++) {
    var index2 = -1;
    var max5 = -Infinity;
    for (var ei = 0; ei < exemplars.length; ei++) {
      var e = exemplars[ei];
      if (S[i * n + e] > max5) {
        index2 = e;
        max5 = S[i * n + e];
      }
    }
    if (index2 > 0) {
      clusters.push(index2);
    }
  }
  for (var _ei = 0; _ei < exemplars.length; _ei++) {
    clusters[exemplars[_ei]] = exemplars[_ei];
  }
  return clusters;
}, "assignClusters2");
var assign3 = /* @__PURE__ */ __name(function assign4(n, S, exemplars) {
  var clusters = assignClusters(n, S, exemplars);
  for (var ei = 0; ei < exemplars.length; ei++) {
    var ii = [];
    for (var c = 0; c < clusters.length; c++) {
      if (clusters[c] === exemplars[ei]) {
        ii.push(c);
      }
    }
    var maxI = -1;
    var maxSum = -Infinity;
    for (var i = 0; i < ii.length; i++) {
      var sum = 0;
      for (var j = 0; j < ii.length; j++) {
        sum += S[ii[j] * n + ii[i]];
      }
      if (sum > maxSum) {
        maxI = i;
        maxSum = sum;
      }
    }
    exemplars[ei] = ii[maxI];
  }
  clusters = assignClusters(n, S, exemplars);
  return clusters;
}, "assign4");
var affinityPropagation = /* @__PURE__ */ __name(function affinityPropagation2(options2) {
  var cy = this.cy();
  var nodes3 = this.nodes();
  var opts = setOptions4(options2);
  var id2position = {};
  for (var i = 0; i < nodes3.length; i++) {
    id2position[nodes3[i].id()] = i;
  }
  var n;
  var n2;
  var S;
  var p2;
  var R;
  var A;
  n = nodes3.length;
  n2 = n * n;
  S = new Array(n2);
  for (var _i = 0; _i < n2; _i++) {
    S[_i] = -Infinity;
  }
  for (var _i2 = 0; _i2 < n; _i2++) {
    for (var j = 0; j < n; j++) {
      if (_i2 !== j) {
        S[_i2 * n + j] = getSimilarity2(opts.distance, nodes3[_i2], nodes3[j], opts.attributes);
      }
    }
  }
  p2 = getPreference(S, opts.preference);
  for (var _i3 = 0; _i3 < n; _i3++) {
    S[_i3 * n + _i3] = p2;
  }
  R = new Array(n2);
  for (var _i4 = 0; _i4 < n2; _i4++) {
    R[_i4] = 0;
  }
  A = new Array(n2);
  for (var _i5 = 0; _i5 < n2; _i5++) {
    A[_i5] = 0;
  }
  var old = new Array(n);
  var Rp = new Array(n);
  var se = new Array(n);
  for (var _i6 = 0; _i6 < n; _i6++) {
    old[_i6] = 0;
    Rp[_i6] = 0;
    se[_i6] = 0;
  }
  var e = new Array(n * opts.minIterations);
  for (var _i7 = 0; _i7 < e.length; _i7++) {
    e[_i7] = 0;
  }
  var iter;
  for (iter = 0; iter < opts.maxIterations; iter++) {
    for (var _i8 = 0; _i8 < n; _i8++) {
      var max5 = -Infinity, max22 = -Infinity, maxI = -1, AS = 0;
      for (var _j = 0; _j < n; _j++) {
        old[_j] = R[_i8 * n + _j];
        AS = A[_i8 * n + _j] + S[_i8 * n + _j];
        if (AS >= max5) {
          max22 = max5;
          max5 = AS;
          maxI = _j;
        } else if (AS > max22) {
          max22 = AS;
        }
      }
      for (var _j2 = 0; _j2 < n; _j2++) {
        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max5) + opts.damping * old[_j2];
      }
      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max22) + opts.damping * old[maxI];
    }
    for (var _i9 = 0; _i9 < n; _i9++) {
      var sum = 0;
      for (var _j3 = 0; _j3 < n; _j3++) {
        old[_j3] = A[_j3 * n + _i9];
        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
        sum += Rp[_j3];
      }
      sum -= Rp[_i9];
      Rp[_i9] = R[_i9 * n + _i9];
      sum += Rp[_i9];
      for (var _j4 = 0; _j4 < n; _j4++) {
        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
      }
      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
    }
    var K2 = 0;
    for (var _i10 = 0; _i10 < n; _i10++) {
      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
      e[iter % opts.minIterations * n + _i10] = E;
      K2 += E;
    }
    if (K2 > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
      var _sum = 0;
      for (var _i11 = 0; _i11 < n; _i11++) {
        se[_i11] = 0;
        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
          se[_i11] += e[_j5 * n + _i11];
        }
        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
          _sum++;
        }
      }
      if (_sum === n) {
        break;
      }
    }
  }
  var exemplarsIndices = findExemplars(n, R, A);
  var clusterIndices = assign3(n, S, exemplarsIndices);
  var clusters = {};
  for (var c = 0; c < exemplarsIndices.length; c++) {
    clusters[exemplarsIndices[c]] = [];
  }
  for (var _i12 = 0; _i12 < nodes3.length; _i12++) {
    var pos = id2position[nodes3[_i12].id()];
    var clusterIndex = clusterIndices[pos];
    if (clusterIndex != null) {
      clusters[clusterIndex].push(nodes3[_i12]);
    }
  }
  var retClusters = new Array(exemplarsIndices.length);
  for (var _c2 = 0; _c2 < exemplarsIndices.length; _c2++) {
    retClusters[_c2] = cy.collection(clusters[exemplarsIndices[_c2]]);
  }
  return retClusters;
}, "affinityPropagation2");
var affinityPropagation$1 = {
  affinityPropagation,
  ap: affinityPropagation
};
var hierholzerDefaults = defaults$g({
  root: void 0,
  directed: false
});
var elesfn$k = {
  hierholzer: /* @__PURE__ */ __name(function hierholzer(options2) {
    if (!plainObject(options2)) {
      var args2 = arguments;
      options2 = {
        root: args2[0],
        directed: args2[1]
      };
    }
    var _hierholzerDefaults = hierholzerDefaults(options2), root2 = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;
    var eles = this;
    var dflag = false;
    var oddIn;
    var oddOut;
    var startVertex;
    if (root2) startVertex = string(root2) ? this.filter(root2)[0].id() : root2[0].id();
    var nodes3 = {};
    var edges3 = {};
    if (directed) {
      eles.forEach(function(ele) {
        var id2 = ele.id();
        if (ele.isNode()) {
          var ind = ele.indegree(true);
          var outd = ele.outdegree(true);
          var d1 = ind - outd;
          var d2 = outd - ind;
          if (d1 == 1) {
            if (oddIn) dflag = true;
            else oddIn = id2;
          } else if (d2 == 1) {
            if (oddOut) dflag = true;
            else oddOut = id2;
          } else if (d2 > 1 || d1 > 1) {
            dflag = true;
          }
          nodes3[id2] = [];
          ele.outgoers().forEach(function(e) {
            if (e.isEdge()) nodes3[id2].push(e.id());
          });
        } else {
          edges3[id2] = [void 0, ele.target().id()];
        }
      });
    } else {
      eles.forEach(function(ele) {
        var id2 = ele.id();
        if (ele.isNode()) {
          var d2 = ele.degree(true);
          if (d2 % 2) {
            if (!oddIn) oddIn = id2;
            else if (!oddOut) oddOut = id2;
            else dflag = true;
          }
          nodes3[id2] = [];
          ele.connectedEdges().forEach(function(e) {
            return nodes3[id2].push(e.id());
          });
        } else {
          edges3[id2] = [ele.source().id(), ele.target().id()];
        }
      });
    }
    var result = {
      found: false,
      trail: void 0
    };
    if (dflag) return result;
    else if (oddOut && oddIn) {
      if (directed) {
        if (startVertex && oddOut != startVertex) {
          return result;
        }
        startVertex = oddOut;
      } else {
        if (startVertex && oddOut != startVertex && oddIn != startVertex) {
          return result;
        } else if (!startVertex) {
          startVertex = oddOut;
        }
      }
    } else {
      if (!startVertex) startVertex = eles[0].id();
    }
    var walk = /* @__PURE__ */ __name(function walk2(v) {
      var currentNode = v;
      var subtour2 = [v];
      var adj, adjTail, adjHead;
      while (nodes3[currentNode].length) {
        adj = nodes3[currentNode].shift();
        adjTail = edges3[adj][0];
        adjHead = edges3[adj][1];
        if (currentNode != adjHead) {
          nodes3[adjHead] = nodes3[adjHead].filter(function(e) {
            return e != adj;
          });
          currentNode = adjHead;
        } else if (!directed && currentNode != adjTail) {
          nodes3[adjTail] = nodes3[adjTail].filter(function(e) {
            return e != adj;
          });
          currentNode = adjTail;
        }
        subtour2.unshift(adj);
        subtour2.unshift(currentNode);
      }
      return subtour2;
    }, "walk2");
    var trail = [];
    var subtour = [];
    subtour = walk(startVertex);
    while (subtour.length != 1) {
      if (nodes3[subtour[0]].length == 0) {
        trail.unshift(eles.getElementById(subtour.shift()));
        trail.unshift(eles.getElementById(subtour.shift()));
      } else {
        subtour = walk(subtour.shift()).concat(subtour);
      }
    }
    trail.unshift(eles.getElementById(subtour.shift()));
    for (var d in nodes3) {
      if (nodes3[d].length) {
        return result;
      }
    }
    result.found = true;
    result.trail = this.spawn(trail, true);
    return result;
  }, "hierholzer")
};
var hopcroftTarjanBiconnected = /* @__PURE__ */ __name(function hopcroftTarjanBiconnected2() {
  var eles = this;
  var nodes3 = {};
  var id2 = 0;
  var edgeCount = 0;
  var components2 = [];
  var stack2 = [];
  var visitedEdges = {};
  var buildComponent = /* @__PURE__ */ __name(function buildComponent2(x2, y2) {
    var i = stack2.length - 1;
    var cutset = [];
    var component22 = eles.spawn();
    while (stack2[i].x != x2 || stack2[i].y != y2) {
      cutset.push(stack2.pop().edge);
      i--;
    }
    cutset.push(stack2.pop().edge);
    cutset.forEach(function(edge) {
      var connectedNodes = edge.connectedNodes().intersection(eles);
      component22.merge(edge);
      connectedNodes.forEach(function(node) {
        var nodeId = node.id();
        var connectedEdges = node.connectedEdges().intersection(eles);
        component22.merge(node);
        if (!nodes3[nodeId].cutVertex) {
          component22.merge(connectedEdges);
        } else {
          component22.merge(connectedEdges.filter(function(edge2) {
            return edge2.isLoop();
          }));
        }
      });
    });
    components2.push(component22);
  }, "buildComponent2");
  var _biconnectedSearch = /* @__PURE__ */ __name(function biconnectedSearch(root2, currentNode, parent4) {
    if (root2 === parent4) edgeCount += 1;
    nodes3[currentNode] = {
      id: id2,
      low: id2++,
      cutVertex: false
    };
    var edges3 = eles.getElementById(currentNode).connectedEdges().intersection(eles);
    if (edges3.size() === 0) {
      components2.push(eles.spawn(eles.getElementById(currentNode)));
    } else {
      var sourceId, targetId, otherNodeId, edgeId;
      edges3.forEach(function(edge) {
        sourceId = edge.source().id();
        targetId = edge.target().id();
        otherNodeId = sourceId === currentNode ? targetId : sourceId;
        if (otherNodeId !== parent4) {
          edgeId = edge.id();
          if (!visitedEdges[edgeId]) {
            visitedEdges[edgeId] = true;
            stack2.push({
              x: currentNode,
              y: otherNodeId,
              edge
            });
          }
          if (!(otherNodeId in nodes3)) {
            _biconnectedSearch(root2, otherNodeId, currentNode);
            nodes3[currentNode].low = Math.min(nodes3[currentNode].low, nodes3[otherNodeId].low);
            if (nodes3[currentNode].id <= nodes3[otherNodeId].low) {
              nodes3[currentNode].cutVertex = true;
              buildComponent(currentNode, otherNodeId);
            }
          } else {
            nodes3[currentNode].low = Math.min(nodes3[currentNode].low, nodes3[otherNodeId].id);
          }
        }
      });
    }
  }, "biconnectedSearch");
  eles.forEach(function(ele) {
    if (ele.isNode()) {
      var nodeId = ele.id();
      if (!(nodeId in nodes3)) {
        edgeCount = 0;
        _biconnectedSearch(nodeId, nodeId);
        nodes3[nodeId].cutVertex = edgeCount > 1;
      }
    }
  });
  var cutVertices = Object.keys(nodes3).filter(function(id3) {
    return nodes3[id3].cutVertex;
  }).map(function(id3) {
    return eles.getElementById(id3);
  });
  return {
    cut: eles.spawn(cutVertices),
    components: components2
  };
}, "hopcroftTarjanBiconnected2");
var hopcroftTarjanBiconnected$1 = {
  hopcroftTarjanBiconnected,
  htbc: hopcroftTarjanBiconnected,
  htb: hopcroftTarjanBiconnected,
  hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected
};
var tarjanStronglyConnected = /* @__PURE__ */ __name(function tarjanStronglyConnected2() {
  var eles = this;
  var nodes3 = {};
  var index2 = 0;
  var components2 = [];
  var stack2 = [];
  var cut = eles.spawn(eles);
  var _stronglyConnectedSearch = /* @__PURE__ */ __name(function stronglyConnectedSearch(sourceNodeId) {
    stack2.push(sourceNodeId);
    nodes3[sourceNodeId] = {
      index: index2,
      low: index2++,
      explored: false
    };
    var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);
    connectedEdges.forEach(function(edge) {
      var targetNodeId = edge.target().id();
      if (targetNodeId !== sourceNodeId) {
        if (!(targetNodeId in nodes3)) {
          _stronglyConnectedSearch(targetNodeId);
        }
        if (!nodes3[targetNodeId].explored) {
          nodes3[sourceNodeId].low = Math.min(nodes3[sourceNodeId].low, nodes3[targetNodeId].low);
        }
      }
    });
    if (nodes3[sourceNodeId].index === nodes3[sourceNodeId].low) {
      var componentNodes = eles.spawn();
      for (; ; ) {
        var nodeId = stack2.pop();
        componentNodes.merge(eles.getElementById(nodeId));
        nodes3[nodeId].low = nodes3[sourceNodeId].index;
        nodes3[nodeId].explored = true;
        if (nodeId === sourceNodeId) {
          break;
        }
      }
      var componentEdges = componentNodes.edgesWith(componentNodes);
      var component22 = componentNodes.merge(componentEdges);
      components2.push(component22);
      cut = cut.difference(component22);
    }
  }, "stronglyConnectedSearch");
  eles.forEach(function(ele) {
    if (ele.isNode()) {
      var nodeId = ele.id();
      if (!(nodeId in nodes3)) {
        _stronglyConnectedSearch(nodeId);
      }
    }
  });
  return {
    cut,
    components: components2
  };
}, "tarjanStronglyConnected2");
var tarjanStronglyConnected$1 = {
  tarjanStronglyConnected,
  tsc: tarjanStronglyConnected,
  tscc: tarjanStronglyConnected,
  tarjanStronglyConnectedComponents: tarjanStronglyConnected
};
var elesfn$j = {};
[elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function(props) {
  extend(elesfn$j, props);
});
var STATE_PENDING = 0;
var STATE_FULFILLED = 1;
var STATE_REJECTED = 2;
var _api = /* @__PURE__ */ __name(function api(executor) {
  if (!(this instanceof _api)) return new _api(executor);
  this.id = "Thenable/1.0.7";
  this.state = STATE_PENDING;
  this.fulfillValue = void 0;
  this.rejectReason = void 0;
  this.onFulfilled = [];
  this.onRejected = [];
  this.proxy = {
    then: this.then.bind(this)
  };
  if (typeof executor === "function") executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
}, "api");
_api.prototype = {
  /*  promise resolving methods  */
  fulfill: /* @__PURE__ */ __name(function fulfill(value2) {
    return deliver(this, STATE_FULFILLED, "fulfillValue", value2);
  }, "fulfill"),
  reject: /* @__PURE__ */ __name(function reject(value2) {
    return deliver(this, STATE_REJECTED, "rejectReason", value2);
  }, "reject"),
  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: /* @__PURE__ */ __name(function then(onFulfilled, onRejected) {
    var curr = this;
    var next2 = new _api();
    curr.onFulfilled.push(resolver(onFulfilled, next2, "fulfill"));
    curr.onRejected.push(resolver(onRejected, next2, "reject"));
    execute(curr);
    return next2.proxy;
  }, "then")
};
var deliver = /* @__PURE__ */ __name(function deliver2(curr, state2, name, value2) {
  if (curr.state === STATE_PENDING) {
    curr.state = state2;
    curr[name] = value2;
    execute(curr);
  }
  return curr;
}, "deliver2");
var execute = /* @__PURE__ */ __name(function execute2(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, "onFulfilled", curr.fulfillValue);
  else if (curr.state === STATE_REJECTED) execute_handlers(curr, "onRejected", curr.rejectReason);
}, "execute2");
var execute_handlers = /* @__PURE__ */ __name(function execute_handlers2(curr, name, value2) {
  if (curr[name].length === 0) return;
  var handlers2 = curr[name];
  curr[name] = [];
  var func = /* @__PURE__ */ __name(function func2() {
    for (var i = 0; i < handlers2.length; i++) handlers2[i](value2);
  }, "func2");
  if (typeof setImmediate === "function") setImmediate(func);
  else setTimeout(func, 0);
}, "execute_handlers2");
var resolver = /* @__PURE__ */ __name(function resolver2(cb, next2, method) {
  return function(value2) {
    if (typeof cb !== "function")
      next2[method].call(next2, value2);
    else {
      var result;
      try {
        result = cb(value2);
      } catch (e) {
        next2.reject(e);
        return;
      }
      _resolve(next2, result);
    }
  };
}, "resolver2");
var _resolve = /* @__PURE__ */ __name(function resolve(promise4, x2) {
  if (promise4 === x2 || promise4.proxy === x2) {
    promise4.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }
  var then2;
  if (_typeof(x2) === "object" && x2 !== null || typeof x2 === "function") {
    try {
      then2 = x2.then;
    } catch (e) {
      promise4.reject(e);
      return;
    }
  }
  if (typeof then2 === "function") {
    var resolved = false;
    try {
      then2.call(
        x2,
        /*  resolvePromise  */
        /*  [Promises/A+ 2.3.3.3.1]  */
        function(y2) {
          if (resolved) return;
          resolved = true;
          if (y2 === x2)
            promise4.reject(new TypeError("circular thenable chain"));
          else _resolve(promise4, y2);
        },
        /*  rejectPromise  */
        /*  [Promises/A+ 2.3.3.3.2]  */
        function(r2) {
          if (resolved) return;
          resolved = true;
          promise4.reject(r2);
        }
      );
    } catch (e) {
      if (!resolved)
        promise4.reject(e);
    }
    return;
  }
  promise4.fulfill(x2);
}, "resolve");
_api.all = function(ps) {
  return new _api(function(resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;
    var fulfill2 = /* @__PURE__ */ __name(function fulfill3(i2, val) {
      vals[i2] = val;
      doneCount++;
      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    }, "fulfill3");
    for (var i = 0; i < ps.length; i++) {
      (function(i2) {
        var p2 = ps[i2];
        var isPromise = p2 != null && p2.then != null;
        if (isPromise) {
          p2.then(function(val2) {
            fulfill2(i2, val2);
          }, function(err2) {
            rejectAll(err2);
          });
        } else {
          var val = p2;
          fulfill2(i2, val);
        }
      })(i);
    }
  });
};
_api.resolve = function(val) {
  return new _api(function(resolve2, reject2) {
    resolve2(val);
  });
};
_api.reject = function(val) {
  return new _api(function(resolve2, reject2) {
    reject2(val);
  });
};
var Promise$1 = typeof Promise !== "undefined" ? Promise : _api;
var Animation = /* @__PURE__ */ __name(function Animation2(target, opts, opts2) {
  var isCore = core(target);
  var isEle = !isCore;
  var _p = this._private = extend({
    duration: 1e3
  }, opts, opts2);
  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];
  if (_p.complete && fn$6(_p.complete)) {
    _p.completes.push(_p.complete);
  }
  if (isEle) {
    var pos = target.position();
    _p.startPosition = _p.startPosition || {
      x: pos.x,
      y: pos.y
    };
    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
  }
  if (isCore) {
    var pan2 = target.pan();
    _p.startPan = {
      x: pan2.x,
      y: pan2.y
    };
    _p.startZoom = target.zoom();
  }
  this.length = 1;
  this[0] = this;
}, "Animation2");
var anifn = Animation.prototype;
extend(anifn, {
  instanceString: /* @__PURE__ */ __name(function instanceString() {
    return "animation";
  }, "instanceString"),
  hook: /* @__PURE__ */ __name(function hook() {
    var _p = this._private;
    if (!_p.hooked) {
      var q;
      var tAni = _p.target._private.animation;
      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push(this);
      if (elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }
      _p.hooked = true;
    }
    return this;
  }, "hook"),
  play: /* @__PURE__ */ __name(function play() {
    var _p = this._private;
    if (_p.progress === 1) {
      _p.progress = 0;
    }
    _p.playing = true;
    _p.started = false;
    _p.stopped = false;
    this.hook();
    return this;
  }, "play"),
  playing: /* @__PURE__ */ __name(function playing() {
    return this._private.playing;
  }, "playing"),
  apply: /* @__PURE__ */ __name(function apply2() {
    var _p = this._private;
    _p.applying = true;
    _p.started = false;
    _p.stopped = false;
    this.hook();
    return this;
  }, "apply"),
  applying: /* @__PURE__ */ __name(function applying() {
    return this._private.applying;
  }, "applying"),
  pause: /* @__PURE__ */ __name(function pause() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    return this;
  }, "pause"),
  stop: /* @__PURE__ */ __name(function stop() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    _p.stopped = true;
    return this;
  }, "stop"),
  rewind: /* @__PURE__ */ __name(function rewind() {
    return this.progress(0);
  }, "rewind"),
  fastforward: /* @__PURE__ */ __name(function fastforward() {
    return this.progress(1);
  }, "fastforward"),
  time: /* @__PURE__ */ __name(function time(t) {
    var _p = this._private;
    if (t === void 0) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  }, "time"),
  progress: /* @__PURE__ */ __name(function progress(p2) {
    var _p = this._private;
    var wasPlaying = _p.playing;
    if (p2 === void 0) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }
      _p.progress = p2;
      _p.started = false;
      if (wasPlaying) {
        this.play();
      }
    }
    return this;
  }, "progress"),
  completed: /* @__PURE__ */ __name(function completed() {
    return this._private.progress === 1;
  }, "completed"),
  reverse: /* @__PURE__ */ __name(function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;
    if (wasPlaying) {
      this.pause();
    }
    _p.progress = 1 - _p.progress;
    _p.started = false;
    var swap = /* @__PURE__ */ __name(function swap2(a, b) {
      var _pa = _p[a];
      if (_pa == null) {
        return;
      }
      _p[a] = _p[b];
      _p[b] = _pa;
    }, "swap2");
    swap("zoom", "startZoom");
    swap("pan", "startPan");
    swap("position", "startPosition");
    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop2 = _p.style[i];
        var name = prop2.name;
        var startStyleProp = _p.startStyle[name];
        _p.startStyle[name] = prop2;
        _p.style[i] = startStyleProp;
      }
    }
    if (wasPlaying) {
      this.play();
    }
    return this;
  }, "reverse"),
  promise: /* @__PURE__ */ __name(function promise3(type) {
    var _p = this._private;
    var arr;
    switch (type) {
      case "frame":
        arr = _p.frames;
        break;
      default:
      case "complete":
      case "completed":
        arr = _p.completes;
    }
    return new Promise$1(function(resolve2, reject2) {
      arr.push(function() {
        resolve2();
      });
    });
  }, "promise3")
});
anifn.complete = anifn.completed;
anifn.run = anifn.play;
anifn.running = anifn.playing;
var define$3 = {
  animated: /* @__PURE__ */ __name(function animated() {
    return /* @__PURE__ */ __name(function animatedImpl() {
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return false;
      }
      var ele = all2[0];
      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    }, "animatedImpl");
  }, "animated"),
  // animated
  clearQueue: /* @__PURE__ */ __name(function clearQueue() {
    return /* @__PURE__ */ __name(function clearQueueImpl() {
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return this;
      }
      for (var i = 0; i < all2.length; i++) {
        var ele = all2[i];
        ele._private.animation.queue = [];
      }
      return this;
    }, "clearQueueImpl");
  }, "clearQueue"),
  // clearQueue
  delay: /* @__PURE__ */ __name(function delay() {
    return /* @__PURE__ */ __name(function delayImpl(time2, complete) {
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return this;
      }
      return this.animate({
        delay: time2,
        duration: time2,
        complete
      });
    }, "delayImpl");
  }, "delay"),
  // delay
  delayAnimation: /* @__PURE__ */ __name(function delayAnimation() {
    return /* @__PURE__ */ __name(function delayAnimationImpl(time2, complete) {
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return this;
      }
      return this.animation({
        delay: time2,
        duration: time2,
        complete
      });
    }, "delayAnimationImpl");
  }, "delayAnimation"),
  // delay
  animation: /* @__PURE__ */ __name(function animation2() {
    return /* @__PURE__ */ __name(function animationImpl(properties, params) {
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;
      if (!cy.styleEnabled()) {
        return this;
      }
      var style3 = cy.style();
      properties = extend({}, properties, params);
      var propertiesEmpty = Object.keys(properties).length === 0;
      if (propertiesEmpty) {
        return new Animation(all2[0], properties);
      }
      if (properties.duration === void 0) {
        properties.duration = 400;
      }
      switch (properties.duration) {
        case "slow":
          properties.duration = 600;
          break;
        case "fast":
          properties.duration = 200;
          break;
      }
      if (isEles) {
        properties.style = style3.getPropsList(properties.style || properties.css);
        properties.css = void 0;
      }
      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan2 = cy.pan();
        var zoom2 = cy.zoom();
        properties.position = renderedToModelPosition(rpos, zoom2, pan2);
      }
      if (isCore && properties.panBy != null) {
        var panBy2 = properties.panBy;
        var cyPan = cy.pan();
        properties.pan = {
          x: cyPan.x + panBy2.x,
          y: cyPan.y + panBy2.y
        };
      }
      var center2 = properties.center || properties.centre;
      if (isCore && center2 != null) {
        var centerPan = cy.getCenterPan(center2.eles, properties.zoom);
        if (centerPan != null) {
          properties.pan = centerPan;
        }
      }
      if (isCore && properties.fit != null) {
        var fit2 = properties.fit;
        var fitVp = cy.getFitViewport(fit2.eles || fit2.boundingBox, fit2.padding);
        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }
      if (isCore && plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);
        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }
          if (vp.panned) {
            properties.pan = vp.pan;
          }
        } else {
          properties.zoom = null;
        }
      }
      return new Animation(all2[0], properties);
    }, "animationImpl");
  }, "animation"),
  // animate
  animate: /* @__PURE__ */ __name(function animate2() {
    return /* @__PURE__ */ __name(function animateImpl(properties, params) {
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return this;
      }
      if (params) {
        properties = extend({}, properties, params);
      }
      for (var i = 0; i < all2.length; i++) {
        var ele = all2[i];
        var queue = ele.animated() && (properties.queue === void 0 || properties.queue);
        var ani = ele.animation(properties, queue ? {
          queue: true
        } : void 0);
        ani.play();
      }
      return this;
    }, "animateImpl");
  }, "animate"),
  // animate
  stop: /* @__PURE__ */ __name(function stop2() {
    return /* @__PURE__ */ __name(function stopImpl(clearQueue2, jumpToEnd) {
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var cy = this._private.cy || this;
      if (!cy.styleEnabled()) {
        return this;
      }
      for (var i = 0; i < all2.length; i++) {
        var ele = all2[i];
        var _p = ele._private;
        var anis = _p.animation.current;
        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;
          if (jumpToEnd) {
            ani_p.duration = 0;
          }
        }
        if (clearQueue2) {
          _p.animation.queue = [];
        }
        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      }
      cy.notify("draw");
      return this;
    }, "stopImpl");
  }, "stop2")
  // stop
};
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
__name(requireIsArray, "requireIsArray");
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value2, object3) {
    if (isArray(value2)) {
      return false;
    }
    var type = typeof value2;
    if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
      return true;
    }
    return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object3 != null && value2 in Object(object3);
  }
  __name(isKey, "isKey");
  _isKey = isKey;
  return _isKey;
}
__name(require_isKey, "require_isKey");
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value2) {
    if (!isObject(value2)) {
      return false;
    }
    var tag2 = baseGetTag(value2);
    return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
  }
  __name(isFunction, "isFunction");
  isFunction_1 = isFunction;
  return isFunction_1;
}
__name(requireIsFunction, "requireIsFunction");
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root2 = require_root();
  var coreJsData = root2["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
__name(require_coreJsData, "require_coreJsData");
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  })();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  __name(isMasked, "isMasked");
  _isMasked = isMasked;
  return _isMasked;
}
__name(require_isMasked, "require_isMasked");
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  __name(toSource, "toSource");
  _toSource = toSource;
  return _toSource;
}
__name(require_toSource, "require_toSource");
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value2) {
    if (!isObject(value2) || isMasked(value2)) {
      return false;
    }
    var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value2));
  }
  __name(baseIsNative, "baseIsNative");
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
__name(require_baseIsNative, "require_baseIsNative");
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object3, key2) {
    return object3 == null ? void 0 : object3[key2];
  }
  __name(getValue2, "getValue2");
  _getValue = getValue2;
  return _getValue;
}
__name(require_getValue, "require_getValue");
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object3, key2) {
    var value2 = getValue2(object3, key2);
    return baseIsNative(value2) ? value2 : void 0;
  }
  __name(getNative, "getNative");
  _getNative = getNative;
  return _getNative;
}
__name(require_getNative, "require_getNative");
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
__name(require_nativeCreate, "require_nativeCreate");
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  __name(hashClear, "hashClear");
  _hashClear = hashClear;
  return _hashClear;
}
__name(require_hashClear, "require_hashClear");
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(hashDelete, "hashDelete");
  _hashDelete = hashDelete;
  return _hashDelete;
}
__name(require_hashDelete, "require_hashDelete");
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function hashGet(key2) {
    var data4 = this.__data__;
    if (nativeCreate) {
      var result = data4[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data4, key2) ? data4[key2] : void 0;
  }
  __name(hashGet, "hashGet");
  _hashGet = hashGet;
  return _hashGet;
}
__name(require_hashGet, "require_hashGet");
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function hashHas(key2) {
    var data4 = this.__data__;
    return nativeCreate ? data4[key2] !== void 0 : hasOwnProperty2.call(data4, key2);
  }
  __name(hashHas, "hashHas");
  _hashHas = hashHas;
  return _hashHas;
}
__name(require_hashHas, "require_hashHas");
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key2, value2) {
    var data4 = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data4[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
    return this;
  }
  __name(hashSet, "hashSet");
  _hashSet = hashSet;
  return _hashSet;
}
__name(require_hashSet, "require_hashSet");
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(Hash, "Hash");
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
__name(require_Hash, "require_Hash");
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  __name(listCacheClear, "listCacheClear");
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
__name(require_listCacheClear, "require_listCacheClear");
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq2(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  __name(eq2, "eq2");
  eq_1 = eq2;
  return eq_1;
}
__name(requireEq, "requireEq");
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq2 = requireEq();
  function assocIndexOf(array3, key2) {
    var length2 = array3.length;
    while (length2--) {
      if (eq2(array3[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  __name(assocIndexOf, "assocIndexOf");
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
__name(require_assocIndexOf, "require_assocIndexOf");
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data4.length - 1;
    if (index2 == lastIndex) {
      data4.pop();
    } else {
      splice.call(data4, index2, 1);
    }
    --this.size;
    return true;
  }
  __name(listCacheDelete, "listCacheDelete");
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
__name(require_listCacheDelete, "require_listCacheDelete");
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key2) {
    var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
    return index2 < 0 ? void 0 : data4[index2][1];
  }
  __name(listCacheGet, "listCacheGet");
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
__name(require_listCacheGet, "require_listCacheGet");
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  __name(listCacheHas, "listCacheHas");
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
__name(require_listCacheHas, "require_listCacheHas");
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key2, value2) {
    var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
    if (index2 < 0) {
      ++this.size;
      data4.push([key2, value2]);
    } else {
      data4[index2][1] = value2;
    }
    return this;
  }
  __name(listCacheSet, "listCacheSet");
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
__name(require_listCacheSet, "require_listCacheSet");
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(ListCache, "ListCache");
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
__name(require_ListCache, "require_ListCache");
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Map2 = getNative(root2, "Map");
  _Map = Map2;
  return _Map;
}
__name(require_Map, "require_Map");
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  __name(mapCacheClear, "mapCacheClear");
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
__name(require_mapCacheClear, "require_mapCacheClear");
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value2) {
    var type = typeof value2;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  __name(isKeyable, "isKeyable");
  _isKeyable = isKeyable;
  return _isKeyable;
}
__name(require_isKeyable, "require_isKeyable");
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map22, key2) {
    var data4 = map22.__data__;
    return isKeyable(key2) ? data4[typeof key2 == "string" ? "string" : "hash"] : data4.map;
  }
  __name(getMapData, "getMapData");
  _getMapData = getMapData;
  return _getMapData;
}
__name(require_getMapData, "require_getMapData");
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(mapCacheDelete, "mapCacheDelete");
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
__name(require_mapCacheDelete, "require_mapCacheDelete");
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  __name(mapCacheGet, "mapCacheGet");
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
__name(require_mapCacheGet, "require_mapCacheGet");
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  __name(mapCacheHas, "mapCacheHas");
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
__name(require_mapCacheHas, "require_mapCacheHas");
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key2, value2) {
    var data4 = getMapData(this, key2), size3 = data4.size;
    data4.set(key2, value2);
    this.size += data4.size == size3 ? 0 : 1;
    return this;
  }
  __name(mapCacheSet, "mapCacheSet");
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
__name(require_mapCacheSet, "require_mapCacheSet");
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(MapCache, "MapCache");
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
__name(require_MapCache, "require_MapCache");
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize3(func, resolver3) {
    if (typeof func != "function" || resolver3 != null && typeof resolver3 != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = /* @__PURE__ */ __name(function() {
      var args2 = arguments, key2 = resolver3 ? resolver3.apply(this, args2) : args2[0], cache3 = memoized.cache;
      if (cache3.has(key2)) {
        return cache3.get(key2);
      }
      var result = func.apply(this, args2);
      memoized.cache = cache3.set(key2, result) || cache3;
      return result;
    }, "memoized");
    memoized.cache = new (memoize3.Cache || MapCache)();
    return memoized;
  }
  __name(memoize3, "memoize3");
  memoize3.Cache = MapCache;
  memoize_1 = memoize3;
  return memoize_1;
}
__name(requireMemoize, "requireMemoize");
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize3 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize3(func, function(key2) {
      if (cache3.size === MAX_MEMOIZE_SIZE) {
        cache3.clear();
      }
      return key2;
    });
    var cache3 = result.cache;
    return result;
  }
  __name(memoizeCapped, "memoizeCapped");
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
__name(require_memoizeCapped, "require_memoizeCapped");
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string3) {
    var result = [];
    if (string3.charCodeAt(0) === 46) {
      result.push("");
    }
    string3.replace(rePropName, function(match2, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
__name(require_stringToPath, "require_stringToPath");
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array3, iteratee) {
    var index2 = -1, length2 = array3 == null ? 0 : array3.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array3[index2], index2, array3);
    }
    return result;
  }
  __name(arrayMap, "arrayMap");
  _arrayMap = arrayMap;
  return _arrayMap;
}
__name(require_arrayMap, "require_arrayMap");
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value2) {
    if (typeof value2 == "string") {
      return value2;
    }
    if (isArray(value2)) {
      return arrayMap(value2, baseToString) + "";
    }
    if (isSymbol(value2)) {
      return symbolToString ? symbolToString.call(value2) : "";
    }
    var result = value2 + "";
    return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
  }
  __name(baseToString, "baseToString");
  _baseToString = baseToString;
  return _baseToString;
}
__name(require_baseToString, "require_baseToString");
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString3(value2) {
    return value2 == null ? "" : baseToString(value2);
  }
  __name(toString3, "toString3");
  toString_1 = toString3;
  return toString_1;
}
__name(requireToString, "requireToString");
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString3 = requireToString();
  function castPath(value2, object3) {
    if (isArray(value2)) {
      return value2;
    }
    return isKey(value2, object3) ? [value2] : stringToPath(toString3(value2));
  }
  __name(castPath, "castPath");
  _castPath = castPath;
  return _castPath;
}
__name(require_castPath, "require_castPath");
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  function toKey(value2) {
    if (typeof value2 == "string" || isSymbol(value2)) {
      return value2;
    }
    var result = value2 + "";
    return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
  }
  __name(toKey, "toKey");
  _toKey = toKey;
  return _toKey;
}
__name(require_toKey, "require_toKey");
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object3, path) {
    path = castPath(path, object3);
    var index2 = 0, length2 = path.length;
    while (object3 != null && index2 < length2) {
      object3 = object3[toKey(path[index2++])];
    }
    return index2 && index2 == length2 ? object3 : void 0;
  }
  __name(baseGet, "baseGet");
  _baseGet = baseGet;
  return _baseGet;
}
__name(require_baseGet, "require_baseGet");
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get2(object3, path, defaultValue) {
    var result = object3 == null ? void 0 : baseGet(object3, path);
    return result === void 0 ? defaultValue : result;
  }
  __name(get2, "get2");
  get_1 = get2;
  return get_1;
}
__name(requireGet, "requireGet");
var getExports = requireGet();
var get = /* @__PURE__ */ getDefaultExportFromCjs(getExports);
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = (function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  })();
  _defineProperty = defineProperty;
  return _defineProperty;
}
__name(require_defineProperty, "require_defineProperty");
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object3, key2, value2) {
    if (key2 == "__proto__" && defineProperty) {
      defineProperty(object3, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value2,
        "writable": true
      });
    } else {
      object3[key2] = value2;
    }
  }
  __name(baseAssignValue, "baseAssignValue");
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
__name(require_baseAssignValue, "require_baseAssignValue");
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq2 = requireEq();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  function assignValue(object3, key2, value2) {
    var objValue = object3[key2];
    if (!(hasOwnProperty2.call(object3, key2) && eq2(objValue, value2)) || value2 === void 0 && !(key2 in object3)) {
      baseAssignValue(object3, key2, value2);
    }
  }
  __name(assignValue, "assignValue");
  _assignValue = assignValue;
  return _assignValue;
}
__name(require_assignValue, "require_assignValue");
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value2, length2) {
    var type = typeof value2;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
  }
  __name(isIndex, "isIndex");
  _isIndex = isIndex;
  return _isIndex;
}
__name(require_isIndex, "require_isIndex");
var _baseSet;
var hasRequired_baseSet;
function require_baseSet() {
  if (hasRequired_baseSet) return _baseSet;
  hasRequired_baseSet = 1;
  var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject = requireIsObject(), toKey = require_toKey();
  function baseSet(object3, path, value2, customizer) {
    if (!isObject(object3)) {
      return object3;
    }
    path = castPath(path, object3);
    var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object3;
    while (nested != null && ++index2 < length2) {
      var key2 = toKey(path[index2]), newValue = value2;
      if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
        return object3;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key2];
        newValue = customizer ? customizer(objValue, key2, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key2, newValue);
      nested = nested[key2];
    }
    return object3;
  }
  __name(baseSet, "baseSet");
  _baseSet = baseSet;
  return _baseSet;
}
__name(require_baseSet, "require_baseSet");
var set_1;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set_1;
  hasRequiredSet = 1;
  var baseSet = require_baseSet();
  function set2(object3, path, value2) {
    return object3 == null ? object3 : baseSet(object3, path, value2);
  }
  __name(set2, "set2");
  set_1 = set2;
  return set_1;
}
__name(requireSet, "requireSet");
var setExports = requireSet();
var set = /* @__PURE__ */ getDefaultExportFromCjs(setExports);
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray3(source2, array3) {
    var index2 = -1, length2 = source2.length;
    array3 || (array3 = Array(length2));
    while (++index2 < length2) {
      array3[index2] = source2[index2];
    }
    return array3;
  }
  __name(copyArray3, "copyArray3");
  _copyArray = copyArray3;
  return _copyArray;
}
__name(require_copyArray, "require_copyArray");
var toPath_1;
var hasRequiredToPath;
function requireToPath() {
  if (hasRequiredToPath) return toPath_1;
  hasRequiredToPath = 1;
  var arrayMap = require_arrayMap(), copyArray3 = require_copyArray(), isArray = requireIsArray(), isSymbol = requireIsSymbol(), stringToPath = require_stringToPath(), toKey = require_toKey(), toString3 = requireToString();
  function toPath2(value2) {
    if (isArray(value2)) {
      return arrayMap(value2, toKey);
    }
    return isSymbol(value2) ? [value2] : copyArray3(stringToPath(toString3(value2)));
  }
  __name(toPath2, "toPath2");
  toPath_1 = toPath2;
  return toPath_1;
}
__name(requireToPath, "requireToPath");
var toPathExports = requireToPath();
var toPath = /* @__PURE__ */ getDefaultExportFromCjs(toPathExports);
var define$2 = {
  // access data field
  data: /* @__PURE__ */ __name(function data(params) {
    var defaults3 = {
      field: "data",
      bindingEvent: "data",
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: "data",
      settingTriggersEvent: false,
      triggerFnName: "trigger",
      immutableKeys: {},
      // key => true if immutable
      updateStyle: false,
      beforeGet: /* @__PURE__ */ __name(function beforeGet2(self2) {
      }, "beforeGet2"),
      beforeSet: /* @__PURE__ */ __name(function beforeSet3(self2, obj) {
      }, "beforeSet3"),
      onSet: /* @__PURE__ */ __name(function onSet3(self2) {
      }, "onSet3"),
      canSet: /* @__PURE__ */ __name(function canSet2(self2) {
        return true;
      }, "canSet2")
    };
    params = extend({}, defaults3, params);
    return /* @__PURE__ */ __name(function dataImpl(name, value2) {
      var p2 = params;
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      var single = selfIsArrayLike ? self2[0] : self2;
      if (string(name)) {
        var isPathLike = name.indexOf(".") !== -1;
        var path = isPathLike && toPath(name);
        if (p2.allowGetting && value2 === void 0) {
          var ret;
          if (single) {
            p2.beforeGet(single);
            if (path && single._private[p2.field][name] === void 0) {
              ret = get(single._private[p2.field], path);
            } else {
              ret = single._private[p2.field][name];
            }
          }
          return ret;
        } else if (p2.allowSetting && value2 !== void 0) {
          var valid2 = !p2.immutableKeys[name];
          if (valid2) {
            var change = _defineProperty$1({}, name, value2);
            p2.beforeSet(self2, change);
            for (var i = 0, l = all2.length; i < l; i++) {
              var ele = all2[i];
              if (p2.canSet(ele)) {
                if (path && single._private[p2.field][name] === void 0) {
                  set(ele._private[p2.field], path, value2);
                } else {
                  ele._private[p2.field][name] = value2;
                }
              }
            }
            if (p2.updateStyle) {
              self2.updateStyle();
            }
            p2.onSet(self2);
            if (p2.settingTriggersEvent) {
              self2[p2.triggerFnName](p2.settingEvent);
            }
          }
        }
      } else if (p2.allowSetting && plainObject(name)) {
        var obj = name;
        var k, v;
        var keys = Object.keys(obj);
        p2.beforeSet(self2, obj);
        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];
          var _valid = !p2.immutableKeys[k];
          if (_valid) {
            for (var j = 0; j < all2.length; j++) {
              var _ele = all2[j];
              if (p2.canSet(_ele)) {
                _ele._private[p2.field][k] = v;
              }
            }
          }
        }
        if (p2.updateStyle) {
          self2.updateStyle();
        }
        p2.onSet(self2);
        if (p2.settingTriggersEvent) {
          self2[p2.triggerFnName](p2.settingEvent);
        }
      } else if (p2.allowBinding && fn$6(name)) {
        var fn3 = name;
        self2.on(p2.bindingEvent, fn3);
      } else if (p2.allowGetting && name === void 0) {
        var _ret;
        if (single) {
          p2.beforeGet(single);
          _ret = single._private[p2.field];
        }
        return _ret;
      }
      return self2;
    }, "dataImpl");
  }, "data"),
  // data
  // remove data field
  removeData: /* @__PURE__ */ __name(function removeData(params) {
    var defaults3 = {
      field: "data",
      event: "data",
      triggerFnName: "trigger",
      triggerEvent: false,
      immutableKeys: {}
      // key => true if immutable
    };
    params = extend({}, defaults3, params);
    return /* @__PURE__ */ __name(function removeDataImpl(names) {
      var p2 = params;
      var self2 = this;
      var selfIsArrayLike = self2.length !== void 0;
      var all2 = selfIsArrayLike ? self2 : [self2];
      if (string(names)) {
        var keys = names.split(/\s+/);
        var l = keys.length;
        for (var i = 0; i < l; i++) {
          var key2 = keys[i];
          if (emptyString(key2)) {
            continue;
          }
          var valid2 = !p2.immutableKeys[key2];
          if (valid2) {
            for (var i_a = 0, l_a = all2.length; i_a < l_a; i_a++) {
              all2[i_a]._private[p2.field][key2] = void 0;
            }
          }
        }
        if (p2.triggerEvent) {
          self2[p2.triggerFnName](p2.event);
        }
      } else if (names === void 0) {
        for (var _i_a = 0, _l_a = all2.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all2[_i_a]._private[p2.field];
          var _keys = Object.keys(_privateFields);
          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p2.immutableKeys[_key];
            if (validKeyToDelete) {
              _privateFields[_key] = void 0;
            }
          }
        }
        if (p2.triggerEvent) {
          self2[p2.triggerFnName](p2.event);
        }
      }
      return self2;
    }, "removeDataImpl");
  }, "removeData")
  // removeData
};
var define$1 = {
  eventAliasesOn: /* @__PURE__ */ __name(function eventAliasesOn(proto) {
    var p2 = proto;
    p2.addListener = p2.listen = p2.bind = p2.on;
    p2.unlisten = p2.unbind = p2.off = p2.removeListener;
    p2.trigger = p2.emit;
    p2.pon = p2.promiseOn = function(events, selector) {
      var self2 = this;
      var args2 = Array.prototype.slice.call(arguments, 0);
      return new Promise$1(function(resolve2, reject2) {
        var callback = /* @__PURE__ */ __name(function callback2(e) {
          self2.off.apply(self2, offArgs);
          resolve2(e);
        }, "callback2");
        var onArgs = args2.concat([callback]);
        var offArgs = onArgs.concat([]);
        self2.on.apply(self2, onArgs);
      });
    };
  }, "eventAliasesOn")
};
var define = {};
[define$3, define$2, define$1].forEach(function(m) {
  extend(define, m);
});
var elesfn$i = {
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
};
var elesfn$h = {
  classes: /* @__PURE__ */ __name(function classes(_classes) {
    var self2 = this;
    if (_classes === void 0) {
      var ret = [];
      self2[0]._private.classes.forEach(function(cls2) {
        return ret.push(cls2);
      });
      return ret;
    } else if (!array(_classes)) {
      _classes = (_classes || "").match(/\S+/g) || [];
    }
    var changed = [];
    var classesSet = new Set$1(_classes);
    for (var j = 0; j < self2.length; j++) {
      var ele = self2[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;
      for (var i = 0; i < _classes.length; i++) {
        var cls = _classes[i];
        var eleHasClass = eleClasses.has(cls);
        if (!eleHasClass) {
          changedEle = true;
          break;
        }
      }
      if (!changedEle) {
        changedEle = eleClasses.size !== _classes.length;
      }
      if (changedEle) {
        _p.classes = classesSet;
        changed.push(ele);
      }
    }
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit("class");
    }
    return self2;
  }, "classes"),
  addClass: /* @__PURE__ */ __name(function addClass(classes2) {
    return this.toggleClass(classes2, true);
  }, "addClass"),
  hasClass: /* @__PURE__ */ __name(function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  }, "hasClass"),
  toggleClass: /* @__PURE__ */ __name(function toggleClass(classes2, toggle) {
    if (!array(classes2)) {
      classes2 = classes2.match(/\S+/g) || [];
    }
    var self2 = this;
    var toggleUndefd = toggle === void 0;
    var changed = [];
    for (var i = 0, il = self2.length; i < il; i++) {
      var ele = self2[i];
      var eleClasses = ele._private.classes;
      var changedEle = false;
      for (var j = 0; j < classes2.length; j++) {
        var cls = classes2[j];
        var hasClass2 = eleClasses.has(cls);
        var changedNow = false;
        if (toggle || toggleUndefd && !hasClass2) {
          eleClasses.add(cls);
          changedNow = true;
        } else if (!toggle || toggleUndefd && hasClass2) {
          eleClasses["delete"](cls);
          changedNow = true;
        }
        if (!changedEle && changedNow) {
          changed.push(ele);
          changedEle = true;
        }
      }
    }
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit("class");
    }
    return self2;
  }, "toggleClass"),
  removeClass: /* @__PURE__ */ __name(function removeClass(classes2) {
    return this.toggleClass(classes2, false);
  }, "removeClass"),
  flashClass: /* @__PURE__ */ __name(function flashClass(classes2, duration) {
    var self2 = this;
    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self2;
    }
    self2.addClass(classes2);
    setTimeout(function() {
      self2.removeClass(classes2);
    }, duration);
    return self2;
  }, "flashClass")
};
elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;
var tokens = {
  metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
  // chars we need to escape in let names, etc
  comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
  // binary comparison op (used in data selectors)
  boolOp: "\\?|\\!|\\^",
  // boolean (unary) operators (used in data selectors)
  string: `"(?:\\\\"|[^"])*"|'(?:\\\\'|[^'])*'`,
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: number22,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: "degree|indegree|outdegree",
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: "\\s*,\\s*",
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: "\\s+",
  child: "\\s+>\\s+",
  subject: "\\$",
  group: "node|edge|\\*",
  directedEdge: "\\s+->\\s+",
  undirectedEdge: "\\s+<->\\s+"
};
tokens.variable = "(?:[\\w-.]|(?:\\\\" + tokens.metaChar + "))+";
tokens.className = "(?:[\\w-]|(?:\\\\" + tokens.metaChar + "))+";
tokens.value = tokens.string + "|" + tokens.number;
tokens.id = tokens.variable;
(function() {
  var ops, op, i;
  ops = tokens.comparatorOp.split("|");
  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += "|@" + op;
  }
  ops = tokens.comparatorOp.split("|");
  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    if (op.indexOf("!") >= 0) {
      continue;
    }
    if (op === "=") {
      continue;
    }
    tokens.comparatorOp += "|\\!" + op;
  }
})();
var newQuery = /* @__PURE__ */ __name(function newQuery2() {
  return {
    checks: []
  };
}, "newQuery2");
var Type = {
  /** E.g. node */
  GROUP: 0,
  /** A collection of elements */
  COLLECTION: 1,
  /** A filter(ele) function */
  FILTER: 2,
  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,
  /** E.g. [foo] */
  DATA_EXIST: 4,
  /** E.g. [?foo] */
  DATA_BOOL: 5,
  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,
  /** E.g. :selected */
  STATE: 7,
  /** E.g. #foo */
  ID: 8,
  /** E.g. .foo */
  CLASS: 9,
  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,
  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,
  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,
  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,
  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,
  /** E.g. #foo > #bar */
  CHILD: 15,
  /** E.g. #foo #bar */
  DESCENDANT: 16,
  /** E.g. $#foo > #bar */
  PARENT: 17,
  /** E.g. $#foo #bar */
  ANCESTOR: 18,
  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,
  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
};
var stateSelectors = [{
  selector: ":selected",
  matches: /* @__PURE__ */ __name(function matches(ele) {
    return ele.selected();
  }, "matches")
}, {
  selector: ":unselected",
  matches: /* @__PURE__ */ __name(function matches2(ele) {
    return !ele.selected();
  }, "matches2")
}, {
  selector: ":selectable",
  matches: /* @__PURE__ */ __name(function matches3(ele) {
    return ele.selectable();
  }, "matches3")
}, {
  selector: ":unselectable",
  matches: /* @__PURE__ */ __name(function matches4(ele) {
    return !ele.selectable();
  }, "matches4")
}, {
  selector: ":locked",
  matches: /* @__PURE__ */ __name(function matches5(ele) {
    return ele.locked();
  }, "matches5")
}, {
  selector: ":unlocked",
  matches: /* @__PURE__ */ __name(function matches6(ele) {
    return !ele.locked();
  }, "matches6")
}, {
  selector: ":visible",
  matches: /* @__PURE__ */ __name(function matches7(ele) {
    return ele.visible();
  }, "matches7")
}, {
  selector: ":hidden",
  matches: /* @__PURE__ */ __name(function matches8(ele) {
    return !ele.visible();
  }, "matches8")
}, {
  selector: ":transparent",
  matches: /* @__PURE__ */ __name(function matches9(ele) {
    return ele.transparent();
  }, "matches9")
}, {
  selector: ":grabbed",
  matches: /* @__PURE__ */ __name(function matches10(ele) {
    return ele.grabbed();
  }, "matches10")
}, {
  selector: ":free",
  matches: /* @__PURE__ */ __name(function matches11(ele) {
    return !ele.grabbed();
  }, "matches11")
}, {
  selector: ":removed",
  matches: /* @__PURE__ */ __name(function matches12(ele) {
    return ele.removed();
  }, "matches12")
}, {
  selector: ":inside",
  matches: /* @__PURE__ */ __name(function matches13(ele) {
    return !ele.removed();
  }, "matches13")
}, {
  selector: ":grabbable",
  matches: /* @__PURE__ */ __name(function matches14(ele) {
    return ele.grabbable();
  }, "matches14")
}, {
  selector: ":ungrabbable",
  matches: /* @__PURE__ */ __name(function matches15(ele) {
    return !ele.grabbable();
  }, "matches15")
}, {
  selector: ":animated",
  matches: /* @__PURE__ */ __name(function matches16(ele) {
    return ele.animated();
  }, "matches16")
}, {
  selector: ":unanimated",
  matches: /* @__PURE__ */ __name(function matches17(ele) {
    return !ele.animated();
  }, "matches17")
}, {
  selector: ":parent",
  matches: /* @__PURE__ */ __name(function matches18(ele) {
    return ele.isParent();
  }, "matches18")
}, {
  selector: ":childless",
  matches: /* @__PURE__ */ __name(function matches19(ele) {
    return ele.isChildless();
  }, "matches19")
}, {
  selector: ":child",
  matches: /* @__PURE__ */ __name(function matches20(ele) {
    return ele.isChild();
  }, "matches20")
}, {
  selector: ":orphan",
  matches: /* @__PURE__ */ __name(function matches21(ele) {
    return ele.isOrphan();
  }, "matches21")
}, {
  selector: ":nonorphan",
  matches: /* @__PURE__ */ __name(function matches22(ele) {
    return ele.isChild();
  }, "matches22")
}, {
  selector: ":compound",
  matches: /* @__PURE__ */ __name(function matches23(ele) {
    if (ele.isNode()) {
      return ele.isParent();
    } else {
      return ele.source().isParent() || ele.target().isParent();
    }
  }, "matches23")
}, {
  selector: ":loop",
  matches: /* @__PURE__ */ __name(function matches24(ele) {
    return ele.isLoop();
  }, "matches24")
}, {
  selector: ":simple",
  matches: /* @__PURE__ */ __name(function matches25(ele) {
    return ele.isSimple();
  }, "matches25")
}, {
  selector: ":active",
  matches: /* @__PURE__ */ __name(function matches26(ele) {
    return ele.active();
  }, "matches26")
}, {
  selector: ":inactive",
  matches: /* @__PURE__ */ __name(function matches27(ele) {
    return !ele.active();
  }, "matches27")
}, {
  selector: ":backgrounding",
  matches: /* @__PURE__ */ __name(function matches28(ele) {
    return ele.backgrounding();
  }, "matches28")
}, {
  selector: ":nonbackgrounding",
  matches: /* @__PURE__ */ __name(function matches29(ele) {
    return !ele.backgrounding();
  }, "matches29")
}].sort(function(a, b) {
  return descending(a.selector, b.selector);
});
var lookup = (function() {
  var selToFn = {};
  var s;
  for (var i = 0; i < stateSelectors.length; i++) {
    s = stateSelectors[i];
    selToFn[s.selector] = s.matches;
  }
  return selToFn;
})();
var stateSelectorMatches = /* @__PURE__ */ __name(function stateSelectorMatches2(sel, ele) {
  return lookup[sel](ele);
}, "stateSelectorMatches2");
var stateSelectorRegex = "(" + stateSelectors.map(function(s) {
  return s.selector;
}).join("|") + ")";
var cleanMetaChars = /* @__PURE__ */ __name(function cleanMetaChars2(str) {
  return str.replace(new RegExp("\\\\(" + tokens.metaChar + ")", "g"), function(match2, $1) {
    return $1;
  });
}, "cleanMetaChars2");
var replaceLastQuery = /* @__PURE__ */ __name(function replaceLastQuery2(selector, examiningQuery, replacementQuery) {
  selector[selector.length - 1] = replacementQuery;
}, "replaceLastQuery2");
var exprs = [{
  name: "group",
  // just used for identifying when debugging
  query: true,
  regex: "(" + tokens.group + ")",
  populate: /* @__PURE__ */ __name(function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1), group2 = _ref2[0];
    query.checks.push({
      type: Type.GROUP,
      value: group2 === "*" ? group2 : group2 + "s"
    });
  }, "populate")
}, {
  name: "state",
  query: true,
  regex: stateSelectorRegex,
  populate: /* @__PURE__ */ __name(function populate2(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1), state2 = _ref4[0];
    query.checks.push({
      type: Type.STATE,
      value: state2
    });
  }, "populate2")
}, {
  name: "id",
  query: true,
  regex: "\\#(" + tokens.id + ")",
  populate: /* @__PURE__ */ __name(function populate3(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1), id2 = _ref6[0];
    query.checks.push({
      type: Type.ID,
      value: cleanMetaChars(id2)
    });
  }, "populate3")
}, {
  name: "className",
  query: true,
  regex: "\\.(" + tokens.className + ")",
  populate: /* @__PURE__ */ __name(function populate4(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];
    query.checks.push({
      type: Type.CLASS,
      value: cleanMetaChars(className)
    });
  }, "populate4")
}, {
  name: "dataExists",
  query: true,
  regex: "\\[\\s*(" + tokens.variable + ")\\s*\\]",
  populate: /* @__PURE__ */ __name(function populate5(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];
    query.checks.push({
      type: Type.DATA_EXIST,
      field: cleanMetaChars(variable)
    });
  }, "populate5")
}, {
  name: "dataCompare",
  query: true,
  regex: "\\[\\s*(" + tokens.variable + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.value + ")\\s*\\]",
  populate: /* @__PURE__ */ __name(function populate6(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value2 = _ref12[2];
    var valueIsString = new RegExp("^" + tokens.string + "$").exec(value2) != null;
    if (valueIsString) {
      value2 = value2.substring(1, value2.length - 1);
    } else {
      value2 = parseFloat(value2);
    }
    query.checks.push({
      type: Type.DATA_COMPARE,
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value2
    });
  }, "populate6")
}, {
  name: "dataBool",
  query: true,
  regex: "\\[\\s*(" + tokens.boolOp + ")\\s*(" + tokens.variable + ")\\s*\\]",
  populate: /* @__PURE__ */ __name(function populate7(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];
    query.checks.push({
      type: Type.DATA_BOOL,
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }, "populate7")
}, {
  name: "metaCompare",
  query: true,
  regex: "\\[\\[\\s*(" + tokens.meta + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.number + ")\\s*\\]\\]",
  populate: /* @__PURE__ */ __name(function populate8(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3), meta3 = _ref16[0], comparatorOp = _ref16[1], number3 = _ref16[2];
    query.checks.push({
      type: Type.META_COMPARE,
      field: cleanMetaChars(meta3),
      operator: comparatorOp,
      value: parseFloat(number3)
    });
  }, "populate8")
}, {
  name: "nextQuery",
  separator: true,
  regex: tokens.separator,
  populate: /* @__PURE__ */ __name(function populate9(selector, query) {
    var currentSubject = selector.currentSubject;
    var edgeCount = selector.edgeCount;
    var compoundCount = selector.compoundCount;
    var lastQ = selector[selector.length - 1];
    if (currentSubject != null) {
      lastQ.subject = currentSubject;
      selector.currentSubject = null;
    }
    lastQ.edgeCount = edgeCount;
    lastQ.compoundCount = compoundCount;
    selector.edgeCount = 0;
    selector.compoundCount = 0;
    var nextQuery = selector[selector.length++] = newQuery();
    return nextQuery;
  }, "populate9")
}, {
  name: "directedEdge",
  separator: true,
  regex: tokens.directedEdge,
  populate: /* @__PURE__ */ __name(function populate10(selector, query) {
    if (selector.currentSubject == null) {
      var edgeQuery = newQuery();
      var source2 = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.DIRECTED_EDGE,
        source: source2,
        target
      });
      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++;
      return target;
    } else {
      var srcTgtQ = newQuery();
      var _source = query;
      var _target = newQuery();
      srcTgtQ.checks.push({
        type: Type.NODE_SOURCE,
        source: _source,
        target: _target
      });
      replaceLastQuery(selector, query, srcTgtQ);
      selector.edgeCount++;
      return _target;
    }
  }, "populate10")
}, {
  name: "undirectedEdge",
  separator: true,
  regex: tokens.undirectedEdge,
  populate: /* @__PURE__ */ __name(function populate11(selector, query) {
    if (selector.currentSubject == null) {
      var edgeQuery = newQuery();
      var source2 = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.UNDIRECTED_EDGE,
        nodes: [source2, target]
      });
      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++;
      return target;
    } else {
      var nhoodQ = newQuery();
      var node = query;
      var neighbor = newQuery();
      nhoodQ.checks.push({
        type: Type.NODE_NEIGHBOR,
        node,
        neighbor
      });
      replaceLastQuery(selector, query, nhoodQ);
      return neighbor;
    }
  }, "populate11")
}, {
  name: "child",
  separator: true,
  regex: tokens.child,
  populate: /* @__PURE__ */ __name(function populate12(selector, query) {
    if (selector.currentSubject == null) {
      var parentChildQuery = newQuery();
      var child2 = newQuery();
      var parent4 = selector[selector.length - 1];
      parentChildQuery.checks.push({
        type: Type.CHILD,
        parent: parent4,
        child: child2
      });
      replaceLastQuery(selector, query, parentChildQuery);
      selector.compoundCount++;
      return child2;
    } else if (selector.currentSubject === query) {
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();
      var _child = newQuery();
      var _parent = newQuery();
      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left,
        right,
        subject
      });
      subject.checks = query.checks;
      query.checks = [{
        type: Type.TRUE
      }];
      _parent.checks.push({
        type: Type.TRUE
      });
      right.checks.push({
        type: Type.PARENT,
        // type is swapped on right side queries
        parent: _parent,
        child: _child
        // empty for now
      });
      replaceLastQuery(selector, left, compound);
      selector.currentSubject = subject;
      selector.compoundCount++;
      return _child;
    } else {
      var _parent2 = newQuery();
      var _child2 = newQuery();
      var pcQChecks = [{
        type: Type.PARENT,
        parent: _parent2,
        child: _child2
      }];
      _parent2.checks = query.checks;
      query.checks = pcQChecks;
      selector.compoundCount++;
      return _child2;
    }
  }, "populate12")
}, {
  name: "descendant",
  separator: true,
  regex: tokens.descendant,
  populate: /* @__PURE__ */ __name(function populate13(selector, query) {
    if (selector.currentSubject == null) {
      var ancChQuery = newQuery();
      var descendant = newQuery();
      var ancestor = selector[selector.length - 1];
      ancChQuery.checks.push({
        type: Type.DESCENDANT,
        ancestor,
        descendant
      });
      replaceLastQuery(selector, query, ancChQuery);
      selector.compoundCount++;
      return descendant;
    } else if (selector.currentSubject === query) {
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();
      var _descendant = newQuery();
      var _ancestor = newQuery();
      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left,
        right,
        subject
      });
      subject.checks = query.checks;
      query.checks = [{
        type: Type.TRUE
      }];
      _ancestor.checks.push({
        type: Type.TRUE
      });
      right.checks.push({
        type: Type.ANCESTOR,
        // type is swapped on right side queries
        ancestor: _ancestor,
        descendant: _descendant
        // empty for now
      });
      replaceLastQuery(selector, left, compound);
      selector.currentSubject = subject;
      selector.compoundCount++;
      return _descendant;
    } else {
      var _ancestor2 = newQuery();
      var _descendant2 = newQuery();
      var adQChecks = [{
        type: Type.ANCESTOR,
        ancestor: _ancestor2,
        descendant: _descendant2
      }];
      _ancestor2.checks = query.checks;
      query.checks = adQChecks;
      selector.compoundCount++;
      return _descendant2;
    }
  }, "populate13")
}, {
  name: "subject",
  modifier: true,
  regex: tokens.subject,
  populate: /* @__PURE__ */ __name(function populate14(selector, query) {
    if (selector.currentSubject != null && selector.currentSubject !== query) {
      warn("Redefinition of subject in selector `" + selector.toString() + "`");
      return false;
    }
    selector.currentSubject = query;
    var topQ = selector[selector.length - 1];
    var topChk = topQ.checks[0];
    var topType = topChk == null ? null : topChk.type;
    if (topType === Type.DIRECTED_EDGE) {
      topChk.type = Type.NODE_TARGET;
    } else if (topType === Type.UNDIRECTED_EDGE) {
      topChk.type = Type.NODE_NEIGHBOR;
      topChk.node = topChk.nodes[1];
      topChk.neighbor = topChk.nodes[0];
      topChk.nodes = null;
    }
  }, "populate14")
}];
exprs.forEach(function(e) {
  return e.regexObj = new RegExp("^" + e.regex);
});
var consumeExpr = /* @__PURE__ */ __name(function consumeExpr2(remaining) {
  var expr;
  var match2;
  var name;
  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;
    var m = remaining.match(e.regexObj);
    if (m != null) {
      match2 = m;
      expr = e;
      name = n;
      var consumed = m[0];
      remaining = remaining.substring(consumed.length);
      break;
    }
  }
  return {
    expr,
    match: match2,
    name,
    remaining
  };
}, "consumeExpr2");
var consumeWhitespace = /* @__PURE__ */ __name(function consumeWhitespace2(remaining) {
  var match2 = remaining.match(/^\s+/);
  if (match2) {
    var consumed = match2[0];
    remaining = remaining.substring(consumed.length);
  }
  return remaining;
}, "consumeWhitespace2");
var parse = /* @__PURE__ */ __name(function parse2(selector) {
  var self2 = this;
  var remaining = self2.inputText = selector;
  var currentQuery = self2[0] = newQuery();
  self2.length = 1;
  remaining = consumeWhitespace(remaining);
  for (; ; ) {
    var exprInfo = consumeExpr(remaining);
    if (exprInfo.expr == null) {
      warn("The selector `" + selector + "`is invalid");
      return false;
    } else {
      var args2 = exprInfo.match.slice(1);
      var ret = exprInfo.expr.populate(self2, currentQuery, args2);
      if (ret === false) {
        return false;
      } else if (ret != null) {
        currentQuery = ret;
      }
    }
    remaining = exprInfo.remaining;
    if (remaining.match(/^\s*$/)) {
      break;
    }
  }
  var lastQ = self2[self2.length - 1];
  if (self2.currentSubject != null) {
    lastQ.subject = self2.currentSubject;
  }
  lastQ.edgeCount = self2.edgeCount;
  lastQ.compoundCount = self2.compoundCount;
  for (var i = 0; i < self2.length; i++) {
    var q = self2[i];
    if (q.compoundCount > 0 && q.edgeCount > 0) {
      warn("The selector `" + selector + "` is invalid because it uses both a compound selector and an edge selector");
      return false;
    }
    if (q.edgeCount > 1) {
      warn("The selector `" + selector + "` is invalid because it uses multiple edge selectors");
      return false;
    } else if (q.edgeCount === 1) {
      warn("The selector `" + selector + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
    }
  }
  return true;
}, "parse2");
var toString = /* @__PURE__ */ __name(function toString2() {
  if (this.toStringCache != null) {
    return this.toStringCache;
  }
  var clean = /* @__PURE__ */ __name(function clean2(obj) {
    if (obj == null) {
      return "";
    } else {
      return obj;
    }
  }, "clean2");
  var cleanVal = /* @__PURE__ */ __name(function cleanVal2(val) {
    if (string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  }, "cleanVal2");
  var space = /* @__PURE__ */ __name(function space2(val) {
    return " " + val + " ";
  }, "space2");
  var checkToString = /* @__PURE__ */ __name(function checkToString2(check2, subject) {
    var type = check2.type, value2 = check2.value;
    switch (type) {
      case Type.GROUP: {
        var group2 = clean(value2);
        return group2.substring(0, group2.length - 1);
      }
      case Type.DATA_COMPARE: {
        var field = check2.field, operator = check2.operator;
        return "[" + field + space(clean(operator)) + cleanVal(value2) + "]";
      }
      case Type.DATA_BOOL: {
        var _operator = check2.operator, _field = check2.field;
        return "[" + clean(_operator) + _field + "]";
      }
      case Type.DATA_EXIST: {
        var _field2 = check2.field;
        return "[" + _field2 + "]";
      }
      case Type.META_COMPARE: {
        var _operator2 = check2.operator, _field3 = check2.field;
        return "[[" + _field3 + space(clean(_operator2)) + cleanVal(value2) + "]]";
      }
      case Type.STATE: {
        return value2;
      }
      case Type.ID: {
        return "#" + value2;
      }
      case Type.CLASS: {
        return "." + value2;
      }
      case Type.PARENT:
      case Type.CHILD: {
        return queryToString(check2.parent, subject) + space(">") + queryToString(check2.child, subject);
      }
      case Type.ANCESTOR:
      case Type.DESCENDANT: {
        return queryToString(check2.ancestor, subject) + " " + queryToString(check2.descendant, subject);
      }
      case Type.COMPOUND_SPLIT: {
        var lhs = queryToString(check2.left, subject);
        var sub = queryToString(check2.subject, subject);
        var rhs = queryToString(check2.right, subject);
        return lhs + (lhs.length > 0 ? " " : "") + sub + rhs;
      }
      case Type.TRUE: {
        return "";
      }
    }
  }, "checkToString2");
  var queryToString = /* @__PURE__ */ __name(function queryToString2(query2, subject) {
    return query2.checks.reduce(function(str2, chk, i2) {
      return str2 + (subject === query2 && i2 === 0 ? "$" : "") + checkToString(chk, subject);
    }, "");
  }, "queryToString2");
  var str = "";
  for (var i = 0; i < this.length; i++) {
    var query = this[i];
    str += queryToString(query, query.subject);
    if (this.length > 1 && i < this.length - 1) {
      str += ", ";
    }
  }
  this.toStringCache = str;
  return str;
}, "toString2");
var parse$1 = {
  parse,
  toString
};
var valCmp = /* @__PURE__ */ __name(function valCmp2(fieldVal, operator, value2) {
  var matches33;
  var isFieldStr = string(fieldVal);
  var isFieldNum = number$1(fieldVal);
  var isValStr = string(value2);
  var fieldStr, valStr;
  var caseInsensitive = false;
  var notExpr = false;
  var isIneqCmp = false;
  if (operator.indexOf("!") >= 0) {
    operator = operator.replace("!", "");
    notExpr = true;
  }
  if (operator.indexOf("@") >= 0) {
    operator = operator.replace("@", "");
    caseInsensitive = true;
  }
  if (isFieldStr || isValStr || caseInsensitive) {
    fieldStr = !isFieldStr && !isFieldNum ? "" : "" + fieldVal;
    valStr = "" + value2;
  }
  if (caseInsensitive) {
    fieldVal = fieldStr = fieldStr.toLowerCase();
    value2 = valStr = valStr.toLowerCase();
  }
  switch (operator) {
    case "*=":
      matches33 = fieldStr.indexOf(valStr) >= 0;
      break;
    case "$=":
      matches33 = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
      break;
    case "^=":
      matches33 = fieldStr.indexOf(valStr) === 0;
      break;
    case "=":
      matches33 = fieldVal === value2;
      break;
    case ">":
      isIneqCmp = true;
      matches33 = fieldVal > value2;
      break;
    case ">=":
      isIneqCmp = true;
      matches33 = fieldVal >= value2;
      break;
    case "<":
      isIneqCmp = true;
      matches33 = fieldVal < value2;
      break;
    case "<=":
      isIneqCmp = true;
      matches33 = fieldVal <= value2;
      break;
    default:
      matches33 = false;
      break;
  }
  if (notExpr && (fieldVal != null || !isIneqCmp)) {
    matches33 = !matches33;
  }
  return matches33;
}, "valCmp2");
var boolCmp = /* @__PURE__ */ __name(function boolCmp2(fieldVal, operator) {
  switch (operator) {
    case "?":
      return fieldVal ? true : false;
    case "!":
      return fieldVal ? false : true;
    case "^":
      return fieldVal === void 0;
  }
}, "boolCmp2");
var existCmp = /* @__PURE__ */ __name(function existCmp2(fieldVal) {
  return fieldVal !== void 0;
}, "existCmp2");
var data$1 = /* @__PURE__ */ __name(function data2(ele, field) {
  return ele.data(field);
}, "data2");
var meta = /* @__PURE__ */ __name(function meta2(ele, field) {
  return ele[field]();
}, "meta2");
var match = [];
var matches$1 = /* @__PURE__ */ __name(function matches30(query, ele) {
  return query.checks.every(function(chk) {
    return match[chk.type](chk, ele);
  });
}, "matches30");
match[Type.GROUP] = function(check2, ele) {
  var group2 = check2.value;
  return group2 === "*" || group2 === ele.group();
};
match[Type.STATE] = function(check2, ele) {
  var stateSelector = check2.value;
  return stateSelectorMatches(stateSelector, ele);
};
match[Type.ID] = function(check2, ele) {
  var id2 = check2.value;
  return ele.id() === id2;
};
match[Type.CLASS] = function(check2, ele) {
  var cls = check2.value;
  return ele.hasClass(cls);
};
match[Type.META_COMPARE] = function(check2, ele) {
  var field = check2.field, operator = check2.operator, value2 = check2.value;
  return valCmp(meta(ele, field), operator, value2);
};
match[Type.DATA_COMPARE] = function(check2, ele) {
  var field = check2.field, operator = check2.operator, value2 = check2.value;
  return valCmp(data$1(ele, field), operator, value2);
};
match[Type.DATA_BOOL] = function(check2, ele) {
  var field = check2.field, operator = check2.operator;
  return boolCmp(data$1(ele, field), operator);
};
match[Type.DATA_EXIST] = function(check2, ele) {
  var field = check2.field;
  check2.operator;
  return existCmp(data$1(ele, field));
};
match[Type.UNDIRECTED_EDGE] = function(check2, ele) {
  var qA = check2.nodes[0];
  var qB = check2.nodes[1];
  var src = ele.source();
  var tgt = ele.target();
  return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);
};
match[Type.NODE_NEIGHBOR] = function(check2, ele) {
  return matches$1(check2.node, ele) && ele.neighborhood().some(function(n) {
    return n.isNode() && matches$1(check2.neighbor, n);
  });
};
match[Type.DIRECTED_EDGE] = function(check2, ele) {
  return matches$1(check2.source, ele.source()) && matches$1(check2.target, ele.target());
};
match[Type.NODE_SOURCE] = function(check2, ele) {
  return matches$1(check2.source, ele) && ele.outgoers().some(function(n) {
    return n.isNode() && matches$1(check2.target, n);
  });
};
match[Type.NODE_TARGET] = function(check2, ele) {
  return matches$1(check2.target, ele) && ele.incomers().some(function(n) {
    return n.isNode() && matches$1(check2.source, n);
  });
};
match[Type.CHILD] = function(check2, ele) {
  return matches$1(check2.child, ele) && matches$1(check2.parent, ele.parent());
};
match[Type.PARENT] = function(check2, ele) {
  return matches$1(check2.parent, ele) && ele.children().some(function(c) {
    return matches$1(check2.child, c);
  });
};
match[Type.DESCENDANT] = function(check2, ele) {
  return matches$1(check2.descendant, ele) && ele.ancestors().some(function(a) {
    return matches$1(check2.ancestor, a);
  });
};
match[Type.ANCESTOR] = function(check2, ele) {
  return matches$1(check2.ancestor, ele) && ele.descendants().some(function(d) {
    return matches$1(check2.descendant, d);
  });
};
match[Type.COMPOUND_SPLIT] = function(check2, ele) {
  return matches$1(check2.subject, ele) && matches$1(check2.left, ele) && matches$1(check2.right, ele);
};
match[Type.TRUE] = function() {
  return true;
};
match[Type.COLLECTION] = function(check2, ele) {
  var collection4 = check2.value;
  return collection4.has(ele);
};
match[Type.FILTER] = function(check2, ele) {
  var filter4 = check2.value;
  return filter4(ele);
};
var filter = /* @__PURE__ */ __name(function filter2(collection4) {
  var self2 = this;
  if (self2.length === 1 && self2[0].checks.length === 1 && self2[0].checks[0].type === Type.ID) {
    return collection4.getElementById(self2[0].checks[0].value).collection();
  }
  var selectorFunction = /* @__PURE__ */ __name(function selectorFunction2(element3) {
    for (var j = 0; j < self2.length; j++) {
      var query = self2[j];
      if (matches$1(query, element3)) {
        return true;
      }
    }
    return false;
  }, "selectorFunction2");
  if (self2.text() == null) {
    selectorFunction = /* @__PURE__ */ __name(function selectorFunction2() {
      return true;
    }, "selectorFunction2");
  }
  return collection4.filter(selectorFunction);
}, "filter2");
var matches31 = /* @__PURE__ */ __name(function matches32(ele) {
  var self2 = this;
  for (var j = 0; j < self2.length; j++) {
    var query = self2[j];
    if (matches$1(query, ele)) {
      return true;
    }
  }
  return false;
}, "matches32");
var matching = {
  matches: matches31,
  filter
};
var Selector = /* @__PURE__ */ __name(function Selector2(selector) {
  this.inputText = selector;
  this.currentSubject = null;
  this.compoundCount = 0;
  this.edgeCount = 0;
  this.length = 0;
  if (selector == null || string(selector) && selector.match(/^\s*$/)) ;
  else if (elementOrCollection(selector)) {
    this.addQuery({
      checks: [{
        type: Type.COLLECTION,
        value: selector.collection()
      }]
    });
  } else if (fn$6(selector)) {
    this.addQuery({
      checks: [{
        type: Type.FILTER,
        value: selector
      }]
    });
  } else if (string(selector)) {
    if (!this.parse(selector)) {
      this.invalid = true;
    }
  } else {
    error("A selector must be created from a string; found ");
  }
}, "Selector2");
var selfn = Selector.prototype;
[parse$1, matching].forEach(function(p2) {
  return extend(selfn, p2);
});
selfn.text = function() {
  return this.inputText;
};
selfn.size = function() {
  return this.length;
};
selfn.eq = function(i) {
  return this[i];
};
selfn.sameText = function(otherSel) {
  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
};
selfn.addQuery = function(q) {
  this[this.length++] = q;
};
selfn.selector = selfn.toString;
var elesfn$g = {
  allAre: /* @__PURE__ */ __name(function allAre(selector) {
    var selObj = new Selector(selector);
    return this.every(function(ele) {
      return selObj.matches(ele);
    });
  }, "allAre"),
  is: /* @__PURE__ */ __name(function is2(selector) {
    var selObj = new Selector(selector);
    return this.some(function(ele) {
      return selObj.matches(ele);
    });
  }, "is"),
  some: /* @__PURE__ */ __name(function some(fn3, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn3(this[i], i, this) : fn3.apply(thisArg, [this[i], i, this]);
      if (ret) {
        return true;
      }
    }
    return false;
  }, "some"),
  every: /* @__PURE__ */ __name(function every(fn3, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn3(this[i], i, this) : fn3.apply(thisArg, [this[i], i, this]);
      if (!ret) {
        return false;
      }
    }
    return true;
  }, "every"),
  same: /* @__PURE__ */ __name(function same(collection4) {
    if (this === collection4) {
      return true;
    }
    collection4 = this.cy().collection(collection4);
    var thisLength = this.length;
    var collectionLength = collection4.length;
    if (thisLength !== collectionLength) {
      return false;
    }
    if (thisLength === 1) {
      return this[0] === collection4[0];
    }
    return this.every(function(ele) {
      return collection4.hasElementWithId(ele.id());
    });
  }, "same"),
  anySame: /* @__PURE__ */ __name(function anySame(collection4) {
    collection4 = this.cy().collection(collection4);
    return this.some(function(ele) {
      return collection4.hasElementWithId(ele.id());
    });
  }, "anySame"),
  allAreNeighbors: /* @__PURE__ */ __name(function allAreNeighbors(collection4) {
    collection4 = this.cy().collection(collection4);
    var nhood = this.neighborhood();
    return collection4.every(function(ele) {
      return nhood.hasElementWithId(ele.id());
    });
  }, "allAreNeighbors"),
  contains: /* @__PURE__ */ __name(function contains(collection4) {
    collection4 = this.cy().collection(collection4);
    var self2 = this;
    return collection4.every(function(ele) {
      return self2.hasElementWithId(ele.id());
    });
  }, "contains")
};
elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;
elesfn$g.has = elesfn$g.contains;
elesfn$g.equal = elesfn$g.equals = elesfn$g.same;
var cache = /* @__PURE__ */ __name(function cache2(fn3, name) {
  return /* @__PURE__ */ __name(function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key2;
    if (selectorOrEles == null) {
      key2 = "";
    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key2 = selectorOrEles.id();
    }
    if (eles.length === 1 && key2) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || [];
      var hash2 = hashString(key2);
      var cacheHit = ch[hash2];
      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[hash2] = fn3.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn3.call(eles, arg1, arg2, arg3, arg4);
    }
  }, "traversalCache");
}, "cache2");
var elesfn$f = {
  parent: /* @__PURE__ */ __name(function parent(selector) {
    var parents2 = [];
    if (this.length === 1) {
      var parent4 = this[0]._private.parent;
      if (parent4) {
        return parent4;
      }
    }
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;
      if (_parent) {
        parents2.push(_parent);
      }
    }
    return this.spawn(parents2, true).filter(selector);
  }, "parent"),
  parents: /* @__PURE__ */ __name(function parents(selector) {
    var parents2 = [];
    var eles = this.parent();
    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents2.push(ele);
      }
      eles = eles.parent();
    }
    return this.spawn(parents2, true).filter(selector);
  }, "parents"),
  commonAncestors: /* @__PURE__ */ __name(function commonAncestors(selector) {
    var ancestors;
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents2 = ele.parents();
      ancestors = ancestors || parents2;
      ancestors = ancestors.intersect(parents2);
    }
    return ancestors.filter(selector);
  }, "commonAncestors"),
  orphans: /* @__PURE__ */ __name(function orphans(selector) {
    return this.stdFilter(function(ele) {
      return ele.isOrphan();
    }).filter(selector);
  }, "orphans"),
  nonorphans: /* @__PURE__ */ __name(function nonorphans(selector) {
    return this.stdFilter(function(ele) {
      return ele.isChild();
    }).filter(selector);
  }, "nonorphans"),
  children: cache(function(selector) {
    var children = [];
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var eleChildren = ele._private.children;
      for (var j = 0; j < eleChildren.length; j++) {
        children.push(eleChildren[j]);
      }
    }
    return this.spawn(children, true).filter(selector);
  }, "children"),
  siblings: /* @__PURE__ */ __name(function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  }, "siblings"),
  isParent: /* @__PURE__ */ __name(function isParent() {
    var ele = this[0];
    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  }, "isParent"),
  isChildless: /* @__PURE__ */ __name(function isChildless() {
    var ele = this[0];
    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  }, "isChildless"),
  isChild: /* @__PURE__ */ __name(function isChild() {
    var ele = this[0];
    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  }, "isChild"),
  isOrphan: /* @__PURE__ */ __name(function isOrphan() {
    var ele = this[0];
    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  }, "isOrphan"),
  descendants: /* @__PURE__ */ __name(function descendants(selector) {
    var elements = [];
    function add3(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        elements.push(ele);
        if (ele.children().nonempty()) {
          add3(ele.children());
        }
      }
    }
    __name(add3, "add3");
    add3(this.children());
    return this.spawn(elements, true).filter(selector);
  }, "descendants")
};
function forEachCompound(eles, fn3, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set$1();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }
  while (q.length > 0) {
    var _ele = q.shift();
    fn3(_ele);
    did.add(_ele.id());
    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }
  return eles;
}
__name(forEachCompound, "forEachCompound");
function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;
    for (var i = 0; i < children.length; i++) {
      var child2 = children[i];
      if (!did.has(child2.id())) {
        q.push(child2);
      }
    }
  }
}
__name(addChildren, "addChildren");
elesfn$f.forEachDown = function(fn3) {
  var includeSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return forEachCompound(this, fn3, includeSelf, addChildren);
};
function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent4 = ele._private.parent;
    if (!did.has(parent4.id())) {
      q.push(parent4);
    }
  }
}
__name(addParent, "addParent");
elesfn$f.forEachUp = function(fn3) {
  var includeSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return forEachCompound(this, fn3, includeSelf, addParent);
};
function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}
__name(addParentAndChildren, "addParentAndChildren");
elesfn$f.forEachUpAndDown = function(fn3) {
  var includeSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return forEachCompound(this, fn3, includeSelf, addParentAndChildren);
};
elesfn$f.ancestors = elesfn$f.parents;
var fn$5, elesfn$e;
fn$5 = elesfn$e = {
  data: define.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: true,
    allowSetting: true,
    settingEvent: "data",
    settingTriggersEvent: true,
    triggerFnName: "trigger",
    allowGetting: true,
    immutableKeys: {
      "id": true,
      "source": true,
      "target": true,
      "parent": true
    },
    updateStyle: true
  }),
  removeData: define.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: true,
    immutableKeys: {
      "id": true,
      "source": true,
      "target": true,
      "parent": true
    },
    updateStyle: true
  }),
  scratch: define.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: true,
    allowSetting: true,
    settingEvent: "scratch",
    settingTriggersEvent: true,
    triggerFnName: "trigger",
    allowGetting: true,
    updateStyle: true
  }),
  removeScratch: define.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: true,
    updateStyle: true
  }),
  rscratch: define.data({
    field: "rscratch",
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),
  removeRscratch: define.removeData({
    field: "rscratch",
    triggerEvent: false
  }),
  id: /* @__PURE__ */ __name(function id() {
    var ele = this[0];
    if (ele) {
      return ele._private.data.id;
    }
  }, "id")
};
fn$5.attr = fn$5.data;
fn$5.removeAttr = fn$5.removeData;
var data3 = elesfn$e;
var elesfn$d = {};
function defineDegreeFunction(callback) {
  return function(includeLoops) {
    var self2 = this;
    if (includeLoops === void 0) {
      includeLoops = true;
    }
    if (self2.length === 0) {
      return;
    }
    if (self2.isNode() && !self2.removed()) {
      var degree = 0;
      var node = self2[0];
      var connectedEdges = node._private.edges;
      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];
        if (!includeLoops && edge.isLoop()) {
          continue;
        }
        degree += callback(node, edge);
      }
      return degree;
    } else {
      return;
    }
  };
}
__name(defineDegreeFunction, "defineDegreeFunction");
extend(elesfn$d, {
  degree: defineDegreeFunction(function(node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),
  indegree: defineDegreeFunction(function(node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),
  outdegree: defineDegreeFunction(function(node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});
function defineDegreeBoundsFunction(degreeFn, callback) {
  return function(includeLoops) {
    var ret;
    var nodes3 = this.nodes();
    for (var i = 0; i < nodes3.length; i++) {
      var ele = nodes3[i];
      var degree = ele[degreeFn](includeLoops);
      if (degree !== void 0 && (ret === void 0 || callback(degree, ret))) {
        ret = degree;
      }
    }
    return ret;
  };
}
__name(defineDegreeBoundsFunction, "defineDegreeBoundsFunction");
extend(elesfn$d, {
  minDegree: defineDegreeBoundsFunction("degree", function(degree, min4) {
    return degree < min4;
  }),
  maxDegree: defineDegreeBoundsFunction("degree", function(degree, max5) {
    return degree > max5;
  }),
  minIndegree: defineDegreeBoundsFunction("indegree", function(degree, min4) {
    return degree < min4;
  }),
  maxIndegree: defineDegreeBoundsFunction("indegree", function(degree, max5) {
    return degree > max5;
  }),
  minOutdegree: defineDegreeBoundsFunction("outdegree", function(degree, min4) {
    return degree < min4;
  }),
  maxOutdegree: defineDegreeBoundsFunction("outdegree", function(degree, max5) {
    return degree > max5;
  })
});
extend(elesfn$d, {
  totalDegree: /* @__PURE__ */ __name(function totalDegree(includeLoops) {
    var total = 0;
    var nodes3 = this.nodes();
    for (var i = 0; i < nodes3.length; i++) {
      total += nodes3[i].degree(includeLoops);
    }
    return total;
  }, "totalDegree")
});
var fn$4, elesfn$c;
var beforePositionSet = /* @__PURE__ */ __name(function beforePositionSet2(eles, newPos, silent) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    if (!ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x != null ? newPos.x - oldPos.x : 0,
        y: newPos.y != null ? newPos.y - oldPos.y : 0
      };
      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
        ele.children().shift(delta, silent);
      }
      ele.dirtyBoundingBoxCache();
    }
  }
}, "beforePositionSet2");
var positionDef = {
  field: "position",
  bindingEvent: "position",
  allowBinding: true,
  allowSetting: true,
  settingEvent: "position",
  settingTriggersEvent: true,
  triggerFnName: "emitAndNotify",
  allowGetting: true,
  validKeys: ["x", "y"],
  beforeGet: /* @__PURE__ */ __name(function beforeGet(ele) {
    ele.updateCompoundBounds();
  }, "beforeGet"),
  beforeSet: /* @__PURE__ */ __name(function beforeSet(eles, newPos) {
    beforePositionSet(eles, newPos, false);
  }, "beforeSet"),
  onSet: /* @__PURE__ */ __name(function onSet(eles) {
    eles.dirtyCompoundBoundsCache();
  }, "onSet"),
  canSet: /* @__PURE__ */ __name(function canSet(ele) {
    return !ele.locked();
  }, "canSet")
};
fn$4 = elesfn$c = {
  position: define.data(positionDef),
  // position but no notification to renderer
  silentPosition: define.data(extend({}, positionDef, {
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: false,
    beforeSet: /* @__PURE__ */ __name(function beforeSet2(eles, newPos) {
      beforePositionSet(eles, newPos, true);
    }, "beforeSet2"),
    onSet: /* @__PURE__ */ __name(function onSet2(eles) {
      eles.dirtyCompoundBoundsCache();
    }, "onSet2")
  })),
  positions: /* @__PURE__ */ __name(function positions(pos, silent) {
    if (plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (fn$6(pos)) {
      var _fn = pos;
      var cy = this.cy();
      cy.startBatch();
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var _pos = void 0;
        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }
      cy.endBatch();
    }
    return this;
  }, "positions"),
  silentPositions: /* @__PURE__ */ __name(function silentPositions(pos) {
    return this.positions(pos, true);
  }, "silentPositions"),
  shift: /* @__PURE__ */ __name(function shift(dim, val, silent) {
    var delta;
    if (plainObject(dim)) {
      delta = {
        x: number$1(dim.x) ? dim.x : 0,
        y: number$1(dim.y) ? dim.y : 0
      };
      silent = val;
    } else if (string(dim) && number$1(val)) {
      delta = {
        x: 0,
        y: 0
      };
      delta[dim] = val;
    }
    if (delta != null) {
      var cy = this.cy();
      cy.startBatch();
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {
          continue;
        }
        var pos = ele.position();
        var newPos = {
          x: pos.x + delta.x,
          y: pos.y + delta.y
        };
        if (silent) {
          ele.silentPosition(newPos);
        } else {
          ele.position(newPos);
        }
      }
      cy.endBatch();
    }
    return this;
  }, "shift"),
  silentShift: /* @__PURE__ */ __name(function silentShift(dim, val) {
    if (plainObject(dim)) {
      this.shift(dim, true);
    } else if (string(dim) && number$1(val)) {
      this.shift(dim, val, true);
    }
    return this;
  }, "silentShift"),
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: /* @__PURE__ */ __name(function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom2 = cy.zoom();
    var pan2 = cy.pan();
    var rpos = plainObject(dim) ? dim : void 0;
    var setting = rpos !== void 0 || val !== void 0 && string(dim);
    if (ele && ele.isNode()) {
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];
          if (val !== void 0) {
            _ele.position(dim, (val - pan2[dim]) / zoom2);
          } else if (rpos !== void 0) {
            _ele.position(renderedToModelPosition(rpos, zoom2, pan2));
          }
        }
      } else {
        var pos = ele.position();
        rpos = modelToRenderedPosition$1(pos, zoom2, pan2);
        if (dim === void 0) {
          return rpos;
        } else {
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return void 0;
    }
    return this;
  }, "renderedPosition"),
  // get/set the position relative to the parent
  relativePosition: /* @__PURE__ */ __name(function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = plainObject(dim) ? dim : void 0;
    var setting = ppos !== void 0 || val !== void 0 && string(dim);
    var hasCompoundNodes2 = cy.hasCompoundNodes();
    if (ele && ele.isNode()) {
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent4 = hasCompoundNodes2 ? _ele2.parent() : null;
          var hasParent = parent4 && parent4.length > 0;
          var relativeToParent = hasParent;
          if (hasParent) {
            parent4 = parent4[0];
          }
          var origin = relativeToParent ? parent4.position() : {
            x: 0,
            y: 0
          };
          if (val !== void 0) {
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== void 0) {
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        var pos = ele.position();
        var _parent = hasCompoundNodes2 ? ele.parent() : null;
        var _hasParent = _parent && _parent.length > 0;
        var _relativeToParent = _hasParent;
        if (_hasParent) {
          _parent = _parent[0];
        }
        var _origin = _relativeToParent ? _parent.position() : {
          x: 0,
          y: 0
        };
        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };
        if (dim === void 0) {
          return ppos;
        } else {
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return void 0;
    }
    return this;
  }, "relativePosition")
};
fn$4.modelPosition = fn$4.point = fn$4.position;
fn$4.modelPositions = fn$4.points = fn$4.positions;
fn$4.renderedPoint = fn$4.renderedPosition;
fn$4.relativePoint = fn$4.relativePosition;
var position = elesfn$c;
var fn$3, elesfn$b;
fn$3 = elesfn$b = {};
elesfn$b.renderedBoundingBox = function(options2) {
  var bb = this.boundingBox(options2);
  var cy = this.cy();
  var zoom2 = cy.zoom();
  var pan2 = cy.pan();
  var x1 = bb.x1 * zoom2 + pan2.x;
  var x2 = bb.x2 * zoom2 + pan2.x;
  var y1 = bb.y1 * zoom2 + pan2.y;
  var y2 = bb.y2 * zoom2 + pan2.y;
  return {
    x1,
    x2,
    y1,
    y2,
    w: x2 - x1,
    h: y2 - y1
  };
};
elesfn$b.dirtyCompoundBoundsCache = function() {
  var silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var cy = this.cy();
  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }
  this.forEachUp(function(ele) {
    if (ele.isParent()) {
      var _p = ele._private;
      _p.compoundBoundsClean = false;
      _p.bbCache = null;
      if (!silent) {
        ele.emitAndNotify("bounds");
      }
    }
  });
  return this;
};
elesfn$b.updateCompoundBounds = function() {
  var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var cy = this.cy();
  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }
  if (!force && cy.batching()) {
    return this;
  }
  function update2(parent4) {
    if (!parent4.isParent()) {
      return;
    }
    var _p2 = parent4._private;
    var children = parent4.children();
    var includeLabels = parent4.pstyle("compound-sizing-wrt-labels").value === "include";
    var min4 = {
      width: {
        val: parent4.pstyle("min-width").pfValue,
        left: parent4.pstyle("min-width-bias-left"),
        right: parent4.pstyle("min-width-bias-right")
      },
      height: {
        val: parent4.pstyle("min-height").pfValue,
        top: parent4.pstyle("min-height-bias-top"),
        bottom: parent4.pstyle("min-height-bias-bottom")
      }
    };
    var bb = children.boundingBox({
      includeLabels,
      includeOverlays: false,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p2.position;
    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent4.pstyle("width").pfValue,
        h: parent4.pstyle("height").pfValue
      };
      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }
    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;
      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }
      return {
        biasDiff,
        biasComplementDiff
      };
    }
    __name(computeBiasValues, "computeBiasValues");
    function computePaddingValues(width2, height2, paddingObject, relativeTo) {
      if (paddingObject.units === "%") {
        switch (relativeTo) {
          case "width":
            return width2 > 0 ? paddingObject.pfValue * width2 : 0;
          case "height":
            return height2 > 0 ? paddingObject.pfValue * height2 : 0;
          case "average":
            return width2 > 0 && height2 > 0 ? paddingObject.pfValue * (width2 + height2) / 2 : 0;
          case "min":
            return width2 > 0 && height2 > 0 ? width2 > height2 ? paddingObject.pfValue * height2 : paddingObject.pfValue * width2 : 0;
          case "max":
            return width2 > 0 && height2 > 0 ? width2 > height2 ? paddingObject.pfValue * width2 : paddingObject.pfValue * height2 : 0;
          default:
            return 0;
        }
      } else if (paddingObject.units === "px") {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }
    __name(computePaddingValues, "computePaddingValues");
    var leftVal = min4.width.left.value;
    if (min4.width.left.units === "px" && min4.width.val > 0) {
      leftVal = leftVal * 100 / min4.width.val;
    }
    var rightVal = min4.width.right.value;
    if (min4.width.right.units === "px" && min4.width.val > 0) {
      rightVal = rightVal * 100 / min4.width.val;
    }
    var topVal = min4.height.top.value;
    if (min4.height.top.units === "px" && min4.height.val > 0) {
      topVal = topVal * 100 / min4.height.val;
    }
    var bottomVal = min4.height.bottom.value;
    if (min4.height.bottom.units === "px" && min4.height.val > 0) {
      bottomVal = bottomVal * 100 / min4.height.val;
    }
    var widthBiasDiffs = computeBiasValues(min4.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;
    var heightBiasDiffs = computeBiasValues(min4.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;
    _p2.autoPadding = computePaddingValues(bb.w, bb.h, parent4.pstyle("padding"), parent4.pstyle("padding-relative-to").value);
    _p2.autoWidth = Math.max(bb.w, min4.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
    _p2.autoHeight = Math.max(bb.h, min4.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
  }
  __name(update2, "update");
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;
    if (!_p.compoundBoundsClean || force) {
      update2(ele);
      if (!cy.batching()) {
        _p.compoundBoundsClean = true;
      }
    }
  }
  return this;
};
var noninf = /* @__PURE__ */ __name(function noninf2(x2) {
  if (x2 === Infinity || x2 === -Infinity) {
    return 0;
  }
  return x2;
}, "noninf2");
var updateBounds = /* @__PURE__ */ __name(function updateBounds2(b, x1, y1, x2, y2) {
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  }
  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }
  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
  b.w = b.x2 - b.x1;
  b.h = b.y2 - b.y1;
}, "updateBounds2");
var updateBoundsFromBox = /* @__PURE__ */ __name(function updateBoundsFromBox2(b, b2) {
  if (b2 == null) {
    return b;
  }
  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
}, "updateBoundsFromBox2");
var prefixedProperty = /* @__PURE__ */ __name(function prefixedProperty2(obj, field, prefix) {
  return getPrefixedProperty(obj, field, prefix);
}, "prefixedProperty2");
var updateBoundsFromArrow = /* @__PURE__ */ __name(function updateBoundsFromArrow2(bounds2, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }
  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + "-arrow-shape").value;
  var x2;
  var y2;
  if (arrowType !== "none") {
    if (prefix === "source") {
      x2 = rstyle.srcX;
      y2 = rstyle.srcY;
    } else if (prefix === "target") {
      x2 = rstyle.tgtX;
      y2 = rstyle.tgtY;
    } else {
      x2 = rstyle.midX;
      y2 = rstyle.midY;
    }
    var bbs = _p.arrowBounds = _p.arrowBounds || {};
    var bb = bbs[prefix] = bbs[prefix] || {};
    bb.x1 = x2 - halfArW;
    bb.y1 = y2 - halfArW;
    bb.x2 = x2 + halfArW;
    bb.y2 = y2 + halfArW;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    expandBoundingBox(bb, 1);
    updateBounds(bounds2, bb.x1, bb.y1, bb.x2, bb.y2);
  }
}, "updateBoundsFromArrow2");
var updateBoundsFromLabel = /* @__PURE__ */ __name(function updateBoundsFromLabel2(bounds2, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }
  var prefixDash;
  if (prefix) {
    prefixDash = prefix + "-";
  } else {
    prefixDash = "";
  }
  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label2 = ele.pstyle(prefixDash + "label").strValue;
  if (label2) {
    var halign = ele.pstyle("text-halign");
    var valign = ele.pstyle("text-valign");
    var labelWidth = prefixedProperty(rstyle, "labelWidth", prefix);
    var labelHeight = prefixedProperty(rstyle, "labelHeight", prefix);
    var labelX = prefixedProperty(rstyle, "labelX", prefix);
    var labelY = prefixedProperty(rstyle, "labelY", prefix);
    var marginX = ele.pstyle(prefixDash + "text-margin-x").pfValue;
    var marginY = ele.pstyle(prefixDash + "text-margin-y").pfValue;
    var isEdge2 = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + "text-rotation");
    var outlineWidth = ele.pstyle("text-outline-width").pfValue;
    var borderWidth = ele.pstyle("text-border-width").pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle("text-background-padding").pfValue;
    var marginOfError = 2;
    var lh = labelHeight;
    var lw = labelWidth;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;
    if (isEdge2) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case "left":
          lx1 = labelX - lw;
          lx2 = labelX;
          break;
        case "center":
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;
        case "right":
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }
      switch (valign.value) {
        case "top":
          ly1 = labelY - lh;
          ly2 = labelY;
          break;
        case "center":
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;
        case "bottom":
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }
    var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
    var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;
    var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
    var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;
    lx1 += leftPad;
    lx2 += rightPad;
    ly1 += topPad;
    ly2 += botPad;
    var bbPrefix = prefix || "main";
    var bbs = _p.labelBounds;
    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
    bb.x1 = lx1;
    bb.y1 = ly1;
    bb.x2 = lx2;
    bb.y2 = ly2;
    bb.w = lx2 - lx1;
    bb.h = ly2 - ly1;
    bb.leftPad = leftPad;
    bb.rightPad = rightPad;
    bb.topPad = topPad;
    bb.botPad = botPad;
    var isAutorotate = isEdge2 && rotation.strValue === "autorotate";
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;
    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, "labelAngle", prefix) : rotation.pfValue;
      var cos2 = Math.cos(theta);
      var sin2 = Math.sin(theta);
      var xo = (lx1 + lx2) / 2;
      var yo = (ly1 + ly2) / 2;
      if (!isEdge2) {
        switch (halign.value) {
          case "left":
            xo = lx2;
            break;
          case "right":
            xo = lx1;
            break;
        }
        switch (valign.value) {
          case "top":
            yo = ly2;
            break;
          case "bottom":
            yo = ly1;
            break;
        }
      }
      var rotate2 = /* @__PURE__ */ __name(function rotate3(x2, y2) {
        x2 = x2 - xo;
        y2 = y2 - yo;
        return {
          x: x2 * cos2 - y2 * sin2 + xo,
          y: x2 * sin2 + y2 * cos2 + yo
        };
      }, "rotate3");
      var px1y1 = rotate2(lx1, ly1);
      var px1y2 = rotate2(lx1, ly2);
      var px2y1 = rotate2(lx2, ly1);
      var px2y2 = rotate2(lx2, ly2);
      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }
    var bbPrefixRot = bbPrefix + "Rot";
    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
    bbRot.x1 = lx1;
    bbRot.y1 = ly1;
    bbRot.x2 = lx2;
    bbRot.y2 = ly2;
    bbRot.w = lx2 - lx1;
    bbRot.h = ly2 - ly1;
    updateBounds(bounds2, lx1, ly1, lx2, ly2);
    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
  }
  return bounds2;
}, "updateBoundsFromLabel2");
var updateBoundsFromOutline = /* @__PURE__ */ __name(function updateBoundsFromOutline2(bounds2, ele) {
  if (ele.cy().headless()) {
    return;
  }
  var outlineOpacity = ele.pstyle("outline-opacity").value;
  var outlineWidth = ele.pstyle("outline-width").value;
  var outlineOffset = ele.pstyle("outline-offset").value;
  var expansion = outlineWidth + outlineOffset;
  updateBoundsFromMiter(bounds2, ele, outlineOpacity, expansion, "outside", expansion / 2);
}, "updateBoundsFromOutline2");
var updateBoundsFromMiter = /* @__PURE__ */ __name(function updateBoundsFromMiter2(bounds2, ele, opacity, expansionSize, expansionPosition, useFallbackValue) {
  if (opacity === 0 || expansionSize <= 0 || expansionPosition === "inside") {
    return;
  }
  var cy = ele.cy();
  var shape = ele.pstyle("shape").value;
  var rshape = cy.renderer().nodeShapes[shape];
  var _ele$position = ele.position(), x2 = _ele$position.x, y2 = _ele$position.y;
  var w = ele.width();
  var h = ele.height();
  if (rshape.hasMiterBounds) {
    if (expansionPosition === "center") {
      expansionSize /= 2;
    }
    var mbb = rshape.miterBounds(x2, y2, w, h, expansionSize);
    updateBoundsFromBox(bounds2, mbb);
  } else if (useFallbackValue != null && useFallbackValue > 0) {
    expandBoundingBoxSides(bounds2, [useFallbackValue, useFallbackValue, useFallbackValue, useFallbackValue]);
  }
}, "updateBoundsFromMiter2");
var updateBoundsFromMiterBorder = /* @__PURE__ */ __name(function updateBoundsFromMiterBorder2(bounds2, ele) {
  if (ele.cy().headless()) {
    return;
  }
  var borderOpacity = ele.pstyle("border-opacity").value;
  var borderWidth = ele.pstyle("border-width").pfValue;
  var borderPosition = ele.pstyle("border-position").value;
  updateBoundsFromMiter(bounds2, ele, borderOpacity, borderWidth, borderPosition);
}, "updateBoundsFromMiterBorder2");
var boundingBoxImpl = /* @__PURE__ */ __name(function boundingBoxImpl2(ele, options2) {
  var cy = ele._private.cy;
  var styleEnabled2 = cy.styleEnabled();
  var headless2 = cy.headless();
  var bounds2 = makeBoundingBox();
  var _p = ele._private;
  var isNode2 = ele.isNode();
  var isEdge2 = ele.isEdge();
  var ex1, ex2, ey1, ey2;
  var x2, y2;
  var rstyle = _p.rstyle;
  var manualExpansion = isNode2 && styleEnabled2 ? ele.pstyle("bounds-expansion").pfValue : [0];
  var isDisplayed = /* @__PURE__ */ __name(function isDisplayed2(ele2) {
    return ele2.pstyle("display").value !== "none";
  }, "isDisplayed2");
  var displayed = !styleEnabled2 || isDisplayed(ele) && (!isEdge2 || isDisplayed(ele.source()) && isDisplayed(ele.target()));
  if (displayed) {
    var overlayOpacity = 0;
    var overlayPadding = 0;
    if (styleEnabled2 && options2.includeOverlays) {
      overlayOpacity = ele.pstyle("overlay-opacity").value;
      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle("overlay-padding").value;
      }
    }
    var underlayOpacity = 0;
    var underlayPadding = 0;
    if (styleEnabled2 && options2.includeUnderlays) {
      underlayOpacity = ele.pstyle("underlay-opacity").value;
      if (underlayOpacity !== 0) {
        underlayPadding = ele.pstyle("underlay-padding").value;
      }
    }
    var padding = Math.max(overlayPadding, underlayPadding);
    var w = 0;
    var wHalf = 0;
    if (styleEnabled2) {
      w = ele.pstyle("width").pfValue;
      wHalf = w / 2;
    }
    if (isNode2 && options2.includeNodes) {
      var pos = ele.position();
      x2 = pos.x;
      y2 = pos.y;
      var _w = ele.outerWidth();
      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;
      ex1 = x2 - halfW;
      ex2 = x2 + halfW;
      ey1 = y2 - halfH;
      ey2 = y2 + halfH;
      updateBounds(bounds2, ex1, ey1, ex2, ey2);
      if (styleEnabled2) {
        updateBoundsFromOutline(bounds2, ele);
      }
      if (styleEnabled2 && options2.includeOutlines && !headless2) {
        updateBoundsFromOutline(bounds2, ele);
      }
      if (styleEnabled2) {
        updateBoundsFromMiterBorder(bounds2, ele);
      }
    } else if (isEdge2 && options2.includeEdges) {
      if (styleEnabled2 && !headless2) {
        var curveStyle = ele.pstyle("curve-style").strValue;
        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds2, ex1, ey1, ex2, ey2);
        if (curveStyle === "haystack") {
          var hpts = rstyle.haystackPts;
          if (hpts && hpts.length === 2) {
            ex1 = hpts[0].x;
            ey1 = hpts[0].y;
            ex2 = hpts[1].x;
            ey2 = hpts[1].y;
            if (ex1 > ex2) {
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }
            if (ey1 > ey2) {
              var _temp = ey1;
              ey1 = ey2;
              ey2 = _temp;
            }
            updateBounds(bounds2, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
          }
        } else if (curveStyle === "bezier" || curveStyle === "unbundled-bezier" || endsWith(curveStyle, "segments") || endsWith(curveStyle, "taxi")) {
          var pts2;
          switch (curveStyle) {
            case "bezier":
            case "unbundled-bezier":
              pts2 = rstyle.bezierPts;
              break;
            case "segments":
            case "taxi":
            case "round-segments":
            case "round-taxi":
              pts2 = rstyle.linePts;
              break;
          }
          if (pts2 != null) {
            for (var j = 0; j < pts2.length; j++) {
              var pt = pts2[j];
              ex1 = pt.x - wHalf;
              ex2 = pt.x + wHalf;
              ey1 = pt.y - wHalf;
              ey2 = pt.y + wHalf;
              updateBounds(bounds2, ex1, ey1, ex2, ey2);
            }
          }
        }
      } else {
        var n1 = ele.source();
        var n1pos = n1.position();
        var n2 = ele.target();
        var n2pos = n2.position();
        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;
        if (ex1 > ex2) {
          var _temp2 = ex1;
          ex1 = ex2;
          ex2 = _temp2;
        }
        if (ey1 > ey2) {
          var _temp3 = ey1;
          ey1 = ey2;
          ey2 = _temp3;
        }
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds2, ex1, ey1, ex2, ey2);
      }
    }
    if (styleEnabled2 && options2.includeEdges && isEdge2) {
      updateBoundsFromArrow(bounds2, ele, "mid-source");
      updateBoundsFromArrow(bounds2, ele, "mid-target");
      updateBoundsFromArrow(bounds2, ele, "source");
      updateBoundsFromArrow(bounds2, ele, "target");
    }
    if (styleEnabled2) {
      var ghost = ele.pstyle("ghost").value === "yes";
      if (ghost) {
        var gx = ele.pstyle("ghost-offset-x").pfValue;
        var gy = ele.pstyle("ghost-offset-y").pfValue;
        updateBounds(bounds2, bounds2.x1 + gx, bounds2.y1 + gy, bounds2.x2 + gx, bounds2.y2 + gy);
      }
    }
    var bbBody = _p.bodyBounds = _p.bodyBounds || {};
    assignBoundingBox(bbBody, bounds2);
    expandBoundingBoxSides(bbBody, manualExpansion);
    expandBoundingBox(bbBody, 1);
    if (styleEnabled2) {
      ex1 = bounds2.x1;
      ex2 = bounds2.x2;
      ey1 = bounds2.y1;
      ey2 = bounds2.y2;
      updateBounds(bounds2, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);
    }
    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
    assignBoundingBox(bbOverlay, bounds2);
    expandBoundingBoxSides(bbOverlay, manualExpansion);
    expandBoundingBox(bbOverlay, 1);
    var bbLabels = _p.labelBounds = _p.labelBounds || {};
    if (bbLabels.all != null) {
      clearBoundingBox(bbLabels.all);
    } else {
      bbLabels.all = makeBoundingBox();
    }
    if (styleEnabled2 && options2.includeLabels) {
      if (options2.includeMainLabels) {
        updateBoundsFromLabel(bounds2, ele, null);
      }
      if (isEdge2) {
        if (options2.includeSourceLabels) {
          updateBoundsFromLabel(bounds2, ele, "source");
        }
        if (options2.includeTargetLabels) {
          updateBoundsFromLabel(bounds2, ele, "target");
        }
      }
    }
  }
  bounds2.x1 = noninf(bounds2.x1);
  bounds2.y1 = noninf(bounds2.y1);
  bounds2.x2 = noninf(bounds2.x2);
  bounds2.y2 = noninf(bounds2.y2);
  bounds2.w = noninf(bounds2.x2 - bounds2.x1);
  bounds2.h = noninf(bounds2.y2 - bounds2.y1);
  if (bounds2.w > 0 && bounds2.h > 0 && displayed) {
    expandBoundingBoxSides(bounds2, manualExpansion);
    expandBoundingBox(bounds2, 1);
  }
  return bounds2;
}, "boundingBoxImpl2");
var getKey = /* @__PURE__ */ __name(function getKey2(opts) {
  var i = 0;
  var tf = /* @__PURE__ */ __name(function tf2(val) {
    return (val ? 1 : 0) << i++;
  }, "tf2");
  var key2 = 0;
  key2 += tf(opts.incudeNodes);
  key2 += tf(opts.includeEdges);
  key2 += tf(opts.includeLabels);
  key2 += tf(opts.includeMainLabels);
  key2 += tf(opts.includeSourceLabels);
  key2 += tf(opts.includeTargetLabels);
  key2 += tf(opts.includeOverlays);
  key2 += tf(opts.includeOutlines);
  return key2;
}, "getKey2");
var getBoundingBoxPosKey = /* @__PURE__ */ __name(function getBoundingBoxPosKey2(ele) {
  var r2 = /* @__PURE__ */ __name(function r22(x2) {
    return Math.round(x2);
  }, "r2");
  if (ele.isEdge()) {
    var p1 = ele.source().position();
    var p2 = ele.target().position();
    return hashIntsArray([r2(p1.x), r2(p1.y), r2(p2.x), r2(p2.y)]);
  } else {
    var p3 = ele.position();
    return hashIntsArray([r2(p3.x), r2(p3.y)]);
  }
}, "getBoundingBoxPosKey2");
var cachedBoundingBoxImpl = /* @__PURE__ */ __name(function cachedBoundingBoxImpl2(ele, opts) {
  var _p = ele._private;
  var bb;
  var isEdge2 = ele.isEdge();
  var key2 = opts == null ? defBbOptsKey : getKey(opts);
  var usingDefOpts = key2 === defBbOptsKey;
  if (_p.bbCache == null) {
    bb = boundingBoxImpl(ele, defBbOpts);
    _p.bbCache = bb;
    _p.bbCachePosKey = getBoundingBoxPosKey(ele);
  } else {
    bb = _p.bbCache;
  }
  if (!usingDefOpts) {
    var isNode2 = ele.isNode();
    bb = makeBoundingBox();
    if (opts.includeNodes && isNode2 || opts.includeEdges && !isNode2) {
      if (opts.includeOverlays) {
        updateBoundsFromBox(bb, _p.overlayBounds);
      } else {
        updateBoundsFromBox(bb, _p.bodyBounds);
      }
    }
    if (opts.includeLabels) {
      if (opts.includeMainLabels && (!isEdge2 || opts.includeSourceLabels && opts.includeTargetLabels)) {
        updateBoundsFromBox(bb, _p.labelBounds.all);
      } else {
        if (opts.includeMainLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.mainRot);
        }
        if (opts.includeSourceLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
        }
        if (opts.includeTargetLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.targetRot);
        }
      }
    }
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
  }
  return bb;
}, "cachedBoundingBoxImpl2");
var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeMainLabels: true,
  includeSourceLabels: true,
  includeTargetLabels: true,
  includeOverlays: true,
  includeUnderlays: true,
  includeOutlines: true,
  useCache: true
};
var defBbOptsKey = getKey(defBbOpts);
var filledBbOpts = defaults$g(defBbOpts);
elesfn$b.boundingBox = function(options2) {
  var bounds2;
  var useCache = options2 === void 0 || options2.useCache === void 0 || options2.useCache === true;
  var isDirty = memoize(function(ele2) {
    var _p = ele2._private;
    return _p.bbCache == null || _p.styleDirty || _p.bbCachePosKey !== getBoundingBoxPosKey(ele2);
  }, function(ele2) {
    return ele2.id();
  });
  if (useCache && this.length === 1 && !isDirty(this[0])) {
    if (options2 === void 0) {
      options2 = defBbOpts;
    } else {
      options2 = filledBbOpts(options2);
    }
    bounds2 = cachedBoundingBoxImpl(this[0], options2);
  } else {
    bounds2 = makeBoundingBox();
    options2 = options2 || defBbOpts;
    var opts = filledBbOpts(options2);
    var eles = this;
    var cy = eles.cy();
    var styleEnabled2 = cy.styleEnabled();
    this.edges().forEach(isDirty);
    this.nodes().forEach(isDirty);
    if (styleEnabled2) {
      this.recalculateRenderedStyle(useCache);
    }
    this.updateCompoundBounds(!useCache);
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (isDirty(ele)) {
        ele.dirtyBoundingBoxCache();
      }
      updateBoundsFromBox(bounds2, cachedBoundingBoxImpl(ele, opts));
    }
  }
  bounds2.x1 = noninf(bounds2.x1);
  bounds2.y1 = noninf(bounds2.y1);
  bounds2.x2 = noninf(bounds2.x2);
  bounds2.y2 = noninf(bounds2.y2);
  bounds2.w = noninf(bounds2.x2 - bounds2.x1);
  bounds2.h = noninf(bounds2.y2 - bounds2.y1);
  return bounds2;
};
elesfn$b.dirtyBoundingBoxCache = function() {
  for (var i = 0; i < this.length; i++) {
    var _p = this[i]._private;
    _p.bbCache = null;
    _p.bbCachePosKey = null;
    _p.bodyBounds = null;
    _p.overlayBounds = null;
    _p.labelBounds.all = null;
    _p.labelBounds.source = null;
    _p.labelBounds.target = null;
    _p.labelBounds.main = null;
    _p.labelBounds.sourceRot = null;
    _p.labelBounds.targetRot = null;
    _p.labelBounds.mainRot = null;
    _p.arrowBounds.source = null;
    _p.arrowBounds.target = null;
    _p.arrowBounds["mid-source"] = null;
    _p.arrowBounds["mid-target"] = null;
  }
  this.emitAndNotify("bounds");
  return this;
};
elesfn$b.boundingBoxAt = function(fn3) {
  var nodes3 = this.nodes();
  var cy = this.cy();
  var hasCompoundNodes2 = cy.hasCompoundNodes();
  var parents2 = cy.collection();
  if (hasCompoundNodes2) {
    parents2 = nodes3.filter(function(node) {
      return node.isParent();
    });
    nodes3 = nodes3.not(parents2);
  }
  if (plainObject(fn3)) {
    var obj = fn3;
    fn3 = /* @__PURE__ */ __name(function fn4() {
      return obj;
    }, "fn4");
  }
  var storeOldPos = /* @__PURE__ */ __name(function storeOldPos2(node, i) {
    return node._private.bbAtOldPos = fn3(node, i);
  }, "storeOldPos2");
  var getOldPos = /* @__PURE__ */ __name(function getOldPos2(node) {
    return node._private.bbAtOldPos;
  }, "getOldPos2");
  cy.startBatch();
  nodes3.forEach(storeOldPos).silentPositions(fn3);
  if (hasCompoundNodes2) {
    parents2.dirtyCompoundBoundsCache();
    parents2.dirtyBoundingBoxCache();
    parents2.updateCompoundBounds(true);
  }
  var bb = copyBoundingBox(this.boundingBox({
    useCache: false
  }));
  nodes3.silentPositions(getOldPos);
  if (hasCompoundNodes2) {
    parents2.dirtyCompoundBoundsCache();
    parents2.dirtyBoundingBoxCache();
    parents2.updateCompoundBounds(true);
  }
  cy.endBatch();
  return bb;
};
fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
var bounds = elesfn$b;
var fn$2, elesfn$a;
fn$2 = elesfn$a = {};
var defineDimFns = /* @__PURE__ */ __name(function defineDimFns2(opts) {
  opts.uppercaseName = capitalize(opts.name);
  opts.autoName = "auto" + opts.uppercaseName;
  opts.labelName = "label" + opts.uppercaseName;
  opts.outerName = "outer" + opts.uppercaseName;
  opts.uppercaseOuterName = capitalize(opts.outerName);
  fn$2[opts.name] = /* @__PURE__ */ __name(function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled2 = cy._private.styleEnabled;
    if (ele) {
      if (styleEnabled2) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();
          return _p[opts.autoName] || 0;
        }
        var d = ele.pstyle(opts.name);
        switch (d.strValue) {
          case "label":
            ele.recalculateRenderedStyle();
            return _p.rstyle[opts.labelName] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  }, "dimImpl");
  fn$2["outer" + opts.uppercaseName] = /* @__PURE__ */ __name(function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled2 = cy._private.styleEnabled;
    if (ele) {
      if (styleEnabled2) {
        var dim = ele[opts.name]();
        var borderPos = ele.pstyle("border-position").value;
        var border;
        if (borderPos === "center") {
          border = ele.pstyle("border-width").pfValue;
        } else if (borderPos === "outside") {
          border = 2 * ele.pstyle("border-width").pfValue;
        } else {
          border = 0;
        }
        var padding = 2 * ele.padding();
        return dim + border + padding;
      } else {
        return 1;
      }
    }
  }, "outerDimImpl");
  fn$2["rendered" + opts.uppercaseName] = /* @__PURE__ */ __name(function renderedDimImpl() {
    var ele = this[0];
    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  }, "renderedDimImpl");
  fn$2["rendered" + opts.uppercaseOuterName] = /* @__PURE__ */ __name(function renderedOuterDimImpl() {
    var ele = this[0];
    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  }, "renderedOuterDimImpl");
}, "defineDimFns2");
defineDimFns({
  name: "width"
});
defineDimFns({
  name: "height"
});
elesfn$a.padding = function() {
  var ele = this[0];
  var _p = ele._private;
  if (ele.isParent()) {
    ele.updateCompoundBounds();
    if (_p.autoPadding !== void 0) {
      return _p.autoPadding;
    } else {
      return ele.pstyle("padding").pfValue;
    }
  } else {
    return ele.pstyle("padding").pfValue;
  }
};
elesfn$a.paddedHeight = function() {
  var ele = this[0];
  return ele.height() + 2 * ele.padding();
};
elesfn$a.paddedWidth = function() {
  var ele = this[0];
  return ele.width() + 2 * ele.padding();
};
var widthHeight = elesfn$a;
var ifEdge = /* @__PURE__ */ __name(function ifEdge2(ele, getValue2) {
  if (ele.isEdge() && ele.takesUpSpace()) {
    return getValue2(ele);
  }
}, "ifEdge2");
var ifEdgeRenderedPosition = /* @__PURE__ */ __name(function ifEdgeRenderedPosition2(ele, getPoint) {
  if (ele.isEdge() && ele.takesUpSpace()) {
    var cy = ele.cy();
    return modelToRenderedPosition$1(getPoint(ele), cy.zoom(), cy.pan());
  }
}, "ifEdgeRenderedPosition2");
var ifEdgeRenderedPositions = /* @__PURE__ */ __name(function ifEdgeRenderedPositions2(ele, getPoints) {
  if (ele.isEdge() && ele.takesUpSpace()) {
    var cy = ele.cy();
    var pan2 = cy.pan();
    var zoom2 = cy.zoom();
    return getPoints(ele).map(function(p2) {
      return modelToRenderedPosition$1(p2, zoom2, pan2);
    });
  }
}, "ifEdgeRenderedPositions2");
var controlPoints = /* @__PURE__ */ __name(function controlPoints2(ele) {
  return ele.renderer().getControlPoints(ele);
}, "controlPoints2");
var segmentPoints = /* @__PURE__ */ __name(function segmentPoints2(ele) {
  return ele.renderer().getSegmentPoints(ele);
}, "segmentPoints2");
var sourceEndpoint = /* @__PURE__ */ __name(function sourceEndpoint2(ele) {
  return ele.renderer().getSourceEndpoint(ele);
}, "sourceEndpoint2");
var targetEndpoint = /* @__PURE__ */ __name(function targetEndpoint2(ele) {
  return ele.renderer().getTargetEndpoint(ele);
}, "targetEndpoint2");
var midpoint = /* @__PURE__ */ __name(function midpoint2(ele) {
  return ele.renderer().getEdgeMidpoint(ele);
}, "midpoint2");
var pts = {
  controlPoints: {
    get: controlPoints,
    mult: true
  },
  segmentPoints: {
    get: segmentPoints,
    mult: true
  },
  sourceEndpoint: {
    get: sourceEndpoint
  },
  targetEndpoint: {
    get: targetEndpoint
  },
  midpoint: {
    get: midpoint
  }
};
var renderedName = /* @__PURE__ */ __name(function renderedName2(name) {
  return "rendered" + name[0].toUpperCase() + name.substr(1);
}, "renderedName2");
var edgePoints = Object.keys(pts).reduce(function(obj, name) {
  var spec = pts[name];
  var rName = renderedName(name);
  obj[name] = function() {
    return ifEdge(this, spec.get);
  };
  if (spec.mult) {
    obj[rName] = function() {
      return ifEdgeRenderedPositions(this, spec.get);
    };
  } else {
    obj[rName] = function() {
      return ifEdgeRenderedPosition(this, spec.get);
    };
  }
  return obj;
}, {});
var dimensions = extend({}, position, bounds, widthHeight, edgePoints);
var Event$1 = /* @__PURE__ */ __name(function Event2(src, props) {
  this.recycle(src, props);
}, "Event2");
function returnFalse() {
  return false;
}
__name(returnFalse, "returnFalse");
function returnTrue() {
  return true;
}
__name(returnTrue, "returnTrue");
Event$1.prototype = {
  instanceString: /* @__PURE__ */ __name(function instanceString2() {
    return "event";
  }, "instanceString2"),
  recycle: /* @__PURE__ */ __name(function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;
    if (src != null && src.preventDefault) {
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      props = src;
    } else {
      this.type = src;
    }
    if (props != null) {
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }
    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      var pos = this.position;
      var zoom2 = this.cy.zoom();
      var pan2 = this.cy.pan();
      this.renderedPosition = {
        x: pos.x * zoom2 + pan2.x,
        y: pos.y * zoom2 + pan2.y
      };
    }
    this.timeStamp = src && src.timeStamp || Date.now();
  }, "recycle"),
  preventDefault: /* @__PURE__ */ __name(function preventDefault2() {
    this.isDefaultPrevented = returnTrue;
    var e = this.originalEvent;
    if (!e) {
      return;
    }
    if (e.preventDefault) {
      e.preventDefault();
    }
  }, "preventDefault"),
  stopPropagation: /* @__PURE__ */ __name(function stopPropagation2() {
    this.isPropagationStopped = returnTrue;
    var e = this.originalEvent;
    if (!e) {
      return;
    }
    if (e.stopPropagation) {
      e.stopPropagation();
    }
  }, "stopPropagation"),
  stopImmediatePropagation: /* @__PURE__ */ __name(function stopImmediatePropagation2() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  }, "stopImmediatePropagation"),
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};
var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/;
var universalNamespace = ".*";
var defaults$8 = {
  qualifierCompare: /* @__PURE__ */ __name(function qualifierCompare(q1, q2) {
    return q1 === q2;
  }, "qualifierCompare"),
  eventMatches: /* @__PURE__ */ __name(function eventMatches() {
    return true;
  }, "eventMatches"),
  addEventFields: /* @__PURE__ */ __name(function addEventFields() {
  }, "addEventFields"),
  callbackContext: /* @__PURE__ */ __name(function callbackContext(context) {
    return context;
  }, "callbackContext"),
  beforeEmit: /* @__PURE__ */ __name(function beforeEmit() {
  }, "beforeEmit"),
  afterEmit: /* @__PURE__ */ __name(function afterEmit() {
  }, "afterEmit"),
  bubble: /* @__PURE__ */ __name(function bubble() {
    return false;
  }, "bubble"),
  parent: /* @__PURE__ */ __name(function parent2() {
    return null;
  }, "parent2"),
  context: null
};
var defaultsKeys = Object.keys(defaults$8);
var emptyOpts = {};
function Emitter() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyOpts;
  var context = arguments.length > 1 ? arguments[1] : void 0;
  for (var i = 0; i < defaultsKeys.length; i++) {
    var key2 = defaultsKeys[i];
    this[key2] = opts[key2] || defaults$8[key2];
  }
  this.context = context || this.context;
  this.listeners = [];
  this.emitting = 0;
}
__name(Emitter, "Emitter");
var p = Emitter.prototype;
var forEachEvent = /* @__PURE__ */ __name(function forEachEvent2(self2, handler, events, qualifier, callback, conf, confOverrides) {
  if (fn$6(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }
  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = extend({}, conf, confOverrides);
    }
  }
  var eventList = array(events) ? events : events.split(/\s+/);
  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];
    if (emptyString(evt)) {
      continue;
    }
    var match2 = evt.match(eventRegex);
    if (match2) {
      var type = match2[1];
      var namespace = match2[2] ? match2[2] : null;
      var ret = handler(self2, evt, type, namespace, qualifier, callback, conf);
      if (ret === false) {
        break;
      }
    }
  }
}, "forEachEvent2");
var makeEventObj = /* @__PURE__ */ __name(function makeEventObj2(self2, obj) {
  self2.addEventFields(self2.context, obj);
  return new Event$1(obj.type, obj);
}, "makeEventObj2");
var forEachEventObj = /* @__PURE__ */ __name(function forEachEventObj2(self2, handler, events) {
  if (event(events)) {
    handler(self2, events);
    return;
  } else if (plainObject(events)) {
    handler(self2, makeEventObj(self2, events));
    return;
  }
  var eventList = array(events) ? events : events.split(/\s+/);
  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];
    if (emptyString(evt)) {
      continue;
    }
    var match2 = evt.match(eventRegex);
    if (match2) {
      var type = match2[1];
      var namespace = match2[2] ? match2[2] : null;
      var eventObj = makeEventObj(self2, {
        type,
        namespace,
        target: self2.context
      });
      handler(self2, eventObj);
    }
  }
}, "forEachEventObj2");
p.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function(self2, event3, type, namespace, qualifier2, callback2, conf2) {
    if (fn$6(callback2)) {
      self2.listeners.push({
        event: event3,
        // full event string
        callback: callback2,
        // callback to run
        type,
        // the event type (e.g. 'click')
        namespace,
        // the event namespace (e.g. ".foo")
        qualifier: qualifier2,
        // a restriction on whether to match this emitter
        conf: conf2
        // additional configuration
      });
    }
  }, events, qualifier, callback, conf, confOverrides);
  return this;
};
p.one = function(events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, {
    one: true
  });
};
p.removeListener = p.off = function(events, qualifier, callback, conf) {
  var _this = this;
  if (this.emitting !== 0) {
    this.listeners = copyArray(this.listeners);
  }
  var listeners = this.listeners;
  var _loop = /* @__PURE__ */ __name(function _loop2(i2) {
    var listener = listeners[i2];
    forEachEvent(_this, function(self2, event3, type, namespace, qualifier2, callback2) {
      if ((listener.type === type || events === "*") && (!namespace && listener.namespace !== ".*" || listener.namespace === namespace) && (!qualifier2 || self2.qualifierCompare(listener.qualifier, qualifier2)) && (!callback2 || listener.callback === callback2)) {
        listeners.splice(i2, 1);
        return false;
      }
    }, events, qualifier, callback, conf);
  }, "_loop2");
  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }
  return this;
};
p.removeAllListeners = function() {
  return this.removeListener("*");
};
p.emit = p.trigger = function(events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;
  this.emitting++;
  if (!array(extraParams)) {
    extraParams = [extraParams];
  }
  forEachEventObj(this, function(self2, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];
      numListenersBeforeEmit = listeners.length;
    }
    var _loop2 = /* @__PURE__ */ __name(function _loop22() {
      var listener = listeners[i];
      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self2.eventMatches(self2.context, listener, eventObj)) {
        var args2 = [eventObj];
        if (extraParams != null) {
          push(args2, extraParams);
        }
        self2.beforeEmit(self2.context, listener, eventObj);
        if (listener.conf && listener.conf.one) {
          self2.listeners = self2.listeners.filter(function(l) {
            return l !== listener;
          });
        }
        var context = self2.callbackContext(self2.context, listener, eventObj);
        var ret = listener.callback.apply(context, args2);
        self2.afterEmit(self2.context, listener, eventObj);
        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      }
    }, "_loop22");
    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2();
    }
    if (self2.bubble(self2.context) && !eventObj.isPropagationStopped()) {
      self2.parent(self2.context).emit(eventObj, extraParams);
    }
  }, events);
  this.emitting--;
  return this;
};
var emitterOptions$1 = {
  qualifierCompare: /* @__PURE__ */ __name(function qualifierCompare2(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  }, "qualifierCompare2"),
  eventMatches: /* @__PURE__ */ __name(function eventMatches2(ele, listener, eventObj) {
    var selector = listener.qualifier;
    if (selector != null) {
      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }
    return true;
  }, "eventMatches2"),
  addEventFields: /* @__PURE__ */ __name(function addEventFields2(ele, evt) {
    evt.cy = ele.cy();
    evt.target = ele;
  }, "addEventFields2"),
  callbackContext: /* @__PURE__ */ __name(function callbackContext2(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  }, "callbackContext2"),
  beforeEmit: /* @__PURE__ */ __name(function beforeEmit2(context, listener) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  }, "beforeEmit2"),
  bubble: /* @__PURE__ */ __name(function bubble2() {
    return true;
  }, "bubble2"),
  parent: /* @__PURE__ */ __name(function parent3(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }, "parent3")
};
var argSelector$1 = /* @__PURE__ */ __name(function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
}, "argSelector");
var elesfn$9 = {
  createEmitter: /* @__PURE__ */ __name(function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;
      if (!_p.emitter) {
        _p.emitter = new Emitter(emitterOptions$1, ele);
      }
    }
    return this;
  }, "createEmitter"),
  emitter: /* @__PURE__ */ __name(function emitter() {
    return this._private.emitter;
  }, "emitter"),
  on: /* @__PURE__ */ __name(function on2(events, selector, callback) {
    var argSel = argSelector$1(selector);
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback);
    }
    return this;
  }, "on"),
  removeListener: /* @__PURE__ */ __name(function removeListener(events, selector, callback) {
    var argSel = argSelector$1(selector);
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeListener(events, argSel, callback);
    }
    return this;
  }, "removeListener"),
  removeAllListeners: /* @__PURE__ */ __name(function removeAllListeners() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeAllListeners();
    }
    return this;
  }, "removeAllListeners"),
  one: /* @__PURE__ */ __name(function one(events, selector, callback) {
    var argSel = argSelector$1(selector);
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().one(events, argSel, callback);
    }
    return this;
  }, "one"),
  once: /* @__PURE__ */ __name(function once2(events, selector, callback) {
    var argSel = argSelector$1(selector);
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback, {
        once: true,
        onceCollection: this
      });
    }
  }, "once"),
  emit: /* @__PURE__ */ __name(function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().emit(events, extraParams);
    }
    return this;
  }, "emit"),
  emitAndNotify: /* @__PURE__ */ __name(function emitAndNotify(event3, extraParams) {
    if (this.length === 0) {
      return;
    }
    this.cy().notify(event3, this);
    this.emit(event3, extraParams);
    return this;
  }, "emitAndNotify")
};
define.eventAliasesOn(elesfn$9);
var elesfn$8 = {
  nodes: /* @__PURE__ */ __name(function nodes(selector) {
    return this.filter(function(ele) {
      return ele.isNode();
    }).filter(selector);
  }, "nodes"),
  edges: /* @__PURE__ */ __name(function edges(selector) {
    return this.filter(function(ele) {
      return ele.isEdge();
    }).filter(selector);
  }, "edges"),
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: /* @__PURE__ */ __name(function byGroup() {
    var nodes3 = this.spawn();
    var edges3 = this.spawn();
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      if (ele.isNode()) {
        nodes3.push(ele);
      } else {
        edges3.push(ele);
      }
    }
    return {
      nodes: nodes3,
      edges: edges3
    };
  }, "byGroup"),
  filter: /* @__PURE__ */ __name(function filter3(_filter, thisArg) {
    if (_filter === void 0) {
      return this;
    } else if (string(_filter) || elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (fn$6(_filter)) {
      var filterEles = this.spawn();
      var eles = this;
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);
        if (include) {
          filterEles.push(ele);
        }
      }
      return filterEles;
    }
    return this.spawn();
  }, "filter3"),
  not: /* @__PURE__ */ __name(function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {
      if (string(toRemove)) {
        toRemove = this.filter(toRemove);
      }
      var elements = this.spawn();
      for (var i = 0; i < this.length; i++) {
        var element3 = this[i];
        var remove2 = toRemove.has(element3);
        if (!remove2) {
          elements.push(element3);
        }
      }
      return elements;
    }
  }, "not"),
  absoluteComplement: /* @__PURE__ */ __name(function absoluteComplement() {
    var cy = this.cy();
    return cy.mutableElements().not(this);
  }, "absoluteComplement"),
  intersect: /* @__PURE__ */ __name(function intersect2(other) {
    if (string(other)) {
      var selector = other;
      return this.filter(selector);
    }
    var elements = this.spawn();
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var colS = col1Smaller ? col1 : col2;
    var colL = col1Smaller ? col2 : col1;
    for (var i = 0; i < colS.length; i++) {
      var ele = colS[i];
      if (colL.has(ele)) {
        elements.push(ele);
      }
    }
    return elements;
  }, "intersect"),
  xor: /* @__PURE__ */ __name(function xor(other) {
    var cy = this._private.cy;
    if (string(other)) {
      other = cy.$(other);
    }
    var elements = this.spawn();
    var col1 = this;
    var col2 = other;
    var add3 = /* @__PURE__ */ __name(function add4(col, other2) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id2 = ele._private.data.id;
        var inOther = other2.hasElementWithId(id2);
        if (!inOther) {
          elements.push(ele);
        }
      }
    }, "add4");
    add3(col1, col2);
    add3(col2, col1);
    return elements;
  }, "xor"),
  diff: /* @__PURE__ */ __name(function diff(other) {
    var cy = this._private.cy;
    if (string(other)) {
      other = cy.$(other);
    }
    var left = this.spawn();
    var right = this.spawn();
    var both = this.spawn();
    var col1 = this;
    var col2 = other;
    var add3 = /* @__PURE__ */ __name(function add4(col, other2, retEles) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id2 = ele._private.data.id;
        var inOther = other2.hasElementWithId(id2);
        if (inOther) {
          both.merge(ele);
        } else {
          retEles.push(ele);
        }
      }
    }, "add4");
    add3(col1, col2, left);
    add3(col2, col1, right);
    return {
      left,
      right,
      both
    };
  }, "diff"),
  add: /* @__PURE__ */ __name(function add(toAdd) {
    var cy = this._private.cy;
    if (!toAdd) {
      return this;
    }
    if (string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }
    var elements = this.spawnSelf();
    for (var i = 0; i < toAdd.length; i++) {
      var ele = toAdd[i];
      var add3 = !this.has(ele);
      if (add3) {
        elements.push(ele);
      }
    }
    return elements;
  }, "add"),
  // in place merge on calling collection
  merge: /* @__PURE__ */ __name(function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;
    if (!toAdd) {
      return this;
    }
    if (toAdd && string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }
    var map22 = _p.map;
    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id2 = toAddEle._private.data.id;
      var add3 = !map22.has(id2);
      if (add3) {
        var index2 = this.length++;
        this[index2] = toAddEle;
        map22.set(id2, {
          ele: toAddEle,
          index: index2
        });
      }
    }
    return this;
  }, "merge"),
  unmergeAt: /* @__PURE__ */ __name(function unmergeAt(i) {
    var ele = this[i];
    var id2 = ele.id();
    var _p = this._private;
    var map22 = _p.map;
    this[i] = void 0;
    map22["delete"](id2);
    var unmergedLastEle = i === this.length - 1;
    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;
      this[lastEleI] = void 0;
      this[i] = lastEle;
      map22.set(lastEleId, {
        ele: lastEle,
        index: i
      });
    }
    this.length--;
    return this;
  }, "unmergeAt"),
  // remove single ele in place in calling collection
  unmergeOne: /* @__PURE__ */ __name(function unmergeOne(ele) {
    ele = ele[0];
    var _p = this._private;
    var id2 = ele._private.data.id;
    var map22 = _p.map;
    var entry = map22.get(id2);
    if (!entry) {
      return this;
    }
    var i = entry.index;
    this.unmergeAt(i);
    return this;
  }, "unmergeOne"),
  // remove eles in place on calling collection
  unmerge: /* @__PURE__ */ __name(function unmerge(toRemove) {
    var cy = this._private.cy;
    if (!toRemove) {
      return this;
    }
    if (toRemove && string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }
    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }
    return this;
  }, "unmerge"),
  unmergeBy: /* @__PURE__ */ __name(function unmergeBy(toRmFn) {
    for (var i = this.length - 1; i >= 0; i--) {
      var ele = this[i];
      if (toRmFn(ele)) {
        this.unmergeAt(i);
      }
    }
    return this;
  }, "unmergeBy"),
  map: /* @__PURE__ */ __name(function map2(mapFn, thisArg) {
    var arr = [];
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
      arr.push(ret);
    }
    return arr;
  }, "map"),
  reduce: /* @__PURE__ */ __name(function reduce(fn3, initialValue) {
    var val = initialValue;
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      val = fn3(val, eles[i], i, eles);
    }
    return val;
  }, "reduce"),
  max: /* @__PURE__ */ __name(function max4(valFn, thisArg) {
    var max5 = -Infinity;
    var maxEle;
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);
      if (val > max5) {
        max5 = val;
        maxEle = ele;
      }
    }
    return {
      value: max5,
      ele: maxEle
    };
  }, "max4"),
  min: /* @__PURE__ */ __name(function min3(valFn, thisArg) {
    var min4 = Infinity;
    var minEle;
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);
      if (val < min4) {
        min4 = val;
        minEle = ele;
      }
    }
    return {
      value: min4,
      ele: minEle
    };
  }, "min3")
};
var fn$1 = elesfn$8;
fn$1["u"] = fn$1["|"] = fn$1["+"] = fn$1.union = fn$1.or = fn$1.add;
fn$1["\\"] = fn$1["!"] = fn$1["-"] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;
fn$1["n"] = fn$1["&"] = fn$1["."] = fn$1.and = fn$1.intersection = fn$1.intersect;
fn$1["^"] = fn$1["(+)"] = fn$1["(-)"] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;
fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;
fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;
var elesfn$7 = {
  isNode: /* @__PURE__ */ __name(function isNode() {
    return this.group() === "nodes";
  }, "isNode"),
  isEdge: /* @__PURE__ */ __name(function isEdge() {
    return this.group() === "edges";
  }, "isEdge"),
  isLoop: /* @__PURE__ */ __name(function isLoop() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  }, "isLoop"),
  isSimple: /* @__PURE__ */ __name(function isSimple() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  }, "isSimple"),
  group: /* @__PURE__ */ __name(function group() {
    var ele = this[0];
    if (ele) {
      return ele._private.group;
    }
  }, "group")
};
var zIndexSort = /* @__PURE__ */ __name(function zIndexSort2(a, b) {
  var cy = a.cy();
  var hasCompoundNodes2 = cy.hasCompoundNodes();
  function getDepth(ele) {
    var style3 = ele.pstyle("z-compound-depth");
    if (style3.value === "auto") {
      return hasCompoundNodes2 ? ele.zDepth() : 0;
    } else if (style3.value === "bottom") {
      return -1;
    } else if (style3.value === "top") {
      return MAX_INT$1;
    }
    return 0;
  }
  __name(getDepth, "getDepth");
  var depthDiff = getDepth(a) - getDepth(b);
  if (depthDiff !== 0) {
    return depthDiff;
  }
  function getEleDepth(ele) {
    var style3 = ele.pstyle("z-index-compare");
    if (style3.value === "auto") {
      return ele.isNode() ? 1 : 0;
    }
    return 0;
  }
  __name(getEleDepth, "getEleDepth");
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if (eleDiff !== 0) {
    return eleDiff;
  }
  var zDiff = a.pstyle("z-index").value - b.pstyle("z-index").value;
  if (zDiff !== 0) {
    return zDiff;
  }
  return a.poolIndex() - b.poolIndex();
}, "zIndexSort2");
var elesfn$6 = {
  forEach: /* @__PURE__ */ __name(function forEach(fn3, thisArg) {
    if (fn$6(fn3)) {
      var N = this.length;
      for (var i = 0; i < N; i++) {
        var ele = this[i];
        var ret = thisArg ? fn3.apply(thisArg, [ele, i, this]) : fn3(ele, i, this);
        if (ret === false) {
          break;
        }
      }
    }
    return this;
  }, "forEach"),
  toArray: /* @__PURE__ */ __name(function toArray() {
    var array3 = [];
    for (var i = 0; i < this.length; i++) {
      array3.push(this[i]);
    }
    return array3;
  }, "toArray"),
  slice: /* @__PURE__ */ __name(function slice(start, end) {
    var array3 = [];
    var thisSize = this.length;
    if (end == null) {
      end = thisSize;
    }
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start = thisSize + start;
    }
    if (end < 0) {
      end = thisSize + end;
    }
    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array3.push(this[i]);
    }
    return this.spawn(array3);
  }, "slice"),
  size: /* @__PURE__ */ __name(function size2() {
    return this.length;
  }, "size"),
  eq: /* @__PURE__ */ __name(function eq(i) {
    return this[i] || this.spawn();
  }, "eq"),
  first: /* @__PURE__ */ __name(function first() {
    return this[0] || this.spawn();
  }, "first"),
  last: /* @__PURE__ */ __name(function last() {
    return this[this.length - 1] || this.spawn();
  }, "last"),
  empty: /* @__PURE__ */ __name(function empty2() {
    return this.length === 0;
  }, "empty"),
  nonempty: /* @__PURE__ */ __name(function nonempty() {
    return !this.empty();
  }, "nonempty"),
  sort: /* @__PURE__ */ __name(function sort(sortFn) {
    if (!fn$6(sortFn)) {
      return this;
    }
    var sorted = this.toArray().sort(sortFn);
    return this.spawn(sorted);
  }, "sort"),
  sortByZIndex: /* @__PURE__ */ __name(function sortByZIndex() {
    return this.sort(zIndexSort);
  }, "sortByZIndex"),
  zDepth: /* @__PURE__ */ __name(function zDepth() {
    var ele = this[0];
    if (!ele) {
      return void 0;
    }
    var _p = ele._private;
    var group2 = _p.group;
    if (group2 === "nodes") {
      var depth = _p.data.parent ? ele.parents().size() : 0;
      if (!ele.isParent()) {
        return MAX_INT$1 - 1;
      }
      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();
      return Math.max(srcDepth, tgtDepth, 0);
    }
  }, "zDepth")
};
elesfn$6.each = elesfn$6.forEach;
var defineSymbolIterator = /* @__PURE__ */ __name(function defineSymbolIterator2() {
  var typeofUndef = "undefined";
  var isIteratorSupported = (typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef;
  if (isIteratorSupported) {
    elesfn$6[Symbol.iterator] = function() {
      var _this = this;
      var entry = {
        value: void 0,
        done: false
      };
      var i = 0;
      var length2 = this.length;
      return _defineProperty$1({
        next: /* @__PURE__ */ __name(function next2() {
          if (i < length2) {
            entry.value = _this[i++];
          } else {
            entry.value = void 0;
            entry.done = true;
          }
          return entry;
        }, "next")
      }, Symbol.iterator, function() {
        return this;
      });
    };
  }
}, "defineSymbolIterator2");
defineSymbolIterator();
var getLayoutDimensionOptions = defaults$g({
  nodeDimensionsIncludeLabels: false
});
var elesfn$5 = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: /* @__PURE__ */ __name(function layoutDimensions(options2) {
    options2 = getLayoutDimensionOptions(options2);
    var dims;
    if (!this.takesUpSpace()) {
      dims = {
        w: 0,
        h: 0
      };
    } else if (options2.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      dims = {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      dims = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    }
    if (dims.w === 0 || dims.h === 0) {
      dims.w = dims.h = 1;
    }
    return dims;
  }, "layoutDimensions"),
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: /* @__PURE__ */ __name(function layoutPositions(layout4, options2, fn3) {
    var nodes3 = this.nodes().filter(function(n) {
      return !n.isParent();
    });
    var cy = this.cy();
    var layoutEles = options2.eles;
    var getMemoizeKey = /* @__PURE__ */ __name(function getMemoizeKey2(node2) {
      return node2.id();
    }, "getMemoizeKey2");
    var fnMem = memoize(fn3, getMemoizeKey);
    layout4.emit({
      type: "layoutstart",
      layout: layout4
    });
    layout4.animations = [];
    var calculateSpacing = /* @__PURE__ */ __name(function calculateSpacing2(spacing, nodesBb, pos) {
      var center2 = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center2.x) * spacing,
        y: (pos.y - center2.y) * spacing
      };
      return {
        x: center2.x + spacingVector.x,
        y: center2.y + spacingVector.y
      };
    }, "calculateSpacing2");
    var useSpacingFactor = options2.spacingFactor && options2.spacingFactor !== 1;
    var spacingBb = /* @__PURE__ */ __name(function spacingBb2() {
      if (!useSpacingFactor) {
        return null;
      }
      var bb2 = makeBoundingBox();
      for (var i2 = 0; i2 < nodes3.length; i2++) {
        var node2 = nodes3[i2];
        var pos = fnMem(node2, i2);
        expandBoundingBoxByPoint(bb2, pos.x, pos.y);
      }
      return bb2;
    }, "spacingBb2");
    var bb = spacingBb();
    var getFinalPos = memoize(function(node2, i2) {
      var newPos2 = fnMem(node2, i2);
      if (useSpacingFactor) {
        var spacing = Math.abs(options2.spacingFactor);
        newPos2 = calculateSpacing(spacing, bb, newPos2);
      }
      if (options2.transform != null) {
        newPos2 = options2.transform(node2, newPos2);
      }
      return newPos2;
    }, getMemoizeKey);
    if (options2.animate) {
      for (var i = 0; i < nodes3.length; i++) {
        var node = nodes3[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options2.animateFilter == null || options2.animateFilter(node, i);
        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options2.animationDuration,
            easing: options2.animationEasing
          });
          layout4.animations.push(ani);
        } else {
          node.position(newPos);
        }
      }
      if (options2.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options2.padding
          },
          duration: options2.animationDuration,
          easing: options2.animationEasing
        });
        layout4.animations.push(fitAni);
      } else if (options2.zoom !== void 0 && options2.pan !== void 0) {
        var zoomPanAni = cy.animation({
          zoom: options2.zoom,
          pan: options2.pan,
          duration: options2.animationDuration,
          easing: options2.animationEasing
        });
        layout4.animations.push(zoomPanAni);
      }
      layout4.animations.forEach(function(ani2) {
        return ani2.play();
      });
      layout4.one("layoutready", options2.ready);
      layout4.emit({
        type: "layoutready",
        layout: layout4
      });
      Promise$1.all(layout4.animations.map(function(ani2) {
        return ani2.promise();
      })).then(function() {
        layout4.one("layoutstop", options2.stop);
        layout4.emit({
          type: "layoutstop",
          layout: layout4
        });
      });
    } else {
      nodes3.positions(getFinalPos);
      if (options2.fit) {
        cy.fit(options2.eles, options2.padding);
      }
      if (options2.zoom != null) {
        cy.zoom(options2.zoom);
      }
      if (options2.pan) {
        cy.pan(options2.pan);
      }
      layout4.one("layoutready", options2.ready);
      layout4.emit({
        type: "layoutready",
        layout: layout4
      });
      layout4.one("layoutstop", options2.stop);
      layout4.emit({
        type: "layoutstop",
        layout: layout4
      });
    }
    return this;
  }, "layoutPositions"),
  layout: /* @__PURE__ */ __name(function layout(options2) {
    var cy = this.cy();
    return cy.makeLayout(extend({}, options2, {
      eles: this
    }));
  }, "layout")
};
elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;
function styleCache(key2, fn3, ele) {
  var _p = ele._private;
  var cache3 = _p.styleCache = _p.styleCache || [];
  var val;
  if ((val = cache3[key2]) != null) {
    return val;
  } else {
    val = cache3[key2] = fn3(ele);
    return val;
  }
}
__name(styleCache, "styleCache");
function cacheStyleFunction(key2, fn3) {
  key2 = hashString(key2);
  return /* @__PURE__ */ __name(function cachedStyleFunction(ele) {
    return styleCache(key2, fn3, ele);
  }, "cachedStyleFunction");
}
__name(cacheStyleFunction, "cacheStyleFunction");
function cachePrototypeStyleFunction(key2, fn3) {
  key2 = hashString(key2);
  var selfFn = /* @__PURE__ */ __name(function selfFn2(ele) {
    return fn3.call(ele);
  }, "selfFn2");
  return /* @__PURE__ */ __name(function cachedPrototypeStyleFunction() {
    var ele = this[0];
    if (ele) {
      return styleCache(key2, selfFn, ele);
    }
  }, "cachedPrototypeStyleFunction");
}
__name(cachePrototypeStyleFunction, "cachePrototypeStyleFunction");
var elesfn$4 = {
  recalculateRenderedStyle: /* @__PURE__ */ __name(function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer3 = cy.renderer();
    var styleEnabled2 = cy.styleEnabled();
    if (renderer3 && styleEnabled2) {
      renderer3.recalculateRenderedStyle(this, useCache);
    }
    return this;
  }, "recalculateRenderedStyle"),
  dirtyStyleCache: /* @__PURE__ */ __name(function dirtyStyleCache() {
    var cy = this.cy();
    var dirty = /* @__PURE__ */ __name(function dirty2(ele) {
      return ele._private.styleCache = null;
    }, "dirty2");
    if (cy.hasCompoundNodes()) {
      var eles;
      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
      eles.merge(eles.connectedEdges());
      eles.forEach(dirty);
    } else {
      this.forEach(function(ele) {
        dirty(ele);
        ele.connectedEdges().forEach(dirty);
      });
    }
    return this;
  }, "dirtyStyleCache"),
  // fully updates (recalculates) the style for the elements
  updateStyle: /* @__PURE__ */ __name(function updateStyle(notifyRenderer) {
    var cy = this._private.cy;
    if (!cy.styleEnabled()) {
      return this;
    }
    if (cy.batching()) {
      var bEles = cy._private.batchStyleEles;
      bEles.merge(this);
      return this;
    }
    var hasCompounds = cy.hasCompoundNodes();
    var updatedEles = this;
    notifyRenderer = notifyRenderer || notifyRenderer === void 0 ? true : false;
    if (hasCompounds) {
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }
    var changedEles = updatedEles;
    if (notifyRenderer) {
      changedEles.emitAndNotify("style");
    } else {
      changedEles.emit("style");
    }
    updatedEles.forEach(function(ele) {
      return ele._private.styleDirty = true;
    });
    return this;
  }, "updateStyle"),
  // private: clears dirty flag and recalculates style
  cleanStyle: /* @__PURE__ */ __name(function cleanStyle() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return;
    }
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      if (ele._private.styleDirty) {
        ele._private.styleDirty = false;
        cy.style().apply(ele);
      }
    }
  }, "cleanStyle"),
  // get the internal parsed style object for the specified property
  parsedStyle: /* @__PURE__ */ __name(function parsedStyle(property) {
    var includeNonDefault = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var ele = this[0];
    var cy = ele.cy();
    if (!cy.styleEnabled()) {
      return;
    }
    if (ele) {
      if (ele._private.styleDirty) {
        ele._private.styleDirty = false;
        cy.style().apply(ele);
      }
      var overriddenStyle = ele._private.style[property];
      if (overriddenStyle != null) {
        return overriddenStyle;
      } else if (includeNonDefault) {
        return cy.style().getDefaultProperty(property);
      } else {
        return null;
      }
    }
  }, "parsedStyle"),
  numericStyle: /* @__PURE__ */ __name(function numericStyle(property) {
    var ele = this[0];
    if (!ele.cy().styleEnabled()) {
      return;
    }
    if (ele) {
      var pstyle = ele.pstyle(property);
      return pstyle.pfValue !== void 0 ? pstyle.pfValue : pstyle.value;
    }
  }, "numericStyle"),
  numericStyleUnits: /* @__PURE__ */ __name(function numericStyleUnits(property) {
    var ele = this[0];
    if (!ele.cy().styleEnabled()) {
      return;
    }
    if (ele) {
      return ele.pstyle(property).units;
    }
  }, "numericStyleUnits"),
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: /* @__PURE__ */ __name(function renderedStyle(property) {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return this;
    }
    var ele = this[0];
    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  }, "renderedStyle"),
  // read the calculated css style of the element or override the style (via a bypass)
  style: /* @__PURE__ */ __name(function style(name, value2) {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return this;
    }
    var updateTransitions = false;
    var style3 = cy.style();
    if (plainObject(name)) {
      var props = name;
      style3.applyBypass(this, props, updateTransitions);
      this.emitAndNotify("style");
    } else if (string(name)) {
      if (value2 === void 0) {
        var ele = this[0];
        if (ele) {
          return style3.getStylePropertyValue(ele, name);
        } else {
          return;
        }
      } else {
        style3.applyBypass(this, name, value2, updateTransitions);
        this.emitAndNotify("style");
      }
    } else if (name === void 0) {
      var _ele = this[0];
      if (_ele) {
        return style3.getRawStyle(_ele);
      } else {
        return;
      }
    }
    return this;
  }, "style"),
  removeStyle: /* @__PURE__ */ __name(function removeStyle(names) {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return this;
    }
    var updateTransitions = false;
    var style3 = cy.style();
    var eles = this;
    if (names === void 0) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        style3.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);
      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];
        style3.removeBypasses(_ele2, names, updateTransitions);
      }
    }
    this.emitAndNotify("style");
    return this;
  }, "removeStyle"),
  show: /* @__PURE__ */ __name(function show() {
    this.css("display", "element");
    return this;
  }, "show"),
  hide: /* @__PURE__ */ __name(function hide() {
    this.css("display", "none");
    return this;
  }, "hide"),
  effectiveOpacity: /* @__PURE__ */ __name(function effectiveOpacity() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return 1;
    }
    var hasCompoundNodes2 = cy.hasCompoundNodes();
    var ele = this[0];
    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle("opacity").value;
      if (!hasCompoundNodes2) {
        return parentOpacity;
      }
      var parents2 = !_p.data.parent ? null : ele.parents();
      if (parents2) {
        for (var i = 0; i < parents2.length; i++) {
          var parent4 = parents2[i];
          var opacity = parent4.pstyle("opacity").value;
          parentOpacity = opacity * parentOpacity;
        }
      }
      return parentOpacity;
    }
  }, "effectiveOpacity"),
  transparent: /* @__PURE__ */ __name(function transparent() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }
    var ele = this[0];
    var hasCompoundNodes2 = ele.cy().hasCompoundNodes();
    if (ele) {
      if (!hasCompoundNodes2) {
        return ele.pstyle("opacity").value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  }, "transparent"),
  backgrounding: /* @__PURE__ */ __name(function backgrounding() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }
    var ele = this[0];
    return ele._private.backgrounding ? true : false;
  }, "backgrounding")
};
function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents2 = _p.data.parent ? ele.parents() : null;
  if (parents2) {
    for (var i = 0; i < parents2.length; i++) {
      var parent4 = parents2[i];
      if (!parentOk(parent4)) {
        return false;
      }
    }
  }
  return true;
}
__name(checkCompound, "checkCompound");
function defineDerivedStateFunction(specs) {
  var ok2 = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;
  return function() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return true;
    }
    var ele = this[0];
    var hasCompoundNodes2 = cy.hasCompoundNodes();
    if (ele) {
      var _p = ele._private;
      if (!ok2(ele)) {
        return false;
      }
      if (ele.isNode()) {
        return !hasCompoundNodes2 || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;
        return edgeOkViaNode(src) && (!hasCompoundNodes2 || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes2 || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}
__name(defineDerivedStateFunction, "defineDerivedStateFunction");
var eleTakesUpSpace = cacheStyleFunction("eleTakesUpSpace", function(ele) {
  return ele.pstyle("display").value === "element" && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});
elesfn$4.takesUpSpace = cachePrototypeStyleFunction("takesUpSpace", defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));
var eleInteractive = cacheStyleFunction("eleInteractive", function(ele) {
  return ele.pstyle("events").value === "yes" && ele.pstyle("visibility").value === "visible" && eleTakesUpSpace(ele);
});
var parentInteractive = cacheStyleFunction("parentInteractive", function(parent4) {
  return parent4.pstyle("visibility").value === "visible" && eleTakesUpSpace(parent4);
});
elesfn$4.interactive = cachePrototypeStyleFunction("interactive", defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));
elesfn$4.noninteractive = function() {
  var ele = this[0];
  if (ele) {
    return !ele.interactive();
  }
};
var eleVisible = cacheStyleFunction("eleVisible", function(ele) {
  return ele.pstyle("visibility").value === "visible" && ele.pstyle("opacity").pfValue !== 0 && eleTakesUpSpace(ele);
});
var edgeVisibleViaNode = eleTakesUpSpace;
elesfn$4.visible = cachePrototypeStyleFunction("visible", defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));
elesfn$4.hidden = function() {
  var ele = this[0];
  if (ele) {
    return !ele.visible();
  }
};
elesfn$4.isBundledBezier = cachePrototypeStyleFunction("isBundledBezier", function() {
  if (!this.cy().styleEnabled()) {
    return false;
  }
  return !this.removed() && this.pstyle("curve-style").value === "bezier" && this.takesUpSpace();
});
elesfn$4.bypass = elesfn$4.css = elesfn$4.style;
elesfn$4.renderedCss = elesfn$4.renderedStyle;
elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;
elesfn$4.pstyle = elesfn$4.parsedStyle;
var elesfn$3 = {};
function defineSwitchFunction(params) {
  return function() {
    var args2 = arguments;
    var changedEles = [];
    if (args2.length === 2) {
      var data4 = args2[0];
      var handler = args2[1];
      this.on(params.event, data4, handler);
    } else if (args2.length === 1 && fn$6(args2[0])) {
      var _handler = args2[0];
      this.on(params.event, _handler);
    } else if (args2.length === 0 || args2.length === 1 && array(args2[0])) {
      var addlEvents = args2.length === 1 ? args2[0] : null;
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var able = !params.ableField || ele._private[params.ableField];
        var changed = ele._private[params.field] != params.value;
        if (params.overrideAble) {
          var overrideAble2 = params.overrideAble(ele);
          if (overrideAble2 !== void 0) {
            able = overrideAble2;
            if (!overrideAble2) {
              return this;
            }
          }
        }
        if (able) {
          ele._private[params.field] = params.value;
          if (changed) {
            changedEles.push(ele);
          }
        }
      }
      var changedColl = this.spawn(changedEles);
      changedColl.updateStyle();
      changedColl.emit(params.event);
      if (addlEvents) {
        changedColl.emit(addlEvents);
      }
    }
    return this;
  };
}
__name(defineSwitchFunction, "defineSwitchFunction");
function defineSwitchSet(params) {
  elesfn$3[params.field] = function() {
    var ele = this[0];
    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);
        if (val !== void 0) {
          return val;
        }
      }
      return ele._private[params.field];
    }
  };
  elesfn$3[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });
  elesfn$3[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}
__name(defineSwitchSet, "defineSwitchSet");
defineSwitchSet({
  field: "locked",
  overrideField: /* @__PURE__ */ __name(function overrideField(ele) {
    return ele.cy().autolock() ? true : void 0;
  }, "overrideField"),
  on: "lock",
  off: "unlock"
});
defineSwitchSet({
  field: "grabbable",
  overrideField: /* @__PURE__ */ __name(function overrideField2(ele) {
    return ele.cy().autoungrabify() || ele.pannable() ? false : void 0;
  }, "overrideField2"),
  on: "grabify",
  off: "ungrabify"
});
defineSwitchSet({
  field: "selected",
  ableField: "selectable",
  overrideAble: /* @__PURE__ */ __name(function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : void 0;
  }, "overrideAble"),
  on: "select",
  off: "unselect"
});
defineSwitchSet({
  field: "selectable",
  overrideField: /* @__PURE__ */ __name(function overrideField3(ele) {
    return ele.cy().autounselectify() ? false : void 0;
  }, "overrideField3"),
  on: "selectify",
  off: "unselectify"
});
elesfn$3.deselect = elesfn$3.unselect;
elesfn$3.grabbed = function() {
  var ele = this[0];
  if (ele) {
    return ele._private.grabbed;
  }
};
defineSwitchSet({
  field: "active",
  on: "activate",
  off: "unactivate"
});
defineSwitchSet({
  field: "pannable",
  on: "panify",
  off: "unpanify"
});
elesfn$3.inactive = function() {
  var ele = this[0];
  if (ele) {
    return !ele._private.active;
  }
};
var elesfn$2 = {};
var defineDagExtremity = /* @__PURE__ */ __name(function defineDagExtremity2(params) {
  return /* @__PURE__ */ __name(function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (!ele.isNode()) {
        continue;
      }
      var disqualified = false;
      var edges3 = ele.connectedEdges();
      for (var j = 0; j < edges3.length; j++) {
        var edge = edges3[j];
        var src = edge.source();
        var tgt = edge.target();
        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }
      if (!disqualified) {
        ret.push(ele);
      }
    }
    return this.spawn(ret, true).filter(selector);
  }, "dagExtremityImpl");
}, "defineDagExtremity2");
var defineDagOneHop = /* @__PURE__ */ __name(function defineDagOneHop2(params) {
  return function(selector) {
    var eles = this;
    var oEles = [];
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (!ele.isNode()) {
        continue;
      }
      var edges3 = ele.connectedEdges();
      for (var j = 0; j < edges3.length; j++) {
        var edge = edges3[j];
        var src = edge.source();
        var tgt = edge.target();
        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }
    return this.spawn(oEles, true).filter(selector);
  };
}, "defineDagOneHop2");
var defineDagAllHops = /* @__PURE__ */ __name(function defineDagAllHops2(params) {
  return function(selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};
    for (; ; ) {
      var next2 = params.outgoing ? eles.outgoers() : eles.incomers();
      if (next2.length === 0) {
        break;
      }
      var newNext = false;
      for (var i = 0; i < next2.length; i++) {
        var n = next2[i];
        var nid = n.id();
        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }
      if (!newNext) {
        break;
      }
      eles = next2;
    }
    return this.spawn(sEles, true).filter(selector);
  };
}, "defineDagAllHops2");
elesfn$2.clearTraversalCache = function() {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};
extend(elesfn$2, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({
    noIncomingEdges: true
  }),
  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({
    noOutgoingEdges: true
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({
    outgoing: true
  }), "outgoers"),
  // aka DAG descendants
  successors: defineDagAllHops({
    outgoing: true
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({
    incoming: true
  }), "incomers"),
  // aka DAG ancestors
  predecessors: defineDagAllHops({})
});
extend(elesfn$2, {
  neighborhood: cache(function(selector) {
    var elements = [];
    var nodes3 = this.nodes();
    for (var i = 0; i < nodes3.length; i++) {
      var node = nodes3[i];
      var connectedEdges = node.connectedEdges();
      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;
        if (otherNode.length > 0) {
          elements.push(otherNode[0]);
        }
        elements.push(edge[0]);
      }
    }
    return this.spawn(elements, true).filter(selector);
  }, "neighborhood"),
  closedNeighborhood: /* @__PURE__ */ __name(function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  }, "closedNeighborhood"),
  openNeighborhood: /* @__PURE__ */ __name(function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }, "openNeighborhood")
});
elesfn$2.neighbourhood = elesfn$2.neighborhood;
elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;
elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;
extend(elesfn$2, {
  source: cache(/* @__PURE__ */ __name(function sourceImpl(selector) {
    var ele = this[0];
    var src;
    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }
    return src && selector ? src.filter(selector) : src;
  }, "sourceImpl"), "source"),
  target: cache(/* @__PURE__ */ __name(function targetImpl(selector) {
    var ele = this[0];
    var tgt;
    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }
    return tgt && selector ? tgt.filter(selector) : tgt;
  }, "targetImpl"), "target"),
  sources: defineSourceFunction({
    attr: "source"
  }),
  targets: defineSourceFunction({
    attr: "target"
  })
});
function defineSourceFunction(params) {
  return /* @__PURE__ */ __name(function sourceImpl2(selector) {
    var sources = [];
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];
      if (src) {
        sources.push(src);
      }
    }
    return this.spawn(sources, true).filter(selector);
  }, "sourceImpl2");
}
__name(defineSourceFunction, "defineSourceFunction");
extend(elesfn$2, {
  edgesWith: cache(defineEdgesWithFunction(), "edgesWith"),
  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), "edgesTo")
});
function defineEdgesWithFunction(params) {
  return /* @__PURE__ */ __name(function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p2 = params || {};
    if (string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }
    for (var h = 0; h < otherNodes.length; h++) {
      var edges3 = otherNodes[h]._private.edges;
      for (var i = 0; i < edges3.length; i++) {
        var edge = edges3[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;
        if (!edgeConnectsThisAndOther) {
          continue;
        }
        if (p2.thisIsSrc || p2.thisIsTgt) {
          if (p2.thisIsSrc && !thisToOther) {
            continue;
          }
          if (p2.thisIsTgt && !otherToThis) {
            continue;
          }
        }
        elements.push(edge);
      }
    }
    return this.spawn(elements, true);
  }, "edgesWithImpl");
}
__name(defineEdgesWithFunction, "defineEdgesWithFunction");
extend(elesfn$2, {
  connectedEdges: cache(function(selector) {
    var retEles = [];
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];
      if (!node.isNode()) {
        continue;
      }
      var edges3 = node._private.edges;
      for (var j = 0; j < edges3.length; j++) {
        var edge = edges3[j];
        retEles.push(edge);
      }
    }
    return this.spawn(retEles, true).filter(selector);
  }, "connectedEdges"),
  connectedNodes: cache(function(selector) {
    var retEles = [];
    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];
      if (!edge.isEdge()) {
        continue;
      }
      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }
    return this.spawn(retEles, true).filter(selector);
  }, "connectedNodes"),
  parallelEdges: cache(defineParallelEdgesFunction(), "parallelEdges"),
  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), "codirectedEdges")
});
function defineParallelEdgesFunction(params) {
  var defaults3 = {
    codirected: false
  };
  params = extend({}, defaults3, params);
  return /* @__PURE__ */ __name(function parallelEdgesImpl(selector) {
    var elements = [];
    var edges3 = this.edges();
    var p2 = params;
    for (var i = 0; i < edges3.length; i++) {
      var edge1 = edges3[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;
      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;
        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
        if (p2.codirected && codirected || !p2.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }
    return this.spawn(elements, true).filter(selector);
  }, "parallelEdgesImpl");
}
__name(defineParallelEdgesFunction, "defineParallelEdgesFunction");
extend(elesfn$2, {
  components: /* @__PURE__ */ __name(function components(root2) {
    var self2 = this;
    var cy = self2.cy();
    var visited = cy.collection();
    var unvisited = root2 == null ? self2.nodes() : root2.nodes();
    var components2 = [];
    if (root2 != null && unvisited.empty()) {
      unvisited = root2.sources();
    }
    var visitInComponent = /* @__PURE__ */ __name(function visitInComponent2(node, component22) {
      visited.merge(node);
      unvisited.unmerge(node);
      component22.merge(node);
    }, "visitInComponent2");
    if (unvisited.empty()) {
      return self2.spawn();
    }
    var _loop = /* @__PURE__ */ __name(function _loop2() {
      var cmpt = cy.collection();
      components2.push(cmpt);
      var root22 = unvisited[0];
      visitInComponent(root22, cmpt);
      self2.bfs({
        directed: false,
        roots: root22,
        visit: /* @__PURE__ */ __name(function visit(v) {
          return visitInComponent(v, cmpt);
        }, "visit")
      });
      cmpt.forEach(function(node) {
        node.connectedEdges().forEach(function(e) {
          if (self2.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
            cmpt.merge(e);
          }
        });
      });
    }, "_loop2");
    do {
      _loop();
    } while (unvisited.length > 0);
    return components2;
  }, "components"),
  component: /* @__PURE__ */ __name(function component2() {
    var ele = this[0];
    return ele.cy().mutableElements().components(ele)[0];
  }, "component")
});
elesfn$2.componentsOf = elesfn$2.components;
var Collection = /* @__PURE__ */ __name(function Collection2(cy, elements) {
  var unique = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var removed = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (cy === void 0) {
    error("A collection must have a reference to the core");
    return;
  }
  var map22 = new Map$1();
  var createdElements = false;
  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
    createdElements = true;
    var eles = [];
    var elesIds = new Set$1();
    for (var i = 0, l = elements.length; i < l; i++) {
      var json2 = elements[i];
      if (json2.data == null) {
        json2.data = {};
      }
      var _data = json2.data;
      if (_data.id == null) {
        _data.id = uuid();
      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
        continue;
      }
      var ele = new Element$1(cy, json2, false);
      eles.push(ele);
      elesIds.add(_data.id);
    }
    elements = eles;
  }
  this.length = 0;
  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element$12 = elements[_i][0];
    if (element$12 == null) {
      continue;
    }
    var id2 = element$12._private.data.id;
    if (!unique || !map22.has(id2)) {
      if (unique) {
        map22.set(id2, {
          index: this.length,
          ele: element$12
        });
      }
      this[this.length] = element$12;
      this.length++;
    }
  }
  this._private = {
    eles: this,
    cy,
    get map() {
      if (this.lazyMap == null) {
        this.rebuildMap();
      }
      return this.lazyMap;
    },
    set map(m) {
      this.lazyMap = m;
    },
    rebuildMap: /* @__PURE__ */ __name(function rebuildMap() {
      var m = this.lazyMap = new Map$1();
      var eles2 = this.eles;
      for (var _i2 = 0; _i2 < eles2.length; _i2++) {
        var _ele = eles2[_i2];
        m.set(_ele.id(), {
          index: _i2,
          ele: _ele
        });
      }
    }, "rebuildMap")
  };
  if (unique) {
    this._private.map = map22;
  }
  if (createdElements && !removed) {
    this.restore();
  }
}, "Collection2");
var elesfn$1 = Element$1.prototype = Collection.prototype = Object.create(Array.prototype);
elesfn$1.instanceString = function() {
  return "collection";
};
elesfn$1.spawn = function(eles, unique) {
  return new Collection(this.cy(), eles, unique);
};
elesfn$1.spawnSelf = function() {
  return this.spawn(this);
};
elesfn$1.cy = function() {
  return this._private.cy;
};
elesfn$1.renderer = function() {
  return this._private.cy.renderer();
};
elesfn$1.element = function() {
  return this[0];
};
elesfn$1.collection = function() {
  if (collection(this)) {
    return this;
  } else {
    return new Collection(this._private.cy, [this]);
  }
};
elesfn$1.unique = function() {
  return new Collection(this._private.cy, this, true);
};
elesfn$1.hasElementWithId = function(id2) {
  id2 = "" + id2;
  return this._private.map.has(id2);
};
elesfn$1.getElementById = function(id2) {
  id2 = "" + id2;
  var cy = this._private.cy;
  var entry = this._private.map.get(id2);
  return entry ? entry.ele : new Collection(cy);
};
elesfn$1.$id = elesfn$1.getElementById;
elesfn$1.poolIndex = function() {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id2 = this[0]._private.data.id;
  return eles._private.map.get(id2).index;
};
elesfn$1.indexOf = function(ele) {
  var id2 = ele[0]._private.data.id;
  return this._private.map.get(id2).index;
};
elesfn$1.indexOfId = function(id2) {
  id2 = "" + id2;
  return this._private.map.get(id2).index;
};
elesfn$1.json = function(obj) {
  var ele = this.element();
  var cy = this.cy();
  if (ele == null && obj) {
    return this;
  }
  if (ele == null) {
    return void 0;
  }
  var p2 = ele._private;
  if (plainObject(obj)) {
    cy.startBatch();
    if (obj.data) {
      ele.data(obj.data);
      var _data2 = p2.data;
      if (ele.isEdge()) {
        var move2 = false;
        var spec = {};
        var src = obj.data.source;
        var tgt = obj.data.target;
        if (src != null && src != _data2.source) {
          spec.source = "" + src;
          move2 = true;
        }
        if (tgt != null && tgt != _data2.target) {
          spec.target = "" + tgt;
          move2 = true;
        }
        if (move2) {
          ele = ele.move(spec);
        }
      } else {
        var newParentValSpecd = "parent" in obj.data;
        var parent4 = obj.data.parent;
        if (newParentValSpecd && (parent4 != null || _data2.parent != null) && parent4 != _data2.parent) {
          if (parent4 === void 0) {
            parent4 = null;
          }
          if (parent4 != null) {
            parent4 = "" + parent4;
          }
          ele = ele.move({
            parent: parent4
          });
        }
      }
    }
    if (obj.position) {
      ele.position(obj.position);
    }
    var checkSwitch = /* @__PURE__ */ __name(function checkSwitch2(k, trueFnName, falseFnName) {
      var obj_k = obj[k];
      if (obj_k != null && obj_k !== p2[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    }, "checkSwitch2");
    checkSwitch("removed", "remove", "restore");
    checkSwitch("selected", "select", "unselect");
    checkSwitch("selectable", "selectify", "unselectify");
    checkSwitch("locked", "lock", "unlock");
    checkSwitch("grabbable", "grabify", "ungrabify");
    checkSwitch("pannable", "panify", "unpanify");
    if (obj.classes != null) {
      ele.classes(obj.classes);
    }
    cy.endBatch();
    return this;
  } else if (obj === void 0) {
    var json2 = {
      data: copy(p2.data),
      position: copy(p2.position),
      group: p2.group,
      removed: p2.removed,
      selected: p2.selected,
      selectable: p2.selectable,
      locked: p2.locked,
      grabbable: p2.grabbable,
      pannable: p2.pannable,
      classes: null
    };
    json2.classes = "";
    var i = 0;
    p2.classes.forEach(function(cls) {
      return json2.classes += i++ === 0 ? cls : " " + cls;
    });
    return json2;
  }
};
elesfn$1.jsons = function() {
  var jsons = [];
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json2 = ele.json();
    jsons.push(json2);
  }
  return jsons;
};
elesfn$1.clone = function() {
  var cy = this.cy();
  var elesArr = [];
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json2 = ele.json();
    var clone3 = new Element$1(cy, json2, false);
    elesArr.push(clone3);
  }
  return new Collection(cy, elesArr);
};
elesfn$1.copy = elesfn$1.clone;
elesfn$1.restore = function() {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var addToPool2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var self2 = this;
  var cy = self2.cy();
  var cy_p = cy._private;
  var nodes3 = [];
  var edges3 = [];
  var elements;
  for (var _i3 = 0, l = self2.length; _i3 < l; _i3++) {
    var ele = self2[_i3];
    if (addToPool2 && !ele.removed()) {
      continue;
    }
    if (ele.isNode()) {
      nodes3.push(ele);
    } else {
      edges3.push(ele);
    }
  }
  elements = nodes3.concat(edges3);
  var i;
  var removeFromElements = /* @__PURE__ */ __name(function removeFromElements2() {
    elements.splice(i, 1);
    i--;
  }, "removeFromElements2");
  for (i = 0; i < elements.length; i++) {
    var _ele2 = elements[i];
    var _private = _ele2._private;
    var _data3 = _private.data;
    _ele2.clearTraversalCache();
    if (!addToPool2 && !_private.removed) ;
    else if (_data3.id === void 0) {
      _data3.id = uuid();
    } else if (number$1(_data3.id)) {
      _data3.id = "" + _data3.id;
    } else if (emptyString(_data3.id) || !string(_data3.id)) {
      error("Can not create element with invalid string ID `" + _data3.id + "`");
      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(_data3.id)) {
      error("Can not create second element with ID `" + _data3.id + "`");
      removeFromElements();
      continue;
    }
    var id2 = _data3.id;
    if (_ele2.isNode()) {
      var pos = _private.position;
      if (pos.x == null) {
        pos.x = 0;
      }
      if (pos.y == null) {
        pos.y = 0;
      }
    }
    if (_ele2.isEdge()) {
      var edge = _ele2;
      var fields = ["source", "target"];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for (var j = 0; j < fieldsLength; j++) {
        var field = fields[j];
        var val = _data3[field];
        if (number$1(val)) {
          val = _data3[field] = "" + _data3[field];
        }
        if (val == null || val === "") {
          error("Can not create edge `" + id2 + "` with unspecified " + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          error("Can not create edge `" + id2 + "` with nonexistant " + field + " `" + val + "`");
          badSourceOrTarget = true;
        }
      }
      if (badSourceOrTarget) {
        removeFromElements();
        continue;
      }
      var src = cy.getElementById(_data3.source);
      var tgt = cy.getElementById(_data3.target);
      if (src.same(tgt)) {
        src._private.edges.push(edge);
      } else {
        src._private.edges.push(edge);
        tgt._private.edges.push(edge);
      }
      edge._private.source = src;
      edge._private.target = tgt;
    }
    _private.map = new Map$1();
    _private.map.set(id2, {
      ele: _ele2,
      index: 0
    });
    _private.removed = false;
    if (addToPool2) {
      cy.addToPool(_ele2);
    }
  }
  for (var _i4 = 0; _i4 < nodes3.length; _i4++) {
    var node = nodes3[_i4];
    var _data4 = node._private.data;
    if (number$1(_data4.parent)) {
      _data4.parent = "" + _data4.parent;
    }
    var parentId = _data4.parent;
    var specifiedParent = parentId != null;
    if (specifiedParent || node._private.parent) {
      var parent4 = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);
      if (parent4.empty()) {
        _data4.parent = void 0;
      } else if (parent4[0].removed()) {
        warn("Node added with missing parent, reference to parent removed");
        _data4.parent = void 0;
        node._private.parent = null;
      } else {
        var selfAsParent = false;
        var ancestor = parent4;
        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            selfAsParent = true;
            _data4.parent = void 0;
            break;
          }
          ancestor = ancestor.parent();
        }
        if (!selfAsParent) {
          parent4[0]._private.children.push(node);
          node._private.parent = parent4[0];
          cy_p.hasCompoundNodes = true;
        }
      }
    }
  }
  if (elements.length > 0) {
    var restored = elements.length === self2.length ? self2 : new Collection(cy, elements);
    for (var _i5 = 0; _i5 < restored.length; _i5++) {
      var _ele3 = restored[_i5];
      if (_ele3.isNode()) {
        continue;
      }
      _ele3.parallelEdges().clearTraversalCache();
      _ele3.source().clearTraversalCache();
      _ele3.target().clearTraversalCache();
    }
    var toUpdateStyle;
    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }
    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);
    if (notifyRenderer) {
      restored.emitAndNotify("add");
    } else if (addToPool2) {
      restored.emit("add");
    }
  }
  return self2;
};
elesfn$1.removed = function() {
  var ele = this[0];
  return ele && ele._private.removed;
};
elesfn$1.inside = function() {
  var ele = this[0];
  return ele && !ele._private.removed;
};
elesfn$1.remove = function() {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var removeFromPool2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var self2 = this;
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self2._private.cy;
  function addConnectedEdges(node) {
    var edges3 = node._private.edges;
    for (var i2 = 0; i2 < edges3.length; i2++) {
      add3(edges3[i2]);
    }
  }
  __name(addConnectedEdges, "addConnectedEdges");
  function addChildren2(node) {
    var children = node._private.children;
    for (var i2 = 0; i2 < children.length; i2++) {
      add3(children[i2]);
    }
  }
  __name(addChildren2, "addChildren2");
  function add3(ele2) {
    var alreadyAdded = elesToRemoveIds[ele2.id()];
    if (removeFromPool2 && ele2.removed() || alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele2.id()] = true;
    }
    if (ele2.isNode()) {
      elesToRemove.push(ele2);
      addConnectedEdges(ele2);
      addChildren2(ele2);
    } else {
      elesToRemove.unshift(ele2);
    }
  }
  __name(add3, "add3");
  for (var i = 0, l = self2.length; i < l; i++) {
    var ele = self2[i];
    add3(ele);
  }
  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;
    removeFromArray(connectedEdges, edge);
    node.clearTraversalCache();
  }
  __name(removeEdgeRef, "removeEdgeRef");
  function removeParallelRef(pllEdge2) {
    pllEdge2.clearTraversalCache();
  }
  __name(removeParallelRef, "removeParallelRef");
  var alteredParents = [];
  alteredParents.ids = {};
  function removeChildRef(parent5, ele2) {
    ele2 = ele2[0];
    parent5 = parent5[0];
    var children = parent5._private.children;
    var pid = parent5.id();
    removeFromArray(children, ele2);
    ele2._private.parent = null;
    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent5);
    }
  }
  __name(removeChildRef, "removeChildRef");
  self2.dirtyCompoundBoundsCache();
  if (removeFromPool2) {
    cy.removeFromPool(elesToRemove);
  }
  for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {
    var _ele4 = elesToRemove[_i6];
    if (_ele4.isEdge()) {
      var src = _ele4.source()[0];
      var tgt = _ele4.target()[0];
      removeEdgeRef(src, _ele4);
      removeEdgeRef(tgt, _ele4);
      var pllEdges = _ele4.parallelEdges();
      for (var j = 0; j < pllEdges.length; j++) {
        var pllEdge = pllEdges[j];
        removeParallelRef(pllEdge);
        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      }
    } else {
      var parent4 = _ele4.parent();
      if (parent4.length !== 0) {
        removeChildRef(parent4, _ele4);
      }
    }
    if (removeFromPool2) {
      _ele4._private.removed = true;
    }
  }
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {
    var _ele5 = elesStillInside[_i7];
    if (_ele5.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }
  var removedElements = new Collection(this.cy(), elesToRemove);
  if (removedElements.size() > 0) {
    if (notifyRenderer) {
      removedElements.emitAndNotify("remove");
    } else if (removeFromPool2) {
      removedElements.emit("remove");
    }
  }
  for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {
    var _ele6 = alteredParents[_i8];
    if (!removeFromPool2 || !_ele6.removed()) {
      _ele6.updateStyle();
    }
  }
  return removedElements;
};
elesfn$1.move = function(struct) {
  var cy = this._private.cy;
  var eles = this;
  var notifyRenderer = false;
  var modifyPool = false;
  var toString3 = /* @__PURE__ */ __name(function toString4(id2) {
    return id2 == null ? id2 : "" + id2;
  }, "toString4");
  if (struct.source !== void 0 || struct.target !== void 0) {
    var srcId = toString3(struct.source);
    var tgtId = toString3(struct.target);
    var srcExists = srcId != null && cy.hasElementWithId(srcId);
    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);
    if (srcExists || tgtExists) {
      cy.batch(function() {
        eles.remove(notifyRenderer, modifyPool);
        eles.emitAndNotify("moveout");
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data5 = ele._private.data;
          if (ele.isEdge()) {
            if (srcExists) {
              _data5.source = srcId;
            }
            if (tgtExists) {
              _data5.target = tgtId;
            }
          }
        }
        eles.restore(notifyRenderer, modifyPool);
      });
      eles.emitAndNotify("move");
    }
  } else if (struct.parent !== void 0) {
    var parentId = toString3(struct.parent);
    var parentExists = parentId === null || cy.hasElementWithId(parentId);
    if (parentExists) {
      var pidToAssign = parentId === null ? void 0 : parentId;
      cy.batch(function() {
        var updated = eles.remove(notifyRenderer, modifyPool);
        updated.emitAndNotify("moveout");
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data6 = ele._private.data;
          if (ele.isNode()) {
            _data6.parent = pidToAssign;
          }
        }
        updated.restore(notifyRenderer, modifyPool);
      });
      eles.emitAndNotify("move");
    }
  }
  return this;
};
[elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data3, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function(props) {
  extend(elesfn$1, props);
});
var corefn$9 = {
  add: /* @__PURE__ */ __name(function add2(opts) {
    var elements;
    var cy = this;
    if (elementOrCollection(opts)) {
      var eles = opts;
      if (eles._private.cy === cy) {
        elements = eles.restore();
      } else {
        var jsons = [];
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }
        elements = new Collection(cy, jsons);
      }
    } else if (array(opts)) {
      var _jsons = opts;
      elements = new Collection(cy, _jsons);
    } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
      var elesByGroup = opts;
      var _jsons2 = [];
      var grs = ["nodes", "edges"];
      for (var _i = 0, il = grs.length; _i < il; _i++) {
        var group2 = grs[_i];
        var elesArray = elesByGroup[group2];
        if (array(elesArray)) {
          for (var j = 0, jl = elesArray.length; j < jl; j++) {
            var json2 = extend({
              group: group2
            }, elesArray[j]);
            _jsons2.push(json2);
          }
        }
      }
      elements = new Collection(cy, _jsons2);
    } else {
      var _json = opts;
      elements = new Element$1(cy, _json).collection();
    }
    return elements;
  }, "add2"),
  remove: /* @__PURE__ */ __name(function remove(collection4) {
    if (elementOrCollection(collection4)) ;
    else if (string(collection4)) {
      var selector = collection4;
      collection4 = this.$(selector);
    }
    return collection4.remove();
  }, "remove")
};
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 1e-3, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1 / (kSplineTableSize - 1), float32ArraySupported = typeof Float32Array !== "undefined";
  if (arguments.length !== 4) {
    return false;
  }
  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }
  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);
  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  function A(aA1, aA2) {
    return 1 - 3 * aA2 + 3 * aA1;
  }
  __name(A, "A");
  function B(aA1, aA2) {
    return 3 * aA2 - 6 * aA1;
  }
  __name(B, "B");
  function C(aA1) {
    return 3 * aA1;
  }
  __name(C, "C");
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }
  __name(calcBezier, "calcBezier");
  function getSlope(aT, aA1, aA2) {
    return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
  }
  __name(getSlope, "getSlope");
  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0) {
        return aGuessT;
      }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }
  __name(newtonRaphsonIterate, "newtonRaphsonIterate");
  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }
  __name(calcSampleValues, "calcSampleValues");
  function binarySubdivide(aX, aA, aB) {
    var currentX, currentT, i2 = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }
  __name(binarySubdivide, "binarySubdivide");
  function getTForX(aX) {
    var intervalStart = 0, currentSample = 1, lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist3 = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist3 * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }
  __name(getTForX, "getTForX");
  var _precomputed = false;
  function precompute() {
    _precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }
  __name(precompute, "precompute");
  var f = /* @__PURE__ */ __name(function f2(aX) {
    if (!_precomputed) {
      precompute();
    }
    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }
    if (aX === 0) {
      return 0;
    }
    if (aX === 1) {
      return 1;
    }
    return calcBezier(getTForX(aX), mY1, mY2);
  }, "f2");
  f.getControlPoints = function() {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };
  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
  f.toString = function() {
    return str;
  };
  return f;
}
__name(generateCubicBezier, "generateCubicBezier");
var generateSpringRK4 = /* @__PURE__ */ (function() {
  function springAccelerationForState(state2) {
    return -state2.tension * state2.x - state2.friction * state2.v;
  }
  __name(springAccelerationForState, "springAccelerationForState");
  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state2 = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };
    return {
      dx: state2.v,
      dv: springAccelerationForState(state2)
    };
  }
  __name(springEvaluateStateWithDerivative, "springEvaluateStateWithDerivative");
  function springIntegrateState(state2, dt) {
    var a = {
      dx: state2.v,
      dv: springAccelerationForState(state2)
    }, b = springEvaluateStateWithDerivative(state2, dt * 0.5, a), c = springEvaluateStateWithDerivative(state2, dt * 0.5, b), d = springEvaluateStateWithDerivative(state2, dt, c), dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx), dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);
    state2.x = state2.x + dxdt * dt;
    state2.v = state2.v + dvdt * dt;
    return state2;
  }
  __name(springIntegrateState, "springIntegrateState");
  return /* @__PURE__ */ __name(function springRK4Factory(tension, friction, duration) {
    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    }, path = [0], time_lapsed = 0, tolerance = 1 / 1e4, DT = 16 / 1e3, have_duration, dt, last_state;
    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;
    initState.tension = tension;
    initState.friction = friction;
    have_duration = duration !== null;
    if (have_duration) {
      time_lapsed = springRK4Factory(tension, friction);
      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }
    for (; ; ) {
      last_state = springIntegrateState(last_state || initState, dt);
      path.push(1 + last_state.x);
      time_lapsed += 16;
      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }
    return !have_duration ? time_lapsed : function(percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  }, "springRK4Factory");
})();
var cubicBezier = /* @__PURE__ */ __name(function cubicBezier2(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);
  return function(start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
}, "cubicBezier2");
var easings = {
  "linear": /* @__PURE__ */ __name(function linear2(start, end, percent) {
    return start + (end - start) * percent;
  }, "linear"),
  // default easings
  "ease": cubicBezier(0.25, 0.1, 0.25, 1),
  "ease-in": cubicBezier(0.42, 0, 1, 1),
  "ease-out": cubicBezier(0, 0, 0.58, 1),
  "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
  // sine
  "ease-in-sine": cubicBezier(0.47, 0, 0.745, 0.715),
  "ease-out-sine": cubicBezier(0.39, 0.575, 0.565, 1),
  "ease-in-out-sine": cubicBezier(0.445, 0.05, 0.55, 0.95),
  // quad
  "ease-in-quad": cubicBezier(0.55, 0.085, 0.68, 0.53),
  "ease-out-quad": cubicBezier(0.25, 0.46, 0.45, 0.94),
  "ease-in-out-quad": cubicBezier(0.455, 0.03, 0.515, 0.955),
  // cubic
  "ease-in-cubic": cubicBezier(0.55, 0.055, 0.675, 0.19),
  "ease-out-cubic": cubicBezier(0.215, 0.61, 0.355, 1),
  "ease-in-out-cubic": cubicBezier(0.645, 0.045, 0.355, 1),
  // quart
  "ease-in-quart": cubicBezier(0.895, 0.03, 0.685, 0.22),
  "ease-out-quart": cubicBezier(0.165, 0.84, 0.44, 1),
  "ease-in-out-quart": cubicBezier(0.77, 0, 0.175, 1),
  // quint
  "ease-in-quint": cubicBezier(0.755, 0.05, 0.855, 0.06),
  "ease-out-quint": cubicBezier(0.23, 1, 0.32, 1),
  "ease-in-out-quint": cubicBezier(0.86, 0, 0.07, 1),
  // expo
  "ease-in-expo": cubicBezier(0.95, 0.05, 0.795, 0.035),
  "ease-out-expo": cubicBezier(0.19, 1, 0.22, 1),
  "ease-in-out-expo": cubicBezier(1, 0, 0, 1),
  // circ
  "ease-in-circ": cubicBezier(0.6, 0.04, 0.98, 0.335),
  "ease-out-circ": cubicBezier(0.075, 0.82, 0.165, 1),
  "ease-in-out-circ": cubicBezier(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  "spring": /* @__PURE__ */ __name(function spring(tension, friction, duration) {
    if (duration === 0) {
      return easings.linear;
    }
    var spring2 = generateSpringRK4(tension, friction, duration);
    return function(start, end, percent) {
      return start + (end - start) * spring2(percent);
    };
  }, "spring"),
  "cubic-bezier": cubicBezier
};
function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }
  if (start === end) {
    return end;
  }
  var val = easingFn(start, end, percent);
  if (type == null) {
    return val;
  }
  if (type.roundValue || type.color) {
    val = Math.round(val);
  }
  if (type.min !== void 0) {
    val = Math.max(val, type.min);
  }
  if (type.max !== void 0) {
    val = Math.min(val, type.max);
  }
  return val;
}
__name(getEasedValue, "getEasedValue");
function getValue(prop2, spec) {
  if (prop2.pfValue != null || prop2.value != null) {
    if (prop2.pfValue != null && (spec == null || spec.type.units !== "%")) {
      return prop2.pfValue;
    } else {
      return prop2.value;
    }
  } else {
    return prop2;
  }
}
__name(getValue, "getValue");
function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;
  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }
  var start = getValue(startProp, propSpec);
  var end = getValue(endProp, propSpec);
  if (number$1(start) && number$1(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (array(start) && array(end)) {
    var easedArr = [];
    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];
      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);
        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }
    return easedArr;
  }
  return void 0;
}
__name(ease, "ease");
function step$1(self2, ani, now2, isCore) {
  var isEles = !isCore;
  var _p = self2._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self2 : self2.cy();
  var style3 = cy.style();
  if (!ani_p.easingImpl) {
    if (pEasing == null) {
      ani_p.easingImpl = easings["linear"];
    } else {
      var easingVals;
      if (string(pEasing)) {
        var easingProp = style3.parse("transition-timing-function", pEasing);
        easingVals = easingProp.value;
      } else {
        easingVals = pEasing;
      }
      var name, args2;
      if (string(easingVals)) {
        name = easingVals;
        args2 = [];
      } else {
        name = easingVals[1];
        args2 = easingVals.slice(2).map(function(n) {
          return +n;
        });
      }
      if (args2.length > 0) {
        if (name === "spring") {
          args2.push(ani_p.duration);
        }
        ani_p.easingImpl = easings[name].apply(null, args2);
      } else {
        ani_p.easingImpl = easings[name];
      }
    }
  }
  var easing = ani_p.easingImpl;
  var percent;
  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now2 - startTime) / ani_p.duration;
  }
  if (ani_p.applying) {
    percent = ani_p.progress;
  }
  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }
  if (ani_p.delay == null) {
    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;
    if (endPos && isEles && !self2.locked()) {
      var newPos = {};
      if (valid(startPos.x, endPos.x)) {
        newPos.x = ease(startPos.x, endPos.x, percent, easing);
      }
      if (valid(startPos.y, endPos.y)) {
        newPos.y = ease(startPos.y, endPos.y, percent, easing);
      }
      self2.position(newPos);
    }
    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan2 = _p.pan;
    var animatingPan = endPan != null && isCore;
    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan2.x = ease(startPan.x, endPan.x, percent, easing);
      }
      if (valid(startPan.y, endPan.y)) {
        pan2.y = ease(startPan.y, endPan.y, percent, easing);
      }
      self2.emit("pan");
    }
    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;
    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
      }
      self2.emit("zoom");
    }
    if (animatingPan || animatingZoom) {
      self2.emit("viewport");
    }
    var props = ani_p.style;
    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop2 = props[i];
        var _name = prop2.name;
        var end = prop2;
        var start = ani_p.startStyle[_name];
        var propSpec = style3.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);
        style3.overrideBypass(self2, _name, easedVal);
      }
      self2.emit("style");
    }
  }
  ani_p.progress = percent;
  return percent;
}
__name(step$1, "step$1");
function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }
  if (number$1(start) && number$1(end)) {
    return true;
  } else if (start && end) {
    return true;
  }
  return false;
}
__name(valid, "valid");
function startAnimation(self2, ani, now2, isCore) {
  var ani_p = ani._private;
  ani_p.started = true;
  ani_p.startTime = now2 - ani_p.progress * ani_p.duration;
}
__name(startAnimation, "startAnimation");
function stepAll(now2, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];
  function stepOne(ele2, isCore) {
    var _p = ele2._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false;
    if (current.length === 0) {
      var next2 = queue.shift();
      if (next2) {
        current.push(next2);
      }
    }
    var callbacks = /* @__PURE__ */ __name(function callbacks2(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];
        cb();
      }
      _callbacks.splice(0, _callbacks.length);
    }, "callbacks2");
    for (var i = current.length - 1; i >= 0; i--) {
      var ani = current[i];
      var ani_p = ani._private;
      if (ani_p.stopped) {
        current.splice(i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.frames);
        continue;
      }
      if (!ani_p.playing && !ani_p.applying) {
        continue;
      }
      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }
      if (!ani_p.started) {
        startAnimation(ele2, ani, now2);
      }
      step$1(ele2, ani, now2, isCore);
      if (ani_p.applying) {
        ani_p.applying = false;
      }
      callbacks(ani_p.frames);
      if (ani_p.step != null) {
        ani_p.step(now2);
      }
      if (ani.completed()) {
        current.splice(i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.completes);
      }
      ranAnis = true;
    }
    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele2);
    }
    return ranAnis;
  }
  __name(stepOne, "stepOne");
  var ranEleAni = false;
  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);
    ranEleAni = ranEleAni || handledThisEle;
  }
  var ranCoreAni = stepOne(cy, true);
  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      cy.notify("draw", eles);
    } else {
      cy.notify("draw");
    }
  }
  eles.unmerge(doneEles);
  cy.emit("step");
}
__name(stepAll, "stepAll");
var corefn$8 = {
  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),
  addToAnimationPool: /* @__PURE__ */ __name(function addToAnimationPool(eles) {
    var cy = this;
    if (!cy.styleEnabled()) {
      return;
    }
    cy._private.aniEles.merge(eles);
  }, "addToAnimationPool"),
  stopAnimationLoop: /* @__PURE__ */ __name(function stopAnimationLoop() {
    this._private.animationsRunning = false;
  }, "stopAnimationLoop"),
  startAnimationLoop: /* @__PURE__ */ __name(function startAnimationLoop() {
    var cy = this;
    cy._private.animationsRunning = true;
    if (!cy.styleEnabled()) {
      return;
    }
    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }
      requestAnimationFrame$1(/* @__PURE__ */ __name(function animationStep(now2) {
        stepAll(now2, cy);
        headlessStep();
      }, "animationStep"));
    }
    __name(headlessStep, "headlessStep");
    var renderer3 = cy.renderer();
    if (renderer3 && renderer3.beforeRender) {
      renderer3.beforeRender(/* @__PURE__ */ __name(function rendererAnimationStep(willDraw, now2) {
        stepAll(now2, cy);
      }, "rendererAnimationStep"), renderer3.beforeRenderPriorities.animations);
    } else {
      headlessStep();
    }
  }, "startAnimationLoop")
};
var emitterOptions = {
  qualifierCompare: /* @__PURE__ */ __name(function qualifierCompare3(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  }, "qualifierCompare3"),
  eventMatches: /* @__PURE__ */ __name(function eventMatches3(cy, listener, eventObj) {
    var selector = listener.qualifier;
    if (selector != null) {
      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }
    return true;
  }, "eventMatches3"),
  addEventFields: /* @__PURE__ */ __name(function addEventFields3(cy, evt) {
    evt.cy = cy;
    evt.target = cy;
  }, "addEventFields3"),
  callbackContext: /* @__PURE__ */ __name(function callbackContext3(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }, "callbackContext3")
};
var argSelector2 = /* @__PURE__ */ __name(function argSelector3(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
}, "argSelector3");
var elesfn = {
  createEmitter: /* @__PURE__ */ __name(function createEmitter2() {
    var _p = this._private;
    if (!_p.emitter) {
      _p.emitter = new Emitter(emitterOptions, this);
    }
    return this;
  }, "createEmitter2"),
  emitter: /* @__PURE__ */ __name(function emitter2() {
    return this._private.emitter;
  }, "emitter2"),
  on: /* @__PURE__ */ __name(function on22(events, selector, callback) {
    this.emitter().on(events, argSelector2(selector), callback);
    return this;
  }, "on2"),
  removeListener: /* @__PURE__ */ __name(function removeListener2(events, selector, callback) {
    this.emitter().removeListener(events, argSelector2(selector), callback);
    return this;
  }, "removeListener2"),
  removeAllListeners: /* @__PURE__ */ __name(function removeAllListeners2() {
    this.emitter().removeAllListeners();
    return this;
  }, "removeAllListeners2"),
  one: /* @__PURE__ */ __name(function one2(events, selector, callback) {
    this.emitter().one(events, argSelector2(selector), callback);
    return this;
  }, "one2"),
  once: /* @__PURE__ */ __name(function once22(events, selector, callback) {
    this.emitter().one(events, argSelector2(selector), callback);
    return this;
  }, "once2"),
  emit: /* @__PURE__ */ __name(function emit2(events, extraParams) {
    this.emitter().emit(events, extraParams);
    return this;
  }, "emit2"),
  emitAndNotify: /* @__PURE__ */ __name(function emitAndNotify2(event3, eles) {
    this.emit(event3);
    this.notify(event3, eles);
    return this;
  }, "emitAndNotify2")
};
define.eventAliasesOn(elesfn);
var corefn$7 = {
  png: /* @__PURE__ */ __name(function png(options2) {
    var renderer3 = this._private.renderer;
    options2 = options2 || {};
    return renderer3.png(options2);
  }, "png"),
  jpg: /* @__PURE__ */ __name(function jpg(options2) {
    var renderer3 = this._private.renderer;
    options2 = options2 || {};
    options2.bg = options2.bg || "#fff";
    return renderer3.jpg(options2);
  }, "jpg")
};
corefn$7.jpeg = corefn$7.jpg;
var corefn$6 = {
  layout: /* @__PURE__ */ __name(function layout2(options2) {
    var cy = this;
    if (options2 == null) {
      error("Layout options must be specified to make a layout");
      return;
    }
    if (options2.name == null) {
      error("A `name` must be specified to make a layout");
      return;
    }
    var name = options2.name;
    var Layout = cy.extension("layout", name);
    if (Layout == null) {
      error("No such layout `" + name + "` found.  Did you forget to import it and `cytoscape.use()` it?");
      return;
    }
    var eles;
    if (string(options2.eles)) {
      eles = cy.$(options2.eles);
    } else {
      eles = options2.eles != null ? options2.eles : cy.$();
    }
    var layout4 = new Layout(extend({}, options2, {
      cy,
      eles
    }));
    return layout4;
  }, "layout2")
};
corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;
var corefn$5 = {
  notify: /* @__PURE__ */ __name(function notify(eventName, eventEles) {
    var _p = this._private;
    if (this.batching()) {
      _p.batchNotifications = _p.batchNotifications || {};
      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();
      if (eventEles != null) {
        eles.merge(eventEles);
      }
      return;
    }
    if (!_p.notificationsEnabled) {
      return;
    }
    var renderer3 = this.renderer();
    if (this.destroyed() || !renderer3) {
      return;
    }
    renderer3.notify(eventName, eventEles);
  }, "notify"),
  notifications: /* @__PURE__ */ __name(function notifications(bool) {
    var p2 = this._private;
    if (bool === void 0) {
      return p2.notificationsEnabled;
    } else {
      p2.notificationsEnabled = bool ? true : false;
    }
    return this;
  }, "notifications"),
  noNotifications: /* @__PURE__ */ __name(function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  }, "noNotifications"),
  batching: /* @__PURE__ */ __name(function batching() {
    return this._private.batchCount > 0;
  }, "batching"),
  startBatch: /* @__PURE__ */ __name(function startBatch() {
    var _p = this._private;
    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }
    if (_p.batchCount === 0) {
      _p.batchStyleEles = this.collection();
      _p.batchNotifications = {};
    }
    _p.batchCount++;
    return this;
  }, "startBatch"),
  endBatch: /* @__PURE__ */ __name(function endBatch() {
    var _p = this._private;
    if (_p.batchCount === 0) {
      return this;
    }
    _p.batchCount--;
    if (_p.batchCount === 0) {
      _p.batchStyleEles.updateStyle();
      var renderer3 = this.renderer();
      Object.keys(_p.batchNotifications).forEach(function(eventName) {
        var eles = _p.batchNotifications[eventName];
        if (eles.empty()) {
          renderer3.notify(eventName);
        } else {
          renderer3.notify(eventName, eles);
        }
      });
    }
    return this;
  }, "endBatch"),
  batch: /* @__PURE__ */ __name(function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();
    return this;
  }, "batch"),
  // for backwards compatibility
  batchData: /* @__PURE__ */ __name(function batchData(map22) {
    var cy = this;
    return this.batch(function() {
      var ids = Object.keys(map22);
      for (var i = 0; i < ids.length; i++) {
        var id2 = ids[i];
        var data4 = map22[id2];
        var ele = cy.getElementById(id2);
        ele.data(data4);
      }
    });
  }, "batchData")
};
var rendererDefaults = defaults$g({
  hideEdgesOnViewport: false,
  textureOnViewport: false,
  motionBlur: false,
  motionBlurOpacity: 0.05,
  pixelRatio: void 0,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: false,
  showFps: false,
  // webgl options
  webgl: false,
  webglDebug: false,
  webglDebugShowAtlases: false,
  // defaults good for mobile
  webglTexSize: 2048,
  webglTexRows: 36,
  webglTexRowsNodes: 18,
  webglBatchSize: 2048,
  webglTexPerBatch: 14,
  webglBgColor: [255, 255, 255]
});
var corefn$4 = {
  renderTo: /* @__PURE__ */ __name(function renderTo(context, zoom2, pan2, pxRatio) {
    var r2 = this._private.renderer;
    r2.renderTo(context, zoom2, pan2, pxRatio);
    return this;
  }, "renderTo"),
  renderer: /* @__PURE__ */ __name(function renderer() {
    return this._private.renderer;
  }, "renderer"),
  forceRender: /* @__PURE__ */ __name(function forceRender() {
    this.notify("draw");
    return this;
  }, "forceRender"),
  resize: /* @__PURE__ */ __name(function resize() {
    this.invalidateSize();
    this.emitAndNotify("resize");
    return this;
  }, "resize"),
  initRenderer: /* @__PURE__ */ __name(function initRenderer(options2) {
    var cy = this;
    var RendererProto = cy.extension("renderer", options2.name);
    if (RendererProto == null) {
      error("Can not initialise: No such renderer `".concat(options2.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }
    if (options2.wheelSensitivity !== void 0) {
      warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    }
    var rOpts = rendererDefaults(options2);
    rOpts.cy = cy;
    cy._private.renderer = new RendererProto(rOpts);
    this.notify("init");
  }, "initRenderer"),
  destroyRenderer: /* @__PURE__ */ __name(function destroyRenderer() {
    var cy = this;
    cy.notify("destroy");
    var domEle = cy.container();
    if (domEle) {
      domEle._cyreg = null;
      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }
    cy._private.renderer = null;
    cy.mutableElements().forEach(function(ele) {
      var _p = ele._private;
      _p.rscratch = {};
      _p.rstyle = {};
      _p.animation.current = [];
      _p.animation.queue = [];
    });
  }, "destroyRenderer"),
  onRender: /* @__PURE__ */ __name(function onRender(fn3) {
    return this.on("render", fn3);
  }, "onRender"),
  offRender: /* @__PURE__ */ __name(function offRender(fn3) {
    return this.off("render", fn3);
  }, "offRender")
};
corefn$4.invalidateDimensions = corefn$4.resize;
var corefn$3 = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: /* @__PURE__ */ __name(function collection3(eles, opts) {
    if (string(eles)) {
      return this.$(eles);
    } else if (elementOrCollection(eles)) {
      return eles.collection();
    } else if (array(eles)) {
      if (!opts) {
        opts = {};
      }
      return new Collection(this, eles, opts.unique, opts.removed);
    }
    return new Collection(this);
  }, "collection3"),
  nodes: /* @__PURE__ */ __name(function nodes2(selector) {
    var nodes3 = this.$(function(ele) {
      return ele.isNode();
    });
    if (selector) {
      return nodes3.filter(selector);
    }
    return nodes3;
  }, "nodes2"),
  edges: /* @__PURE__ */ __name(function edges2(selector) {
    var edges3 = this.$(function(ele) {
      return ele.isEdge();
    });
    if (selector) {
      return edges3.filter(selector);
    }
    return edges3;
  }, "edges2"),
  // search the graph like jQuery
  $: /* @__PURE__ */ __name(function $(selector) {
    var eles = this._private.elements;
    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  }, "$"),
  mutableElements: /* @__PURE__ */ __name(function mutableElements() {
    return this._private.elements;
  }, "mutableElements")
};
corefn$3.elements = corefn$3.filter = corefn$3.$;
var styfn$8 = {};
var TRUE = "t";
var FALSE = "f";
styfn$8.apply = function(eles) {
  var self2 = this;
  var _p = self2._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();
  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];
    var cxtMeta = self2.getContextMeta(ele);
    if (cxtMeta.empty) {
      continue;
    }
    var cxtStyle = self2.getContextStyle(cxtMeta);
    var app = self2.applyContextStyle(cxtMeta, cxtStyle, ele);
    if (ele._private.appliedInitStyle) {
      self2.updateTransitions(ele, app.diffProps);
    } else {
      ele._private.appliedInitStyle = true;
    }
    var hintsDiff = self2.updateStyleHints(ele);
    if (hintsDiff) {
      updatedEles.push(ele);
    }
  }
  return updatedEles;
};
styfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {
  var self2 = this;
  var cache3 = self2._private.propDiffs = self2._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + "-" + newCxtKey;
  var cachedVal = cache3[dualCxtKey];
  if (cachedVal) {
    return cachedVal;
  }
  var diffProps = [];
  var addedProp = {};
  for (var i = 0; i < self2.length; i++) {
    var cxt = self2[i];
    var oldHasCxt = oldCxtKey[i] === TRUE;
    var newHasCxt = newCxtKey[i] === TRUE;
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;
    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
      var props = void 0;
      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties;
      } else if (cxtHasDiffed) {
        props = cxt.properties;
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties;
      }
      for (var j = 0; j < props.length; j++) {
        var prop2 = props[j];
        var name = prop2.name;
        var laterCxtOverrides = false;
        for (var k = i + 1; k < self2.length; k++) {
          var laterCxt = self2[k];
          var hasLaterCxt = newCxtKey[k] === TRUE;
          if (!hasLaterCxt) {
            continue;
          }
          laterCxtOverrides = laterCxt.properties[prop2.name] != null;
          if (laterCxtOverrides) {
            break;
          }
        }
        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      }
    }
  }
  cache3[dualCxtKey] = diffProps;
  return diffProps;
};
styfn$8.getContextMeta = function(ele) {
  var self2 = this;
  var cxtKey = "";
  var diffProps;
  var prevKey = ele._private.styleCxtKey || "";
  for (var i = 0; i < self2.length; i++) {
    var context = self2[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele);
    if (contextSelectorMatches) {
      cxtKey += TRUE;
    } else {
      cxtKey += FALSE;
    }
  }
  diffProps = self2.getPropertiesDiff(prevKey, cxtKey);
  ele._private.styleCxtKey = cxtKey;
  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
};
styfn$8.getContextStyle = function(cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self2 = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};
  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }
  var style3 = {
    _private: {
      key: cxtKey
    }
  };
  for (var i = 0; i < self2.length; i++) {
    var cxt = self2[i];
    var hasCxt = cxtKey[i] === TRUE;
    if (!hasCxt) {
      continue;
    }
    for (var j = 0; j < cxt.properties.length; j++) {
      var prop2 = cxt.properties[j];
      style3[prop2.name] = prop2;
    }
  }
  cxtStyles[cxtKey] = style3;
  return style3;
};
styfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {
  var self2 = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};
  var types = self2.types;
  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);
    if (!cxtProp) {
      if (!eleProp) {
        continue;
      } else if (eleProp.bypass) {
        cxtProp = {
          name: diffPropName,
          deleteBypassed: true
        };
      } else {
        cxtProp = {
          name: diffPropName,
          "delete": true
        };
      }
    }
    if (eleProp === cxtProp) {
      continue;
    }
    if (cxtProp.mapped === types.fn && eleProp != null && eleProp.mapping != null && eleProp.mapping.value === cxtProp.value) {
      var mapping = eleProp.mapping;
      var fnValue = mapping.fnValue = cxtProp.value(ele);
      if (fnValue === mapping.prevFnValue) {
        continue;
      }
    }
    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };
    self2.applyParsedProperty(ele, cxtProp);
    retDiffProp.next = ele.pstyle(diffPropName);
    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }
  return {
    diffProps: retDiffProps
  };
};
styfn$8.updateStyleHints = function(ele) {
  var _p = ele._private;
  var self2 = this;
  var propNames = self2.propertyGroupNames;
  var propGrKeys = self2.propertyGroupKeys;
  var propHash = /* @__PURE__ */ __name(function propHash2(ele2, propNames2, seedKey) {
    return self2.getPropertiesHash(ele2, propNames2, seedKey);
  }, "propHash2");
  var oldStyleKey = _p.styleKey;
  if (ele.removed()) {
    return false;
  }
  var isNode2 = _p.group === "nodes";
  var overriddenStyles = ele._private.style;
  propNames = Object.keys(overriddenStyles);
  for (var i = 0; i < propGrKeys.length; i++) {
    var grKey = propGrKeys[i];
    _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];
  }
  var updateGrKey1 = /* @__PURE__ */ __name(function updateGrKey12(val, grKey2) {
    return _p.styleKeys[grKey2][0] = hashInt(val, _p.styleKeys[grKey2][0]);
  }, "updateGrKey12");
  var updateGrKey2 = /* @__PURE__ */ __name(function updateGrKey22(val, grKey2) {
    return _p.styleKeys[grKey2][1] = hashIntAlt(val, _p.styleKeys[grKey2][1]);
  }, "updateGrKey22");
  var updateGrKey = /* @__PURE__ */ __name(function updateGrKey3(val, grKey2) {
    updateGrKey1(val, grKey2);
    updateGrKey2(val, grKey2);
  }, "updateGrKey3");
  var updateGrKeyWStr = /* @__PURE__ */ __name(function updateGrKeyWStr2(strVal, grKey2) {
    for (var j = 0; j < strVal.length; j++) {
      var ch = strVal.charCodeAt(j);
      updateGrKey1(ch, grKey2);
      updateGrKey2(ch, grKey2);
    }
  }, "updateGrKeyWStr2");
  var N = 2e9;
  var cleanNum = /* @__PURE__ */ __name(function cleanNum2(val) {
    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
  }, "cleanNum2");
  for (var _i = 0; _i < propNames.length; _i++) {
    var name = propNames[_i];
    var parsedProp = overriddenStyles[name];
    if (parsedProp == null) {
      continue;
    }
    var propInfo = this.properties[name];
    var type = propInfo.type;
    var _grKey = propInfo.groupKey;
    var normalizedNumberVal = void 0;
    if (propInfo.hashOverride != null) {
      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
    } else if (parsedProp.pfValue != null) {
      normalizedNumberVal = parsedProp.pfValue;
    }
    var numberVal = propInfo.enums == null ? parsedProp.value : null;
    var haveNormNum = normalizedNumberVal != null;
    var haveUnitedNum = numberVal != null;
    var haveNum = haveNormNum || haveUnitedNum;
    var units = parsedProp.units;
    if (type.number && haveNum && !type.multiple) {
      var v = haveNormNum ? normalizedNumberVal : numberVal;
      updateGrKey(cleanNum(v), _grKey);
      if (!haveNormNum && units != null) {
        updateGrKeyWStr(units, _grKey);
      }
    } else {
      updateGrKeyWStr(parsedProp.strValue, _grKey);
    }
  }
  var hash2 = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];
  for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {
    var _grKey2 = propGrKeys[_i2];
    var grHash = _p.styleKeys[_grKey2];
    hash2[0] = hashInt(grHash[0], hash2[0]);
    hash2[1] = hashIntAlt(grHash[1], hash2[1]);
  }
  _p.styleKey = combineHashes(hash2[0], hash2[1]);
  var sk = _p.styleKeys;
  _p.labelDimsKey = combineHashesArray(sk.labelDimensions);
  var labelKeys = propHash(ele, ["label"], sk.labelDimensions);
  _p.labelKey = combineHashesArray(labelKeys);
  _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));
  if (!isNode2) {
    var sourceLabelKeys = propHash(ele, ["source-label"], sk.labelDimensions);
    _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);
    _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));
    var targetLabelKeys = propHash(ele, ["target-label"], sk.labelDimensions);
    _p.targetLabelKey = combineHashesArray(targetLabelKeys);
    _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));
  }
  if (isNode2) {
    var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, nodeOutline = _p$styleKeys.nodeOutline, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie, stripe = _p$styleKeys.stripe;
    var nodeKeys = [nodeBody, nodeBorder, nodeOutline, backgroundImage, compound, pie, stripe].filter(function(k) {
      return k != null;
    }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);
    _p.nodeKey = combineHashesArray(nodeKeys);
    _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;
    _p.hasStripe = stripe != null && stripe[0] !== DEFAULT_HASH_SEED && stripe[1] !== DEFAULT_HASH_SEED_ALT;
  }
  return oldStyleKey !== _p.styleKey;
};
styfn$8.clearStyleHints = function(ele) {
  var _p = ele._private;
  _p.styleCxtKey = "";
  _p.styleKeys = {};
  _p.styleKey = null;
  _p.labelKey = null;
  _p.labelStyleKey = null;
  _p.sourceLabelKey = null;
  _p.sourceLabelStyleKey = null;
  _p.targetLabelKey = null;
  _p.targetLabelStyleKey = null;
  _p.nodeKey = null;
  _p.hasPie = null;
  _p.hasStripe = null;
};
styfn$8.applyParsedProperty = function(ele, parsedProp) {
  var self2 = this;
  var prop2 = parsedProp;
  var style3 = ele._private.style;
  var flatProp;
  var types = self2.types;
  var type = self2.properties[prop2.name].type;
  var propIsBypass = prop2.bypass;
  var origProp = style3[prop2.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = "mapping";
  var getVal = /* @__PURE__ */ __name(function getVal2(p2) {
    if (p2 == null) {
      return null;
    } else if (p2.pfValue != null) {
      return p2.pfValue;
    } else {
      return p2.value;
    }
  }, "getVal2");
  var checkTriggers = /* @__PURE__ */ __name(function checkTriggers2() {
    var fromVal = getVal(origProp);
    var toVal = getVal(prop2);
    self2.checkTriggers(ele, prop2.name, fromVal, toVal);
  }, "checkTriggers2");
  if (parsedProp.name === "curve-style" && ele.isEdge() && // loops must be bundled beziers
  (parsedProp.value !== "bezier" && ele.isLoop() || // edges connected to compound nodes can not be haystacks
  parsedProp.value === "haystack" && (ele.source().isParent() || ele.target().isParent()))) {
    prop2 = parsedProp = this.parse(parsedProp.name, "bezier", propIsBypass);
  }
  if (prop2["delete"]) {
    style3[prop2.name] = void 0;
    checkTriggers();
    return true;
  }
  if (prop2.deleteBypassed) {
    if (!origProp) {
      checkTriggers();
      return true;
    } else if (origProp.bypass) {
      origProp.bypassed = void 0;
      checkTriggers();
      return true;
    } else {
      return false;
    }
  }
  if (prop2.deleteBypass) {
    if (!origProp) {
      checkTriggers();
      return true;
    } else if (origProp.bypass) {
      style3[prop2.name] = origProp.bypassed;
      checkTriggers();
      return true;
    } else {
      return false;
    }
  }
  var printMappingErr = /* @__PURE__ */ __name(function printMappingErr2() {
    warn("Do not assign mappings to elements without corresponding data (i.e. ele `" + ele.id() + "` has no mapping for property `" + prop2.name + "` with data field `" + prop2.field + "`); try a `[" + prop2.field + "]` selector to limit scope to elements with `" + prop2.field + "` defined");
  }, "printMappingErr2");
  switch (prop2.mapped) {
    // flatten the property if mapped
    case types.mapData: {
      var fields = prop2.field.split(".");
      var fieldVal = _p.data;
      for (var i = 0; i < fields.length && fieldVal; i++) {
        var field = fields[i];
        fieldVal = fieldVal[field];
      }
      if (fieldVal == null) {
        printMappingErr();
        return false;
      }
      var percent;
      if (!number$1(fieldVal)) {
        warn("Do not use continuous mappers without specifying numeric data (i.e. `" + prop2.field + ": " + fieldVal + "` for `" + ele.id() + "` is non-numeric)");
        return false;
      } else {
        var fieldWidth = prop2.fieldMax - prop2.fieldMin;
        if (fieldWidth === 0) {
          percent = 0;
        } else {
          percent = (fieldVal - prop2.fieldMin) / fieldWidth;
        }
      }
      if (percent < 0) {
        percent = 0;
      } else if (percent > 1) {
        percent = 1;
      }
      if (type.color) {
        var r1 = prop2.valueMin[0];
        var r2 = prop2.valueMax[0];
        var g1 = prop2.valueMin[1];
        var g2 = prop2.valueMax[1];
        var b1 = prop2.valueMin[2];
        var b2 = prop2.valueMax[2];
        var a1 = prop2.valueMin[3] == null ? 1 : prop2.valueMin[3];
        var a2 = prop2.valueMax[3] == null ? 1 : prop2.valueMax[3];
        var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
        flatProp = {
          // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop2.bypass,
          // we're a bypass if the mapping property is a bypass
          name: prop2.name,
          value: clr,
          strValue: "rgb(" + clr[0] + ", " + clr[1] + ", " + clr[2] + ")"
        };
      } else if (type.number) {
        var calcValue = prop2.valueMin + (prop2.valueMax - prop2.valueMin) * percent;
        flatProp = this.parse(prop2.name, calcValue, prop2.bypass, flatPropMapping);
      } else {
        return false;
      }
      if (!flatProp) {
        printMappingErr();
        return false;
      }
      flatProp.mapping = prop2;
      prop2 = flatProp;
      break;
    }
    // direct mapping
    case types.data: {
      var _fields = prop2.field.split(".");
      var _fieldVal = _p.data;
      for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {
        var _field = _fields[_i3];
        _fieldVal = _fieldVal[_field];
      }
      if (_fieldVal != null) {
        flatProp = this.parse(prop2.name, _fieldVal, prop2.bypass, flatPropMapping);
      }
      if (!flatProp) {
        printMappingErr();
        return false;
      }
      flatProp.mapping = prop2;
      prop2 = flatProp;
      break;
    }
    case types.fn: {
      var fn3 = prop2.value;
      var fnRetVal = prop2.fnValue != null ? prop2.fnValue : fn3(ele);
      prop2.prevFnValue = fnRetVal;
      if (fnRetVal == null) {
        warn("Custom function mappers may not return null (i.e. `" + prop2.name + "` for ele `" + ele.id() + "` is null)");
        return false;
      }
      flatProp = this.parse(prop2.name, fnRetVal, prop2.bypass, flatPropMapping);
      if (!flatProp) {
        warn("Custom function mappers may not return invalid values for the property type (i.e. `" + prop2.name + "` for ele `" + ele.id() + "` is invalid)");
        return false;
      }
      flatProp.mapping = copy(prop2);
      prop2 = flatProp;
      break;
    }
    case void 0:
      break;
    // just set the property
    default:
      return false;
  }
  if (propIsBypass) {
    if (origPropIsBypass) {
      prop2.bypassed = origProp.bypassed;
    } else {
      prop2.bypassed = origProp;
    }
    style3[prop2.name] = prop2;
  } else {
    if (origPropIsBypass) {
      origProp.bypassed = prop2;
    } else {
      style3[prop2.name] = prop2;
    }
  }
  checkTriggers();
  return true;
};
styfn$8.cleanElements = function(eles, keepBypasses) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    this.clearStyleHints(ele);
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache();
    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style3 = ele._private.style;
      var propNames = Object.keys(style3);
      for (var j = 0; j < propNames.length; j++) {
        var propName = propNames[j];
        var eleProp = style3[propName];
        if (eleProp != null) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style3[propName] = null;
          }
        }
      }
    }
  }
};
styfn$8.update = function() {
  var cy = this._private.cy;
  var eles = cy.mutableElements();
  eles.updateStyle();
};
styfn$8.updateTransitions = function(ele, diffProps) {
  var self2 = this;
  var _p = ele._private;
  var props = ele.pstyle("transition-property").value;
  var duration = ele.pstyle("transition-duration").pfValue;
  var delay2 = ele.pstyle("transition-delay").pfValue;
  if (props.length > 0 && duration > 0) {
    var style3 = {};
    var anyPrev = false;
    for (var i = 0; i < props.length; i++) {
      var prop2 = props[i];
      var styProp = ele.pstyle(prop2);
      var diffProp = diffProps[prop2];
      if (!diffProp) {
        continue;
      }
      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff2 = false;
      var initVal = void 0;
      var initDt = 1e-6;
      if (!fromProp) {
        continue;
      }
      if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {
        diff2 = toProp.pfValue - fromProp.pfValue;
        initVal = fromProp.pfValue + initDt * diff2;
      } else if (number$1(fromProp.value) && number$1(toProp.value)) {
        diff2 = toProp.value - fromProp.value;
        initVal = fromProp.value + initDt * diff2;
      } else if (array(fromProp.value) && array(toProp.value)) {
        diff2 = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
        initVal = fromProp.strValue;
      }
      if (diff2) {
        style3[prop2] = toProp.strValue;
        this.applyBypass(ele, prop2, initVal);
        anyPrev = true;
      }
    }
    if (!anyPrev) {
      return;
    }
    _p.transitioning = true;
    new Promise$1(function(resolve2) {
      if (delay2 > 0) {
        ele.delayAnimation(delay2).play().promise().then(resolve2);
      } else {
        resolve2();
      }
    }).then(function() {
      return ele.animation({
        style: style3,
        duration,
        easing: ele.pstyle("transition-timing-function").value,
        queue: false
      }).play().promise();
    }).then(function() {
      self2.removeBypasses(ele, props);
      ele.emitAndNotify("style");
      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify("style");
    _p.transitioning = false;
  }
};
styfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {
  var prop2 = this.properties[name];
  var triggerCheck = getTrigger(prop2);
  if (ele.removed()) {
    return;
  }
  if (triggerCheck != null && triggerCheck(fromValue, toValue, ele)) {
    onTrigger(prop2);
  }
};
styfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {
  var _this = this;
  this.checkTrigger(ele, name, fromValue, toValue, function(prop2) {
    return prop2.triggersZOrder;
  }, function() {
    _this._private.cy.notify("zorder", ele);
  });
};
styfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function(prop2) {
    return prop2.triggersBounds;
  }, function(prop2) {
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache();
  });
};
styfn$8.checkConnectedEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function(prop2) {
    return prop2.triggersBoundsOfConnectedEdges;
  }, function(prop2) {
    ele.connectedEdges().forEach(function(edge) {
      edge.dirtyBoundingBoxCache();
    });
  });
};
styfn$8.checkParallelEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function(prop2) {
    return prop2.triggersBoundsOfParallelEdges;
  }, function(prop2) {
    ele.parallelEdges().forEach(function(pllEdge) {
      pllEdge.dirtyBoundingBoxCache();
    });
  });
};
styfn$8.checkTriggers = function(ele, name, fromValue, toValue) {
  ele.dirtyStyleCache();
  this.checkZOrderTrigger(ele, name, fromValue, toValue);
  this.checkBoundsTrigger(ele, name, fromValue, toValue);
  this.checkConnectedEdgesBoundsTrigger(ele, name, fromValue, toValue);
  this.checkParallelEdgesBoundsTrigger(ele, name, fromValue, toValue);
};
var styfn$7 = {};
styfn$7.applyBypass = function(eles, name, value2, updateTransitions) {
  var self2 = this;
  var props = [];
  var isBypass = true;
  if (name === "*" || name === "**") {
    if (value2 !== void 0) {
      for (var i = 0; i < self2.properties.length; i++) {
        var prop2 = self2.properties[i];
        var _name = prop2.name;
        var parsedProp = this.parse(_name, value2, true);
        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (string(name)) {
    var _parsedProp = this.parse(name, value2, true);
    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (plainObject(name)) {
    var specifiedProps = name;
    updateTransitions = value2;
    var names = Object.keys(specifiedProps);
    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _value = specifiedProps[_name2];
      if (_value === void 0) {
        _value = specifiedProps[dash2camel(_name2)];
      }
      if (_value !== void 0) {
        var _parsedProp2 = this.parse(_name2, _value, true);
        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    return false;
  }
  if (props.length === 0) {
    return false;
  }
  var ret = false;
  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;
    for (var j = 0; j < props.length; j++) {
      var _prop = props[j];
      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop.name);
        diffProp = diffProps[_prop.name] = {
          prev: prevProp
        };
      }
      ret = this.applyParsedProperty(ele, copy(_prop)) || ret;
      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop.name);
      }
    }
    if (ret) {
      this.updateStyleHints(ele);
    }
    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  }
  return ret;
};
styfn$7.overrideBypass = function(eles, name, value2) {
  name = camel2dash(name);
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop2 = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;
    var oldValue = !prop2 ? null : prop2.pfValue != null ? prop2.pfValue : prop2.value;
    if (!prop2 || !prop2.bypass) {
      this.applyBypass(ele, name, value2);
    } else {
      prop2.value = value2;
      if (prop2.pfValue != null) {
        prop2.pfValue = value2;
      }
      if (isColor) {
        prop2.strValue = "rgb(" + value2.join(",") + ")";
      } else if (isMulti) {
        prop2.strValue = value2.join(" ");
      } else {
        prop2.strValue = "" + value2;
      }
      this.updateStyleHints(ele);
    }
    this.checkTriggers(ele, name, oldValue, value2);
  }
};
styfn$7.removeAllBypasses = function(eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};
styfn$7.removeBypasses = function(eles, props, updateTransitions) {
  var isBypass = true;
  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};
    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop2 = this.properties[name];
      var prevProp = ele.pstyle(prop2.name);
      if (!prevProp || !prevProp.bypass) {
        continue;
      }
      var value2 = "";
      var parsedProp = this.parse(name, value2, true);
      var diffProp = diffProps[prop2.name] = {
        prev: prevProp
      };
      this.applyParsedProperty(ele, parsedProp);
      diffProp.next = ele.pstyle(prop2.name);
    }
    this.updateStyleHints(ele);
    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  }
};
var styfn$6 = {};
styfn$6.getEmSizeInPixels = function() {
  var px = this.containerCss("font-size");
  if (px != null) {
    return parseFloat(px);
  } else {
    return 1;
  }
};
styfn$6.containerCss = function(propName) {
  var cy = this._private.cy;
  var domElement3 = cy.container();
  var containerWindow = cy.window();
  if (containerWindow && domElement3 && containerWindow.getComputedStyle) {
    return containerWindow.getComputedStyle(domElement3).getPropertyValue(propName);
  }
};
var styfn$5 = {};
styfn$5.getRenderedStyle = function(ele, prop2) {
  if (prop2) {
    return this.getStylePropertyValue(ele, prop2, true);
  } else {
    return this.getRawStyle(ele, true);
  }
};
styfn$5.getRawStyle = function(ele, isRenderedVal) {
  var self2 = this;
  ele = ele[0];
  if (ele) {
    var rstyle = {};
    for (var i = 0; i < self2.properties.length; i++) {
      var prop2 = self2.properties[i];
      var val = self2.getStylePropertyValue(ele, prop2.name, isRenderedVal);
      if (val != null) {
        rstyle[prop2.name] = val;
        rstyle[dash2camel(prop2.name)] = val;
      }
    }
    return rstyle;
  }
};
styfn$5.getIndexedStyle = function(ele, property, subproperty, index2) {
  var pstyle = ele.pstyle(property)[subproperty][index2];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};
styfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {
  var self2 = this;
  ele = ele[0];
  if (ele) {
    var prop2 = self2.properties[propName];
    if (prop2.alias) {
      prop2 = prop2.pointsTo;
    }
    var type = prop2.type;
    var styleProp = ele.pstyle(prop2.name);
    if (styleProp) {
      var value2 = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;
      if (isRenderedVal && type.number && value2 != null && number$1(value2)) {
        var zoom2 = ele.cy().zoom();
        var getRenderedValue = /* @__PURE__ */ __name(function getRenderedValue2(val) {
          return val * zoom2;
        }, "getRenderedValue2");
        var getValueStringWithUnits = /* @__PURE__ */ __name(function getValueStringWithUnits2(val, units2) {
          return getRenderedValue(val) + units2;
        }, "getValueStringWithUnits2");
        var isArrayValue = array(value2);
        var haveUnits = isArrayValue ? units.every(function(u) {
          return u != null;
        }) : units != null;
        if (haveUnits) {
          if (isArrayValue) {
            return value2.map(function(v, i) {
              return getValueStringWithUnits(v, units[i]);
            }).join(" ");
          } else {
            return getValueStringWithUnits(value2, units);
          }
        } else {
          if (isArrayValue) {
            return value2.map(function(v) {
              return string(v) ? v : "" + getRenderedValue(v);
            }).join(" ");
          } else {
            return "" + getRenderedValue(value2);
          }
        }
      } else if (strValue != null) {
        return strValue;
      }
    }
    return null;
  }
};
styfn$5.getAnimationStartStyle = function(ele, aniProps) {
  var rstyle = {};
  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;
    var styleProp = ele.pstyle(name);
    if (styleProp !== void 0) {
      if (plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }
    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }
  return rstyle;
};
styfn$5.getPropsList = function(propsObj) {
  var self2 = this;
  var rstyle = [];
  var style3 = propsObj;
  var props = self2.properties;
  if (style3) {
    var names = Object.keys(style3);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style3[name];
      var prop2 = props[name] || props[camel2dash(name)];
      var styleProp = this.parse(prop2.name, val);
      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }
  return rstyle;
};
styfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {
  var hash2 = seed.slice();
  var name, val, strVal, chVal;
  var i, j;
  for (i = 0; i < propNames.length; i++) {
    name = propNames[i];
    val = ele.pstyle(name, false);
    if (val == null) {
      continue;
    } else if (val.pfValue != null) {
      hash2[0] = hashInt(chVal, hash2[0]);
      hash2[1] = hashIntAlt(chVal, hash2[1]);
    } else {
      strVal = val.strValue;
      for (j = 0; j < strVal.length; j++) {
        chVal = strVal.charCodeAt(j);
        hash2[0] = hashInt(chVal, hash2[0]);
        hash2[1] = hashIntAlt(chVal, hash2[1]);
      }
    }
  }
  return hash2;
};
styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;
var styfn$4 = {};
styfn$4.appendFromJson = function(json2) {
  var style3 = this;
  for (var i = 0; i < json2.length; i++) {
    var context = json2[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);
    style3.selector(selector);
    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value2 = props[name];
      style3.css(name, value2);
    }
  }
  return style3;
};
styfn$4.fromJson = function(json2) {
  var style3 = this;
  style3.resetToDefault();
  style3.appendFromJson(json2);
  return style3;
};
styfn$4.json = function() {
  var json2 = [];
  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};
    for (var j = 0; j < props.length; j++) {
      var prop2 = props[j];
      css[prop2.name] = prop2.strValue;
    }
    json2.push({
      selector: !selector ? "core" : selector.toString(),
      style: css
    });
  }
  return json2;
};
var styfn$3 = {};
styfn$3.appendFromString = function(string3) {
  var self2 = this;
  var style3 = this;
  var remaining = "" + string3;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;
  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, "");
  function removeSelAndBlockFromRemaining() {
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = "";
    }
  }
  __name(removeSelAndBlockFromRemaining, "removeSelAndBlockFromRemaining");
  function removePropAndValFromRem() {
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = "";
    }
  }
  __name(removePropAndValFromRem, "removePropAndValFromRem");
  for (; ; ) {
    var nothingLeftToParse = remaining.match(/^\s*$/);
    if (nothingLeftToParse) {
      break;
    }
    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
    if (!selAndBlock) {
      warn("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + remaining);
      break;
    }
    selAndBlockStr = selAndBlock[0];
    var selectorStr = selAndBlock[1];
    if (selectorStr !== "core") {
      var selector = new Selector(selectorStr);
      if (selector.invalid) {
        warn("Skipping parsing of block: Invalid selector found in string stylesheet: " + selectorStr);
        removeSelAndBlockFromRemaining();
        continue;
      }
    }
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];
    for (; ; ) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);
      if (_nothingLeftToParse) {
        break;
      }
      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
      if (!propAndVal) {
        warn("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + blockStr);
        invalidBlock = true;
        break;
      }
      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];
      var prop2 = self2.properties[propStr];
      if (!prop2) {
        warn("Skipping property: Invalid property name in: " + propAndValStr);
        removePropAndValFromRem();
        continue;
      }
      var parsedProp = style3.parse(propStr, valStr);
      if (!parsedProp) {
        warn("Skipping property: Invalid property definition in: " + propAndValStr);
        removePropAndValFromRem();
        continue;
      }
      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }
    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    }
    style3.selector(selectorStr);
    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style3.css(_prop.name, _prop.val);
    }
    removeSelAndBlockFromRemaining();
  }
  return style3;
};
styfn$3.fromString = function(string3) {
  var style3 = this;
  style3.resetToDefault();
  style3.appendFromString(string3);
  return style3;
};
var styfn$2 = {};
(function() {
  var number$12 = number22;
  var rgba2 = rgbaNoBackRefs;
  var hsla2 = hslaNoBackRefs;
  var hex3$1 = hex3;
  var hex6$1 = hex6;
  var data4 = /* @__PURE__ */ __name(function data5(prefix) {
    return "^" + prefix + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
  }, "data5");
  var mapData = /* @__PURE__ */ __name(function mapData2(prefix) {
    var mapArg = number$12 + "|\\w+|" + rgba2 + "|" + hsla2 + "|" + hex3$1 + "|" + hex6$1;
    return "^" + prefix + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + number$12 + ")\\s*\\,\\s*(" + number$12 + ")\\s*,\\s*(" + mapArg + ")\\s*\\,\\s*(" + mapArg + ")\\)$";
  }, "mapData2");
  var urlRegexes = [`^url\\s*\\(\\s*['"]?(.+?)['"]?\\s*\\)$`, "^(none)$", "^(.+)$"];
  styfn$2.types = {
    time: {
      number: true,
      min: 0,
      units: "s|ms",
      implicitUnits: "ms"
    },
    percent: {
      number: true,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%"
    },
    percentages: {
      number: true,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%",
      multiple: true
    },
    zeroOneNumber: {
      number: true,
      min: 0,
      max: 1,
      unitless: true
    },
    zeroOneNumbers: {
      number: true,
      min: 0,
      max: 1,
      unitless: true,
      multiple: true
    },
    nOneOneNumber: {
      number: true,
      min: -1,
      max: 1,
      unitless: true
    },
    nonNegativeInt: {
      number: true,
      min: 0,
      integer: true,
      unitless: true
    },
    nonNegativeNumber: {
      number: true,
      min: 0,
      unitless: true
    },
    position: {
      enums: ["parent", "origin"]
    },
    nodeSize: {
      number: true,
      min: 0,
      enums: ["label"]
    },
    number: {
      number: true,
      unitless: true
    },
    numbers: {
      number: true,
      unitless: true,
      multiple: true
    },
    positiveNumber: {
      number: true,
      unitless: true,
      min: 0,
      strictMin: true
    },
    size: {
      number: true,
      min: 0
    },
    bidirectionalSize: {
      number: true
    },
    // allows negative
    bidirectionalSizeMaybePercent: {
      number: true,
      allowPercent: true
    },
    // allows negative
    bidirectionalSizes: {
      number: true,
      multiple: true
    },
    // allows negative
    sizeMaybePercent: {
      number: true,
      min: 0,
      allowPercent: true
    },
    axisDirection: {
      enums: ["horizontal", "leftward", "rightward", "vertical", "upward", "downward", "auto"]
    },
    axisDirectionExplicit: {
      enums: ["leftward", "rightward", "upward", "downward"]
    },
    axisDirectionPrimary: {
      enums: ["horizontal", "vertical"]
    },
    paddingRelativeTo: {
      enums: ["width", "height", "average", "min", "max"]
    },
    bgWH: {
      number: true,
      min: 0,
      allowPercent: true,
      enums: ["auto"],
      multiple: true
    },
    bgPos: {
      number: true,
      allowPercent: true,
      multiple: true
    },
    bgRelativeTo: {
      enums: ["inner", "include-padding"],
      multiple: true
    },
    bgRepeat: {
      enums: ["repeat", "repeat-x", "repeat-y", "no-repeat"],
      multiple: true
    },
    bgFit: {
      enums: ["none", "contain", "cover"],
      multiple: true
    },
    bgCrossOrigin: {
      enums: ["anonymous", "use-credentials", "null"],
      multiple: true
    },
    bgClip: {
      enums: ["none", "node"],
      multiple: true
    },
    bgContainment: {
      enums: ["inside", "over"],
      multiple: true
    },
    boxSelection: {
      enums: ["contain", "overlap", "none"]
    },
    color: {
      color: true
    },
    colors: {
      color: true,
      multiple: true
    },
    fill: {
      enums: ["solid", "linear-gradient", "radial-gradient"]
    },
    bool: {
      enums: ["yes", "no"]
    },
    bools: {
      enums: ["yes", "no"],
      multiple: true
    },
    lineStyle: {
      enums: ["solid", "dotted", "dashed"]
    },
    lineCap: {
      enums: ["butt", "round", "square"]
    },
    linePosition: {
      enums: ["center", "inside", "outside"]
    },
    lineJoin: {
      enums: ["round", "bevel", "miter"]
    },
    borderStyle: {
      enums: ["solid", "dotted", "dashed", "double"]
    },
    curveStyle: {
      enums: ["bezier", "unbundled-bezier", "haystack", "segments", "straight", "straight-triangle", "taxi", "round-segments", "round-taxi"]
    },
    radiusType: {
      enums: ["arc-radius", "influence-radius"],
      multiple: true
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ["italic", "normal", "oblique"]
    },
    fontWeight: {
      enums: ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "800", "900", 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ["none", "underline", "overline", "line-through"]
    },
    textTransform: {
      enums: ["none", "uppercase", "lowercase"]
    },
    textWrap: {
      enums: ["none", "wrap", "ellipsis"]
    },
    textOverflowWrap: {
      enums: ["whitespace", "anywhere"]
    },
    textBackgroundShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "circle"]
    },
    nodeShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "cutrectangle", "cut-rectangle", "bottomroundrectangle", "bottom-round-rectangle", "barrel", "ellipse", "triangle", "round-triangle", "square", "pentagon", "round-pentagon", "hexagon", "round-hexagon", "concavehexagon", "concave-hexagon", "heptagon", "round-heptagon", "octagon", "round-octagon", "tag", "round-tag", "star", "diamond", "round-diamond", "vee", "rhomboid", "right-rhomboid", "polygon"]
    },
    overlayShape: {
      enums: ["roundrectangle", "round-rectangle", "ellipse"]
    },
    cornerRadius: {
      number: true,
      min: 0,
      units: "px|em",
      implicitUnits: "px",
      enums: ["auto"]
    },
    compoundIncludeLabels: {
      enums: ["include", "exclude"]
    },
    arrowShape: {
      enums: ["tee", "triangle", "triangle-tee", "circle-triangle", "triangle-cross", "triangle-backcurve", "vee", "square", "circle", "diamond", "chevron", "none"]
    },
    arrowFill: {
      enums: ["filled", "hollow"]
    },
    arrowWidth: {
      number: true,
      units: "%|px|em",
      implicitUnits: "px",
      enums: ["match-line"]
    },
    display: {
      enums: ["element", "none"]
    },
    visibility: {
      enums: ["hidden", "visible"]
    },
    zCompoundDepth: {
      enums: ["bottom", "orphan", "auto", "top"]
    },
    zIndexCompare: {
      enums: ["auto", "manual"]
    },
    valign: {
      enums: ["top", "center", "bottom"]
    },
    halign: {
      enums: ["left", "center", "right"]
    },
    justification: {
      enums: ["left", "center", "right", "auto"]
    },
    text: {
      string: true
    },
    data: {
      mapping: true,
      regex: data4("data")
    },
    layoutData: {
      mapping: true,
      regex: data4("layoutData")
    },
    scratch: {
      mapping: true,
      regex: data4("scratch")
    },
    mapData: {
      mapping: true,
      regex: mapData("mapData")
    },
    mapLayoutData: {
      mapping: true,
      regex: mapData("mapLayoutData")
    },
    mapScratch: {
      mapping: true,
      regex: mapData("mapScratch")
    },
    fn: {
      mapping: true,
      fn: true
    },
    url: {
      regexes: urlRegexes,
      singleRegexMatchValue: true
    },
    urls: {
      regexes: urlRegexes,
      singleRegexMatchValue: true,
      multiple: true
    },
    propList: {
      propList: true
    },
    angle: {
      number: true,
      units: "deg|rad",
      implicitUnits: "rad"
    },
    textRotation: {
      number: true,
      units: "deg|rad",
      implicitUnits: "rad",
      enums: ["none", "autorotate"]
    },
    polygonPointList: {
      number: true,
      multiple: true,
      evenMultiple: true,
      min: -1,
      max: 1,
      unitless: true
    },
    edgeDistances: {
      enums: ["intersection", "node-position", "endpoints"]
    },
    edgeEndpoint: {
      number: true,
      multiple: true,
      units: "%|px|em|deg|rad",
      implicitUnits: "px",
      enums: ["inside-to-node", "outside-to-node", "outside-to-node-or-label", "outside-to-line", "outside-to-line-or-label"],
      singleEnum: true,
      validate: /* @__PURE__ */ __name(function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            return unitsArr[0] !== "deg" && unitsArr[0] !== "rad" && unitsArr[1] !== "deg" && unitsArr[1] !== "rad";
          case 1:
            return string(valArr[0]) || unitsArr[0] === "deg" || unitsArr[0] === "rad";
          default:
            return false;
        }
      }, "validate")
    },
    easing: {
      regexes: ["^(spring)\\s*\\(\\s*(" + number$12 + ")\\s*,\\s*(" + number$12 + ")\\s*\\)$", "^(cubic-bezier)\\s*\\(\\s*(" + number$12 + ")\\s*,\\s*(" + number$12 + ")\\s*,\\s*(" + number$12 + ")\\s*,\\s*(" + number$12 + ")\\s*\\)$"],
      enums: ["linear", "ease", "ease-in", "ease-out", "ease-in-out", "ease-in-sine", "ease-out-sine", "ease-in-out-sine", "ease-in-quad", "ease-out-quad", "ease-in-out-quad", "ease-in-cubic", "ease-out-cubic", "ease-in-out-cubic", "ease-in-quart", "ease-out-quart", "ease-in-out-quart", "ease-in-quint", "ease-out-quint", "ease-in-out-quint", "ease-in-expo", "ease-out-expo", "ease-in-out-expo", "ease-in-circ", "ease-out-circ", "ease-in-out-circ"]
    },
    gradientDirection: {
      enums: [
        "to-bottom",
        "to-top",
        "to-left",
        "to-right",
        "to-bottom-right",
        "to-bottom-left",
        "to-top-right",
        "to-top-left",
        "to-right-bottom",
        "to-left-bottom",
        "to-right-top",
        "to-left-top"
        // different order
      ]
    },
    boundsExpansion: {
      number: true,
      multiple: true,
      min: 0,
      validate: /* @__PURE__ */ __name(function validate(valArr) {
        var length2 = valArr.length;
        return length2 === 1 || length2 === 2 || length2 === 4;
      }, "validate")
    }
  };
  var diff2 = {
    zeroNonZero: /* @__PURE__ */ __name(function zeroNonZero(val1, val2) {
      if ((val1 == null || val2 == null) && val1 !== val2) {
        return true;
      }
      if (val1 == 0 && val2 != 0) {
        return true;
      } else if (val1 != 0 && val2 == 0) {
        return true;
      } else {
        return false;
      }
    }, "zeroNonZero"),
    any: /* @__PURE__ */ __name(function any2(val1, val2) {
      return val1 != val2;
    }, "any"),
    emptyNonEmpty: /* @__PURE__ */ __name(function emptyNonEmpty(str1, str2) {
      var empty1 = emptyString(str1);
      var empty22 = emptyString(str2);
      return empty1 && !empty22 || !empty1 && empty22;
    }, "emptyNonEmpty")
  };
  var t = styfn$2.types;
  var mainLabel = [{
    name: "label",
    type: t.text,
    triggersBounds: diff2.any,
    triggersZOrder: diff2.emptyNonEmpty
  }, {
    name: "text-rotation",
    type: t.textRotation,
    triggersBounds: diff2.any
  }, {
    name: "text-margin-x",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "text-margin-y",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }];
  var sourceLabel = [{
    name: "source-label",
    type: t.text,
    triggersBounds: diff2.any
  }, {
    name: "source-text-rotation",
    type: t.textRotation,
    triggersBounds: diff2.any
  }, {
    name: "source-text-margin-x",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "source-text-margin-y",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "source-text-offset",
    type: t.size,
    triggersBounds: diff2.any
  }];
  var targetLabel = [{
    name: "target-label",
    type: t.text,
    triggersBounds: diff2.any
  }, {
    name: "target-text-rotation",
    type: t.textRotation,
    triggersBounds: diff2.any
  }, {
    name: "target-text-margin-x",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "target-text-margin-y",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "target-text-offset",
    type: t.size,
    triggersBounds: diff2.any
  }];
  var labelDimensions = [{
    name: "font-family",
    type: t.fontFamily,
    triggersBounds: diff2.any
  }, {
    name: "font-style",
    type: t.fontStyle,
    triggersBounds: diff2.any
  }, {
    name: "font-weight",
    type: t.fontWeight,
    triggersBounds: diff2.any
  }, {
    name: "font-size",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "text-transform",
    type: t.textTransform,
    triggersBounds: diff2.any
  }, {
    name: "text-wrap",
    type: t.textWrap,
    triggersBounds: diff2.any
  }, {
    name: "text-overflow-wrap",
    type: t.textOverflowWrap,
    triggersBounds: diff2.any
  }, {
    name: "text-max-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "text-outline-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "line-height",
    type: t.positiveNumber,
    triggersBounds: diff2.any
  }];
  var commonLabel = [{
    name: "text-valign",
    type: t.valign,
    triggersBounds: diff2.any
  }, {
    name: "text-halign",
    type: t.halign,
    triggersBounds: diff2.any
  }, {
    name: "color",
    type: t.color
  }, {
    name: "text-outline-color",
    type: t.color
  }, {
    name: "text-outline-opacity",
    type: t.zeroOneNumber
  }, {
    name: "text-background-color",
    type: t.color
  }, {
    name: "text-background-opacity",
    type: t.zeroOneNumber
  }, {
    name: "text-background-padding",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "text-border-opacity",
    type: t.zeroOneNumber
  }, {
    name: "text-border-color",
    type: t.color
  }, {
    name: "text-border-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "text-border-style",
    type: t.borderStyle,
    triggersBounds: diff2.any
  }, {
    name: "text-background-shape",
    type: t.textBackgroundShape,
    triggersBounds: diff2.any
  }, {
    name: "text-justification",
    type: t.justification
  }, {
    name: "box-select-labels",
    type: t.bool,
    triggersBounds: diff2.any
  }];
  var behavior = [{
    name: "events",
    type: t.bool,
    triggersZOrder: diff2.any
  }, {
    name: "text-events",
    type: t.bool,
    triggersZOrder: diff2.any
  }, {
    name: "box-selection",
    type: t.boxSelection,
    triggersZOrder: diff2.any
  }];
  var visibility = [{
    name: "display",
    type: t.display,
    triggersZOrder: diff2.any,
    triggersBounds: diff2.any,
    triggersBoundsOfConnectedEdges: diff2.any,
    triggersBoundsOfParallelEdges: /* @__PURE__ */ __name(function triggersBoundsOfParallelEdges(fromValue, toValue, ele) {
      if (fromValue === toValue) {
        return false;
      }
      return ele.pstyle("curve-style").value === "bezier";
    }, "triggersBoundsOfParallelEdges")
  }, {
    name: "visibility",
    type: t.visibility,
    triggersZOrder: diff2.any
  }, {
    name: "opacity",
    type: t.zeroOneNumber,
    triggersZOrder: diff2.zeroNonZero
  }, {
    name: "text-opacity",
    type: t.zeroOneNumber
  }, {
    name: "min-zoomed-font-size",
    type: t.size
  }, {
    name: "z-compound-depth",
    type: t.zCompoundDepth,
    triggersZOrder: diff2.any
  }, {
    name: "z-index-compare",
    type: t.zIndexCompare,
    triggersZOrder: diff2.any
  }, {
    name: "z-index",
    type: t.number,
    triggersZOrder: diff2.any
  }];
  var overlay = [{
    name: "overlay-padding",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "overlay-color",
    type: t.color
  }, {
    name: "overlay-opacity",
    type: t.zeroOneNumber,
    triggersBounds: diff2.zeroNonZero
  }, {
    name: "overlay-shape",
    type: t.overlayShape,
    triggersBounds: diff2.any
  }, {
    name: "overlay-corner-radius",
    type: t.cornerRadius
  }];
  var underlay = [{
    name: "underlay-padding",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "underlay-color",
    type: t.color
  }, {
    name: "underlay-opacity",
    type: t.zeroOneNumber,
    triggersBounds: diff2.zeroNonZero
  }, {
    name: "underlay-shape",
    type: t.overlayShape,
    triggersBounds: diff2.any
  }, {
    name: "underlay-corner-radius",
    type: t.cornerRadius
  }];
  var transition2 = [{
    name: "transition-property",
    type: t.propList
  }, {
    name: "transition-duration",
    type: t.time
  }, {
    name: "transition-delay",
    type: t.time
  }, {
    name: "transition-timing-function",
    type: t.easing
  }];
  var nodeSizeHashOverride = /* @__PURE__ */ __name(function nodeSizeHashOverride2(ele, parsedProp) {
    if (parsedProp.value === "label") {
      return -ele.poolIndex();
    } else {
      return parsedProp.pfValue;
    }
  }, "nodeSizeHashOverride2");
  var nodeBody = [{
    name: "height",
    type: t.nodeSize,
    triggersBounds: diff2.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: "width",
    type: t.nodeSize,
    triggersBounds: diff2.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: "shape",
    type: t.nodeShape,
    triggersBounds: diff2.any
  }, {
    name: "shape-polygon-points",
    type: t.polygonPointList,
    triggersBounds: diff2.any
  }, {
    name: "corner-radius",
    type: t.cornerRadius
  }, {
    name: "background-color",
    type: t.color
  }, {
    name: "background-fill",
    type: t.fill
  }, {
    name: "background-opacity",
    type: t.zeroOneNumber
  }, {
    name: "background-blacken",
    type: t.nOneOneNumber
  }, {
    name: "background-gradient-stop-colors",
    type: t.colors
  }, {
    name: "background-gradient-stop-positions",
    type: t.percentages
  }, {
    name: "background-gradient-direction",
    type: t.gradientDirection
  }, {
    name: "padding",
    type: t.sizeMaybePercent,
    triggersBounds: diff2.any
  }, {
    name: "padding-relative-to",
    type: t.paddingRelativeTo,
    triggersBounds: diff2.any
  }, {
    name: "bounds-expansion",
    type: t.boundsExpansion,
    triggersBounds: diff2.any
  }];
  var nodeBorder = [{
    name: "border-color",
    type: t.color
  }, {
    name: "border-opacity",
    type: t.zeroOneNumber
  }, {
    name: "border-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "border-style",
    type: t.borderStyle
  }, {
    name: "border-cap",
    type: t.lineCap
  }, {
    name: "border-join",
    type: t.lineJoin
  }, {
    name: "border-dash-pattern",
    type: t.numbers
  }, {
    name: "border-dash-offset",
    type: t.number
  }, {
    name: "border-position",
    type: t.linePosition
  }];
  var nodeOutline = [{
    name: "outline-color",
    type: t.color
  }, {
    name: "outline-opacity",
    type: t.zeroOneNumber
  }, {
    name: "outline-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "outline-style",
    type: t.borderStyle
  }, {
    name: "outline-offset",
    type: t.size,
    triggersBounds: diff2.any
  }];
  var backgroundImage = [{
    name: "background-image",
    type: t.urls
  }, {
    name: "background-image-crossorigin",
    type: t.bgCrossOrigin
  }, {
    name: "background-image-opacity",
    type: t.zeroOneNumbers
  }, {
    name: "background-image-containment",
    type: t.bgContainment
  }, {
    name: "background-image-smoothing",
    type: t.bools
  }, {
    name: "background-position-x",
    type: t.bgPos
  }, {
    name: "background-position-y",
    type: t.bgPos
  }, {
    name: "background-width-relative-to",
    type: t.bgRelativeTo
  }, {
    name: "background-height-relative-to",
    type: t.bgRelativeTo
  }, {
    name: "background-repeat",
    type: t.bgRepeat
  }, {
    name: "background-fit",
    type: t.bgFit
  }, {
    name: "background-clip",
    type: t.bgClip
  }, {
    name: "background-width",
    type: t.bgWH
  }, {
    name: "background-height",
    type: t.bgWH
  }, {
    name: "background-offset-x",
    type: t.bgPos
  }, {
    name: "background-offset-y",
    type: t.bgPos
  }];
  var compound = [{
    name: "position",
    type: t.position,
    triggersBounds: diff2.any
  }, {
    name: "compound-sizing-wrt-labels",
    type: t.compoundIncludeLabels,
    triggersBounds: diff2.any
  }, {
    name: "min-width",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "min-width-bias-left",
    type: t.sizeMaybePercent,
    triggersBounds: diff2.any
  }, {
    name: "min-width-bias-right",
    type: t.sizeMaybePercent,
    triggersBounds: diff2.any
  }, {
    name: "min-height",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "min-height-bias-top",
    type: t.sizeMaybePercent,
    triggersBounds: diff2.any
  }, {
    name: "min-height-bias-bottom",
    type: t.sizeMaybePercent,
    triggersBounds: diff2.any
  }];
  var edgeLine = [{
    name: "line-style",
    type: t.lineStyle
  }, {
    name: "line-color",
    type: t.color
  }, {
    name: "line-fill",
    type: t.fill
  }, {
    name: "line-cap",
    type: t.lineCap
  }, {
    name: "line-opacity",
    type: t.zeroOneNumber
  }, {
    name: "line-dash-pattern",
    type: t.numbers
  }, {
    name: "line-dash-offset",
    type: t.number
  }, {
    name: "line-outline-width",
    type: t.size
  }, {
    name: "line-outline-color",
    type: t.color
  }, {
    name: "line-gradient-stop-colors",
    type: t.colors
  }, {
    name: "line-gradient-stop-positions",
    type: t.percentages
  }, {
    name: "curve-style",
    type: t.curveStyle,
    triggersBounds: diff2.any,
    triggersBoundsOfParallelEdges: /* @__PURE__ */ __name(function triggersBoundsOfParallelEdges(fromValue, toValue) {
      if (fromValue === toValue) {
        return false;
      }
      return fromValue === "bezier" || // remove from bundle
      toValue === "bezier";
    }, "triggersBoundsOfParallelEdges")
  }, {
    name: "haystack-radius",
    type: t.zeroOneNumber,
    triggersBounds: diff2.any
  }, {
    name: "source-endpoint",
    type: t.edgeEndpoint,
    triggersBounds: diff2.any
  }, {
    name: "target-endpoint",
    type: t.edgeEndpoint,
    triggersBounds: diff2.any
  }, {
    name: "control-point-step-size",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "control-point-distances",
    type: t.bidirectionalSizes,
    triggersBounds: diff2.any
  }, {
    name: "control-point-weights",
    type: t.numbers,
    triggersBounds: diff2.any
  }, {
    name: "segment-distances",
    type: t.bidirectionalSizes,
    triggersBounds: diff2.any
  }, {
    name: "segment-weights",
    type: t.numbers,
    triggersBounds: diff2.any
  }, {
    name: "segment-radii",
    type: t.numbers,
    triggersBounds: diff2.any
  }, {
    name: "radius-type",
    type: t.radiusType,
    triggersBounds: diff2.any
  }, {
    name: "taxi-turn",
    type: t.bidirectionalSizeMaybePercent,
    triggersBounds: diff2.any
  }, {
    name: "taxi-turn-min-distance",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "taxi-direction",
    type: t.axisDirection,
    triggersBounds: diff2.any
  }, {
    name: "taxi-radius",
    type: t.number,
    triggersBounds: diff2.any
  }, {
    name: "edge-distances",
    type: t.edgeDistances,
    triggersBounds: diff2.any
  }, {
    name: "arrow-scale",
    type: t.positiveNumber,
    triggersBounds: diff2.any
  }, {
    name: "loop-direction",
    type: t.angle,
    triggersBounds: diff2.any
  }, {
    name: "loop-sweep",
    type: t.angle,
    triggersBounds: diff2.any
  }, {
    name: "source-distance-from-node",
    type: t.size,
    triggersBounds: diff2.any
  }, {
    name: "target-distance-from-node",
    type: t.size,
    triggersBounds: diff2.any
  }];
  var ghost = [{
    name: "ghost",
    type: t.bool,
    triggersBounds: diff2.any
  }, {
    name: "ghost-offset-x",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "ghost-offset-y",
    type: t.bidirectionalSize,
    triggersBounds: diff2.any
  }, {
    name: "ghost-opacity",
    type: t.zeroOneNumber
  }];
  var core3 = [{
    name: "selection-box-color",
    type: t.color
  }, {
    name: "selection-box-opacity",
    type: t.zeroOneNumber
  }, {
    name: "selection-box-border-color",
    type: t.color
  }, {
    name: "selection-box-border-width",
    type: t.size
  }, {
    name: "active-bg-color",
    type: t.color
  }, {
    name: "active-bg-opacity",
    type: t.zeroOneNumber
  }, {
    name: "active-bg-size",
    type: t.size
  }, {
    name: "outside-texture-bg-color",
    type: t.color
  }, {
    name: "outside-texture-bg-opacity",
    type: t.zeroOneNumber
  }];
  var pie = [];
  styfn$2.pieBackgroundN = 16;
  pie.push({
    name: "pie-size",
    type: t.sizeMaybePercent
  });
  pie.push({
    name: "pie-hole",
    type: t.sizeMaybePercent
  });
  pie.push({
    name: "pie-start-angle",
    type: t.angle
  });
  for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {
    pie.push({
      name: "pie-" + i + "-background-color",
      type: t.color
    });
    pie.push({
      name: "pie-" + i + "-background-size",
      type: t.percent
    });
    pie.push({
      name: "pie-" + i + "-background-opacity",
      type: t.zeroOneNumber
    });
  }
  var stripe = [];
  styfn$2.stripeBackgroundN = 16;
  stripe.push({
    name: "stripe-size",
    type: t.sizeMaybePercent
  });
  stripe.push({
    name: "stripe-direction",
    type: t.axisDirectionPrimary
  });
  for (var _i = 1; _i <= styfn$2.stripeBackgroundN; _i++) {
    stripe.push({
      name: "stripe-" + _i + "-background-color",
      type: t.color
    });
    stripe.push({
      name: "stripe-" + _i + "-background-size",
      type: t.percent
    });
    stripe.push({
      name: "stripe-" + _i + "-background-opacity",
      type: t.zeroOneNumber
    });
  }
  var edgeArrow = [];
  var arrowPrefixes = styfn$2.arrowPrefixes = ["source", "mid-source", "target", "mid-target"];
  [{
    name: "arrow-shape",
    type: t.arrowShape,
    triggersBounds: diff2.any
  }, {
    name: "arrow-color",
    type: t.color
  }, {
    name: "arrow-fill",
    type: t.arrowFill
  }, {
    name: "arrow-width",
    type: t.arrowWidth
  }].forEach(function(prop22) {
    arrowPrefixes.forEach(function(prefix) {
      var name = prefix + "-" + prop22.name;
      var type = prop22.type, triggersBounds = prop22.triggersBounds;
      edgeArrow.push({
        name,
        type,
        triggersBounds
      });
    });
  }, {});
  var props = styfn$2.properties = [].concat(behavior, transition2, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, stripe, compound, edgeLine, edgeArrow, core3);
  var propGroups = styfn$2.propertyGroups = {
    // common to all eles
    behavior,
    transition: transition2,
    visibility,
    overlay,
    underlay,
    ghost,
    // labels
    commonLabel,
    labelDimensions,
    mainLabel,
    sourceLabel,
    targetLabel,
    // node props
    nodeBody,
    nodeBorder,
    nodeOutline,
    backgroundImage,
    pie,
    stripe,
    compound,
    // edge props
    edgeLine,
    edgeArrow,
    core: core3
  };
  var propGroupNames = styfn$2.propertyGroupNames = {};
  var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);
  propGroupKeys.forEach(function(key2) {
    propGroupNames[key2] = propGroups[key2].map(function(prop22) {
      return prop22.name;
    });
    propGroups[key2].forEach(function(prop22) {
      return prop22.groupKey = key2;
    });
  });
  var aliases = styfn$2.aliases = [{
    name: "content",
    pointsTo: "label"
  }, {
    name: "control-point-distance",
    pointsTo: "control-point-distances"
  }, {
    name: "control-point-weight",
    pointsTo: "control-point-weights"
  }, {
    name: "segment-distance",
    pointsTo: "segment-distances"
  }, {
    name: "segment-weight",
    pointsTo: "segment-weights"
  }, {
    name: "segment-radius",
    pointsTo: "segment-radii"
  }, {
    name: "edge-text-rotation",
    pointsTo: "text-rotation"
  }, {
    name: "padding-left",
    pointsTo: "padding"
  }, {
    name: "padding-right",
    pointsTo: "padding"
  }, {
    name: "padding-top",
    pointsTo: "padding"
  }, {
    name: "padding-bottom",
    pointsTo: "padding"
  }];
  styfn$2.propertyNames = props.map(function(p2) {
    return p2.name;
  });
  for (var _i2 = 0; _i2 < props.length; _i2++) {
    var prop2 = props[_i2];
    props[prop2.name] = prop2;
  }
  for (var _i3 = 0; _i3 < aliases.length; _i3++) {
    var alias = aliases[_i3];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };
    props.push(aliasProp);
    props[alias.name] = aliasProp;
  }
})();
styfn$2.getDefaultProperty = function(name) {
  return this.getDefaultProperties()[name];
};
styfn$2.getDefaultProperties = function() {
  var _p = this._private;
  if (_p.defaultProperties != null) {
    return _p.defaultProperties;
  }
  var rawProps = extend({
    // core props
    "selection-box-color": "#ddd",
    "selection-box-opacity": 0.65,
    "selection-box-border-color": "#aaa",
    "selection-box-border-width": 1,
    "active-bg-color": "black",
    "active-bg-opacity": 0.15,
    "active-bg-size": 30,
    "outside-texture-bg-color": "#000",
    "outside-texture-bg-opacity": 0.125,
    // common node/edge props
    "events": "yes",
    "text-events": "no",
    "text-valign": "top",
    "text-halign": "center",
    "text-justification": "auto",
    "line-height": 1,
    "color": "#000",
    "box-selection": "contain",
    "text-outline-color": "#000",
    "text-outline-width": 0,
    "text-outline-opacity": 1,
    "text-opacity": 1,
    "text-decoration": "none",
    "text-transform": "none",
    "text-wrap": "none",
    "text-overflow-wrap": "whitespace",
    "text-max-width": 9999,
    "text-background-color": "#000",
    "text-background-opacity": 0,
    "text-background-shape": "rectangle",
    "text-background-padding": 0,
    "text-border-opacity": 0,
    "text-border-width": 0,
    "text-border-style": "solid",
    "text-border-color": "#000",
    "font-family": "Helvetica Neue, Helvetica, sans-serif",
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": 16,
    "min-zoomed-font-size": 0,
    "text-rotation": "none",
    "source-text-rotation": "none",
    "target-text-rotation": "none",
    "visibility": "visible",
    "display": "element",
    "opacity": 1,
    "z-compound-depth": "auto",
    "z-index-compare": "auto",
    "z-index": 0,
    "label": "",
    "text-margin-x": 0,
    "text-margin-y": 0,
    "source-label": "",
    "source-text-offset": 0,
    "source-text-margin-x": 0,
    "source-text-margin-y": 0,
    "target-label": "",
    "target-text-offset": 0,
    "target-text-margin-x": 0,
    "target-text-margin-y": 0,
    "overlay-opacity": 0,
    "overlay-color": "#000",
    "overlay-padding": 10,
    "overlay-shape": "round-rectangle",
    "overlay-corner-radius": "auto",
    "underlay-opacity": 0,
    "underlay-color": "#000",
    "underlay-padding": 10,
    "underlay-shape": "round-rectangle",
    "underlay-corner-radius": "auto",
    "transition-property": "none",
    "transition-duration": 0,
    "transition-delay": 0,
    "transition-timing-function": "linear",
    "box-select-labels": "no",
    // node props
    "background-blacken": 0,
    "background-color": "#999",
    "background-fill": "solid",
    "background-opacity": 1,
    "background-image": "none",
    "background-image-crossorigin": "anonymous",
    "background-image-opacity": 1,
    "background-image-containment": "inside",
    "background-image-smoothing": "yes",
    "background-position-x": "50%",
    "background-position-y": "50%",
    "background-offset-x": 0,
    "background-offset-y": 0,
    "background-width-relative-to": "include-padding",
    "background-height-relative-to": "include-padding",
    "background-repeat": "no-repeat",
    "background-fit": "none",
    "background-clip": "node",
    "background-width": "auto",
    "background-height": "auto",
    "border-color": "#000",
    "border-opacity": 1,
    "border-width": 0,
    "border-style": "solid",
    "border-dash-pattern": [4, 2],
    "border-dash-offset": 0,
    "border-cap": "butt",
    "border-join": "miter",
    "border-position": "center",
    "outline-color": "#999",
    "outline-opacity": 1,
    "outline-width": 0,
    "outline-offset": 0,
    "outline-style": "solid",
    "height": 30,
    "width": 30,
    "shape": "ellipse",
    "shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
    "corner-radius": "auto",
    "bounds-expansion": 0,
    // node gradient
    "background-gradient-direction": "to-bottom",
    "background-gradient-stop-colors": "#999",
    "background-gradient-stop-positions": "0%",
    // ghost props
    "ghost": "no",
    "ghost-offset-y": 0,
    "ghost-offset-x": 0,
    "ghost-opacity": 0,
    // compound props
    "padding": 0,
    "padding-relative-to": "width",
    "position": "origin",
    "compound-sizing-wrt-labels": "include",
    "min-width": 0,
    "min-width-bias-left": 0,
    "min-width-bias-right": 0,
    "min-height": 0,
    "min-height-bias-top": 0,
    "min-height-bias-bottom": 0
  }, {
    // node pie bg
    "pie-size": "100%",
    "pie-hole": 0,
    "pie-start-angle": "0deg"
  }, [{
    name: "pie-{{i}}-background-color",
    value: "black"
  }, {
    name: "pie-{{i}}-background-size",
    value: "0%"
  }, {
    name: "pie-{{i}}-background-opacity",
    value: 1
  }].reduce(function(css, prop22) {
    for (var i2 = 1; i2 <= styfn$2.pieBackgroundN; i2++) {
      var name2 = prop22.name.replace("{{i}}", i2);
      var val2 = prop22.value;
      css[name2] = val2;
    }
    return css;
  }, {}), {
    // node stripes bg
    "stripe-size": "100%",
    "stripe-direction": "horizontal"
  }, [{
    name: "stripe-{{i}}-background-color",
    value: "black"
  }, {
    name: "stripe-{{i}}-background-size",
    value: "0%"
  }, {
    name: "stripe-{{i}}-background-opacity",
    value: 1
  }].reduce(function(css, prop22) {
    for (var i2 = 1; i2 <= styfn$2.stripeBackgroundN; i2++) {
      var name2 = prop22.name.replace("{{i}}", i2);
      var val2 = prop22.value;
      css[name2] = val2;
    }
    return css;
  }, {}), {
    // edge props
    "line-style": "solid",
    "line-color": "#999",
    "line-fill": "solid",
    "line-cap": "butt",
    "line-opacity": 1,
    "line-outline-width": 0,
    "line-outline-color": "#000",
    "line-gradient-stop-colors": "#999",
    "line-gradient-stop-positions": "0%",
    "control-point-step-size": 40,
    "control-point-weights": 0.5,
    "segment-weights": 0.5,
    "segment-distances": 20,
    "segment-radii": 15,
    "radius-type": "arc-radius",
    "taxi-turn": "50%",
    "taxi-radius": 15,
    "taxi-turn-min-distance": 10,
    "taxi-direction": "auto",
    "edge-distances": "intersection",
    "curve-style": "haystack",
    "haystack-radius": 0,
    "arrow-scale": 1,
    "loop-direction": "-45deg",
    "loop-sweep": "-90deg",
    "source-distance-from-node": 0,
    "target-distance-from-node": 0,
    "source-endpoint": "outside-to-node",
    "target-endpoint": "outside-to-node",
    "line-dash-pattern": [6, 3],
    "line-dash-offset": 0
  }, [{
    name: "arrow-shape",
    value: "none"
  }, {
    name: "arrow-color",
    value: "#999"
  }, {
    name: "arrow-fill",
    value: "filled"
  }, {
    name: "arrow-width",
    value: 1
  }].reduce(function(css, prop22) {
    styfn$2.arrowPrefixes.forEach(function(prefix) {
      var name2 = prefix + "-" + prop22.name;
      var val2 = prop22.value;
      css[name2] = val2;
    });
    return css;
  }, {}));
  var parsedProps = {};
  for (var i = 0; i < this.properties.length; i++) {
    var prop2 = this.properties[i];
    if (prop2.pointsTo) {
      continue;
    }
    var name = prop2.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);
    parsedProps[name] = parsedProp;
  }
  _p.defaultProperties = parsedProps;
  return _p.defaultProperties;
};
styfn$2.addDefaultStylesheet = function() {
  this.selector(":parent").css({
    "shape": "rectangle",
    "padding": 10,
    "background-color": "#eee",
    "border-color": "#ccc",
    "border-width": 1
  }).selector("edge").css({
    "width": 3
  }).selector(":loop").css({
    "curve-style": "bezier"
  }).selector("edge:compound").css({
    "curve-style": "bezier",
    "source-endpoint": "outside-to-line",
    "target-endpoint": "outside-to-line"
  }).selector(":selected").css({
    "background-color": "#0169D9",
    "line-color": "#0169D9",
    "source-arrow-color": "#0169D9",
    "target-arrow-color": "#0169D9",
    "mid-source-arrow-color": "#0169D9",
    "mid-target-arrow-color": "#0169D9"
  }).selector(":parent:selected").css({
    "background-color": "#CCE1F9",
    "border-color": "#aec8e5"
  }).selector(":active").css({
    "overlay-color": "black",
    "overlay-padding": 10,
    "overlay-opacity": 0.25
  });
  this.defaultLength = this.length;
};
var styfn$1 = {};
styfn$1.parse = function(name, value2, propIsBypass, propIsFlat) {
  var self2 = this;
  if (fn$6(value2)) {
    return self2.parseImplWarn(name, value2, propIsBypass, propIsFlat);
  }
  var flatKey = propIsFlat === "mapping" || propIsFlat === true || propIsFlat === false || propIsFlat == null ? "dontcare" : propIsFlat;
  var bypassKey = propIsBypass ? "t" : "f";
  var valueKey = "" + value2;
  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
  var propCache = self2.propCache = self2.propCache || [];
  var ret;
  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self2.parseImplWarn(name, value2, propIsBypass, propIsFlat);
  }
  if (propIsBypass || propIsFlat === "mapping") {
    ret = copy(ret);
    if (ret) {
      ret.value = copy(ret.value);
    }
  }
  return ret;
};
styfn$1.parseImplWarn = function(name, value2, propIsBypass, propIsFlat) {
  var prop2 = this.parseImpl(name, value2, propIsBypass, propIsFlat);
  if (!prop2 && value2 != null) {
    warn("The style property `".concat(name, ": ").concat(value2, "` is invalid"));
  }
  if (prop2 && (prop2.name === "width" || prop2.name === "height") && value2 === "label") {
    warn("The style value of `label` is deprecated for `" + prop2.name + "`");
  }
  return prop2;
};
styfn$1.parseImpl = function(name, value2, propIsBypass, propIsFlat) {
  var self2 = this;
  name = camel2dash(name);
  var property = self2.properties[name];
  var passedValue = value2;
  var types = self2.types;
  if (!property) {
    return null;
  }
  if (value2 === void 0) {
    return null;
  }
  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }
  var valueIsString = string(value2);
  if (valueIsString) {
    value2 = value2.trim();
  }
  var type = property.type;
  if (!type) {
    return null;
  }
  if (propIsBypass && (value2 === "" || value2 === null)) {
    return {
      name,
      value: value2,
      bypass: true,
      deleteBypass: true
    };
  }
  if (fn$6(value2)) {
    return {
      name,
      value: value2,
      strValue: "fn",
      mapped: types.fn,
      bypass: propIsBypass
    };
  }
  var data4, mapData;
  if (!valueIsString || propIsFlat || value2.length < 7 || value2[1] !== "a") ;
  else if (value2.length >= 7 && value2[0] === "d" && (data4 = new RegExp(types.data.regex).exec(value2))) {
    if (propIsBypass) {
      return false;
    }
    var mapped = types.data;
    return {
      name,
      value: data4,
      strValue: "" + value2,
      mapped,
      field: data4[1],
      bypass: propIsBypass
    };
  } else if (value2.length >= 10 && value2[0] === "m" && (mapData = new RegExp(types.mapData.regex).exec(value2))) {
    if (propIsBypass) {
      return false;
    }
    if (type.multiple) {
      return false;
    }
    var _mapped = types.mapData;
    if (!(type.color || type.number)) {
      return false;
    }
    var valueMin = this.parse(name, mapData[4]);
    if (!valueMin || valueMin.mapped) {
      return false;
    }
    var valueMax = this.parse(name, mapData[5]);
    if (!valueMax || valueMax.mapped) {
      return false;
    }
    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
      warn("`" + name + ": " + value2 + "` is not a valid mapper because the output range is zero; converting to `" + name + ": " + valueMin.strValue + "`");
      return this.parse(name, valueMin.strValue);
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;
      var same2 = c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && // optional alpha
      (c1[3] === c2[3] || (c1[3] == null || c1[3] === 1) && (c2[3] == null || c2[3] === 1));
      if (same2) {
        return false;
      }
    }
    return {
      name,
      value: mapData,
      strValue: "" + value2,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]),
      // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }
  if (type.multiple && propIsFlat !== "multiple") {
    var vals;
    if (valueIsString) {
      vals = value2.split(/\s+/);
    } else if (array(value2)) {
      vals = value2;
    } else {
      vals = [value2];
    }
    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }
    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var strVal = "";
    var hasEnum = false;
    for (var i = 0; i < vals.length; i++) {
      var p2 = self2.parse(name, vals[i], propIsBypass, "multiple");
      hasEnum = hasEnum || string(p2.value);
      valArr.push(p2.value);
      pfValArr.push(p2.pfValue != null ? p2.pfValue : p2.value);
      unitsArr.push(p2.units);
      strVal += (i > 0 ? " " : "") + p2.strValue;
    }
    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }
    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && string(valArr[0])) {
        return {
          name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }
    return {
      name,
      value: valArr,
      pfValue: pfValArr,
      strValue: strVal,
      bypass: propIsBypass,
      units: unitsArr
    };
  }
  var checkEnums = /* @__PURE__ */ __name(function checkEnums2() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];
      if (en === value2) {
        return {
          name,
          value: value2,
          strValue: "" + value2,
          bypass: propIsBypass
        };
      }
    }
    return null;
  }, "checkEnums2");
  if (type.number) {
    var units;
    var implicitUnits = "px";
    if (type.units) {
      units = type.units;
    }
    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }
    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = "px|em" + (type.allowPercent ? "|\\%" : "");
        if (units) {
          unitsRegex = units;
        }
        var match2 = value2.match("^(" + number22 + ")(" + unitsRegex + ")?$");
        if (match2) {
          value2 = match2[1];
          units = match2[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits;
      }
    }
    value2 = parseFloat(value2);
    if (isNaN(value2) && type.enums === void 0) {
      return null;
    }
    if (isNaN(value2) && type.enums !== void 0) {
      value2 = passedValue;
      return checkEnums();
    }
    if (type.integer && !integer(value2)) {
      return null;
    }
    if (type.min !== void 0 && (value2 < type.min || type.strictMin && value2 === type.min) || type.max !== void 0 && (value2 > type.max || type.strictMax && value2 === type.max)) {
      return null;
    }
    var ret = {
      name,
      value: value2,
      strValue: "" + value2 + (units ? units : ""),
      units,
      bypass: propIsBypass
    };
    if (type.unitless || units !== "px" && units !== "em") {
      ret.pfValue = value2;
    } else {
      ret.pfValue = units === "px" || !units ? value2 : this.getEmSizeInPixels() * value2;
    }
    if (units === "ms" || units === "s") {
      ret.pfValue = units === "ms" ? value2 : 1e3 * value2;
    }
    if (units === "deg" || units === "rad") {
      ret.pfValue = units === "rad" ? value2 : deg2rad(value2);
    }
    if (units === "%") {
      ret.pfValue = value2 / 100;
    }
    return ret;
  } else if (type.propList) {
    var props = [];
    var propsStr = "" + value2;
    if (propsStr === "none") ;
    else {
      var propsSplit = propsStr.split(/\s*,\s*|\s+/);
      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();
        if (self2.properties[propName]) {
          props.push(propName);
        } else {
          warn("`" + propName + "` is not a valid property name");
        }
      }
      if (props.length === 0) {
        return null;
      }
    }
    return {
      name,
      value: props,
      strValue: props.length === 0 ? "none" : props.join(" "),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple2 = color2tuple(value2);
    if (!tuple2) {
      return null;
    }
    return {
      name,
      value: tuple2,
      pfValue: tuple2,
      strValue: "rgb(" + tuple2[0] + "," + tuple2[1] + "," + tuple2[2] + ")",
      // n.b. no spaces b/c of multiple support
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {
    if (type.enums) {
      var enumProp = checkEnums();
      if (enumProp) {
        return enumProp;
      }
    }
    var regexes = type.regexes ? type.regexes : [type.regex];
    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex2 = new RegExp(regexes[_i3]);
      var m = regex2.exec(value2);
      if (m) {
        return {
          name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: "" + value2,
          bypass: propIsBypass
        };
      }
    }
    return null;
  } else if (type.string) {
    return {
      name,
      value: "" + value2,
      strValue: "" + value2,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    return checkEnums();
  } else {
    return null;
  }
};
var _Style = /* @__PURE__ */ __name(function Style(cy) {
  if (!(this instanceof _Style)) {
    return new _Style(cy);
  }
  if (!core(cy)) {
    error("A style must have a core reference");
    return;
  }
  this._private = {
    cy,
    coreStyle: {}
  };
  this.length = 0;
  this.resetToDefault();
}, "Style");
var styfn = _Style.prototype;
styfn.instanceString = function() {
  return "style";
};
styfn.clear = function() {
  var _p = this._private;
  var cy = _p.cy;
  var eles = cy.elements();
  for (var i = 0; i < this.length; i++) {
    this[i] = void 0;
  }
  this.length = 0;
  _p.contextStyles = {};
  _p.propDiffs = {};
  this.cleanElements(eles, true);
  eles.forEach(function(ele) {
    var ele_p = ele[0]._private;
    ele_p.styleDirty = true;
    ele_p.appliedInitStyle = false;
  });
  return this;
};
styfn.resetToDefault = function() {
  this.clear();
  this.addDefaultStylesheet();
  return this;
};
styfn.core = function(propName) {
  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
};
styfn.selector = function(selectorStr) {
  var selector = selectorStr === "core" ? null : new Selector(selectorStr);
  var i = this.length++;
  this[i] = {
    selector,
    properties: [],
    mappedProperties: [],
    index: i
  };
  return this;
};
styfn.css = function() {
  var self2 = this;
  var args2 = arguments;
  if (args2.length === 1) {
    var map22 = args2[0];
    for (var i = 0; i < self2.properties.length; i++) {
      var prop2 = self2.properties[i];
      var mapVal = map22[prop2.name];
      if (mapVal === void 0) {
        mapVal = map22[dash2camel(prop2.name)];
      }
      if (mapVal !== void 0) {
        this.cssRule(prop2.name, mapVal);
      }
    }
  } else if (args2.length === 2) {
    this.cssRule(args2[0], args2[1]);
  }
  return this;
};
styfn.style = styfn.css;
styfn.cssRule = function(name, value2) {
  var property = this.parse(name, value2);
  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property;
    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }
    if (property.name.match(/stripe-(\d+)-background-size/) && property.value) {
      this._private.hasStripe = true;
    }
    if (property.mapped) {
      this[i].mappedProperties.push(property);
    }
    var currentSelectorIsCore = !this[i].selector;
    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }
  return this;
};
styfn.append = function(style3) {
  if (stylesheet(style3)) {
    style3.appendToStyle(this);
  } else if (array(style3)) {
    this.appendFromJson(style3);
  } else if (string(style3)) {
    this.appendFromString(style3);
  }
  return this;
};
_Style.fromJson = function(cy, json2) {
  var style3 = new _Style(cy);
  style3.fromJson(json2);
  return style3;
};
_Style.fromString = function(cy, string3) {
  return new _Style(cy).fromString(string3);
};
[styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function(props) {
  extend(styfn, props);
});
_Style.types = styfn.types;
_Style.properties = styfn.properties;
_Style.propertyGroups = styfn.propertyGroups;
_Style.propertyGroupNames = styfn.propertyGroupNames;
_Style.propertyGroupKeys = styfn.propertyGroupKeys;
var corefn$2 = {
  style: /* @__PURE__ */ __name(function style2(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);
      s.update();
    }
    return this._private.style;
  }, "style2"),
  setStyle: /* @__PURE__ */ __name(function setStyle(style3) {
    var _p = this._private;
    if (stylesheet(style3)) {
      _p.style = style3.generateStyle(this);
    } else if (array(style3)) {
      _p.style = _Style.fromJson(this, style3);
    } else if (string(style3)) {
      _p.style = _Style.fromString(this, style3);
    } else {
      _p.style = _Style(this);
    }
    return _p.style;
  }, "setStyle"),
  // e.g. cy.data() changed => recalc ele mappers
  updateStyle: /* @__PURE__ */ __name(function updateStyle2() {
    this.mutableElements().updateStyle();
  }, "updateStyle2")
};
var defaultSelectionType = "single";
var corefn$1 = {
  autolock: /* @__PURE__ */ __name(function autolock(bool) {
    if (bool !== void 0) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }
    return this;
  }, "autolock"),
  autoungrabify: /* @__PURE__ */ __name(function autoungrabify(bool) {
    if (bool !== void 0) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }
    return this;
  }, "autoungrabify"),
  autounselectify: /* @__PURE__ */ __name(function autounselectify(bool) {
    if (bool !== void 0) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }
    return this;
  }, "autounselectify"),
  selectionType: /* @__PURE__ */ __name(function selectionType(selType) {
    var _p = this._private;
    if (_p.selectionType == null) {
      _p.selectionType = defaultSelectionType;
    }
    if (selType !== void 0) {
      if (selType === "additive" || selType === "single") {
        _p.selectionType = selType;
      }
    } else {
      return _p.selectionType;
    }
    return this;
  }, "selectionType"),
  panningEnabled: /* @__PURE__ */ __name(function panningEnabled(bool) {
    if (bool !== void 0) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }
    return this;
  }, "panningEnabled"),
  userPanningEnabled: /* @__PURE__ */ __name(function userPanningEnabled(bool) {
    if (bool !== void 0) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }
    return this;
  }, "userPanningEnabled"),
  zoomingEnabled: /* @__PURE__ */ __name(function zoomingEnabled(bool) {
    if (bool !== void 0) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }
    return this;
  }, "zoomingEnabled"),
  userZoomingEnabled: /* @__PURE__ */ __name(function userZoomingEnabled(bool) {
    if (bool !== void 0) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }
    return this;
  }, "userZoomingEnabled"),
  boxSelectionEnabled: /* @__PURE__ */ __name(function boxSelectionEnabled(bool) {
    if (bool !== void 0) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }
    return this;
  }, "boxSelectionEnabled"),
  pan: /* @__PURE__ */ __name(function pan() {
    var args2 = arguments;
    var pan2 = this._private.pan;
    var dim, val, dims, x2, y2;
    switch (args2.length) {
      case 0:
        return pan2;
      case 1:
        if (string(args2[0])) {
          dim = args2[0];
          return pan2[dim];
        } else if (plainObject(args2[0])) {
          if (!this._private.panningEnabled) {
            return this;
          }
          dims = args2[0];
          x2 = dims.x;
          y2 = dims.y;
          if (number$1(x2)) {
            pan2.x = x2;
          }
          if (number$1(y2)) {
            pan2.y = y2;
          }
          this.emit("pan viewport");
        }
        break;
      case 2:
        if (!this._private.panningEnabled) {
          return this;
        }
        dim = args2[0];
        val = args2[1];
        if ((dim === "x" || dim === "y") && number$1(val)) {
          pan2[dim] = val;
        }
        this.emit("pan viewport");
        break;
    }
    this.notify("viewport");
    return this;
  }, "pan"),
  panBy: /* @__PURE__ */ __name(function panBy(arg0, arg1) {
    var args2 = arguments;
    var pan2 = this._private.pan;
    var dim, val, dims, x2, y2;
    if (!this._private.panningEnabled) {
      return this;
    }
    switch (args2.length) {
      case 1:
        if (plainObject(arg0)) {
          dims = args2[0];
          x2 = dims.x;
          y2 = dims.y;
          if (number$1(x2)) {
            pan2.x += x2;
          }
          if (number$1(y2)) {
            pan2.y += y2;
          }
          this.emit("pan viewport");
        }
        break;
      case 2:
        dim = arg0;
        val = arg1;
        if ((dim === "x" || dim === "y") && number$1(val)) {
          pan2[dim] += val;
        }
        this.emit("pan viewport");
        break;
    }
    this.notify("viewport");
    return this;
  }, "panBy"),
  gc: /* @__PURE__ */ __name(function gc() {
    this.notify("gc");
  }, "gc"),
  fit: /* @__PURE__ */ __name(function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);
    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;
      this.emit("pan zoom viewport");
      this.notify("viewport");
    }
    return this;
  }, "fit"),
  getFitViewport: /* @__PURE__ */ __name(function getFitViewport(elements, padding) {
    if (number$1(elements) && padding === void 0) {
      padding = elements;
      elements = void 0;
    }
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }
    var bb;
    if (string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (boundingBox(elements)) {
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }
    if (elementOrCollection(elements) && elements.empty()) {
      return;
    }
    bb = bb || elements.boundingBox();
    var w = this.width();
    var h = this.height();
    var zoom2;
    padding = number$1(padding) ? padding : 0;
    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom2 = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);
      zoom2 = zoom2 > this._private.maxZoom ? this._private.maxZoom : zoom2;
      zoom2 = zoom2 < this._private.minZoom ? this._private.minZoom : zoom2;
      var pan2 = {
        // now pan to middle
        x: (w - zoom2 * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom2 * (bb.y1 + bb.y2)) / 2
      };
      return {
        zoom: zoom2,
        pan: pan2
      };
    }
    return;
  }, "getFitViewport"),
  zoomRange: /* @__PURE__ */ __name(function zoomRange(min4, max5) {
    var _p = this._private;
    if (max5 == null) {
      var opts = min4;
      min4 = opts.min;
      max5 = opts.max;
    }
    if (number$1(min4) && number$1(max5) && min4 <= max5) {
      _p.minZoom = min4;
      _p.maxZoom = max5;
    } else if (number$1(min4) && max5 === void 0 && min4 <= _p.maxZoom) {
      _p.minZoom = min4;
    } else if (number$1(max5) && min4 === void 0 && max5 >= _p.minZoom) {
      _p.maxZoom = max5;
    }
    return this;
  }, "zoomRange"),
  minZoom: /* @__PURE__ */ __name(function minZoom(zoom2) {
    if (zoom2 === void 0) {
      return this._private.minZoom;
    } else {
      return this.zoomRange({
        min: zoom2
      });
    }
  }, "minZoom"),
  maxZoom: /* @__PURE__ */ __name(function maxZoom(zoom2) {
    if (zoom2 === void 0) {
      return this._private.maxZoom;
    } else {
      return this.zoomRange({
        max: zoom2
      });
    }
  }, "maxZoom"),
  getZoomedViewport: /* @__PURE__ */ __name(function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos;
    var zoom2;
    var bail = false;
    if (!_p.zoomingEnabled) {
      bail = true;
    }
    if (number$1(params)) {
      zoom2 = params;
    } else if (plainObject(params)) {
      zoom2 = params.level;
      if (params.position != null) {
        pos = modelToRenderedPosition$1(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }
      if (pos != null && !_p.panningEnabled) {
        bail = true;
      }
    }
    zoom2 = zoom2 > _p.maxZoom ? _p.maxZoom : zoom2;
    zoom2 = zoom2 < _p.minZoom ? _p.minZoom : zoom2;
    if (bail || !number$1(zoom2) || zoom2 === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {
      return null;
    }
    if (pos != null) {
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom22 = zoom2;
      var pan2 = {
        x: -zoom22 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom22 / zoom1 * (pos.y - pan1.y) + pos.y
      };
      return {
        zoomed: true,
        panned: true,
        zoom: zoom22,
        pan: pan2
      };
    } else {
      return {
        zoomed: true,
        panned: false,
        zoom: zoom2,
        pan: currentPan
      };
    }
  }, "getZoomedViewport"),
  zoom: /* @__PURE__ */ __name(function zoom(params) {
    if (params === void 0) {
      return this._private.zoom;
    } else {
      var vp = this.getZoomedViewport(params);
      var _p = this._private;
      if (vp == null || !vp.zoomed) {
        return this;
      }
      _p.zoom = vp.zoom;
      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }
      this.emit("zoom" + (vp.panned ? " pan" : "") + " viewport");
      this.notify("viewport");
      return this;
    }
  }, "zoom"),
  viewport: /* @__PURE__ */ __name(function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = [];
    var zoomFailed = false;
    var panFailed = false;
    if (!opts) {
      return this;
    }
    if (!number$1(opts.zoom)) {
      zoomDefd = false;
    }
    if (!plainObject(opts.pan)) {
      panDefd = false;
    }
    if (!zoomDefd && !panDefd) {
      return this;
    }
    if (zoomDefd) {
      var z = opts.zoom;
      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;
        events.push("zoom");
      }
    }
    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p2 = opts.pan;
      if (number$1(p2.x)) {
        _p.pan.x = p2.x;
        panFailed = false;
      }
      if (number$1(p2.y)) {
        _p.pan.y = p2.y;
        panFailed = false;
      }
      if (!panFailed) {
        events.push("pan");
      }
    }
    if (events.length > 0) {
      events.push("viewport");
      this.emit(events.join(" "));
      this.notify("viewport");
    }
    return this;
  }, "viewport"),
  center: /* @__PURE__ */ __name(function center(elements) {
    var pan2 = this.getCenterPan(elements);
    if (pan2) {
      this._private.pan = pan2;
      this.emit("pan viewport");
      this.notify("viewport");
    }
    return this;
  }, "center"),
  getCenterPan: /* @__PURE__ */ __name(function getCenterPan(elements, zoom2) {
    if (!this._private.panningEnabled) {
      return;
    }
    if (string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }
    if (elements.length === 0) {
      return;
    }
    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom2 = zoom2 === void 0 ? this._private.zoom : zoom2;
    var pan2 = {
      // middle
      x: (w - zoom2 * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom2 * (bb.y1 + bb.y2)) / 2
    };
    return pan2;
  }, "getCenterPan"),
  reset: /* @__PURE__ */ __name(function reset2() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }
    this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    });
    return this;
  }, "reset"),
  invalidateSize: /* @__PURE__ */ __name(function invalidateSize() {
    this._private.sizeCache = null;
  }, "invalidateSize"),
  size: /* @__PURE__ */ __name(function size22() {
    var _p = this._private;
    var container2 = _p.container;
    var cy = this;
    return _p.sizeCache = _p.sizeCache || (container2 ? (function() {
      var style3 = cy.window().getComputedStyle(container2);
      var val = /* @__PURE__ */ __name(function val2(name) {
        return parseFloat(style3.getPropertyValue(name));
      }, "val2");
      return {
        width: container2.clientWidth - val("padding-left") - val("padding-right"),
        height: container2.clientHeight - val("padding-top") - val("padding-bottom")
      };
    })() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  }, "size2"),
  width: /* @__PURE__ */ __name(function width() {
    return this.size().width;
  }, "width"),
  height: /* @__PURE__ */ __name(function height() {
    return this.size().height;
  }, "height"),
  extent: /* @__PURE__ */ __name(function extent() {
    var pan2 = this._private.pan;
    var zoom2 = this._private.zoom;
    var rb = this.renderedExtent();
    var b = {
      x1: (rb.x1 - pan2.x) / zoom2,
      x2: (rb.x2 - pan2.x) / zoom2,
      y1: (rb.y1 - pan2.y) / zoom2,
      y2: (rb.y2 - pan2.y) / zoom2
    };
    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;
    return b;
  }, "extent"),
  renderedExtent: /* @__PURE__ */ __name(function renderedExtent() {
    var width2 = this.width();
    var height2 = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: width2,
      y2: height2,
      w: width2,
      h: height2
    };
  }, "renderedExtent"),
  multiClickDebounceTime: /* @__PURE__ */ __name(function multiClickDebounceTime(_int) {
    if (_int) this._private.multiClickDebounceTime = _int;
    else return this._private.multiClickDebounceTime;
    return this;
  }, "multiClickDebounceTime")
};
corefn$1.centre = corefn$1.center;
corefn$1.autolockNodes = corefn$1.autolock;
corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;
var fn2 = {
  data: define.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: true,
    allowSetting: true,
    settingEvent: "data",
    settingTriggersEvent: true,
    triggerFnName: "trigger",
    allowGetting: true,
    updateStyle: true
  }),
  removeData: define.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: true,
    updateStyle: true
  }),
  scratch: define.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: true,
    allowSetting: true,
    settingEvent: "scratch",
    settingTriggersEvent: true,
    triggerFnName: "trigger",
    allowGetting: true,
    updateStyle: true
  }),
  removeScratch: define.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: true,
    updateStyle: true
  })
};
fn2.attr = fn2.data;
fn2.removeAttr = fn2.removeData;
var Core = /* @__PURE__ */ __name(function Core2(opts) {
  var cy = this;
  opts = extend({}, opts);
  var container2 = opts.container;
  if (container2 && !htmlElement(container2) && htmlElement(container2[0])) {
    container2 = container2[0];
  }
  var reg = container2 ? container2._cyreg : null;
  reg = reg || {};
  if (reg && reg.cy) {
    reg.cy.destroy();
    reg = {};
  }
  var readies = reg.readies = reg.readies || [];
  if (container2) {
    container2._cyreg = reg;
  }
  reg.cy = cy;
  var head2 = _window !== void 0 && container2 !== void 0 && !opts.headless;
  var options2 = opts;
  options2.layout = extend({
    name: head2 ? "grid" : "null"
  }, options2.layout);
  options2.renderer = extend({
    name: head2 ? "canvas" : "null"
  }, options2.renderer);
  var defVal = /* @__PURE__ */ __name(function defVal2(def, val, altVal) {
    if (val !== void 0) {
      return val;
    } else if (altVal !== void 0) {
      return altVal;
    } else {
      return def;
    }
  }, "defVal2");
  var _p = this._private = {
    container: container2,
    // html dom ele container
    ready: false,
    // whether ready has been triggered
    options: options2,
    // cached options
    elements: new Collection(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new Collection(this),
    // elements being animated
    data: options2.data || {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false,
    // whether destroy was called
    notificationsEnabled: true,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options2.zoomingEnabled),
    userZoomingEnabled: defVal(true, options2.userZoomingEnabled),
    panningEnabled: defVal(true, options2.panningEnabled),
    userPanningEnabled: defVal(true, options2.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options2.boxSelectionEnabled),
    autolock: defVal(false, options2.autolock, options2.autolockNodes),
    autoungrabify: defVal(false, options2.autoungrabify, options2.autoungrabifyNodes),
    autounselectify: defVal(false, options2.autounselectify),
    styleEnabled: options2.styleEnabled === void 0 ? head2 : options2.styleEnabled,
    zoom: number$1(options2.zoom) ? options2.zoom : 1,
    pan: {
      x: plainObject(options2.pan) && number$1(options2.pan.x) ? options2.pan.x : 0,
      y: plainObject(options2.pan) && number$1(options2.pan.y) ? options2.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false,
    multiClickDebounceTime: defVal(250, options2.multiClickDebounceTime)
  };
  this.createEmitter();
  this.selectionType(options2.selectionType);
  this.zoomRange({
    min: options2.minZoom,
    max: options2.maxZoom
  });
  var loadExtData = /* @__PURE__ */ __name(function loadExtData2(extData, next2) {
    var anyIsPromise = extData.some(promise);
    if (anyIsPromise) {
      return Promise$1.all(extData).then(next2);
    } else {
      next2(extData);
    }
  }, "loadExtData2");
  if (_p.styleEnabled) {
    cy.setStyle([]);
  }
  var rendererOptions = extend({}, options2, options2.renderer);
  cy.initRenderer(rendererOptions);
  var setElesAndLayout = /* @__PURE__ */ __name(function setElesAndLayout2(elements, onload, ondone) {
    cy.notifications(false);
    var oldEles = cy.mutableElements();
    if (oldEles.length > 0) {
      oldEles.remove();
    }
    if (elements != null) {
      if (plainObject(elements) || array(elements)) {
        cy.add(elements);
      }
    }
    cy.one("layoutready", function(e) {
      cy.notifications(true);
      cy.emit(e);
      cy.one("load", onload);
      cy.emitAndNotify("load");
    }).one("layoutstop", function() {
      cy.one("done", ondone);
      cy.emit("done");
    });
    var layoutOpts = extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();
    cy.layout(layoutOpts).run();
  }, "setElesAndLayout2");
  loadExtData([options2.style, options2.elements], function(thens) {
    var initStyle = thens[0];
    var initEles = thens[1];
    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    }
    setElesAndLayout(initEles, function() {
      cy.startAnimationLoop();
      _p.ready = true;
      if (fn$6(options2.ready)) {
        cy.on("ready", options2.ready);
      }
      for (var i = 0; i < readies.length; i++) {
        var fn3 = readies[i];
        cy.on("ready", fn3);
      }
      if (reg) {
        reg.readies = [];
      }
      cy.emit("ready");
    }, options2.done);
  });
}, "Core2");
var corefn = Core.prototype;
extend(corefn, {
  instanceString: /* @__PURE__ */ __name(function instanceString3() {
    return "core";
  }, "instanceString3"),
  isReady: /* @__PURE__ */ __name(function isReady() {
    return this._private.ready;
  }, "isReady"),
  destroyed: /* @__PURE__ */ __name(function destroyed() {
    return this._private.destroyed;
  }, "destroyed"),
  ready: /* @__PURE__ */ __name(function ready(fn3) {
    if (this.isReady()) {
      this.emitter().emit("ready", [], fn3);
    } else {
      this.on("ready", fn3);
    }
    return this;
  }, "ready"),
  destroy: /* @__PURE__ */ __name(function destroy() {
    var cy = this;
    if (cy.destroyed()) return;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    this.emit("destroy");
    cy._private.destroyed = true;
    return cy;
  }, "destroy"),
  hasElementWithId: /* @__PURE__ */ __name(function hasElementWithId(id2) {
    return this._private.elements.hasElementWithId(id2);
  }, "hasElementWithId"),
  getElementById: /* @__PURE__ */ __name(function getElementById(id2) {
    return this._private.elements.getElementById(id2);
  }, "getElementById"),
  hasCompoundNodes: /* @__PURE__ */ __name(function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  }, "hasCompoundNodes"),
  headless: /* @__PURE__ */ __name(function headless() {
    return this._private.renderer.isHeadless();
  }, "headless"),
  styleEnabled: /* @__PURE__ */ __name(function styleEnabled() {
    return this._private.styleEnabled;
  }, "styleEnabled"),
  addToPool: /* @__PURE__ */ __name(function addToPool(eles) {
    this._private.elements.merge(eles);
    return this;
  }, "addToPool"),
  removeFromPool: /* @__PURE__ */ __name(function removeFromPool(eles) {
    this._private.elements.unmerge(eles);
    return this;
  }, "removeFromPool"),
  container: /* @__PURE__ */ __name(function container() {
    return this._private.container || null;
  }, "container"),
  window: /* @__PURE__ */ __name(function window2() {
    var container2 = this._private.container;
    if (container2 == null) return _window;
    var ownerDocument = this._private.container.ownerDocument;
    if (ownerDocument === void 0 || ownerDocument == null) {
      return _window;
    }
    return ownerDocument.defaultView || _window;
  }, "window2"),
  mount: /* @__PURE__ */ __name(function mount2(container2) {
    if (container2 == null) {
      return;
    }
    var cy = this;
    var _p = cy._private;
    var options2 = _p.options;
    if (!htmlElement(container2) && htmlElement(container2[0])) {
      container2 = container2[0];
    }
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    _p.container = container2;
    _p.styleEnabled = true;
    cy.invalidateSize();
    cy.initRenderer(extend({}, options2, options2.renderer, {
      // allow custom renderer name to be re-used, otherwise use canvas
      name: options2.renderer.name === "null" ? "canvas" : options2.renderer.name
    }));
    cy.startAnimationLoop();
    cy.style(options2.style);
    cy.emit("mount");
    return cy;
  }, "mount"),
  unmount: /* @__PURE__ */ __name(function unmount2() {
    var cy = this;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    cy.initRenderer({
      name: "null"
    });
    cy.emit("unmount");
    return cy;
  }, "unmount"),
  options: /* @__PURE__ */ __name(function options() {
    return copy(this._private.options);
  }, "options"),
  json: /* @__PURE__ */ __name(function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();
    var getFreshRef = /* @__PURE__ */ __name(function getFreshRef2(ele) {
      return cy.getElementById(ele.id());
    }, "getFreshRef2");
    if (plainObject(obj)) {
      cy.startBatch();
      if (obj.elements) {
        var idInJson = {};
        var updateEles = /* @__PURE__ */ __name(function updateEles2(jsons, gr2) {
          var toAdd = [];
          var toMod = [];
          for (var i2 = 0; i2 < jsons.length; i2++) {
            var json3 = jsons[i2];
            if (!json3.data.id) {
              warn("cy.json() cannot handle elements without an ID attribute");
              continue;
            }
            var id2 = "" + json3.data.id;
            var ele = cy.getElementById(id2);
            idInJson[id2] = true;
            if (ele.length !== 0) {
              toMod.push({
                ele,
                json: json3
              });
            } else {
              if (gr2) {
                json3.group = gr2;
                toAdd.push(json3);
              } else {
                toAdd.push(json3);
              }
            }
          }
          cy.add(toAdd);
          for (var _i = 0; _i < toMod.length; _i++) {
            var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;
            _ele.json(_json);
          }
        }, "updateEles2");
        if (array(obj.elements)) {
          updateEles(obj.elements);
        } else {
          var grs = ["nodes", "edges"];
          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];
            if (array(elements)) {
              updateEles(elements, gr);
            }
          }
        }
        var parentsToRemove = cy.collection();
        eles.filter(function(ele) {
          return !idInJson[ele.id()];
        }).forEach(function(ele) {
          if (ele.isParent()) {
            parentsToRemove.merge(ele);
          } else {
            ele.remove();
          }
        });
        parentsToRemove.forEach(function(ele) {
          return ele.children().move({
            parent: null
          });
        });
        parentsToRemove.forEach(function(ele) {
          return getFreshRef(ele).remove();
        });
      }
      if (obj.style) {
        cy.style(obj.style);
      }
      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }
      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }
      if (obj.data) {
        cy.data(obj.data);
      }
      var fields = ["minZoom", "maxZoom", "zoomingEnabled", "userZoomingEnabled", "panningEnabled", "userPanningEnabled", "boxSelectionEnabled", "autolock", "autoungrabify", "autounselectify", "multiClickDebounceTime"];
      for (var _i2 = 0; _i2 < fields.length; _i2++) {
        var f = fields[_i2];
        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }
      cy.endBatch();
      return this;
    } else {
      var flat = !!obj;
      var json2 = {};
      if (flat) {
        json2.elements = this.elements().map(function(ele) {
          return ele.json();
        });
      } else {
        json2.elements = {};
        eles.forEach(function(ele) {
          var group2 = ele.group();
          if (!json2.elements[group2]) {
            json2.elements[group2] = [];
          }
          json2.elements[group2].push(ele.json());
        });
      }
      if (this._private.styleEnabled) {
        json2.style = cy.style().json();
      }
      json2.data = copy(cy.data());
      var options2 = _p.options;
      json2.zoomingEnabled = _p.zoomingEnabled;
      json2.userZoomingEnabled = _p.userZoomingEnabled;
      json2.zoom = _p.zoom;
      json2.minZoom = _p.minZoom;
      json2.maxZoom = _p.maxZoom;
      json2.panningEnabled = _p.panningEnabled;
      json2.userPanningEnabled = _p.userPanningEnabled;
      json2.pan = copy(_p.pan);
      json2.boxSelectionEnabled = _p.boxSelectionEnabled;
      json2.renderer = copy(options2.renderer);
      json2.hideEdgesOnViewport = options2.hideEdgesOnViewport;
      json2.textureOnViewport = options2.textureOnViewport;
      json2.wheelSensitivity = options2.wheelSensitivity;
      json2.motionBlur = options2.motionBlur;
      json2.multiClickDebounceTime = options2.multiClickDebounceTime;
      return json2;
    }
  }, "json")
});
corefn.$id = corefn.getElementById;
[corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn2].forEach(function(props) {
  extend(corefn, props);
});
var defaults$7 = {
  fit: true,
  // whether to fit the viewport to the graph
  directed: false,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  direction: "downward",
  // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.
  padding: 30,
  // padding on fit
  circle: false,
  // put depths in concentric circles if true, put depths top down if false
  grid: false,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: void 0,
  // the roots of the trees
  depthSort: void 0,
  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled,
  animateFilter: /* @__PURE__ */ __name(function animateFilter(node, i) {
    return true;
  }, "animateFilter"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform2(node, position3) {
    return position3;
  }, "transform")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
var deprecatedOptionDefaults = {
  maximal: false,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also
  acyclic: false
  // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops
};
var getInfo = /* @__PURE__ */ __name(function getInfo2(ele) {
  return ele.scratch("breadthfirst");
}, "getInfo2");
var setInfo = /* @__PURE__ */ __name(function setInfo2(ele, obj) {
  return ele.scratch("breadthfirst", obj);
}, "setInfo2");
function BreadthFirstLayout(options2) {
  this.options = extend({}, defaults$7, deprecatedOptionDefaults, options2);
}
__name(BreadthFirstLayout, "BreadthFirstLayout");
BreadthFirstLayout.prototype.run = function() {
  var options2 = this.options;
  var cy = options2.cy;
  var eles = options2.eles;
  var nodes3 = eles.nodes().filter(function(n2) {
    return n2.isChildless();
  });
  var graph = eles;
  var directed = options2.directed;
  var maximal = options2.acyclic || options2.maximal || options2.maximalAdjustments > 0;
  var hasBoundingBox = !!options2.boundingBox;
  var bb = makeBoundingBox(hasBoundingBox ? options2.boundingBox : structuredClone(cy.extent()));
  var roots;
  if (elementOrCollection(options2.roots)) {
    roots = options2.roots;
  } else if (array(options2.roots)) {
    var rootsArray = [];
    for (var i = 0; i < options2.roots.length; i++) {
      var id2 = options2.roots[i];
      var ele = cy.getElementById(id2);
      rootsArray.push(ele);
    }
    roots = cy.collection(rootsArray);
  } else if (string(options2.roots)) {
    roots = cy.$(options2.roots);
  } else {
    if (directed) {
      roots = nodes3.roots();
    } else {
      var components2 = eles.components();
      roots = cy.collection();
      var _loop = /* @__PURE__ */ __name(function _loop2() {
        var comp = components2[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function(ele2) {
          return ele2.degree(false) === maxDegree;
        });
        roots = roots.add(compRoots);
      }, "_loop2");
      for (var _i = 0; _i < components2.length; _i++) {
        _loop();
      }
    }
  }
  var depths = [];
  var foundByBfs = {};
  var addToDepth = /* @__PURE__ */ __name(function addToDepth2(ele2, d) {
    if (depths[d] == null) {
      depths[d] = [];
    }
    var i2 = depths[d].length;
    depths[d].push(ele2);
    setInfo(ele2, {
      index: i2,
      depth: d
    });
  }, "addToDepth2");
  var changeDepth = /* @__PURE__ */ __name(function changeDepth2(ele2, newDepth) {
    var _getInfo = getInfo(ele2), depth = _getInfo.depth, index2 = _getInfo.index;
    depths[depth][index2] = null;
    if (ele2.isChildless()) addToDepth(ele2, newDepth);
  }, "changeDepth2");
  graph.bfs({
    roots,
    directed: options2.directed,
    visit: /* @__PURE__ */ __name(function visit(node, edge, pNode, i2, depth) {
      var ele2 = node[0];
      var id3 = ele2.id();
      if (ele2.isChildless()) addToDepth(ele2, depth);
      foundByBfs[id3] = true;
    }, "visit")
  });
  var orphanNodes = [];
  for (var _i2 = 0; _i2 < nodes3.length; _i2++) {
    var _ele = nodes3[_i2];
    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  }
  var assignDepthsAt = /* @__PURE__ */ __name(function assignDepthsAt2(i2) {
    var eles2 = depths[i2];
    for (var j = 0; j < eles2.length; j++) {
      var _ele2 = eles2[j];
      if (_ele2 == null) {
        eles2.splice(j, 1);
        j--;
        continue;
      }
      setInfo(_ele2, {
        depth: i2,
        index: j
      });
    }
  }, "assignDepthsAt2");
  var adjustMaximally = /* @__PURE__ */ __name(function adjustMaximally2(ele2, shifted2) {
    var eInfo = getInfo(ele2);
    var incomers = ele2.incomers().filter(function(el) {
      return el.isNode() && eles.has(el);
    });
    var maxDepth = -1;
    var id3 = ele2.id();
    for (var k = 0; k < incomers.length; k++) {
      var incmr = incomers[k];
      var iInfo = getInfo(incmr);
      maxDepth = Math.max(maxDepth, iInfo.depth);
    }
    if (eInfo.depth <= maxDepth) {
      if (!options2.acyclic && shifted2[id3]) {
        return null;
      }
      var newDepth = maxDepth + 1;
      changeDepth(ele2, newDepth);
      shifted2[id3] = newDepth;
      return true;
    }
    return false;
  }, "adjustMaximally2");
  if (directed && maximal) {
    var Q = [];
    var shifted = {};
    var enqueue = /* @__PURE__ */ __name(function enqueue2(n2) {
      return Q.push(n2);
    }, "enqueue2");
    var dequeue = /* @__PURE__ */ __name(function dequeue2() {
      return Q.shift();
    }, "dequeue2");
    nodes3.forEach(function(n2) {
      return Q.push(n2);
    });
    while (Q.length > 0) {
      var _ele3 = dequeue();
      var didShift = adjustMaximally(_ele3, shifted);
      if (didShift) {
        _ele3.outgoers().filter(function(el) {
          return el.isNode() && eles.has(el);
        }).forEach(enqueue);
      } else if (didShift === null) {
        warn("Detected double maximal shift for node `" + _ele3.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
        break;
      }
    }
  }
  var minDistance = 0;
  if (options2.avoidOverlap) {
    for (var _i3 = 0; _i3 < nodes3.length; _i3++) {
      var n = nodes3[_i3];
      var nbb = n.layoutDimensions(options2);
      var w = nbb.w;
      var h = nbb.h;
      minDistance = Math.max(minDistance, w, h);
    }
  }
  var cachedWeightedPercent = {};
  var getWeightedPercent = /* @__PURE__ */ __name(function getWeightedPercent2(ele2) {
    if (cachedWeightedPercent[ele2.id()]) {
      return cachedWeightedPercent[ele2.id()];
    }
    var eleDepth = getInfo(ele2).depth;
    var neighbors = ele2.neighborhood();
    var percent = 0;
    var samples = 0;
    for (var _i4 = 0; _i4 < neighbors.length; _i4++) {
      var neighbor = neighbors[_i4];
      if (neighbor.isEdge() || neighbor.isParent() || !nodes3.has(neighbor)) {
        continue;
      }
      var bf = getInfo(neighbor);
      if (bf == null) {
        continue;
      }
      var index2 = bf.index;
      var depth = bf.depth;
      if (index2 == null || depth == null) {
        continue;
      }
      var nDepth = depths[depth].length;
      if (depth < eleDepth) {
        percent += index2 / nDepth;
        samples++;
      }
    }
    samples = Math.max(1, samples);
    percent = percent / samples;
    if (samples === 0) {
      percent = 0;
    }
    cachedWeightedPercent[ele2.id()] = percent;
    return percent;
  }, "getWeightedPercent2");
  var sortFn = /* @__PURE__ */ __name(function sortFn2(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);
    var diff2 = apct - bpct;
    if (diff2 === 0) {
      return ascending(a.id(), b.id());
    } else {
      return diff2;
    }
  }, "sortFn2");
  if (options2.depthSort !== void 0) {
    sortFn = options2.depthSort;
  }
  var depthsLen = depths.length;
  for (var _i5 = 0; _i5 < depthsLen; _i5++) {
    depths[_i5].sort(sortFn);
    assignDepthsAt(_i5);
  }
  var orphanDepth = [];
  for (var _i6 = 0; _i6 < orphanNodes.length; _i6++) {
    orphanDepth.push(orphanNodes[_i6]);
  }
  var assignDepths = /* @__PURE__ */ __name(function assignDepths2() {
    for (var _i7 = 0; _i7 < depthsLen; _i7++) {
      assignDepthsAt(_i7);
    }
  }, "assignDepths2");
  if (orphanDepth.length) {
    depths.unshift(orphanDepth);
    depthsLen = depths.length;
    assignDepths();
  }
  var biggestDepthSize = 0;
  for (var _i8 = 0; _i8 < depthsLen; _i8++) {
    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
  }
  var center2 = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var aveNodeSize = nodes3.reduce(function(acc, node) {
    return (function(box) {
      return {
        w: acc.w === -1 ? box.w : (acc.w + box.w) / 2,
        h: acc.h === -1 ? box.h : (acc.h + box.h) / 2
      };
    })(node.boundingBox({
      includeLabels: options2.nodeDimensionsIncludeLabels
    }));
  }, {
    w: -1,
    h: -1
  });
  var distanceY = Math.max(
    // only one depth
    depthsLen === 1 ? 0 : (
      // inside a bounding box, no need for top & bottom padding
      hasBoundingBox ? (bb.h - options2.padding * 2 - aveNodeSize.h) / (depthsLen - 1) : (bb.h - options2.padding * 2 - aveNodeSize.h) / (depthsLen + 1)
    ),
    minDistance
  );
  var maxDepthSize = depths.reduce(function(max5, eles2) {
    return Math.max(max5, eles2.length);
  }, 0);
  var getPositionTopBottom = /* @__PURE__ */ __name(function getPositionTopBottom2(ele2) {
    var _getInfo2 = getInfo(ele2), depth = _getInfo2.depth, index2 = _getInfo2.index;
    if (options2.circle) {
      var radiusStepSize = Math.min(bb.w / 2 / depthsLen, bb.h / 2 / depthsLen);
      radiusStepSize = Math.max(radiusStepSize, minDistance);
      var radius2 = radiusStepSize * depth + radiusStepSize - (depthsLen > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
      var theta = 2 * Math.PI / depths[depth].length * index2;
      if (depth === 0 && depths[0].length === 1) {
        radius2 = 1;
      }
      return {
        x: center2.x + radius2 * Math.cos(theta),
        y: center2.y + radius2 * Math.sin(theta)
      };
    } else {
      var depthSize = depths[depth].length;
      var distanceX = Math.max(
        // only one depth
        depthSize === 1 ? 0 : (
          // inside a bounding box, no need for left & right padding
          hasBoundingBox ? (bb.w - options2.padding * 2 - aveNodeSize.w) / ((options2.grid ? maxDepthSize : depthSize) - 1) : (bb.w - options2.padding * 2 - aveNodeSize.w) / ((options2.grid ? maxDepthSize : depthSize) + 1)
        ),
        minDistance
      );
      var epos = {
        x: center2.x + (index2 + 1 - (depthSize + 1) / 2) * distanceX,
        y: center2.y + (depth + 1 - (depthsLen + 1) / 2) * distanceY
      };
      return epos;
    }
  }, "getPositionTopBottom2");
  var rotateDegrees = {
    "downward": 0,
    "leftward": 90,
    "upward": 180,
    "rightward": -90
  };
  if (Object.keys(rotateDegrees).indexOf(options2.direction) === -1) {
    error("Invalid direction '".concat(options2.direction, "' specified for breadthfirst layout. Valid values are: ").concat(Object.keys(rotateDegrees).join(", ")));
  }
  var getPosition = /* @__PURE__ */ __name(function getPosition2(ele2) {
    return rotatePosAndSkewByBox(getPositionTopBottom(ele2), bb, rotateDegrees[options2.direction]);
  }, "getPosition2");
  eles.nodes().layoutPositions(this, options2, getPosition);
  return this;
};
var defaults$6 = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: void 0,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: /* @__PURE__ */ __name(function animateFilter2(node, i) {
    return true;
  }, "animateFilter2"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform22(node, position3) {
    return position3;
  }, "transform2")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function CircleLayout(options2) {
  this.options = extend({}, defaults$6, options2);
}
__name(CircleLayout, "CircleLayout");
CircleLayout.prototype.run = function() {
  var params = this.options;
  var options2 = params;
  var cy = params.cy;
  var eles = options2.eles;
  var clockwise = options2.counterclockwise !== void 0 ? !options2.counterclockwise : options2.clockwise;
  var nodes3 = eles.nodes().not(":parent");
  if (options2.sort) {
    nodes3 = nodes3.sort(options2.sort);
  }
  var bb = makeBoundingBox(options2.boundingBox ? options2.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center2 = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var sweep = options2.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / nodes3.length : options2.sweep;
  var dTheta = sweep / Math.max(1, nodes3.length - 1);
  var r2;
  var minDistance = 0;
  for (var i = 0; i < nodes3.length; i++) {
    var n = nodes3[i];
    var nbb = n.layoutDimensions(options2);
    var w = nbb.w;
    var h = nbb.h;
    minDistance = Math.max(minDistance, w, h);
  }
  if (number$1(options2.radius)) {
    r2 = options2.radius;
  } else if (nodes3.length <= 1) {
    r2 = 0;
  } else {
    r2 = Math.min(bb.h, bb.w) / 2 - minDistance;
  }
  if (nodes3.length > 1 && options2.avoidOverlap) {
    minDistance *= 1.75;
    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin));
    r2 = Math.max(rMin, r2);
  }
  var getPos = /* @__PURE__ */ __name(function getPos2(ele, i2) {
    var theta = options2.startAngle + i2 * dTheta * (clockwise ? 1 : -1);
    var rx = r2 * Math.cos(theta);
    var ry = r2 * Math.sin(theta);
    var pos = {
      x: center2.x + rx,
      y: center2.y + ry
    };
    return pos;
  }, "getPos2");
  eles.nodes().layoutPositions(this, options2, getPos);
  return this;
};
var defaults$5 = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: void 0,
  // height of layout area (overrides container height)
  width: void 0,
  // width of layout area (overrides container width)
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: /* @__PURE__ */ __name(function concentric(node) {
    return node.degree();
  }, "concentric"),
  levelWidth: /* @__PURE__ */ __name(function levelWidth(nodes3) {
    return nodes3.maxDegree() / 4;
  }, "levelWidth"),
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: /* @__PURE__ */ __name(function animateFilter3(node, i) {
    return true;
  }, "animateFilter3"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform3(node, position3) {
    return position3;
  }, "transform3")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function ConcentricLayout(options2) {
  this.options = extend({}, defaults$5, options2);
}
__name(ConcentricLayout, "ConcentricLayout");
ConcentricLayout.prototype.run = function() {
  var params = this.options;
  var options2 = params;
  var clockwise = options2.counterclockwise !== void 0 ? !options2.counterclockwise : options2.clockwise;
  var cy = params.cy;
  var eles = options2.eles;
  var nodes3 = eles.nodes().not(":parent");
  var bb = makeBoundingBox(options2.boundingBox ? options2.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center2 = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var nodeValues = [];
  var maxNodeSize = 0;
  for (var i = 0; i < nodes3.length; i++) {
    var node = nodes3[i];
    var value2 = void 0;
    value2 = options2.concentric(node);
    nodeValues.push({
      value: value2,
      node
    });
    node._private.scratch.concentric = value2;
  }
  nodes3.updateStyle();
  for (var _i = 0; _i < nodes3.length; _i++) {
    var _node = nodes3[_i];
    var nbb = _node.layoutDimensions(options2);
    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  }
  nodeValues.sort(function(a, b) {
    return b.value - a.value;
  });
  var levelWidth2 = options2.levelWidth(nodes3);
  var levels = [[]];
  var currentLevel = levels[0];
  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];
    if (currentLevel.length > 0) {
      var diff2 = Math.abs(currentLevel[0].value - val.value);
      if (diff2 >= levelWidth2) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }
    currentLevel.push(val);
  }
  var minDist = maxNodeSize + options2.minNodeSpacing;
  if (!options2.avoidOverlap) {
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
    minDist = Math.min(minDist, rStep);
  }
  var r2 = 0;
  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options2.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / level.length : options2.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);
    if (level.length > 1 && options2.avoidOverlap) {
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
      r2 = Math.max(rMin, r2);
    }
    level.r = r2;
    r2 += minDist;
  }
  if (options2.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;
    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;
      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }
    _r = 0;
    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];
      if (_i5 === 0) {
        _r = _level2.r;
      }
      _level2.r = _r;
      _r += rDeltaMax;
    }
  }
  var pos = {};
  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;
    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var theta = options2.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
      var p2 = {
        x: center2.x + _r2 * Math.cos(theta),
        y: center2.y + _r2 * Math.sin(theta)
      };
      pos[_val.node.id()] = p2;
    }
  }
  eles.nodes().layoutPositions(this, options2, function(ele) {
    var id2 = ele.id();
    return pos[id2];
  });
  return this;
};
var DEBUG;
var defaults$4 = {
  // Called on `layoutready`
  ready: /* @__PURE__ */ __name(function ready2() {
  }, "ready2"),
  // Called on `layoutstop`
  stop: /* @__PURE__ */ __name(function stop3() {
  }, "stop3"),
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,
  // Easing of the animation for animate:'end'
  animationEasing: void 0,
  // The duration of the animation for animate:'end'
  animationDuration: void 0,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: /* @__PURE__ */ __name(function animateFilter4(node, i) {
    return true;
  }, "animateFilter4"),
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: true,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: void 0,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: /* @__PURE__ */ __name(function nodeRepulsion(node) {
    return 2048;
  }, "nodeRepulsion"),
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: /* @__PURE__ */ __name(function idealEdgeLength(edge) {
    return 32;
  }, "idealEdgeLength"),
  // Divisor to compute edge forces
  edgeElasticity: /* @__PURE__ */ __name(function edgeElasticity(edge) {
    return 32;
  }, "edgeElasticity"),
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1e3,
  // Initial temperature (maximum node displacement)
  initialTemp: 1e3,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1
};
function CoseLayout(options2) {
  this.options = extend({}, defaults$4, options2);
  this.options.layout = this;
  var nodes3 = this.options.eles.nodes();
  var edges3 = this.options.eles.edges();
  var notEdges = edges3.filter(function(e) {
    var sourceId = e.source().data("id");
    var targetId = e.target().data("id");
    var hasSource = nodes3.some(function(n) {
      return n.data("id") === sourceId;
    });
    var hasTarget = nodes3.some(function(n) {
      return n.data("id") === targetId;
    });
    return !hasSource || !hasTarget;
  });
  this.options.eles = this.options.eles.not(notEdges);
}
__name(CoseLayout, "CoseLayout");
CoseLayout.prototype.run = function() {
  var options2 = this.options;
  var cy = options2.cy;
  var layout4 = this;
  layout4.stopped = false;
  if (options2.animate === true || options2.animate === false) {
    layout4.emit({
      type: "layoutstart",
      layout: layout4
    });
  }
  if (true === options2.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  }
  var layoutInfo = createLayoutInfo(cy, layout4, options2);
  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  }
  if (options2.randomize) {
    randomizePositions(layoutInfo);
  }
  var startTime = performanceNow();
  var refresh = /* @__PURE__ */ __name(function refresh2() {
    refreshPositions(layoutInfo, cy, options2);
    if (true === options2.fit) {
      cy.fit(options2.padding);
    }
  }, "refresh2");
  var mainLoop = /* @__PURE__ */ __name(function mainLoop2(i2) {
    if (layout4.stopped || i2 >= options2.numIter) {
      return false;
    }
    step(layoutInfo, options2);
    layoutInfo.temperature = layoutInfo.temperature * options2.coolingFactor;
    if (layoutInfo.temperature < options2.minTemp) {
      return false;
    }
    return true;
  }, "mainLoop2");
  var done = /* @__PURE__ */ __name(function done2() {
    if (options2.animate === true || options2.animate === false) {
      refresh();
      layout4.one("layoutstop", options2.stop);
      layout4.emit({
        type: "layoutstop",
        layout: layout4
      });
    } else {
      var nodes3 = options2.eles.nodes();
      var getScaledPos = getScaleInBoundsFn(layoutInfo, options2, nodes3);
      nodes3.layoutPositions(layout4, options2, getScaledPos);
    }
  }, "done2");
  var i = 0;
  var loopRet = true;
  if (options2.animate === true) {
    var _frame = /* @__PURE__ */ __name(function frame() {
      var f = 0;
      while (loopRet && f < options2.refresh) {
        loopRet = mainLoop(i);
        i++;
        f++;
      }
      if (!loopRet) {
        separateComponents(layoutInfo, options2);
        done();
      } else {
        var now2 = performanceNow();
        if (now2 - startTime >= options2.animationThreshold) {
          refresh();
        }
        requestAnimationFrame$1(_frame);
      }
    }, "frame");
    _frame();
  } else {
    while (loopRet) {
      loopRet = mainLoop(i);
      i++;
    }
    separateComponents(layoutInfo, options2);
    done();
  }
  return this;
};
CoseLayout.prototype.stop = function() {
  this.stopped = true;
  if (this.thread) {
    this.thread.stop();
  }
  this.emit("layoutstop");
  return this;
};
CoseLayout.prototype.destroy = function() {
  if (this.thread) {
    this.thread.stop();
  }
  return this;
};
var createLayoutInfo = /* @__PURE__ */ __name(function createLayoutInfo2(cy, layout4, options2) {
  var edges3 = options2.eles.edges();
  var nodes3 = options2.eles.nodes();
  var bb = makeBoundingBox(options2.boundingBox ? options2.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes3.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges3.size(),
    temperature: options2.initialTemp,
    clientWidth: bb.w,
    clientHeight: bb.h,
    boundingBox: bb
  };
  var components2 = options2.eles.components();
  var id2cmptId = {};
  for (var i = 0; i < components2.length; i++) {
    var component22 = components2[i];
    for (var j = 0; j < component22.length; j++) {
      var node = component22[j];
      id2cmptId[node.id()] = i;
    }
  }
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes3[i];
    var nbb = n.layoutDimensions(options2);
    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data("id");
    tempNode.parentId = n.data("parent");
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position("x");
    tempNode.positionY = n.position("y");
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style("padding"));
    tempNode.padRight = parseFloat(n.style("padding"));
    tempNode.padTop = parseFloat(n.style("padding"));
    tempNode.padBottom = parseFloat(n.style("padding"));
    tempNode.nodeRepulsion = fn$6(options2.nodeRepulsion) ? options2.nodeRepulsion(n) : options2.nodeRepulsion;
    layoutInfo.layoutNodes.push(tempNode);
    layoutInfo.idToIndex[tempNode.id] = i;
  }
  var queue = [];
  var start = 0;
  var end = -1;
  var tempGraph = [];
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId;
    if (null != p_id) {
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  }
  layoutInfo.graphSet.push(tempGraph);
  while (start <= end) {
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;
    if (children.length > 0) {
      layoutInfo.graphSet.push(children);
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  }
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    for (var j = 0; j < graph.length; j++) {
      var index2 = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index2] = i;
    }
  }
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges3[i];
    var tempEdge = {};
    tempEdge.id = e.data("id");
    tempEdge.sourceId = e.data("source");
    tempEdge.targetId = e.data("target");
    var idealLength = fn$6(options2.idealEdgeLength) ? options2.idealEdgeLength(e) : options2.idealEdgeLength;
    var elasticity = fn$6(options2.edgeElasticity) ? options2.edgeElasticity(e) : options2.edgeElasticity;
    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];
    if (sourceGraph != targetGraph) {
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0;
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }
      idealLength *= depth * options2.nestingFactor;
    }
    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;
    layoutInfo.layoutEdges.push(tempEdge);
  }
  return layoutInfo;
}, "createLayoutInfo2");
var findLCA = /* @__PURE__ */ __name(function findLCA2(node1, node2, layoutInfo) {
  var res = _findLCA_aux(node1, node2, 0, layoutInfo);
  if (2 > res.count) {
    return 0;
  } else {
    return res.graph;
  }
}, "findLCA2");
var _findLCA_aux = /* @__PURE__ */ __name(function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx];
  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {
      count: 2,
      graph: graphIx
    };
  }
  var c = 0;
  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children;
    if (0 === children.length) {
      continue;
    }
    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = _findLCA_aux(node1, node2, childGraphIx, layoutInfo);
    if (0 === result.count) {
      continue;
    } else if (1 === result.count) {
      c++;
      if (2 === c) {
        break;
      }
    } else {
      return result;
    }
  }
  return {
    count: c,
    graph: graphIx
  };
}, "findLCA_aux");
var printLayoutInfo;
var randomizePositions = /* @__PURE__ */ __name(function randomizePositions2(layoutInfo, cy) {
  var width2 = layoutInfo.clientWidth;
  var height2 = layoutInfo.clientHeight;
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width2;
      n.positionY = Math.random() * height2;
    }
  }
}, "randomizePositions2");
var getScaleInBoundsFn = /* @__PURE__ */ __name(function getScaleInBoundsFn2(layoutInfo, options2, nodes3) {
  var bb = layoutInfo.boundingBox;
  var coseBB = {
    x1: Infinity,
    x2: -Infinity,
    y1: Infinity,
    y2: -Infinity
  };
  if (options2.boundingBox) {
    nodes3.forEach(function(node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data("id")]];
      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });
    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }
  return function(ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data("id")]];
    if (options2.boundingBox) {
      var pctX = coseBB.w === 0 ? 0.5 : (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = coseBB.h === 0 ? 0.5 : (lnode.positionY - coseBB.y1) / coseBB.h;
      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  };
}, "getScaleInBoundsFn2");
var refreshPositions = /* @__PURE__ */ __name(function refreshPositions2(layoutInfo, cy, options2) {
  var layout4 = options2.layout;
  var nodes3 = options2.eles.nodes();
  var getScaledPos = getScaleInBoundsFn(layoutInfo, options2, nodes3);
  nodes3.positions(getScaledPos);
  if (true !== layoutInfo.ready) {
    layoutInfo.ready = true;
    layout4.one("layoutready", options2.ready);
    layout4.emit({
      type: "layoutready",
      layout: this
    });
  }
}, "refreshPositions2");
var step = /* @__PURE__ */ __name(function step2(layoutInfo, options2, _step) {
  calculateNodeForces(layoutInfo, options2);
  calculateEdgeForces(layoutInfo);
  calculateGravityForces(layoutInfo, options2);
  propagateForces(layoutInfo);
  updatePositions(layoutInfo);
}, "step2");
var calculateNodeForces = /* @__PURE__ */ __name(function calculateNodeForces2(layoutInfo, options2) {
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length;
    for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion2(node1, node2, layoutInfo, options2);
      }
    }
  }
}, "calculateNodeForces2");
var randomDistance = /* @__PURE__ */ __name(function randomDistance2(max5) {
  return -1 + 2 * max5 * Math.random();
}, "randomDistance2");
var nodeRepulsion2 = /* @__PURE__ */ __name(function nodeRepulsion3(node1, node2, layoutInfo, options2) {
  var cmptId1 = node1.cmptId;
  var cmptId2 = node2.cmptId;
  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
    return;
  }
  var directionX = node2.positionX - node1.positionX;
  var directionY = node2.positionY - node1.positionY;
  var maxRandDist = 1;
  if (0 === directionX && 0 === directionY) {
    directionX = randomDistance(maxRandDist);
    directionY = randomDistance(maxRandDist);
  }
  var overlap = nodesOverlap(node1, node2, directionX, directionY);
  if (overlap > 0) {
    var force = options2.nodeOverlap * overlap;
    var distance = Math.sqrt(directionX * directionX + directionY * directionY);
    var forceX = force * directionX / distance;
    var forceY = force * directionY / distance;
  } else {
    var point1 = findClippingPoint(node1, directionX, directionY);
    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);
    var distanceX = point2.x - point1.x;
    var distanceY = point2.y - point1.y;
    var distanceSqr = distanceX * distanceX + distanceY * distanceY;
    var distance = Math.sqrt(distanceSqr);
    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
    var forceX = force * distanceX / distance;
    var forceY = force * distanceY / distance;
  }
  if (!node1.isLocked) {
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
  }
  if (!node2.isLocked) {
    node2.offsetX += forceX;
    node2.offsetY += forceY;
  }
  return;
}, "nodeRepulsion3");
var nodesOverlap = /* @__PURE__ */ __name(function nodesOverlap2(node1, node2, dX, dY) {
  if (dX > 0) {
    var overlapX = node1.maxX - node2.minX;
  } else {
    var overlapX = node2.maxX - node1.minX;
  }
  if (dY > 0) {
    var overlapY = node1.maxY - node2.minY;
  } else {
    var overlapY = node2.maxY - node1.minY;
  }
  if (overlapX >= 0 && overlapY >= 0) {
    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
  } else {
    return 0;
  }
}, "nodesOverlap2");
var findClippingPoint = /* @__PURE__ */ __name(function findClippingPoint2(node, dX, dY) {
  var X = node.positionX;
  var Y = node.positionY;
  var H = node.height || 1;
  var W = node.width || 1;
  var dirSlope = dY / dX;
  var nodeSlope = H / W;
  var res = {};
  if (0 === dX && 0 < dY) {
    res.x = X;
    res.y = Y + H / 2;
    return res;
  }
  if (0 === dX && 0 > dY) {
    res.x = X;
    res.y = Y + H / 2;
    return res;
  }
  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X + W / 2;
    res.y = Y + W * dY / 2 / dX;
    return res;
  }
  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X - W / 2;
    res.y = Y - W * dY / 2 / dX;
    return res;
  }
  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X + H * dX / 2 / dY;
    res.y = Y + H / 2;
    return res;
  }
  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X - H * dX / 2 / dY;
    res.y = Y - H / 2;
    return res;
  }
  return res;
}, "findClippingPoint2");
var calculateEdgeForces = /* @__PURE__ */ __name(function calculateEdgeForces2(layoutInfo, options2) {
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var edge = layoutInfo.layoutEdges[i];
    var sourceIx = layoutInfo.idToIndex[edge.sourceId];
    var source2 = layoutInfo.layoutNodes[sourceIx];
    var targetIx = layoutInfo.idToIndex[edge.targetId];
    var target = layoutInfo.layoutNodes[targetIx];
    var directionX = target.positionX - source2.positionX;
    var directionY = target.positionY - source2.positionY;
    if (0 === directionX && 0 === directionY) {
      continue;
    }
    var point1 = findClippingPoint(source2, directionX, directionY);
    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
    var lx = point2.x - point1.x;
    var ly = point2.y - point1.y;
    var l = Math.sqrt(lx * lx + ly * ly);
    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;
    if (0 !== l) {
      var forceX = force * lx / l;
      var forceY = force * ly / l;
    } else {
      var forceX = 0;
      var forceY = 0;
    }
    if (!source2.isLocked) {
      source2.offsetX += forceX;
      source2.offsetY += forceY;
    }
    if (!target.isLocked) {
      target.offsetX -= forceX;
      target.offsetY -= forceY;
    }
  }
}, "calculateEdgeForces2");
var calculateGravityForces = /* @__PURE__ */ __name(function calculateGravityForces2(layoutInfo, options2) {
  if (options2.gravity === 0) {
    return;
  }
  var distThreshold = 1;
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length;
    if (0 === i) {
      var centerX = layoutInfo.clientHeight / 2;
      var centerY = layoutInfo.clientWidth / 2;
    } else {
      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
      var parent4 = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
      var centerX = parent4.positionX;
      var centerY = parent4.positionY;
    }
    for (var j = 0; j < numNodes; j++) {
      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      if (node.isLocked) {
        continue;
      }
      var dx = centerX - node.positionX;
      var dy = centerY - node.positionY;
      var d = Math.sqrt(dx * dx + dy * dy);
      if (d > distThreshold) {
        var fx = options2.gravity * dx / d;
        var fy = options2.gravity * dy / d;
        node.offsetX += fx;
        node.offsetY += fy;
      }
    }
  }
}, "calculateGravityForces2");
var propagateForces = /* @__PURE__ */ __name(function propagateForces2(layoutInfo, options2) {
  var queue = [];
  var start = 0;
  var end = -1;
  queue.push.apply(queue, layoutInfo.graphSet[0]);
  end += layoutInfo.graphSet[0].length;
  while (start <= end) {
    var nodeId = queue[start++];
    var nodeIndex = layoutInfo.idToIndex[nodeId];
    var node = layoutInfo.layoutNodes[nodeIndex];
    var children = node.children;
    if (0 < children.length && !node.isLocked) {
      var offX = node.offsetX;
      var offY = node.offsetY;
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        queue[++end] = children[i];
      }
      node.offsetX = 0;
      node.offsetY = 0;
    }
  }
}, "propagateForces2");
var updatePositions = /* @__PURE__ */ __name(function updatePositions2(layoutInfo, options2) {
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    if (0 < n.children.length) {
      n.maxX = void 0;
      n.minX = void 0;
      n.maxY = void 0;
      n.minY = void 0;
    }
  }
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    if (0 < n.children.length || n.isLocked) {
      continue;
    }
    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
    n.positionX += tempForce.x;
    n.positionY += tempForce.y;
    n.offsetX = 0;
    n.offsetY = 0;
    n.minX = n.positionX - n.width;
    n.maxX = n.positionX + n.width;
    n.minY = n.positionY - n.height;
    n.maxY = n.positionY + n.height;
    _updateAncestryBoundaries(n, layoutInfo);
  }
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    if (0 < n.children.length && !n.isLocked) {
      n.positionX = (n.maxX + n.minX) / 2;
      n.positionY = (n.maxY + n.minY) / 2;
      n.width = n.maxX - n.minX;
      n.height = n.maxY - n.minY;
    }
  }
}, "updatePositions2");
var limitForce = /* @__PURE__ */ __name(function limitForce2(forceX, forceY, max5) {
  var force = Math.sqrt(forceX * forceX + forceY * forceY);
  if (force > max5) {
    var res = {
      x: max5 * forceX / force,
      y: max5 * forceY / force
    };
  } else {
    var res = {
      x: forceX,
      y: forceY
    };
  }
  return res;
}, "limitForce2");
var _updateAncestryBoundaries = /* @__PURE__ */ __name(function updateAncestryBoundaries(node, layoutInfo) {
  var parentId = node.parentId;
  if (null == parentId) {
    return;
  }
  var p2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
  var flag = false;
  if (null == p2.maxX || node.maxX + p2.padRight > p2.maxX) {
    p2.maxX = node.maxX + p2.padRight;
    flag = true;
  }
  if (null == p2.minX || node.minX - p2.padLeft < p2.minX) {
    p2.minX = node.minX - p2.padLeft;
    flag = true;
  }
  if (null == p2.maxY || node.maxY + p2.padBottom > p2.maxY) {
    p2.maxY = node.maxY + p2.padBottom;
    flag = true;
  }
  if (null == p2.minY || node.minY - p2.padTop < p2.minY) {
    p2.minY = node.minY - p2.padTop;
    flag = true;
  }
  if (flag) {
    return _updateAncestryBoundaries(p2, layoutInfo);
  }
  return;
}, "updateAncestryBoundaries");
var separateComponents = /* @__PURE__ */ __name(function separateComponents2(layoutInfo, options2) {
  var nodes3 = layoutInfo.layoutNodes;
  var components2 = [];
  for (var i = 0; i < nodes3.length; i++) {
    var node = nodes3[i];
    var cid = node.cmptId;
    var component22 = components2[cid] = components2[cid] || [];
    component22.push(node);
  }
  var totalA = 0;
  for (var i = 0; i < components2.length; i++) {
    var c = components2[i];
    if (!c) {
      continue;
    }
    c.x1 = Infinity;
    c.x2 = -Infinity;
    c.y1 = Infinity;
    c.y2 = -Infinity;
    for (var j = 0; j < c.length; j++) {
      var n = c[j];
      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
    }
    c.w = c.x2 - c.x1;
    c.h = c.y2 - c.y1;
    totalA += c.w * c.h;
  }
  components2.sort(function(c1, c2) {
    return c2.w * c2.h - c1.w * c1.h;
  });
  var x2 = 0;
  var y2 = 0;
  var usedW = 0;
  var rowH = 0;
  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;
  for (var i = 0; i < components2.length; i++) {
    var c = components2[i];
    if (!c) {
      continue;
    }
    for (var j = 0; j < c.length; j++) {
      var n = c[j];
      if (!n.isLocked) {
        n.positionX += x2 - c.x1;
        n.positionY += y2 - c.y1;
      }
    }
    x2 += c.w + options2.componentSpacing;
    usedW += c.w + options2.componentSpacing;
    rowH = Math.max(rowH, c.h);
    if (usedW > maxRowW) {
      y2 += rowH + options2.componentSpacing;
      x2 = 0;
      usedW = 0;
      rowH = 0;
    }
  }
}, "separateComponents2");
var defaults$3 = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false,
  // uses all available space on false, uses minimal space on true
  rows: void 0,
  // force num of rows in the grid
  cols: void 0,
  // force num of columns in the grid
  position: /* @__PURE__ */ __name(function position2(node) {
  }, "position2"),
  // returns { row, col } for element
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: /* @__PURE__ */ __name(function animateFilter5(node, i) {
    return true;
  }, "animateFilter5"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform4(node, position3) {
    return position3;
  }, "transform4")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function GridLayout(options2) {
  this.options = extend({}, defaults$3, options2);
}
__name(GridLayout, "GridLayout");
GridLayout.prototype.run = function() {
  var params = this.options;
  var options2 = params;
  var cy = params.cy;
  var eles = options2.eles;
  var nodes3 = eles.nodes().not(":parent");
  if (options2.sort) {
    nodes3 = nodes3.sort(options2.sort);
  }
  var bb = makeBoundingBox(options2.boundingBox ? options2.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  if (bb.h === 0 || bb.w === 0) {
    eles.nodes().layoutPositions(this, options2, function(ele) {
      return {
        x: bb.x1,
        y: bb.y1
      };
    });
  } else {
    var cells = nodes3.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);
    var small = /* @__PURE__ */ __name(function small2(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min4 = Math.min(rows, cols);
        if (min4 == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    }, "small2");
    var large = /* @__PURE__ */ __name(function large2(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max5 = Math.max(rows, cols);
        if (max5 == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    }, "large2");
    var oRows = options2.rows;
    var oCols = options2.cols != null ? options2.cols : options2.columns;
    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    } else if (cols * rows > cells) {
      var sm = small();
      var lg = large();
      if ((sm - 1) * lg >= cells) {
        small(sm - 1);
      } else if ((lg - 1) * sm >= cells) {
        large(lg - 1);
      }
    } else {
      while (cols * rows < cells) {
        var _sm = small();
        var _lg = large();
        if ((_lg + 1) * _sm >= cells) {
          large(_lg + 1);
        } else {
          small(_sm + 1);
        }
      }
    }
    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;
    if (options2.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }
    if (options2.avoidOverlap) {
      for (var i = 0; i < nodes3.length; i++) {
        var node = nodes3[i];
        var pos = node._private.position;
        if (pos.x == null || pos.y == null) {
          pos.x = 0;
          pos.y = 0;
        }
        var nbb = node.layoutDimensions(options2);
        var p2 = options2.avoidOverlapPadding;
        var w = nbb.w + p2;
        var h = nbb.h + p2;
        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }
    var cellUsed = {};
    var used = /* @__PURE__ */ __name(function used2(row2, col2) {
      return cellUsed["c-" + row2 + "-" + col2] ? true : false;
    }, "used2");
    var use = /* @__PURE__ */ __name(function use2(row2, col2) {
      cellUsed["c-" + row2 + "-" + col2] = true;
    }, "use2");
    var row = 0;
    var col = 0;
    var moveToNextCell = /* @__PURE__ */ __name(function moveToNextCell2() {
      col++;
      if (col >= cols) {
        col = 0;
        row++;
      }
    }, "moveToNextCell2");
    var id2manPos = {};
    for (var _i = 0; _i < nodes3.length; _i++) {
      var _node = nodes3[_i];
      var rcPos = options2.position(_node);
      if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };
        if (_pos.col === void 0) {
          _pos.col = 0;
          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === void 0) {
          _pos.row = 0;
          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }
        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }
    var getPos = /* @__PURE__ */ __name(function getPos2(element3, i2) {
      var x2, y2;
      if (element3.locked() || element3.isParent()) {
        return false;
      }
      var rcPos2 = id2manPos[element3.id()];
      if (rcPos2) {
        x2 = rcPos2.col * cellWidth + cellWidth / 2 + bb.x1;
        y2 = rcPos2.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        while (used(row, col)) {
          moveToNextCell();
        }
        x2 = col * cellWidth + cellWidth / 2 + bb.x1;
        y2 = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);
        moveToNextCell();
      }
      return {
        x: x2,
        y: y2
      };
    }, "getPos2");
    nodes3.layoutPositions(this, options2, getPos);
  }
  return this;
};
var defaults$2 = {
  ready: /* @__PURE__ */ __name(function ready3() {
  }, "ready3"),
  // on layoutready
  stop: /* @__PURE__ */ __name(function stop4() {
  }, "stop4")
  // on layoutstop
};
function NullLayout(options2) {
  this.options = extend({}, defaults$2, options2);
}
__name(NullLayout, "NullLayout");
NullLayout.prototype.run = function() {
  var options2 = this.options;
  var eles = options2.eles;
  var layout4 = this;
  options2.cy;
  layout4.emit("layoutstart");
  eles.nodes().positions(function() {
    return {
      x: 0,
      y: 0
    };
  });
  layout4.one("layoutready", options2.ready);
  layout4.emit("layoutready");
  layout4.one("layoutstop", options2.stop);
  layout4.emit("layoutstop");
  return this;
};
NullLayout.prototype.stop = function() {
  return this;
};
var defaults$1 = {
  positions: void 0,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: void 0,
  // the zoom level to set (prob want fit = false if set)
  pan: void 0,
  // the pan level to set (prob want fit = false if set)
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: /* @__PURE__ */ __name(function animateFilter6(node, i) {
    return true;
  }, "animateFilter6"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform5(node, position3) {
    return position3;
  }, "transform5")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function PresetLayout(options2) {
  this.options = extend({}, defaults$1, options2);
}
__name(PresetLayout, "PresetLayout");
PresetLayout.prototype.run = function() {
  var options2 = this.options;
  var eles = options2.eles;
  var nodes3 = eles.nodes();
  var posIsFn = fn$6(options2.positions);
  function getPosition(node) {
    if (options2.positions == null) {
      return copyPosition(node.position());
    }
    if (posIsFn) {
      return options2.positions(node);
    }
    var pos = options2.positions[node._private.data.id];
    if (pos == null) {
      return null;
    }
    return pos;
  }
  __name(getPosition, "getPosition");
  nodes3.layoutPositions(this, options2, function(node, i) {
    var position3 = getPosition(node);
    if (node.locked() || position3 == null) {
      return false;
    }
    return position3;
  });
  return this;
};
var defaults2 = {
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: /* @__PURE__ */ __name(function animateFilter7(node, i) {
    return true;
  }, "animateFilter7"),
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: /* @__PURE__ */ __name(function transform6(node, position3) {
    return position3;
  }, "transform6")
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function RandomLayout(options2) {
  this.options = extend({}, defaults2, options2);
}
__name(RandomLayout, "RandomLayout");
RandomLayout.prototype.run = function() {
  var options2 = this.options;
  var cy = options2.cy;
  var eles = options2.eles;
  var bb = makeBoundingBox(options2.boundingBox ? options2.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var getPos = /* @__PURE__ */ __name(function getPos2(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  }, "getPos2");
  eles.nodes().layoutPositions(this, options2, getPos);
  return this;
};
var layout3 = [{
  name: "breadthfirst",
  impl: BreadthFirstLayout
}, {
  name: "circle",
  impl: CircleLayout
}, {
  name: "concentric",
  impl: ConcentricLayout
}, {
  name: "cose",
  impl: CoseLayout
}, {
  name: "grid",
  impl: GridLayout
}, {
  name: "null",
  impl: NullLayout
}, {
  name: "preset",
  impl: PresetLayout
}, {
  name: "random",
  impl: RandomLayout
}];
function NullRenderer(options2) {
  this.options = options2;
  this.notifications = 0;
}
__name(NullRenderer, "NullRenderer");
var noop22 = /* @__PURE__ */ __name(function noop3() {
}, "noop3");
var throwImgErr = /* @__PURE__ */ __name(function throwImgErr2() {
  throw new Error("A headless instance can not render images");
}, "throwImgErr2");
NullRenderer.prototype = {
  recalculateRenderedStyle: noop22,
  notify: /* @__PURE__ */ __name(function notify2() {
    this.notifications++;
  }, "notify2"),
  init: noop22,
  isHeadless: /* @__PURE__ */ __name(function isHeadless() {
    return true;
  }, "isHeadless"),
  png: throwImgErr,
  jpg: throwImgErr
};
var BRp$f = {};
BRp$f.arrowShapeWidth = 0.3;
BRp$f.registerArrowShapes = function() {
  var arrowShapes = this.arrowShapes = {};
  var renderer3 = this;
  var bbCollide = /* @__PURE__ */ __name(function bbCollide2(x2, y2, size3, angle2, translation, edgeWidth, padding) {
    var x1 = translation.x - size3 / 2 - padding;
    var x22 = translation.x + size3 / 2 + padding;
    var y1 = translation.y - size3 / 2 - padding;
    var y22 = translation.y + size3 / 2 + padding;
    var inside = x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
    return inside;
  }, "bbCollide2");
  var transform7 = /* @__PURE__ */ __name(function transform8(x2, y2, size3, angle2, translation) {
    var xRotated = x2 * Math.cos(angle2) - y2 * Math.sin(angle2);
    var yRotated = x2 * Math.sin(angle2) + y2 * Math.cos(angle2);
    var xScaled = xRotated * size3;
    var yScaled = yRotated * size3;
    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    return {
      x: xTranslated,
      y: yTranslated
    };
  }, "transform8");
  var transformPoints3 = /* @__PURE__ */ __name(function transformPoints4(pts2, size3, angle2, translation) {
    var retPts = [];
    for (var i = 0; i < pts2.length; i += 2) {
      var x2 = pts2[i];
      var y2 = pts2[i + 1];
      retPts.push(transform7(x2, y2, size3, angle2, translation));
    }
    return retPts;
  }, "transformPoints4");
  var pointsToArr = /* @__PURE__ */ __name(function pointsToArr2(pts2) {
    var ret = [];
    for (var i = 0; i < pts2.length; i++) {
      var p2 = pts2[i];
      ret.push(p2.x, p2.y);
    }
    return ret;
  }, "pointsToArr2");
  var standardGap = /* @__PURE__ */ __name(function standardGap2(edge) {
    return edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").pfValue * 2;
  }, "standardGap2");
  var defineArrowShape = /* @__PURE__ */ __name(function defineArrowShape2(name, defn) {
    if (string(defn)) {
      defn = arrowShapes[defn];
    }
    arrowShapes[name] = extend({
      name,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: /* @__PURE__ */ __name(function collide(x2, y2, size3, angle2, translation, padding) {
        var points = pointsToArr(transformPoints3(this.points, size3 + 2 * padding, angle2, translation));
        var inside = pointInsidePolygonPoints(x2, y2, points);
        return inside;
      }, "collide"),
      roughCollide: bbCollide,
      draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation) {
        var points = transformPoints3(this.points, size3, angle2, translation);
        renderer3.arrowShapeImpl("polygon")(context, points);
      }, "draw"),
      spacing: /* @__PURE__ */ __name(function spacing(edge) {
        return 0;
      }, "spacing"),
      gap: standardGap
    }, defn);
  }, "defineArrowShape2");
  defineArrowShape("none", {
    collide: falsify,
    roughCollide: falsify,
    draw: noop$1,
    spacing: zeroify,
    gap: zeroify
  });
  defineArrowShape("triangle", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });
  defineArrowShape("arrow", "triangle");
  defineArrowShape("triangle-backcurve", {
    points: arrowShapes["triangle"].points,
    controlPoint: [0, -0.15],
    roughCollide: bbCollide,
    draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation, edgeWidth) {
      var ptsTrans = transformPoints3(this.points, size3, angle2, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform7(ctrlPt[0], ctrlPt[1], size3, angle2, translation);
      renderer3.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    }, "draw"),
    gap: /* @__PURE__ */ __name(function gap(edge) {
      return standardGap(edge) * 0.8;
    }, "gap")
  });
  defineArrowShape("triangle-tee", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: /* @__PURE__ */ __name(function collide(x2, y2, size3, angle2, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints3(this.points, size3 + 2 * padding, angle2, translation));
      var teePts = pointsToArr(transformPoints3(this.pointsTee, size3 + 2 * padding, angle2, translation));
      var inside = pointInsidePolygonPoints(x2, y2, triPts) || pointInsidePolygonPoints(x2, y2, teePts);
      return inside;
    }, "collide"),
    draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation, edgeWidth) {
      var triPts = transformPoints3(this.points, size3, angle2, translation);
      var teePts = transformPoints3(this.pointsTee, size3, angle2, translation);
      renderer3.arrowShapeImpl(this.name)(context, triPts, teePts);
    }, "draw")
  });
  defineArrowShape("circle-triangle", {
    radius: 0.15,
    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
    collide: /* @__PURE__ */ __name(function collide(x2, y2, size3, angle2, translation, edgeWidth, padding) {
      var t = translation;
      var circleInside = Math.pow(t.x - x2, 2) + Math.pow(t.y - y2, 2) <= Math.pow((size3 + 2 * padding) * this.radius, 2);
      var triPts = pointsToArr(transformPoints3(this.points, size3 + 2 * padding, angle2, translation));
      return pointInsidePolygonPoints(x2, y2, triPts) || circleInside;
    }, "collide"),
    draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation, edgeWidth) {
      var triPts = transformPoints3(this.pointsTr, size3, angle2, translation);
      renderer3.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size3);
    }, "draw"),
    spacing: /* @__PURE__ */ __name(function spacing(edge) {
      return renderer3.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
    }, "spacing")
  });
  defineArrowShape("triangle-cross", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [
      -0.15,
      -0.4,
      // first half of the rectangle
      -0.15,
      -0.4,
      0.15,
      -0.4,
      // second half of the rectangle
      0.15,
      -0.4
    ],
    crossLinePts: /* @__PURE__ */ __name(function crossLinePts(size3, edgeWidth) {
      var p2 = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size3;
      var y0 = 3;
      var y1 = 5;
      p2[y0] = p2[y0] - shiftFactor;
      p2[y1] = p2[y1] - shiftFactor;
      return p2;
    }, "crossLinePts"),
    collide: /* @__PURE__ */ __name(function collide(x2, y2, size3, angle2, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints3(this.points, size3 + 2 * padding, angle2, translation));
      var teePts = pointsToArr(transformPoints3(this.crossLinePts(size3, edgeWidth), size3 + 2 * padding, angle2, translation));
      var inside = pointInsidePolygonPoints(x2, y2, triPts) || pointInsidePolygonPoints(x2, y2, teePts);
      return inside;
    }, "collide"),
    draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation, edgeWidth) {
      var triPts = transformPoints3(this.points, size3, angle2, translation);
      var crossLinePts = transformPoints3(this.crossLinePts(size3, edgeWidth), size3, angle2, translation);
      renderer3.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }, "draw")
  });
  defineArrowShape("vee", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: /* @__PURE__ */ __name(function gap(edge) {
      return standardGap(edge) * 0.525;
    }, "gap")
  });
  defineArrowShape("circle", {
    radius: 0.15,
    collide: /* @__PURE__ */ __name(function collide(x2, y2, size3, angle2, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x2, 2) + Math.pow(t.y - y2, 2) <= Math.pow((size3 + 2 * padding) * this.radius, 2);
      return inside;
    }, "collide"),
    draw: /* @__PURE__ */ __name(function draw(context, size3, angle2, translation, edgeWidth) {
      renderer3.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size3);
    }, "draw"),
    spacing: /* @__PURE__ */ __name(function spacing(edge) {
      return renderer3.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
    }, "spacing")
  });
  defineArrowShape("tee", {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: /* @__PURE__ */ __name(function spacing(edge) {
      return 1;
    }, "spacing"),
    gap: /* @__PURE__ */ __name(function gap(edge) {
      return 1;
    }, "gap")
  });
  defineArrowShape("square", {
    points: [-0.15, 0, 0.15, 0, 0.15, -0.3, -0.15, -0.3]
  });
  defineArrowShape("diamond", {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: /* @__PURE__ */ __name(function gap(edge) {
      return edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").value;
    }, "gap")
  });
  defineArrowShape("chevron", {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: /* @__PURE__ */ __name(function gap(edge) {
      return 0.95 * edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").value;
    }, "gap")
  });
};
var BRp$e = {};
BRp$e.projectIntoViewport = function(clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale2 = offsets[4];
  var pan2 = cy.pan();
  var zoom2 = cy.zoom();
  var x2 = ((clientX - offsetLeft) / scale2 - pan2.x) / zoom2;
  var y2 = ((clientY - offsetTop) / scale2 - pan2.y) / zoom2;
  return [x2, y2];
};
BRp$e.findContainerClientCoords = function() {
  if (this.containerBB) {
    return this.containerBB;
  }
  var container2 = this.container;
  var rect = container2.getBoundingClientRect();
  var style3 = this.cy.window().getComputedStyle(container2);
  var styleValue = /* @__PURE__ */ __name(function styleValue2(name) {
    return parseFloat(style3.getPropertyValue(name));
  }, "styleValue2");
  var padding = {
    left: styleValue("padding-left"),
    right: styleValue("padding-right"),
    top: styleValue("padding-top"),
    bottom: styleValue("padding-bottom")
  };
  var border = {
    left: styleValue("border-left-width"),
    right: styleValue("border-right-width"),
    top: styleValue("border-top-width"),
    bottom: styleValue("border-bottom-width")
  };
  var clientWidth = container2.clientWidth;
  var clientHeight = container2.clientHeight;
  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;
  var borderHor = border.left + border.right;
  var scale2 = rect.width / (clientWidth + borderHor);
  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;
  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;
  return this.containerBB = [left, top, unscaledW, unscaledH, scale2];
};
BRp$e.invalidateContainerClientCoordsCache = function() {
  this.containerBB = null;
};
BRp$e.findNearestElement = function(x2, y2, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x2, y2, interactiveElementsOnly, isTouch)[0];
};
BRp$e.findNearestElements = function(x2, y2, interactiveElementsOnly, isTouch) {
  var self2 = this;
  var r2 = this;
  var eles = r2.getCachedZSortedEles();
  var near = [];
  var zoom2 = r2.cy.zoom();
  var hasCompounds = r2.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom2;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom2;
  var labelThreshold = (isTouch ? 8 : 2) / zoom2;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;
  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }
  function addEle(ele2, sqDist) {
    if (ele2.isNode()) {
      if (nearNode) {
        return;
      } else {
        nearNode = ele2;
        near.push(ele2);
      }
    }
    if (ele2.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        if (nearEdge.pstyle("z-compound-depth").value === ele2.pstyle("z-compound-depth").value && nearEdge.pstyle("z-compound-depth").value === ele2.pstyle("z-compound-depth").value) {
          for (var i2 = 0; i2 < near.length; i2++) {
            if (near[i2].isEdge()) {
              near[i2] = ele2;
              nearEdge = ele2;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele2);
        nearEdge = ele2;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }
  __name(addEle, "addEle");
  function checkNode(node) {
    var width2 = node.outerWidth() + 2 * nodeThreshold;
    var height2 = node.outerHeight() + 2 * nodeThreshold;
    var hw = width2 / 2;
    var hh = height2 / 2;
    var pos = node.position();
    var cornerRadius = node.pstyle("corner-radius").value === "auto" ? "auto" : node.pstyle("corner-radius").pfValue;
    var rs = node._private.rscratch;
    if (pos.x - hw <= x2 && x2 <= pos.x + hw && pos.y - hh <= y2 && y2 <= pos.y + hh) {
      var shape = r2.nodeShapes[self2.getNodeShape(node)];
      if (shape.checkPoint(x2, y2, 0, width2, height2, pos.x, pos.y, cornerRadius, rs)) {
        addEle(node, 0);
        return true;
      }
    }
  }
  __name(checkNode, "checkNode");
  function checkEdge(edge) {
    var _p = edge._private;
    var rs = _p.rscratch;
    var styleWidth = edge.pstyle("width").pfValue;
    var scale2 = edge.pstyle("arrow-scale").value;
    var width2 = styleWidth / 2 + edgeThreshold;
    var widthSq = width2 * width2;
    var width22 = width2 * 2;
    var src = _p.source;
    var tgt = _p.target;
    var sqDist;
    if (rs.edgeType === "segments" || rs.edgeType === "straight" || rs.edgeType === "haystack") {
      var pts2 = rs.allpts;
      for (var i2 = 0; i2 + 3 < pts2.length; i2 += 2) {
        if (inLineVicinity(x2, y2, pts2[i2], pts2[i2 + 1], pts2[i2 + 2], pts2[i2 + 3], width22) && widthSq > (sqDist = sqdistToFiniteLine(x2, y2, pts2[i2], pts2[i2 + 1], pts2[i2 + 2], pts2[i2 + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === "bezier" || rs.edgeType === "multibezier" || rs.edgeType === "self" || rs.edgeType === "compound") {
      var pts2 = rs.allpts;
      for (var i2 = 0; i2 + 5 < rs.allpts.length; i2 += 4) {
        if (inBezierVicinity(x2, y2, pts2[i2], pts2[i2 + 1], pts2[i2 + 2], pts2[i2 + 3], pts2[i2 + 4], pts2[i2 + 5], width22) && widthSq > (sqDist = sqdistToQuadraticBezier(x2, y2, pts2[i2], pts2[i2 + 1], pts2[i2 + 2], pts2[i2 + 3], pts2[i2 + 4], pts2[i2 + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    }
    var src = src || _p.source;
    var tgt = tgt || _p.target;
    var arSize = self2.getArrowWidth(styleWidth, scale2);
    var arrows = [{
      name: "source",
      x: rs.arrowStartX,
      y: rs.arrowStartY,
      angle: rs.srcArrowAngle
    }, {
      name: "target",
      x: rs.arrowEndX,
      y: rs.arrowEndY,
      angle: rs.tgtArrowAngle
    }, {
      name: "mid-source",
      x: rs.midX,
      y: rs.midY,
      angle: rs.midsrcArrowAngle
    }, {
      name: "mid-target",
      x: rs.midX,
      y: rs.midY,
      angle: rs.midtgtArrowAngle
    }];
    for (var i2 = 0; i2 < arrows.length; i2++) {
      var ar = arrows[i2];
      var shape = r2.arrowShapes[edge.pstyle(ar.name + "-arrow-shape").value];
      var edgeWidth = edge.pstyle("width").pfValue;
      if (shape.roughCollide(x2, y2, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold) && shape.collide(x2, y2, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    }
    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }
  __name(checkEdge, "checkEdge");
  function preprop(obj, name, pre) {
    return getPrefixedProperty(obj, name, pre);
  }
  __name(preprop, "preprop");
  function checkLabel(ele2, prefix) {
    var _p = ele2._private;
    var th = labelThreshold;
    var prefixDash;
    if (prefix) {
      prefixDash = prefix + "-";
    } else {
      prefixDash = "";
    }
    ele2.boundingBox();
    var bb = _p.labelBounds[prefix || "main"];
    var text2 = ele2.pstyle(prefixDash + "label").value;
    var eventsEnabled = ele2.pstyle("text-events").strValue === "yes";
    if (!eventsEnabled || !text2) {
      return;
    }
    var lx = preprop(_p.rscratch, "labelX", prefix);
    var ly = preprop(_p.rscratch, "labelY", prefix);
    var theta = preprop(_p.rscratch, "labelAngle", prefix);
    var ox = ele2.pstyle(prefixDash + "text-margin-x").pfValue;
    var oy = ele2.pstyle(prefixDash + "text-margin-y").pfValue;
    var lx1 = bb.x1 - th - ox;
    var lx2 = bb.x2 + th - ox;
    var ly1 = bb.y1 - th - oy;
    var ly2 = bb.y2 + th - oy;
    if (theta) {
      var cos2 = Math.cos(theta);
      var sin2 = Math.sin(theta);
      var rotate2 = /* @__PURE__ */ __name(function rotate3(x3, y3) {
        x3 = x3 - lx;
        y3 = y3 - ly;
        return {
          x: x3 * cos2 - y3 * sin2 + lx,
          y: x3 * sin2 + y3 * cos2 + ly
        };
      }, "rotate3");
      var px1y1 = rotate2(lx1, ly1);
      var px1y2 = rotate2(lx1, ly2);
      var px2y1 = rotate2(lx2, ly1);
      var px2y2 = rotate2(lx2, ly2);
      var points = [
        // with the margin added after the rotation is applied
        px1y1.x + ox,
        px1y1.y + oy,
        px2y1.x + ox,
        px2y1.y + oy,
        px2y2.x + ox,
        px2y2.y + oy,
        px1y2.x + ox,
        px1y2.y + oy
      ];
      if (pointInsidePolygonPoints(x2, y2, points)) {
        addEle(ele2);
        return true;
      }
    } else {
      if (inBoundingBox(bb, x2, y2)) {
        addEle(ele2);
        return true;
      }
    }
  }
  __name(checkLabel, "checkLabel");
  for (var i = eles.length - 1; i >= 0; i--) {
    var ele = eles[i];
    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, "source") || checkLabel(ele, "target");
    }
  }
  return near;
};
BRp$e.getAllInBox = function(x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var zoom2 = this.cy.zoom();
  var labelThreshold = 2 / zoom2;
  var box = [];
  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);
  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;
  var boxBb = makeBoundingBox({
    x1,
    y1,
    x2,
    y2
  });
  var selectionBox = [{
    x: boxBb.x1,
    y: boxBb.y1
  }, {
    x: boxBb.x2,
    y: boxBb.y1
  }, {
    x: boxBb.x2,
    y: boxBb.y2
  }, {
    x: boxBb.x1,
    y: boxBb.y2
  }];
  var boxEdges = [[selectionBox[0], selectionBox[1]], [selectionBox[1], selectionBox[2]], [selectionBox[2], selectionBox[3]], [selectionBox[3], selectionBox[0]]];
  function preprop(obj, name, pre) {
    return getPrefixedProperty(obj, name, pre);
  }
  __name(preprop, "preprop");
  function getRotatedLabelBox(ele2, prefix) {
    var _p2 = ele2._private;
    var th = labelThreshold;
    var prefixDash = "";
    ele2.boundingBox();
    var bb = _p2.labelBounds["main"];
    if (!bb) {
      return null;
    }
    var lx = preprop(_p2.rscratch, "labelX", prefix);
    var ly = preprop(_p2.rscratch, "labelY", prefix);
    var theta = preprop(_p2.rscratch, "labelAngle", prefix);
    var ox = ele2.pstyle(prefixDash + "text-margin-x").pfValue;
    var oy = ele2.pstyle(prefixDash + "text-margin-y").pfValue;
    var lx1 = bb.x1 - th - ox;
    var lx2 = bb.x2 + th - ox;
    var ly1 = bb.y1 - th - oy;
    var ly2 = bb.y2 + th - oy;
    if (theta) {
      var cos2 = Math.cos(theta);
      var sin2 = Math.sin(theta);
      var rotate2 = /* @__PURE__ */ __name(function rotate3(x3, y3) {
        x3 = x3 - lx;
        y3 = y3 - ly;
        return {
          x: x3 * cos2 - y3 * sin2 + lx,
          y: x3 * sin2 + y3 * cos2 + ly
        };
      }, "rotate3");
      return [rotate2(lx1, ly1), rotate2(lx2, ly1), rotate2(lx2, ly2), rotate2(lx1, ly2)];
    } else {
      return [{
        x: lx1,
        y: ly1
      }, {
        x: lx2,
        y: ly1
      }, {
        x: lx2,
        y: ly2
      }, {
        x: lx1,
        y: ly2
      }];
    }
  }
  __name(getRotatedLabelBox, "getRotatedLabelBox");
  function doLinesIntersect(p1, p2, q1, q2) {
    function ccw(a, b2, c) {
      return (c.y - a.y) * (b2.x - a.x) > (b2.y - a.y) * (c.x - a.x);
    }
    __name(ccw, "ccw");
    return ccw(p1, q1, q2) !== ccw(p2, q1, q2) && ccw(p1, p2, q1) !== ccw(p1, p2, q2);
  }
  __name(doLinesIntersect, "doLinesIntersect");
  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    if (ele.isNode()) {
      var node = ele;
      var textEvents = node.pstyle("text-events").strValue === "yes";
      var nodeBoxSelectMode = node.pstyle("box-selection").strValue;
      var labelBoxSelectEnabled = node.pstyle("box-select-labels").strValue === "yes";
      if (nodeBoxSelectMode === "none") {
        continue;
      }
      var includeLabels = (nodeBoxSelectMode === "overlap" || labelBoxSelectEnabled) && textEvents;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels
      });
      if (nodeBoxSelectMode === "contain") {
        var selected = false;
        if (labelBoxSelectEnabled && textEvents) {
          var rotatedLabelBox = getRotatedLabelBox(node);
          if (rotatedLabelBox && satPolygonIntersection(rotatedLabelBox, selectionBox)) {
            box.push(node);
            selected = true;
          }
        }
        if (!selected && boundingBoxInBoundingBox(boxBb, nodeBb)) {
          box.push(node);
        }
      } else if (nodeBoxSelectMode === "overlap") {
        if (boundingBoxesIntersect(boxBb, nodeBb)) {
          var nodeBodyBb = node.boundingBox({
            includeNodes: true,
            includeEdges: true,
            includeLabels: false,
            includeMainLabels: false,
            includeSourceLabels: false,
            includeTargetLabels: false
          });
          var nodeBodyCorners = [{
            x: nodeBodyBb.x1,
            y: nodeBodyBb.y1
          }, {
            x: nodeBodyBb.x2,
            y: nodeBodyBb.y1
          }, {
            x: nodeBodyBb.x2,
            y: nodeBodyBb.y2
          }, {
            x: nodeBodyBb.x1,
            y: nodeBodyBb.y2
          }];
          if (satPolygonIntersection(nodeBodyCorners, selectionBox)) {
            box.push(node);
          } else {
            var _rotatedLabelBox = getRotatedLabelBox(node);
            if (_rotatedLabelBox && satPolygonIntersection(_rotatedLabelBox, selectionBox)) {
              box.push(node);
            }
          }
        }
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;
      var edgeBoxSelectMode = edge.pstyle("box-selection").strValue;
      if (edgeBoxSelectMode === "none") {
        continue;
      }
      if (edgeBoxSelectMode === "contain") {
        if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
          continue;
        }
        if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
          continue;
        }
        if (rs.edgeType === "bezier" || rs.edgeType === "multibezier" || rs.edgeType === "self" || rs.edgeType === "compound" || rs.edgeType === "segments" || rs.edgeType === "haystack") {
          var pts2 = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
          var allInside = true;
          for (var i = 0; i < pts2.length; i++) {
            if (!pointInBoundingBox(boxBb, pts2[i])) {
              allInside = false;
              break;
            }
          }
          if (allInside) {
            box.push(edge);
          }
        } else if (rs.edgeType === "straight") {
          box.push(edge);
        }
      } else if (edgeBoxSelectMode === "overlap") {
        var _selected = false;
        if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null && (inBoundingBox(boxBb, rs.startX, rs.startY) || inBoundingBox(boxBb, rs.endX, rs.endY))) {
          box.push(edge);
          _selected = true;
        } else if (!_selected && rs.edgeType === "haystack") {
          var haystackPts = _p.rstyle.haystackPts;
          for (var _i = 0; _i < haystackPts.length; _i++) {
            if (pointInBoundingBox(boxBb, haystackPts[_i])) {
              box.push(edge);
              _selected = true;
              break;
            }
          }
        }
        if (!_selected) {
          var _pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
          if ((!_pts || _pts.length < 2) && rs.edgeType === "straight") {
            if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null) {
              _pts = [{
                x: rs.startX,
                y: rs.startY
              }, {
                x: rs.endX,
                y: rs.endY
              }];
            }
          }
          if (!_pts || _pts.length < 2) continue;
          for (var _i2 = 0; _i2 < _pts.length - 1; _i2++) {
            var segStart = _pts[_i2];
            var segEnd = _pts[_i2 + 1];
            for (var b = 0; b < boxEdges.length; b++) {
              var _boxEdges$b = _slicedToArray(boxEdges[b], 2), boxStart = _boxEdges$b[0], boxEnd = _boxEdges$b[1];
              if (doLinesIntersect(segStart, segEnd, boxStart, boxEnd)) {
                box.push(edge);
                _selected = true;
                break;
              }
            }
            if (_selected) break;
          }
        }
      }
    }
  }
  return box;
};
var BRp$d = {};
BRp$d.calculateArrowAngles = function(edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === "haystack";
  var isBezier = rs.edgeType === "bezier";
  var isMultibezier = rs.edgeType === "multibezier";
  var isSegments = rs.edgeType === "segments";
  var isCompound = rs.edgeType === "compound";
  var isSelf = rs.edgeType === "self";
  var dispX, dispY;
  var startX2, startY2, endX, endY, midX, midY;
  if (isHaystack) {
    startX2 = rs.haystackPts[0];
    startY2 = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX2 = rs.arrowStartX;
    startY2 = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }
  midX = rs.midX;
  midY = rs.midY;
  if (isSegments) {
    dispX = startX2 - rs.segpts[0];
    dispY = startY2 - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts2 = rs.allpts;
    var bX = qbezierAt(pts2[0], pts2[2], pts2[4], 0.1);
    var bY = qbezierAt(pts2[1], pts2[3], pts2[5], 0.1);
    dispX = startX2 - bX;
    dispY = startY2 - bY;
  } else {
    dispX = startX2 - midX;
    dispY = startY2 - midY;
  }
  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);
  var midX = rs.midX;
  var midY = rs.midY;
  if (isHaystack) {
    midX = (startX2 + endX) / 2;
    midY = (startY2 + endY) / 2;
  }
  dispX = endX - startX2;
  dispY = endY - startY2;
  if (isSegments) {
    var pts2 = rs.allpts;
    if (pts2.length / 2 % 2 === 0) {
      var i2 = pts2.length / 2;
      var i1 = i2 - 2;
      dispX = pts2[i2] - pts2[i1];
      dispY = pts2[i2 + 1] - pts2[i1 + 1];
    } else if (rs.isRound) {
      dispX = rs.midVector[1];
      dispY = -rs.midVector[0];
    } else {
      var i2 = pts2.length / 2 - 1;
      var i1 = i2 - 2;
      dispX = pts2[i2] - pts2[i1];
      dispY = pts2[i2 + 1] - pts2[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts2 = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;
    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts2.length / 2 - 1;
      var ic = p0 + 2;
      var p1 = ic + 2;
      bp0x = qbezierAt(pts2[p0], pts2[ic], pts2[p1], 0);
      bp0y = qbezierAt(pts2[p0 + 1], pts2[ic + 1], pts2[p1 + 1], 0);
      bp1x = qbezierAt(pts2[p0], pts2[ic], pts2[p1], 1e-4);
      bp1y = qbezierAt(pts2[p0 + 1], pts2[ic + 1], pts2[p1 + 1], 1e-4);
    } else {
      var ic = pts2.length / 2 - 1;
      var p0 = ic - 2;
      var p1 = ic + 2;
      bp0x = qbezierAt(pts2[p0], pts2[ic], pts2[p1], 0.4999);
      bp0y = qbezierAt(pts2[p0 + 1], pts2[ic + 1], pts2[p1 + 1], 0.4999);
      bp1x = qbezierAt(pts2[p0], pts2[ic], pts2[p1], 0.5);
      bp1y = qbezierAt(pts2[p0 + 1], pts2[ic + 1], pts2[p1 + 1], 0.5);
    }
    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }
  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
  rs.midDispX = dispX;
  rs.midDispY = dispY;
  dispX *= -1;
  dispY *= -1;
  if (isSegments) {
    var pts2 = rs.allpts;
    if (pts2.length / 2 % 2 === 0) ;
    else if (!rs.isRound) {
      var i2 = pts2.length / 2 - 1;
      var i3 = i2 + 2;
      dispX = -(pts2[i3] - pts2[i2]);
      dispY = -(pts2[i3 + 1] - pts2[i2 + 1]);
    }
  }
  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);
  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts2 = rs.allpts;
    var l = pts2.length;
    var bX = qbezierAt(pts2[l - 6], pts2[l - 4], pts2[l - 2], 0.9);
    var bY = qbezierAt(pts2[l - 5], pts2[l - 3], pts2[l - 1], 0.9);
    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }
  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
};
BRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale2) {
  var cache3 = this.arrowWidthCache = this.arrowWidthCache || {};
  var cachedVal = cache3[edgeWidth + ", " + scale2];
  if (cachedVal) {
    return cachedVal;
  }
  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale2;
  cache3[edgeWidth + ", " + scale2] = cachedVal;
  return cachedVal;
};
var x, y, v1 = {}, v2 = {}, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut, radius, limit;
var startX, startY, stopX, stopY;
var lastPoint;
var asVec = /* @__PURE__ */ __name(function asVec2(p2, pp, v) {
  v.x = pp.x - p2.x;
  v.y = pp.y - p2.y;
  v.len = Math.sqrt(v.x * v.x + v.y * v.y);
  v.nx = v.x / v.len;
  v.ny = v.y / v.len;
  v.ang = Math.atan2(v.ny, v.nx);
}, "asVec2");
var invertVec = /* @__PURE__ */ __name(function invertVec2(originalV, invertedV) {
  invertedV.x = originalV.x * -1;
  invertedV.y = originalV.y * -1;
  invertedV.nx = originalV.nx * -1;
  invertedV.ny = originalV.ny * -1;
  invertedV.ang = originalV.ang > 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;
}, "invertVec2");
var calcCornerArc = /* @__PURE__ */ __name(function calcCornerArc2(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {
  previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1);
  asVec(currentPoint, nextPoint, v2);
  sinA = v1.nx * v2.ny - v1.ny * v2.nx;
  sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
  angle = Math.asin(Math.max(-1, Math.min(1, sinA)));
  if (Math.abs(angle) < 1e-6) {
    x = currentPoint.x;
    y = currentPoint.y;
    cRadius = radius = 0;
    return;
  }
  radDirection = 1;
  drawDirection = false;
  if (sinA90 < 0) {
    if (angle < 0) {
      angle = Math.PI + angle;
    } else {
      angle = Math.PI - angle;
      radDirection = -1;
      drawDirection = true;
    }
  } else {
    if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
  }
  if (currentPoint.radius !== void 0) {
    radius = currentPoint.radius;
  } else {
    radius = radiusMax;
  }
  halfAngle = angle / 2;
  limit = Math.min(v1.len / 2, v2.len / 2);
  if (isArcRadius) {
    lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    if (lenOut > limit) {
      lenOut = limit;
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }
  } else {
    lenOut = Math.min(limit, radius);
    cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
  }
  stopX = currentPoint.x + v2.nx * lenOut;
  stopY = currentPoint.y + v2.ny * lenOut;
  x = stopX - v2.ny * cRadius * radDirection;
  y = stopY + v2.nx * cRadius * radDirection;
  startX = currentPoint.x + v1.nx * lenOut;
  startY = currentPoint.y + v1.ny * lenOut;
  lastPoint = currentPoint;
}, "calcCornerArc2");
function drawPreparedRoundCorner(ctx, roundCorner) {
  if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);
  else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);
}
__name(drawPreparedRoundCorner, "drawPreparedRoundCorner");
function getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {
  var isArcRadius = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  if (radiusMax === 0 || currentPoint.radius === 0) return {
    cx: currentPoint.x,
    cy: currentPoint.y,
    radius: 0,
    startX: currentPoint.x,
    startY: currentPoint.y,
    stopX: currentPoint.x,
    stopY: currentPoint.y,
    startAngle: void 0,
    endAngle: void 0,
    counterClockwise: void 0
  };
  calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);
  return {
    cx: x,
    cy: y,
    radius: cRadius,
    startX,
    startY,
    stopX,
    stopY,
    startAngle: v1.ang + Math.PI / 2 * radDirection,
    endAngle: v2.ang - Math.PI / 2 * radDirection,
    counterClockwise: drawDirection
  };
}
__name(getRoundCorner, "getRoundCorner");
var AVOID_IMPOSSIBLE_BEZIER_CONSTANT = 0.01;
var AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L = Math.sqrt(2 * AVOID_IMPOSSIBLE_BEZIER_CONSTANT);
var BRp$c = {};
BRp$c.findMidptPtsEtc = function(edge, pairInfo) {
  var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;
  var midptPts;
  var srcManEndpt = edge.pstyle("source-endpoint");
  var tgtManEndpt = edge.pstyle("target-endpoint");
  var haveManualEndPts = srcManEndpt.units != null && tgtManEndpt.units != null;
  var recalcVectorNormInverse = /* @__PURE__ */ __name(function recalcVectorNormInverse2(x12, y12, x22, y22) {
    var dy = y22 - y12;
    var dx = x22 - x12;
    var l = Math.sqrt(dx * dx + dy * dy);
    return {
      x: -dy / l,
      y: dx / l
    };
  }, "recalcVectorNormInverse2");
  var edgeDistances = edge.pstyle("edge-distances").value;
  switch (edgeDistances) {
    case "node-position":
      midptPts = posPts;
      break;
    case "intersection":
      midptPts = intersectionPts;
      break;
    case "endpoints": {
      if (haveManualEndPts) {
        var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt), _this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2), x1 = _this$manualEndptToPx2[0], y1 = _this$manualEndptToPx2[1];
        var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt), _this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2), x2 = _this$manualEndptToPx4[0], y2 = _this$manualEndptToPx4[1];
        var endPts = {
          x1,
          y1,
          x2,
          y2
        };
        vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);
        midptPts = endPts;
      } else {
        warn("Edge ".concat(edge.id(), " has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default)."));
        midptPts = intersectionPts;
      }
      break;
    }
  }
  return {
    midptPts,
    vectorNormInverse
  };
};
BRp$c.findHaystackPoints = function(edges3) {
  for (var i = 0; i < edges3.length; i++) {
    var edge = edges3[i];
    var _p = edge._private;
    var rs = _p.rscratch;
    if (!rs.haystack) {
      var angle2 = Math.random() * 2 * Math.PI;
      rs.source = {
        x: Math.cos(angle2),
        y: Math.sin(angle2)
      };
      angle2 = Math.random() * 2 * Math.PI;
      rs.target = {
        x: Math.cos(angle2),
        y: Math.sin(angle2)
      };
    }
    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius2 = edge.pstyle("haystack-radius").value;
    var halfRadius = radius2 / 2;
    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;
    rs.edgeType = "haystack";
    rs.haystack = true;
    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};
BRp$c.findSegmentsPoints = function(edge, pairInfo) {
  var rs = edge._private.rscratch;
  var segmentWs = edge.pstyle("segment-weights");
  var segmentDs = edge.pstyle("segment-distances");
  var segmentRs = edge.pstyle("segment-radii");
  var segmentTs = edge.pstyle("radius-type");
  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
  var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];
  var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];
  rs.edgeType = "segments";
  rs.segpts = [];
  rs.radii = [];
  rs.isArcRadius = [];
  for (var s = 0; s < segmentsN; s++) {
    var w = segmentWs.pfValue[s];
    var d = segmentDs.pfValue[s];
    var w1 = 1 - w;
    var w2 = w;
    var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc.midptPts, vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
    rs.radii.push(segmentRs.pfValue[s] !== void 0 ? segmentRs.pfValue[s] : lastRadius);
    rs.isArcRadius.push((segmentTs.pfValue[s] !== void 0 ? segmentTs.pfValue[s] : lastRadiusType) === "arc-radius");
  }
};
BRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {
  var rs = edge._private.rscratch;
  var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;
  var ctrlptDists = edge.pstyle("control-point-distances");
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : void 0;
  var loopDir = edge.pstyle("loop-direction").pfValue;
  var loopSwp = edge.pstyle("loop-sweep").pfValue;
  var stepSize = edge.pstyle("control-point-step-size").pfValue;
  rs.edgeType = "self";
  var j = i;
  var loopDist = stepSize;
  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }
  var loopAngle = loopDir - Math.PI / 2;
  var outAngle = loopAngle - loopSwp / 2;
  var inAngle = loopAngle + loopSwp / 2;
  var dc = String(loopDir + "_" + loopSwp);
  j = dirCounts[dc] === void 0 ? dirCounts[dc] = 0 : ++dirCounts[dc];
  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
};
BRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {
  var rs = edge._private.rscratch;
  rs.edgeType = "compound";
  var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;
  var stepSize = edge.pstyle("control-point-step-size").pfValue;
  var ctrlptDists = edge.pstyle("control-point-distances");
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : void 0;
  var j = i;
  var loopDist = stepSize;
  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }
  var loopW = 50;
  var loopaPos = {
    x: srcPos.x - srcW / 2,
    y: srcPos.y - srcH / 2
  };
  var loopbPos = {
    x: tgtPos.x - tgtW / 2,
    y: tgtPos.y - tgtH / 2
  };
  var loopPos = {
    x: Math.min(loopaPos.x, loopbPos.x),
    y: Math.min(loopaPos.y, loopbPos.y)
  };
  var minCompoundStretch = 0.5;
  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));
  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));
  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
};
BRp$c.findStraightEdgePoints = function(edge) {
  edge._private.rscratch.edgeType = "straight";
};
BRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
  var rs = edge._private.rscratch;
  var stepSize = edge.pstyle("control-point-step-size").pfValue;
  var ctrlptDists = edge.pstyle("control-point-distances");
  var ctrlptWs = edge.pstyle("control-point-weights");
  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : void 0;
  var ctrlptWeight = ctrlptWs.value[0];
  var multi = edgeIsUnbundled;
  rs.edgeType = multi ? "multibezier" : "bezier";
  rs.ctrlpts = [];
  for (var b = 0; b < bezierN; b++) {
    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
    var manctrlptDist = void 0;
    var sign = signum(normctrlptDist);
    if (multi) {
      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize;
      ctrlptWeight = ctrlptWs.value[b];
    }
    if (edgeIsUnbundled) {
      manctrlptDist = ctrlptDist;
    } else {
      manctrlptDist = ctrlptDist !== void 0 ? sign * ctrlptDist : void 0;
    }
    var distanceFromMidpoint = manctrlptDist !== void 0 ? manctrlptDist : normctrlptDist;
    var w1 = 1 - ctrlptWeight;
    var w2 = ctrlptWeight;
    var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc2.midptPts, vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
  }
};
BRp$c.findTaxiPoints = function(edge, pairInfo) {
  var rs = edge._private.rscratch;
  rs.edgeType = "segments";
  var VERTICAL = "vertical";
  var HORIZONTAL = "horizontal";
  var LEFTWARD = "leftward";
  var RIGHTWARD = "rightward";
  var DOWNWARD = "downward";
  var UPWARD = "upward";
  var AUTO = "auto";
  var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;
  var edgeDistances = edge.pstyle("edge-distances").value;
  var dIncludesNodeBody = edgeDistances !== "node-position";
  var taxiDir = edge.pstyle("taxi-direction").value;
  var rawTaxiDir = taxiDir;
  var taxiTurn = edge.pstyle("taxi-turn");
  var turnIsPercent = taxiTurn.units === "%";
  var taxiTurnPfVal = taxiTurn.pfValue;
  var turnIsNegative = taxiTurnPfVal < 0;
  var minD = edge.pstyle("taxi-turn-min-distance").pfValue;
  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
  var pdx = posPts.x2 - posPts.x1;
  var pdy = posPts.y2 - posPts.y1;
  var subDWH = /* @__PURE__ */ __name(function subDWH2(dxy, dwh) {
    if (dxy > 0) {
      return Math.max(dxy - dwh, 0);
    } else {
      return Math.min(dxy + dwh, 0);
    }
  }, "subDWH2");
  var dx = subDWH(pdx, dw);
  var dy = subDWH(pdy, dh);
  var isExplicitDir = false;
  if (rawTaxiDir === AUTO) {
    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
  } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {
    taxiDir = VERTICAL;
    isExplicitDir = true;
  } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {
    taxiDir = HORIZONTAL;
    isExplicitDir = true;
  }
  var isVert = taxiDir === VERTICAL;
  var l = isVert ? dy : dx;
  var pl = isVert ? pdy : pdx;
  var sgnL = signum(pl);
  var forcedDir = false;
  if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
    sgnL *= -1;
    l = sgnL * Math.abs(l);
    forcedDir = true;
  }
  var d;
  if (turnIsPercent) {
    var p2 = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;
    d = p2 * l;
  } else {
    var k = taxiTurnPfVal < 0 ? l : 0;
    d = k + taxiTurnPfVal * sgnL;
  }
  var getIsTooClose = /* @__PURE__ */ __name(function getIsTooClose2(d2) {
    return Math.abs(d2) < minD || Math.abs(d2) >= Math.abs(l);
  }, "getIsTooClose2");
  var isTooCloseSrc = getIsTooClose(d);
  var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));
  var isTooClose = isTooCloseSrc || isTooCloseTgt;
  if (isTooClose && !forcedDir) {
    if (isVert) {
      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;
      if (lShapeInsideSrc) {
        var x2 = (posPts.x1 + posPts.x2) / 2;
        var y1 = posPts.y1, y2 = posPts.y2;
        rs.segpts = [x2, y1, x2, y2];
      } else if (lShapeInsideTgt) {
        var y3 = (posPts.y1 + posPts.y2) / 2;
        var x1 = posPts.x1, x22 = posPts.x2;
        rs.segpts = [x1, y3, x22, y3];
      } else {
        rs.segpts = [posPts.x1, posPts.y2];
      }
    } else {
      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;
      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;
      if (_lShapeInsideSrc) {
        var _y = (posPts.y1 + posPts.y2) / 2;
        var _x = posPts.x1, _x2 = posPts.x2;
        rs.segpts = [_x, _y, _x2, _y];
      } else if (_lShapeInsideTgt) {
        var _x3 = (posPts.x1 + posPts.x2) / 2;
        var _y2 = posPts.y1, _y3 = posPts.y2;
        rs.segpts = [_x3, _y2, _x3, _y3];
      } else {
        rs.segpts = [posPts.x2, posPts.y1];
      }
    }
  } else {
    if (isVert) {
      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);
      var _x4 = posPts.x1, _x5 = posPts.x2;
      rs.segpts = [_x4, _y4, _x5, _y4];
    } else {
      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);
      var _y5 = posPts.y1, _y6 = posPts.y2;
      rs.segpts = [_x6, _y5, _x6, _y6];
    }
  }
  if (rs.isRound) {
    var radius2 = edge.pstyle("taxi-radius").value;
    var isArcRadius = edge.pstyle("radius-type").value[0] === "arc-radius";
    rs.radii = new Array(rs.segpts.length / 2).fill(radius2);
    rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);
  }
};
BRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {
  var rs = edge._private.rscratch;
  if (rs.edgeType === "bezier") {
    var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape, srcCornerRadius = pairInfo.srcCornerRadius, tgtCornerRadius = pairInfo.tgtCornerRadius, srcRs = pairInfo.srcRs, tgtRs = pairInfo.tgtRs;
    var badStart = !number$1(rs.startX) || !number$1(rs.startY);
    var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);
    var badEnd = !number$1(rs.endX) || !number$1(rs.endY);
    var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);
    var minCpADistFactor = 3;
    var arrowW = this.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.arrowShapeWidth;
    var minCpADist = minCpADistFactor * arrowW;
    var startACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.startX,
      y: rs.startY
    });
    var closeStartACp = startACpDist < minCpADist;
    var endACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.endX,
      y: rs.endY
    });
    var closeEndACp = endACpDist < minCpADist;
    var overlapping = false;
    if (badStart || badAStart || closeStartACp) {
      overlapping = true;
      var cpD = {
        // delta
        x: rs.ctrlpts[0] - srcPos.x,
        y: rs.ctrlpts[1] - srcPos.y
      };
      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y);
      var cpM = {
        // normalised delta
        x: cpD.x / cpL,
        y: cpD.y / cpL
      };
      var radius2 = Math.max(srcW, srcH);
      var cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + cpM.x * 2 * radius2,
        y: rs.ctrlpts[1] + cpM.y * 2 * radius2
      };
      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);
      if (closeStartACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
      } else {
        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
      }
    }
    if (badEnd || badAEnd || closeEndACp) {
      overlapping = true;
      var _cpD = {
        // delta
        x: rs.ctrlpts[0] - tgtPos.x,
        y: rs.ctrlpts[1] - tgtPos.y
      };
      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y);
      var _cpM = {
        // normalised delta
        x: _cpD.x / _cpL,
        y: _cpD.y / _cpL
      };
      var _radius = Math.max(srcW, srcH);
      var _cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
      };
      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);
      if (closeEndACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
      } else {
        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
      }
    }
    if (overlapping) {
      this.findEndpoints(edge);
    }
  }
};
BRp$c.storeAllpts = function(edge) {
  var rs = edge._private.rscratch;
  if (rs.edgeType === "multibezier" || rs.edgeType === "bezier" || rs.edgeType === "self" || rs.edgeType === "compound") {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);
    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);
      if (b + 3 < rs.ctrlpts.length) {
        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
      }
    }
    rs.allpts.push(rs.endX, rs.endY);
    var m, mt;
    if (rs.ctrlpts.length / 2 % 2 === 0) {
      m = rs.allpts.length / 2 - 1;
      rs.midX = rs.allpts[m];
      rs.midY = rs.allpts[m + 1];
    } else {
      m = rs.allpts.length / 2 - 3;
      mt = 0.5;
      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
    }
  } else if (rs.edgeType === "straight") {
    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];
    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
  } else if (rs.edgeType === "segments") {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);
    rs.allpts.push.apply(rs.allpts, rs.segpts);
    rs.allpts.push(rs.endX, rs.endY);
    if (rs.isRound) {
      rs.roundCorners = [];
      for (var i = 2; i + 3 < rs.allpts.length; i += 2) {
        var radius2 = rs.radii[i / 2 - 1];
        var isArcRadius = rs.isArcRadius[i / 2 - 1];
        rs.roundCorners.push(getRoundCorner({
          x: rs.allpts[i - 2],
          y: rs.allpts[i - 1]
        }, {
          x: rs.allpts[i],
          y: rs.allpts[i + 1],
          radius: radius2
        }, {
          x: rs.allpts[i + 2],
          y: rs.allpts[i + 3]
        }, radius2, isArcRadius));
      }
    }
    if (rs.segpts.length % 4 === 0) {
      var i2 = rs.segpts.length / 2;
      var i1 = i2 - 2;
      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
    } else {
      var _i = rs.segpts.length / 2 - 1;
      if (!rs.isRound) {
        rs.midX = rs.segpts[_i];
        rs.midY = rs.segpts[_i + 1];
      } else {
        var point = {
          x: rs.segpts[_i],
          y: rs.segpts[_i + 1]
        };
        var corner = rs.roundCorners[_i / 2];
        if (corner.radius === 0) {
          var nextPoint = {
            x: rs.segpts[_i + 2],
            y: rs.segpts[_i + 3]
          };
          rs.midX = point.x;
          rs.midY = point.y;
          rs.midVector = [point.y - nextPoint.y, nextPoint.x - point.x];
        } else {
          var v = [point.x - corner.cx, point.y - corner.cy];
          var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
          v = v.map(function(c) {
            return c * factor;
          });
          rs.midX = corner.cx + v[0];
          rs.midY = corner.cy + v[1];
          rs.midVector = v;
        }
      }
    }
  }
};
BRp$c.checkForInvalidEdgeWarning = function(edge) {
  var rs = edge[0]._private.rscratch;
  if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {
    rs.loggedErr = false;
  } else {
    if (!rs.loggedErr) {
      rs.loggedErr = true;
      warn("Edge `" + edge.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.");
    }
  }
};
BRp$c.findEdgeControlPoints = function(edges3) {
  var _this = this;
  if (!edges3 || edges3.length === 0) {
    return;
  }
  var r2 = this;
  var cy = r2.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = new Map$1();
  var getKey3 = /* @__PURE__ */ __name(function getKey4(pairId2, edgeIsUnbundled2) {
    return [].concat(_toConsumableArray(pairId2), [edgeIsUnbundled2 ? 1 : 0]).join("-");
  }, "getKey4");
  var pairIds = [];
  var haystackEdges = [];
  for (var i = 0; i < edges3.length; i++) {
    var edge = edges3[i];
    var _p = edge._private;
    var curveStyle = edge.pstyle("curve-style").value;
    if (edge.removed() || !edge.takesUpSpace()) {
      continue;
    }
    if (curveStyle === "haystack") {
      haystackEdges.push(edge);
      continue;
    }
    var edgeIsUnbundled = curveStyle === "unbundled-bezier" || endsWith(curveStyle, "segments") || curveStyle === "straight" || curveStyle === "straight-triangle" || endsWith(curveStyle, "taxi");
    var edgeIsBezier = curveStyle === "unbundled-bezier" || curveStyle === "bezier";
    var src = _p.source;
    var tgt = _p.target;
    var srcIndex = src.poolIndex();
    var tgtIndex = tgt.poolIndex();
    var pairId = [srcIndex, tgtIndex].sort();
    var key2 = getKey3(pairId, edgeIsUnbundled);
    var tableEntry = hashTable.get(key2);
    if (tableEntry == null) {
      tableEntry = {
        eles: []
      };
      pairIds.push({
        pairId,
        edgeIsUnbundled
      });
      hashTable.set(key2, tableEntry);
    }
    tableEntry.eles.push(edge);
    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }
    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  }
  var _loop = /* @__PURE__ */ __name(function _loop2() {
    var _pairIds$p = pairIds[p2], pairId2 = _pairIds$p.pairId, edgeIsUnbundled2 = _pairIds$p.edgeIsUnbundled;
    var key22 = getKey3(pairId2, edgeIsUnbundled2);
    var pairInfo = hashTable.get(key22);
    var swappedpairInfo;
    if (!pairInfo.hasUnbundled) {
      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {
        return e.isBundledBezier();
      });
      clearArray(pairInfo.eles);
      pllEdges.forEach(function(edge2) {
        return pairInfo.eles.push(edge2);
      });
      pairInfo.eles.sort(function(edge1, edge2) {
        return edge1.poolIndex() - edge2.poolIndex();
      });
    }
    var firstEdge = pairInfo.eles[0];
    var src2 = firstEdge.source();
    var tgt2 = firstEdge.target();
    if (src2.poolIndex() > tgt2.poolIndex()) {
      var temp = src2;
      src2 = tgt2;
      tgt2 = temp;
    }
    var srcPos = pairInfo.srcPos = src2.position();
    var tgtPos = pairInfo.tgtPos = tgt2.position();
    var srcW = pairInfo.srcW = src2.outerWidth();
    var srcH = pairInfo.srcH = src2.outerHeight();
    var tgtW = pairInfo.tgtW = tgt2.outerWidth();
    var tgtH = pairInfo.tgtH = tgt2.outerHeight();
    var srcShape = pairInfo.srcShape = r2.nodeShapes[_this.getNodeShape(src2)];
    var tgtShape = pairInfo.tgtShape = r2.nodeShapes[_this.getNodeShape(tgt2)];
    var srcCornerRadius = pairInfo.srcCornerRadius = src2.pstyle("corner-radius").value === "auto" ? "auto" : src2.pstyle("corner-radius").pfValue;
    var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt2.pstyle("corner-radius").value === "auto" ? "auto" : tgt2.pstyle("corner-radius").pfValue;
    var tgtRs = pairInfo.tgtRs = tgt2._private.rscratch;
    var srcRs = pairInfo.srcRs = src2._private.rscratch;
    pairInfo.dirCounts = {
      "north": 0,
      "west": 0,
      "south": 0,
      "east": 0,
      "northwest": 0,
      "southwest": 0,
      "northeast": 0,
      "southeast": 0
    };
    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
      var _edge = pairInfo.eles[_i2];
      var rs = _edge[0]._private.rscratch;
      var _curveStyle = _edge.pstyle("curve-style").value;
      var _edgeIsUnbundled = _curveStyle === "unbundled-bezier" || endsWith(_curveStyle, "segments") || endsWith(_curveStyle, "taxi");
      var edgeIsSwapped = !src2.same(_edge.source());
      if (!pairInfo.calculatedIntersection && src2 !== tgt2 && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
        pairInfo.calculatedIntersection = true;
        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);
        var srcIntn = pairInfo.srcIntn = srcOutside;
        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);
        var tgtIntn = pairInfo.tgtIntn = tgtOutside;
        var intersectionPts = pairInfo.intersectionPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };
        var posPts = pairInfo.posPts = {
          x1: srcPos.x,
          x2: tgtPos.x,
          y1: srcPos.y,
          y2: tgtPos.y
        };
        var dy = tgtOutside[1] - srcOutside[1];
        var dx = tgtOutside[0] - srcOutside[0];
        var l = Math.sqrt(dx * dx + dy * dy);
        if (number$1(l) && l >= AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L) ;
        else {
          l = Math.sqrt(Math.max(dx * dx, AVOID_IMPOSSIBLE_BEZIER_CONSTANT) + Math.max(dy * dy, AVOID_IMPOSSIBLE_BEZIER_CONSTANT));
        }
        var vector = pairInfo.vector = {
          x: dx,
          y: dy
        };
        var vectorNorm = pairInfo.vectorNorm = {
          x: vector.x / l,
          y: vector.y / l
        };
        var vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };
        pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);
        pairInfo.vectorNormInverse = vectorNormInverse;
        swappedpairInfo = {
          nodesOverlap: pairInfo.nodesOverlap,
          dirCounts: pairInfo.dirCounts,
          calculatedIntersection: true,
          hasBezier: pairInfo.hasBezier,
          hasUnbundled: pairInfo.hasUnbundled,
          eles: pairInfo.eles,
          srcPos: tgtPos,
          srcRs: tgtRs,
          tgtPos: srcPos,
          tgtRs: srcRs,
          srcW: tgtW,
          srcH: tgtH,
          tgtW: srcW,
          tgtH: srcH,
          srcIntn: tgtIntn,
          tgtIntn: srcIntn,
          srcShape: tgtShape,
          tgtShape: srcShape,
          posPts: {
            x1: posPts.x2,
            y1: posPts.y2,
            x2: posPts.x1,
            y2: posPts.y1
          },
          intersectionPts: {
            x1: intersectionPts.x2,
            y1: intersectionPts.y2,
            x2: intersectionPts.x1,
            y2: intersectionPts.y1
          },
          vector: {
            x: -vector.x,
            y: -vector.y
          },
          vectorNorm: {
            x: -vectorNorm.x,
            y: -vectorNorm.y
          },
          vectorNormInverse: {
            x: -vectorNormInverse.x,
            y: -vectorNormInverse.y
          }
        };
      }
      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
      rs.nodesOverlap = passedPairInfo.nodesOverlap;
      rs.srcIntn = passedPairInfo.srcIntn;
      rs.tgtIntn = passedPairInfo.tgtIntn;
      rs.isRound = _curveStyle.startsWith("round");
      if (hasCompounds && (src2.isParent() || src2.isChild() || tgt2.isParent() || tgt2.isChild()) && (src2.parents().anySame(tgt2) || tgt2.parents().anySame(src2) || src2.same(tgt2) && src2.isParent())) {
        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (src2 === tgt2) {
        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (_curveStyle.endsWith("segments")) {
        _this.findSegmentsPoints(_edge, passedPairInfo);
      } else if (_curveStyle.endsWith("taxi")) {
        _this.findTaxiPoints(_edge, passedPairInfo);
      } else if (_curveStyle === "straight" || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
        _this.findStraightEdgePoints(_edge);
      } else {
        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
      }
      _this.findEndpoints(_edge);
      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);
      _this.checkForInvalidEdgeWarning(_edge);
      _this.storeAllpts(_edge);
      _this.storeEdgeProjections(_edge);
      _this.calculateArrowAngles(_edge);
      _this.recalculateEdgeLabelProjections(_edge);
      _this.calculateLabelAngles(_edge);
    }
  }, "_loop2");
  for (var p2 = 0; p2 < pairIds.length; p2++) {
    _loop();
  }
  this.findHaystackPoints(haystackEdges);
};
function getPts(pts2) {
  var retPts = [];
  if (pts2 == null) {
    return;
  }
  for (var i = 0; i < pts2.length; i += 2) {
    var x2 = pts2[i];
    var y2 = pts2[i + 1];
    retPts.push({
      x: x2,
      y: y2
    });
  }
  return retPts;
}
__name(getPts, "getPts");
BRp$c.getSegmentPoints = function(edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  var type = rs.edgeType;
  if (type === "segments") {
    return getPts(rs.segpts);
  }
};
BRp$c.getControlPoints = function(edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  var type = rs.edgeType;
  if (type === "bezier" || type === "multibezier" || type === "self" || type === "compound") {
    return getPts(rs.ctrlpts);
  }
};
BRp$c.getEdgeMidpoint = function(edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  return {
    x: rs.midX,
    y: rs.midY
  };
};
var BRp$b = {};
BRp$b.manualEndptToPx = function(node, prop2) {
  var r2 = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();
  var rs = node._private.rscratch;
  if (prop2.value.length === 2) {
    var p2 = [prop2.pfValue[0], prop2.pfValue[1]];
    if (prop2.units[0] === "%") {
      p2[0] = p2[0] * w;
    }
    if (prop2.units[1] === "%") {
      p2[1] = p2[1] * h;
    }
    p2[0] += npos.x;
    p2[1] += npos.y;
    return p2;
  } else {
    var angle2 = prop2.pfValue[0];
    angle2 = -Math.PI / 2 + angle2;
    var l = 2 * Math.max(w, h);
    var _p = [npos.x + Math.cos(angle2) * l, npos.y + Math.sin(angle2) * l];
    return r2.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle("corner-radius").value === "auto" ? "auto" : node.pstyle("corner-radius").pfValue, rs);
  }
};
BRp$b.findEndpoints = function(edge) {
  var _ref, _tgtManEndpt$pfValue, _ref2, _srcManEndpt$pfValue;
  var r2 = this;
  var intersect22;
  var source2 = edge.source()[0];
  var target = edge.target()[0];
  var srcPos = source2.position();
  var tgtPos = target.position();
  var tgtArShape = edge.pstyle("target-arrow-shape").value;
  var srcArShape = edge.pstyle("source-arrow-shape").value;
  var tgtDist = edge.pstyle("target-distance-from-node").pfValue;
  var srcDist = edge.pstyle("source-distance-from-node").pfValue;
  var srcRs = source2._private.rscratch;
  var tgtRs = target._private.rscratch;
  var curveStyle = edge.pstyle("curve-style").value;
  var rs = edge._private.rscratch;
  var et = rs.edgeType;
  var taxi = endsWith(curveStyle, "taxi");
  var self2 = et === "self" || et === "compound";
  var bezier = et === "bezier" || et === "multibezier" || self2;
  var multi = et !== "bezier";
  var lines = et === "straight" || et === "segments";
  var segments = et === "segments";
  var hasEndpts = bezier || multi || lines;
  var overrideEndpts = self2 || taxi;
  var srcManEndpt = edge.pstyle("source-endpoint");
  var srcManEndptVal = overrideEndpts ? "outside-to-node" : srcManEndpt.value;
  var srcCornerRadius = source2.pstyle("corner-radius").value === "auto" ? "auto" : source2.pstyle("corner-radius").pfValue;
  var tgtManEndpt = edge.pstyle("target-endpoint");
  var tgtManEndptVal = overrideEndpts ? "outside-to-node" : tgtManEndpt.value;
  var tgtCornerRadius = target.pstyle("corner-radius").value === "auto" ? "auto" : target.pstyle("corner-radius").pfValue;
  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;
  var p1;
  var p2;
  var p1_i;
  var p2_i;
  var tgtManEndptPt = (_ref = (tgtManEndpt === null || tgtManEndpt === void 0 || (_tgtManEndpt$pfValue = tgtManEndpt.pfValue) === null || _tgtManEndpt$pfValue === void 0 ? void 0 : _tgtManEndpt$pfValue.length) === 2 ? tgtManEndpt.pfValue : null) !== null && _ref !== void 0 ? _ref : [0, 0];
  var srcManEndptPt = (_ref2 = (srcManEndpt === null || srcManEndpt === void 0 || (_srcManEndpt$pfValue = srcManEndpt.pfValue) === null || _srcManEndpt$pfValue === void 0 ? void 0 : _srcManEndpt$pfValue.length) === 2 ? srcManEndpt.pfValue : null) !== null && _ref2 !== void 0 ? _ref2 : [0, 0];
  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x + tgtManEndptPt[0], tgtPos.y + tgtManEndptPt[1]] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x + srcManEndptPt[0], srcPos.y + srcManEndptPt[1]] : rs.segpts.slice(rs.segpts.length - 2);
    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }
  if (tgtManEndptVal === "inside-to-node") {
    intersect22 = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect22 = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === "outside-to-line") {
    intersect22 = rs.tgtIntn;
  } else {
    if (tgtManEndptVal === "outside-to-node" || tgtManEndptVal === "outside-to-node-or-label") {
      p1_i = p1;
    } else if (tgtManEndptVal === "outside-to-line" || tgtManEndptVal === "outside-to-line-or-label") {
      p1_i = [srcPos.x, srcPos.y];
    }
    intersect22 = r2.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);
    if (tgtManEndptVal === "outside-to-node-or-label" || tgtManEndptVal === "outside-to-line-or-label") {
      var trs = target._private.rscratch;
      var lw = trs.labelWidth;
      var lh = trs.labelHeight;
      var lx = trs.labelX;
      var ly = trs.labelY;
      var lw2 = lw / 2;
      var lh2 = lh / 2;
      var va = target.pstyle("text-valign").value;
      if (va === "top") {
        ly -= lh2;
      } else if (va === "bottom") {
        ly += lh2;
      }
      var ha = target.pstyle("text-halign").value;
      if (ha === "left") {
        lx -= lw2;
      } else if (ha === "right") {
        lx += lw2;
      }
      var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);
      if (labelIntersect.length > 0) {
        var refPt = srcPos;
        var intSqdist = sqdist(refPt, array2point(intersect22));
        var labIntSqdist = sqdist(refPt, array2point(labelIntersect));
        var minSqDist = intSqdist;
        if (labIntSqdist < intSqdist) {
          intersect22 = labelIntersect;
          minSqDist = labIntSqdist;
        }
        if (labelIntersect.length > 2) {
          var labInt2SqDist = sqdist(refPt, {
            x: labelIntersect[2],
            y: labelIntersect[3]
          });
          if (labInt2SqDist < minSqDist) {
            intersect22 = [labelIntersect[2], labelIntersect[3]];
          }
        }
      }
    }
  }
  var arrowEnd = shortenIntersection(intersect22, p1, r2.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = shortenIntersection(intersect22, p1, r2.arrowShapes[tgtArShape].gap(edge) + tgtDist);
  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];
  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];
  if (srcManEndptVal === "inside-to-node") {
    intersect22 = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect22 = this.manualEndptToPx(source2, srcManEndpt);
  } else if (srcManEndptVal === "outside-to-line") {
    intersect22 = rs.srcIntn;
  } else {
    if (srcManEndptVal === "outside-to-node" || srcManEndptVal === "outside-to-node-or-label") {
      p2_i = p2;
    } else if (srcManEndptVal === "outside-to-line" || srcManEndptVal === "outside-to-line-or-label") {
      p2_i = [tgtPos.x, tgtPos.y];
    }
    intersect22 = r2.nodeShapes[this.getNodeShape(source2)].intersectLine(srcPos.x, srcPos.y, source2.outerWidth(), source2.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);
    if (srcManEndptVal === "outside-to-node-or-label" || srcManEndptVal === "outside-to-line-or-label") {
      var srs = source2._private.rscratch;
      var _lw = srs.labelWidth;
      var _lh = srs.labelHeight;
      var _lx = srs.labelX;
      var _ly = srs.labelY;
      var _lw2 = _lw / 2;
      var _lh2 = _lh / 2;
      var _va = source2.pstyle("text-valign").value;
      if (_va === "top") {
        _ly -= _lh2;
      } else if (_va === "bottom") {
        _ly += _lh2;
      }
      var _ha = source2.pstyle("text-halign").value;
      if (_ha === "left") {
        _lx -= _lw2;
      } else if (_ha === "right") {
        _lx += _lw2;
      }
      var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);
      if (_labelIntersect.length > 0) {
        var _refPt = tgtPos;
        var _intSqdist = sqdist(_refPt, array2point(intersect22));
        var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));
        var _minSqDist = _intSqdist;
        if (_labIntSqdist < _intSqdist) {
          intersect22 = [_labelIntersect[0], _labelIntersect[1]];
          _minSqDist = _labIntSqdist;
        }
        if (_labelIntersect.length > 2) {
          var _labInt2SqDist = sqdist(_refPt, {
            x: _labelIntersect[2],
            y: _labelIntersect[3]
          });
          if (_labInt2SqDist < _minSqDist) {
            intersect22 = [_labelIntersect[2], _labelIntersect[3]];
          }
        }
      }
    }
  }
  var arrowStart = shortenIntersection(intersect22, p2, r2.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = shortenIntersection(intersect22, p2, r2.arrowShapes[srcArShape].gap(edge) + srcDist);
  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];
  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];
  if (hasEndpts) {
    if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};
BRp$b.getSourceEndpoint = function(edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  switch (rs.edgeType) {
    case "haystack":
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };
    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};
BRp$b.getTargetEndpoint = function(edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  switch (rs.edgeType) {
    case "haystack":
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };
    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};
var BRp$a = {};
function pushBezierPts(r2, edge, pts2) {
  var qbezierAt$1 = /* @__PURE__ */ __name(function qbezierAt$12(p1, p22, p3, t) {
    return qbezierAt(p1, p22, p3, t);
  }, "qbezierAt$12");
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;
  for (var i = 0; i < r2.bezierProjPcts.length; i++) {
    var p2 = r2.bezierProjPcts[i];
    bpts.push({
      x: qbezierAt$1(pts2[0], pts2[2], pts2[4], p2),
      y: qbezierAt$1(pts2[1], pts2[3], pts2[5], p2)
    });
  }
}
__name(pushBezierPts, "pushBezierPts");
BRp$a.storeEdgeProjections = function(edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;
  if (et === "multibezier" || et === "bezier" || et === "self" || et === "compound") {
    _p.rstyle.bezierPts = [];
    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === "segments") {
    var lpts = _p.rstyle.linePts = [];
    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === "haystack") {
    var hpts = rs.haystackPts;
    _p.rstyle.haystackPts = [{
      x: hpts[0],
      y: hpts[1]
    }, {
      x: hpts[2],
      y: hpts[3]
    }];
  }
  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.arrowShapeWidth;
};
BRp$a.recalculateEdgeProjections = function(edges3) {
  this.findEdgeControlPoints(edges3);
};
var BRp$9 = {};
BRp$9.recalculateNodeLabelProjection = function(node) {
  var content = node.pstyle("label").strValue;
  if (emptyString(content)) {
    return;
  }
  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle("text-halign").strValue;
  var textValign = node.pstyle("text-valign").strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;
  switch (textHalign) {
    case "left":
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;
    case "right":
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;
    default:
      textX = nodePos.x;
  }
  switch (textValign) {
    case "top":
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;
    case "bottom":
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;
    default:
      textY = nodePos.y;
  }
  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;
  this.calculateLabelAngles(node);
  this.applyLabelDimensions(node);
};
var lineAngleFromDelta = /* @__PURE__ */ __name(function lineAngleFromDelta2(dx, dy) {
  var angle2 = Math.atan(dy / dx);
  if (dx === 0 && angle2 < 0) {
    angle2 = angle2 * -1;
  }
  return angle2;
}, "lineAngleFromDelta2");
var lineAngle = /* @__PURE__ */ __name(function lineAngle2(p0, p1) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  return lineAngleFromDelta(dx, dy);
}, "lineAngle2");
var bezierAngle = /* @__PURE__ */ __name(function bezierAngle2(p0, p1, p2, t) {
  var t0 = bound(0, t - 1e-3, 1);
  var t1 = bound(0, t + 1e-3, 1);
  var lp0 = qbezierPtAt(p0, p1, p2, t0);
  var lp1 = qbezierPtAt(p0, p1, p2, t1);
  return lineAngle(lp0, lp1);
}, "bezierAngle2");
BRp$9.recalculateEdgeLabelProjections = function(edge) {
  var p2;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r2 = this;
  var content = {
    mid: edge.pstyle("label").strValue,
    source: edge.pstyle("source-label").strValue,
    target: edge.pstyle("target-label").strValue
  };
  if (content.mid || content.source || content.target) ;
  else {
    return;
  }
  p2 = {
    x: rs.midX,
    y: rs.midY
  };
  var setRs = /* @__PURE__ */ __name(function setRs2(propName, prefix, value2) {
    setPrefixedProperty(_p.rscratch, propName, prefix, value2);
    setPrefixedProperty(_p.rstyle, propName, prefix, value2);
  }, "setRs2");
  setRs("labelX", null, p2.x);
  setRs("labelY", null, p2.y);
  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
  setRs("labelAutoAngle", null, midAngle);
  var _createControlPointInfo = /* @__PURE__ */ __name(function createControlPointInfo() {
    if (_createControlPointInfo.cache) {
      return _createControlPointInfo.cache;
    }
    var ctrlpts = [];
    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = {
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      };
      var p1 = {
        x: rs.allpts[i + 2],
        y: rs.allpts[i + 3]
      };
      var p22 = {
        x: rs.allpts[i + 4],
        y: rs.allpts[i + 5]
      };
      ctrlpts.push({
        p0,
        p1,
        p2: p22,
        startDist: 0,
        length: 0,
        segments: []
      });
    }
    var bpts = _p.rstyle.bezierPts;
    var nProjs = r2.bezierProjPcts.length;
    function addSegment(cp2, p02, p12, t0, t1) {
      var length2 = dist(p02, p12);
      var prevSegment = cp2.segments[cp2.segments.length - 1];
      var segment = {
        p0: p02,
        p1: p12,
        t0,
        t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length2
      };
      cp2.segments.push(segment);
      cp2.length += length2;
    }
    __name(addSegment, "addSegment");
    for (var _i = 0; _i < ctrlpts.length; _i++) {
      var cp = ctrlpts[_i];
      var prevCp = ctrlpts[_i - 1];
      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }
      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r2.bezierProjPcts[0]);
      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r2.bezierProjPcts[j], r2.bezierProjPcts[j + 1]);
      }
      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r2.bezierProjPcts[nProjs - 1], 1);
    }
    return _createControlPointInfo.cache = ctrlpts;
  }, "createControlPointInfo");
  var calculateEndProjection = /* @__PURE__ */ __name(function calculateEndProjection2(prefix) {
    var angle2;
    var isSrc = prefix === "source";
    if (!content[prefix]) {
      return;
    }
    var offset = edge.pstyle(prefix + "-text-offset").pfValue;
    switch (rs.edgeType) {
      case "self":
      case "compound":
      case "bezier":
      case "multibezier": {
        var cps = _createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;
        for (var i = 0; i < cps.length; i++) {
          var _cp = cps[isSrc ? i : cps.length - 1 - i];
          for (var j = 0; j < _cp.segments.length; j++) {
            var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
            var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
            startDist = totalDist;
            totalDist += _seg.length;
            if (totalDist >= offset || lastSeg) {
              selected = {
                cp: _cp,
                segment: _seg
              };
              break;
            }
          }
          if (selected) {
            break;
          }
        }
        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = (offset - startDist) / seg.length;
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
        t = bound(0, t, 1);
        p2 = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
        angle2 = bezierAngle(cp.p0, cp.p1, cp.p2, t);
        break;
      }
      case "straight":
      case "segments":
      case "haystack": {
        var d = 0, di, d0;
        var p0, p1;
        var l = rs.allpts.length;
        for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {
          if (isSrc) {
            p0 = {
              x: rs.allpts[_i2],
              y: rs.allpts[_i2 + 1]
            };
            p1 = {
              x: rs.allpts[_i2 + 2],
              y: rs.allpts[_i2 + 3]
            };
          } else {
            p0 = {
              x: rs.allpts[l - 2 - _i2],
              y: rs.allpts[l - 1 - _i2]
            };
            p1 = {
              x: rs.allpts[l - 4 - _i2],
              y: rs.allpts[l - 3 - _i2]
            };
          }
          di = dist(p0, p1);
          d0 = d;
          d += di;
          if (d >= offset) {
            break;
          }
        }
        var pD = offset - d0;
        var _t = pD / di;
        _t = bound(0, _t, 1);
        p2 = lineAt(p0, p1, _t);
        angle2 = lineAngle(p0, p1);
        break;
      }
    }
    setRs("labelX", prefix, p2.x);
    setRs("labelY", prefix, p2.y);
    setRs("labelAutoAngle", prefix, angle2);
  }, "calculateEndProjection2");
  calculateEndProjection("source");
  calculateEndProjection("target");
  this.applyLabelDimensions(edge);
};
BRp$9.applyLabelDimensions = function(ele) {
  this.applyPrefixedLabelDimensions(ele);
  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, "source");
    this.applyPrefixedLabelDimensions(ele, "target");
  }
};
BRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {
  var _p = ele._private;
  var text2 = this.getLabelText(ele, prefix);
  var cacheKey = hashString(text2, ele._private.labelDimsKey);
  if (getPrefixedProperty(_p.rscratch, "prefixedLabelDimsKey", prefix) === cacheKey) {
    return;
  }
  setPrefixedProperty(_p.rscratch, "prefixedLabelDimsKey", prefix, cacheKey);
  var labelDims = this.calculateLabelDimensions(ele, text2);
  var lineHeight = ele.pstyle("line-height").pfValue;
  var textWrap = ele.pstyle("text-wrap").strValue;
  var lines = getPrefixedProperty(_p.rscratch, "labelWrapCachedLines", prefix) || [];
  var numLines = textWrap !== "wrap" ? 1 : Math.max(lines.length, 1);
  var normPerLineHeight = labelDims.height / numLines;
  var labelLineHeight = normPerLineHeight * lineHeight;
  var width2 = labelDims.width;
  var height2 = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
  setPrefixedProperty(_p.rstyle, "labelWidth", prefix, width2);
  setPrefixedProperty(_p.rscratch, "labelWidth", prefix, width2);
  setPrefixedProperty(_p.rstyle, "labelHeight", prefix, height2);
  setPrefixedProperty(_p.rscratch, "labelHeight", prefix, height2);
  setPrefixedProperty(_p.rscratch, "labelLineHeight", prefix, labelLineHeight);
};
BRp$9.getLabelText = function(ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + "-" : "";
  var text2 = ele.pstyle(pfd + "label").strValue;
  var textTransform = ele.pstyle("text-transform").value;
  var rscratch = /* @__PURE__ */ __name(function rscratch2(propName, value2) {
    if (value2) {
      setPrefixedProperty(_p.rscratch, propName, prefix, value2);
      return value2;
    } else {
      return getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  }, "rscratch2");
  if (!text2) {
    return "";
  }
  if (textTransform == "none") ;
  else if (textTransform == "uppercase") {
    text2 = text2.toUpperCase();
  } else if (textTransform == "lowercase") {
    text2 = text2.toLowerCase();
  }
  var wrapStyle = ele.pstyle("text-wrap").value;
  if (wrapStyle === "wrap") {
    var labelKey = rscratch("labelKey");
    if (labelKey != null && rscratch("labelWrapKey") === labelKey) {
      return rscratch("labelWrapCachedText");
    }
    var zwsp = "​";
    var lines = text2.split("\n");
    var maxW = ele.pstyle("text-max-width").pfValue;
    var overflow = ele.pstyle("text-overflow-wrap").value;
    var overflowAny = overflow === "anywhere";
    var wrappedLines = [];
    var separatorRegex = /[\s\u200b]+|$/g;
    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line);
      var lineW = lineDims.width;
      if (overflowAny) {
        var processedLine = line.split("").join(zwsp);
        line = processedLine;
      }
      if (lineW > maxW) {
        var separatorMatches = line.matchAll(separatorRegex);
        var subline = "";
        var previousIndex = 0;
        var _iterator = _createForOfIteratorHelper(separatorMatches), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var separatorMatch = _step.value;
            var wordSeparator = separatorMatch[0];
            var word = line.substring(previousIndex, separatorMatch.index);
            previousIndex = separatorMatch.index + wordSeparator.length;
            var testLine = subline.length === 0 ? word : subline + word + wordSeparator;
            var testDims = this.calculateLabelDimensions(ele, testLine);
            var testW = testDims.width;
            if (testW <= maxW) {
              subline += word + wordSeparator;
            } else {
              if (subline) {
                wrappedLines.push(subline);
              }
              subline = word + wordSeparator;
            }
          }
        } catch (err2) {
          _iterator.e(err2);
        } finally {
          _iterator.f();
        }
        if (!subline.match(/^[\s\u200b]+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        wrappedLines.push(line);
      }
    }
    rscratch("labelWrapCachedLines", wrappedLines);
    text2 = rscratch("labelWrapCachedText", wrappedLines.join("\n"));
    rscratch("labelWrapKey", labelKey);
  } else if (wrapStyle === "ellipsis") {
    var _maxW = ele.pstyle("text-max-width").pfValue;
    var ellipsized = "";
    var ellipsis = "…";
    var incLastCh = false;
    if (this.calculateLabelDimensions(ele, text2).width < _maxW) {
      return text2;
    }
    for (var i = 0; i < text2.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text2[i] + ellipsis).width;
      if (widthWithNextCh > _maxW) {
        break;
      }
      ellipsized += text2[i];
      if (i === text2.length - 1) {
        incLastCh = true;
      }
    }
    if (!incLastCh) {
      ellipsized += ellipsis;
    }
    return ellipsized;
  }
  return text2;
};
BRp$9.getLabelJustification = function(ele) {
  var justification = ele.pstyle("text-justification").strValue;
  var textHalign = ele.pstyle("text-halign").strValue;
  if (justification === "auto") {
    if (ele.isNode()) {
      switch (textHalign) {
        case "left":
          return "right";
        case "right":
          return "left";
        default:
          return "center";
      }
    } else {
      return "center";
    }
  } else {
    return justification;
  }
};
BRp$9.calculateLabelDimensions = function(ele, text2) {
  var r2 = this;
  var containerWindow = r2.cy.window();
  var document2 = containerWindow.document;
  var padding = 0;
  var fStyle = ele.pstyle("font-style").strValue;
  var size3 = ele.pstyle("font-size").pfValue;
  var family = ele.pstyle("font-family").strValue;
  var weight8 = ele.pstyle("font-weight").strValue;
  var canvas = this.labelCalcCanvas;
  var c2d = this.labelCalcCanvasContext;
  if (!canvas) {
    canvas = this.labelCalcCanvas = document2.createElement("canvas");
    c2d = this.labelCalcCanvasContext = canvas.getContext("2d");
    var ds = canvas.style;
    ds.position = "absolute";
    ds.left = "-9999px";
    ds.top = "-9999px";
    ds.zIndex = "-1";
    ds.visibility = "hidden";
    ds.pointerEvents = "none";
  }
  c2d.font = "".concat(fStyle, " ").concat(weight8, " ").concat(size3, "px ").concat(family);
  var width2 = 0;
  var height2 = 0;
  var lines = text2.split("\n");
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var metrics = c2d.measureText(line);
    var w = Math.ceil(metrics.width);
    var h = size3;
    width2 = Math.max(w, width2);
    height2 += h;
  }
  width2 += padding;
  height2 += padding;
  return {
    width: width2,
    height: height2
  };
};
BRp$9.calculateLabelAngle = function(ele, prefix) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge2 = ele.isEdge();
  var prefixDash = prefix ? prefix + "-" : "";
  var rot = ele.pstyle(prefixDash + "text-rotation");
  var rotStr = rot.strValue;
  if (rotStr === "none") {
    return 0;
  } else if (isEdge2 && rotStr === "autorotate") {
    return rs.labelAutoAngle;
  } else if (rotStr === "autorotate") {
    return 0;
  } else {
    return rot.pfValue;
  }
};
BRp$9.calculateLabelAngles = function(ele) {
  var r2 = this;
  var isEdge2 = ele.isEdge();
  var _p = ele._private;
  var rs = _p.rscratch;
  rs.labelAngle = r2.calculateLabelAngle(ele);
  if (isEdge2) {
    rs.sourceLabelAngle = r2.calculateLabelAngle(ele, "source");
    rs.targetLabelAngle = r2.calculateLabelAngle(ele, "target");
  }
};
var BRp$8 = {};
var TOO_SMALL_CUT_RECT = 28;
var warnedCutRect = false;
BRp$8.getNodeShape = function(node) {
  var r2 = this;
  var shape = node.pstyle("shape").value;
  if (shape === "cutrectangle" && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
    if (!warnedCutRect) {
      warn("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead");
      warnedCutRect = true;
    }
    return "rectangle";
  }
  if (node.isParent()) {
    if (shape === "rectangle" || shape === "roundrectangle" || shape === "round-rectangle" || shape === "cutrectangle" || shape === "cut-rectangle" || shape === "barrel") {
      return shape;
    } else {
      return "rectangle";
    }
  }
  if (shape === "polygon") {
    var points = node.pstyle("shape-polygon-points").value;
    return r2.nodeShapes.makePolygon(points).name;
  }
  return shape;
};
var BRp$7 = {};
BRp$7.registerCalculationListeners = function() {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r2 = this;
  var enqueue = /* @__PURE__ */ __name(function enqueue2(eles) {
    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    elesToUpdate.merge(eles);
    if (dirtyStyleCaches) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle;
        rstyle.clean = false;
        rstyle.cleanConnected = false;
      }
    }
  }, "enqueue2");
  r2.binder(cy).on("bounds.* dirty.*", /* @__PURE__ */ __name(function onDirtyBounds(e) {
    var ele = e.target;
    enqueue(ele);
  }, "onDirtyBounds")).on("style.* background.*", /* @__PURE__ */ __name(function onDirtyStyle(e) {
    var ele = e.target;
    enqueue(ele, false);
  }, "onDirtyStyle"));
  var updateEleCalcs = /* @__PURE__ */ __name(function updateEleCalcs2(willDraw) {
    if (willDraw) {
      var fns = r2.onUpdateEleCalcsFns;
      elesToUpdate.cleanStyle();
      for (var i = 0; i < elesToUpdate.length; i++) {
        var ele = elesToUpdate[i];
        var rstyle = ele._private.rstyle;
        if (ele.isNode() && !rstyle.cleanConnected) {
          enqueue(ele.connectedEdges());
          rstyle.cleanConnected = true;
        }
      }
      if (fns) {
        for (var _i = 0; _i < fns.length; _i++) {
          var fn3 = fns[_i];
          fn3(willDraw, elesToUpdate);
        }
      }
      r2.recalculateRenderedStyle(elesToUpdate);
      elesToUpdate = cy.collection();
    }
  }, "updateEleCalcs2");
  r2.flushRenderedStyleQueue = function() {
    updateEleCalcs(true);
  };
  r2.beforeRender(updateEleCalcs, r2.beforeRenderPriorities.eleCalcs);
};
BRp$7.onUpdateEleCalcs = function(fn3) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  fns.push(fn3);
};
BRp$7.recalculateRenderedStyle = function(eles, useCache) {
  var isCleanConnected = /* @__PURE__ */ __name(function isCleanConnected2(ele2) {
    return ele2._private.rstyle.cleanConnected;
  }, "isCleanConnected2");
  if (eles.length === 0) {
    return;
  }
  var edges3 = [];
  var nodes3 = [];
  if (this.destroyed) {
    return;
  }
  if (useCache === void 0) {
    useCache = true;
  }
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {
      rstyle.clean = false;
    }
    if (ele.isEdge() && ele.isBundledBezier()) {
      if (ele.parallelEdges().some(function(ele2) {
        return !ele2._private.rstyle.clean && ele2.isBundledBezier();
      })) {
        rstyle.clean = false;
      }
    }
    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    }
    if (ele.pstyle("display").value === "none") {
      continue;
    }
    if (_p.group === "nodes") {
      nodes3.push(ele);
    } else {
      edges3.push(ele);
    }
    rstyle.clean = true;
  }
  for (var _i2 = 0; _i2 < nodes3.length; _i2++) {
    var _ele = nodes3[_i2];
    var _p2 = _ele._private;
    var _rstyle = _p2.rstyle;
    var pos = _ele.position();
    this.recalculateNodeLabelProjection(_ele);
    _rstyle.nodeX = pos.x;
    _rstyle.nodeY = pos.y;
    _rstyle.nodeW = _ele.pstyle("width").pfValue;
    _rstyle.nodeH = _ele.pstyle("height").pfValue;
  }
  this.recalculateEdgeProjections(edges3);
  for (var _i3 = 0; _i3 < edges3.length; _i3++) {
    var _ele2 = edges3[_i3];
    var _p3 = _ele2._private;
    var _rstyle2 = _p3.rstyle;
    var rs = _p3.rscratch;
    _rstyle2.srcX = rs.arrowStartX;
    _rstyle2.srcY = rs.arrowStartY;
    _rstyle2.tgtX = rs.arrowEndX;
    _rstyle2.tgtY = rs.arrowEndY;
    _rstyle2.midX = rs.midX;
    _rstyle2.midY = rs.midY;
    _rstyle2.labelAngle = rs.labelAngle;
    _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;
    _rstyle2.targetLabelAngle = rs.targetLabelAngle;
  }
};
var BRp$6 = {};
BRp$6.updateCachedGrabbedEles = function() {
  var eles = this.cachedZSortedEles;
  if (!eles) {
    return;
  }
  eles.drag = [];
  eles.nondrag = [];
  var grabTargets = [];
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  }
  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];
    eles.drag.push(ele);
  }
};
BRp$6.invalidateCachedZSortedEles = function() {
  this.cachedZSortedEles = null;
};
BRp$6.getCachedZSortedEles = function(forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    var eles = this.cy.mutableElements().toArray();
    eles.sort(zIndexSort);
    eles.interactive = eles.filter(function(ele) {
      return ele.interactive();
    });
    this.cachedZSortedEles = eles;
    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }
  return eles;
};
var BRp$5 = {};
[BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function(props) {
  extend(BRp$5, props);
});
var BRp$4 = {};
BRp$4.getCachedImage = function(url2, crossOrigin, onLoad) {
  var r2 = this;
  var imageCache = r2.imageCache = r2.imageCache || {};
  var cache3 = imageCache[url2];
  if (cache3) {
    if (!cache3.image.complete) {
      cache3.image.addEventListener("load", onLoad);
    }
    return cache3.image;
  } else {
    cache3 = imageCache[url2] = imageCache[url2] || {};
    var image = cache3.image = new Image();
    image.addEventListener("load", onLoad);
    image.addEventListener("error", function() {
      image.error = true;
    });
    var dataUriPrefix = "data:";
    var isDataUri = url2.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
    if (!isDataUri) {
      crossOrigin = crossOrigin === "null" ? null : crossOrigin;
      image.crossOrigin = crossOrigin;
    }
    image.src = url2;
    return image;
  }
};
var BRp$3 = {};
BRp$3.registerBinding = function(target, event3, handler, useCapture) {
  var args2 = Array.prototype.slice.apply(arguments, [1]);
  if (Array.isArray(target)) {
    var res = [];
    for (var i = 0; i < target.length; i++) {
      var t = target[i];
      if (t !== void 0) {
        var b = this.binder(t);
        res.push(b.on.apply(b, args2));
      }
    }
    return res;
  }
  var b = this.binder(target);
  return b.on.apply(b, args2);
};
BRp$3.binder = function(tgt) {
  var r2 = this;
  var containerWindow = r2.cy.window();
  var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);
  if (r2.supportsPassiveEvents == null) {
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: /* @__PURE__ */ __name(function get2() {
          supportsPassive = true;
          return true;
        }, "get2")
      });
      containerWindow.addEventListener("test", null, opts);
    } catch (err2) {
    }
    r2.supportsPassiveEvents = supportsPassive;
  }
  var on3 = /* @__PURE__ */ __name(function on4(event3, handler, useCapture) {
    var args2 = Array.prototype.slice.call(arguments);
    if (tgtIsDom && r2.supportsPassiveEvents) {
      args2[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }
    r2.bindings.push({
      target: tgt,
      args: args2
    });
    (tgt.addEventListener || tgt.on).apply(tgt, args2);
    return this;
  }, "on4");
  return {
    on: on3,
    addEventListener: on3,
    addListener: on3,
    bind: on3
  };
};
BRp$3.nodeIsDraggable = function(node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};
BRp$3.nodeIsGrabbable = function(node) {
  return this.nodeIsDraggable(node) && node.interactive();
};
BRp$3.load = function() {
  var r2 = this;
  var containerWindow = r2.cy.window();
  var isSelected = /* @__PURE__ */ __name(function isSelected2(ele) {
    return ele.selected();
  }, "isSelected2");
  var getShadowRoot = /* @__PURE__ */ __name(function getShadowRoot2(element3) {
    var rootNode = element3.getRootNode();
    if (rootNode && rootNode.nodeType === 11 && rootNode.host !== void 0) {
      return rootNode;
    }
  }, "getShadowRoot2");
  var triggerEvents = /* @__PURE__ */ __name(function triggerEvents2(target, names, e, position3) {
    if (target == null) {
      target = r2.cy;
    }
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      target.emit({
        originalEvent: e,
        type: name,
        position: position3
      });
    }
  }, "triggerEvents2");
  var isMultSelKeyDown = /* @__PURE__ */ __name(function isMultSelKeyDown2(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey;
  }, "isMultSelKeyDown2");
  var allowPanningPassthrough = /* @__PURE__ */ __name(function allowPanningPassthrough2(down, downs) {
    var allowPassthrough = true;
    if (r2.cy.hasCompoundNodes() && down && down.pannable()) {
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];
        if (down.isNode() && down.isParent() && !down.pannable()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }
    return allowPassthrough;
  }, "allowPanningPassthrough2");
  var setGrabbed = /* @__PURE__ */ __name(function setGrabbed2(ele) {
    ele[0]._private.grabbed = true;
  }, "setGrabbed2");
  var setFreed = /* @__PURE__ */ __name(function setFreed2(ele) {
    ele[0]._private.grabbed = false;
  }, "setFreed2");
  var setInDragLayer = /* @__PURE__ */ __name(function setInDragLayer2(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  }, "setInDragLayer2");
  var setOutDragLayer = /* @__PURE__ */ __name(function setOutDragLayer2(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  }, "setOutDragLayer2");
  var setGrabTarget = /* @__PURE__ */ __name(function setGrabTarget2(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  }, "setGrabTarget2");
  var removeGrabTarget = /* @__PURE__ */ __name(function removeGrabTarget2(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  }, "removeGrabTarget2");
  var addToDragList = /* @__PURE__ */ __name(function addToDragList2(ele, opts) {
    var list = opts.addToList;
    var listHasEle = list.has(ele);
    if (!listHasEle && ele.grabbable() && !ele.locked()) {
      list.merge(ele);
      setGrabbed(ele);
    }
  }, "addToDragList2");
  var addDescendantsToDrag = /* @__PURE__ */ __name(function addDescendantsToDrag2(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }
    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    }
    var innerNodes = node.descendants();
    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }
    if (opts.addToList) {
      addToDragList(innerNodes, opts);
    }
  }, "addDescendantsToDrag2");
  var addNodesToDrag = /* @__PURE__ */ __name(function addNodesToDrag2(nodes3, opts) {
    opts = opts || {};
    var hasCompoundNodes2 = nodes3.cy().hasCompoundNodes();
    if (opts.inDragLayer) {
      nodes3.forEach(setInDragLayer);
      nodes3.neighborhood().stdFilter(function(ele) {
        return !hasCompoundNodes2 || ele.isEdge();
      }).forEach(setInDragLayer);
    }
    if (opts.addToList) {
      nodes3.forEach(function(ele) {
        addToDragList(ele, opts);
      });
    }
    addDescendantsToDrag(nodes3, opts);
    updateAncestorsInDragLayer(nodes3, {
      inDragLayer: opts.inDragLayer
    });
    r2.updateCachedGrabbedEles();
  }, "addNodesToDrag2");
  var addNodeToDrag = addNodesToDrag;
  var freeDraggedElements = /* @__PURE__ */ __name(function freeDraggedElements2(grabbedEles) {
    if (!grabbedEles) {
      return;
    }
    r2.getCachedZSortedEles().forEach(function(ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });
    r2.updateCachedGrabbedEles();
  }, "freeDraggedElements2");
  var updateAncestorsInDragLayer = /* @__PURE__ */ __name(function updateAncestorsInDragLayer2(node, opts) {
    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    }
    if (!node.cy().hasCompoundNodes()) {
      return;
    }
    var parent4 = node.ancestors().orphans();
    if (parent4.same(node)) {
      return;
    }
    var nodes3 = parent4.descendants().spawnSelf().merge(parent4).unmerge(node).unmerge(node.descendants());
    var edges3 = nodes3.connectedEdges();
    if (opts.inDragLayer) {
      edges3.forEach(setInDragLayer);
      nodes3.forEach(setInDragLayer);
    }
    if (opts.addToList) {
      nodes3.forEach(function(ele) {
        addToDragList(ele, opts);
      });
    }
  }, "updateAncestorsInDragLayer2");
  var blurActiveDomElement = /* @__PURE__ */ __name(function blurActiveDomElement2() {
    if (document.activeElement != null && document.activeElement.blur != null) {
      document.activeElement.blur();
    }
  }, "blurActiveDomElement2");
  var haveMutationsApi = typeof MutationObserver !== "undefined";
  var haveResizeObserverApi = typeof ResizeObserver !== "undefined";
  if (haveMutationsApi) {
    r2.removeObserver = new MutationObserver(function(mutns) {
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;
        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];
            if (rNode === r2.container) {
              r2.destroy();
              break;
            }
          }
        }
      }
    });
    if (r2.container.parentNode) {
      r2.removeObserver.observe(r2.container.parentNode, {
        childList: true
      });
    }
  } else {
    r2.registerBinding(r2.container, "DOMNodeRemoved", function(e) {
      r2.destroy();
    });
  }
  var onResize = debounce(function() {
    r2.cy.resize();
  }, 100);
  if (haveMutationsApi) {
    r2.styleObserver = new MutationObserver(onResize);
    r2.styleObserver.observe(r2.container, {
      attributes: true
    });
  }
  r2.registerBinding(containerWindow, "resize", onResize);
  if (haveResizeObserverApi) {
    r2.resizeObserver = new ResizeObserver(onResize);
    r2.resizeObserver.observe(r2.container);
  }
  var forEachUp = /* @__PURE__ */ __name(function forEachUp2(domEle, fn3) {
    while (domEle != null) {
      fn3(domEle);
      domEle = domEle.parentNode;
    }
  }, "forEachUp2");
  var invalidateCoords = /* @__PURE__ */ __name(function invalidateCoords2() {
    r2.invalidateContainerClientCoordsCache();
  }, "invalidateCoords2");
  forEachUp(r2.container, function(domEle) {
    r2.registerBinding(domEle, "transitionend", invalidateCoords);
    r2.registerBinding(domEle, "animationend", invalidateCoords);
    r2.registerBinding(domEle, "scroll", invalidateCoords);
  });
  r2.registerBinding(r2.container, "contextmenu", function(e) {
    e.preventDefault();
  });
  var inBoxSelection = /* @__PURE__ */ __name(function inBoxSelection2() {
    return r2.selection[4] !== 0;
  }, "inBoxSelection2");
  var eventInContainer = /* @__PURE__ */ __name(function eventInContainer2(e) {
    var containerPageCoords = r2.findContainerClientCoords();
    var x2 = containerPageCoords[0];
    var y2 = containerPageCoords[1];
    var width2 = containerPageCoords[2];
    var height2 = containerPageCoords[3];
    var positions2 = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;
    for (var i = 0; i < positions2.length; i++) {
      var p2 = positions2[i];
      if (x2 <= p2.clientX && p2.clientX <= x2 + width2 && y2 <= p2.clientY && p2.clientY <= y2 + height2) {
        atLeastOnePosInside = true;
        break;
      }
    }
    if (!atLeastOnePosInside) {
      return false;
    }
    var container2 = r2.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;
    while (tParent) {
      if (tParent === container2) {
        containerIsTarget = true;
        break;
      }
      tParent = tParent.parentNode;
    }
    if (!containerIsTarget) {
      return false;
    }
    return true;
  }, "eventInContainer2");
  r2.registerBinding(r2.container, "mousedown", /* @__PURE__ */ __name(function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }
    if (r2.hoverData.which === 1 && e.which !== 1) {
      return;
    }
    e.preventDefault();
    blurActiveDomElement();
    r2.hoverData.capture = true;
    r2.hoverData.which = e.which;
    var cy = r2.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r2.projectIntoViewport(gpos[0], gpos[1]);
    var select = r2.selection;
    var nears = r2.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r2.dragData.possibleDragElements;
    r2.hoverData.mdownPos = pos;
    r2.hoverData.mdownGPos = gpos;
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: pos[0],
          y: pos[1]
        }
      };
    }, "makeEvent2");
    var checkForTaphold = /* @__PURE__ */ __name(function checkForTaphold2() {
      r2.hoverData.tapholdCancelled = false;
      clearTimeout(r2.hoverData.tapholdTimeout);
      r2.hoverData.tapholdTimeout = setTimeout(function() {
        if (r2.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r2.hoverData.down;
          if (ele) {
            ele.emit(makeEvent("taphold"));
          } else {
            cy.emit(makeEvent("taphold"));
          }
        }
      }, r2.tapholdDuration);
    }, "checkForTaphold2");
    if (e.which == 3) {
      r2.hoverData.cxtStarted = true;
      var cxtEvt = {
        originalEvent: e,
        type: "cxttapstart",
        position: {
          x: pos[0],
          y: pos[1]
        }
      };
      if (near) {
        near.activate();
        near.emit(cxtEvt);
        r2.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }
      r2.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime();
      r2.hoverData.cxtDragged = false;
    } else if (e.which == 1) {
      if (near) {
        near.activate();
      }
      {
        if (near != null) {
          if (r2.nodeIsGrabbable(near)) {
            var triggerGrab = /* @__PURE__ */ __name(function triggerGrab2(ele) {
              ele.emit(makeEvent("grab"));
            }, "triggerGrab2");
            setGrabTarget(near);
            if (!near.selected()) {
              draggedElements = r2.dragData.possibleDragElements = cy.collection();
              addNodeToDrag(near, {
                addToList: draggedElements
              });
              near.emit(makeEvent("grabon")).emit(makeEvent("grab"));
            } else {
              draggedElements = r2.dragData.possibleDragElements = cy.collection();
              var selectedNodes = cy.$(function(ele) {
                return ele.isNode() && ele.selected() && r2.nodeIsGrabbable(ele);
              });
              addNodesToDrag(selectedNodes, {
                addToList: draggedElements
              });
              near.emit(makeEvent("grabon"));
              selectedNodes.forEach(triggerGrab);
            }
            r2.redrawHint("eles", true);
            r2.redrawHint("drag", true);
          }
        }
        r2.hoverData.down = near;
        r2.hoverData.downs = nears;
        r2.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime();
      }
      triggerEvents(near, ["mousedown", "tapstart", "vmousedown"], e, {
        x: pos[0],
        y: pos[1]
      });
      if (near == null) {
        select[4] = 1;
        r2.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r2.redrawHint("select", true);
        r2.redraw();
      } else if (near.pannable()) {
        select[4] = 1;
      }
      checkForTaphold();
    }
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, "mousedownHandler"), false);
  var shadowRoot = getShadowRoot(r2.container);
  r2.registerBinding([containerWindow, shadowRoot], "mousemove", /* @__PURE__ */ __name(function mousemoveHandler(e) {
    var capture2 = r2.hoverData.capture;
    if (!capture2 && !eventInContainer(e)) {
      return;
    }
    var preventDefault22 = false;
    var cy = r2.cy;
    var zoom2 = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r2.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r2.hoverData.mdownPos;
    var mdownGPos = r2.hoverData.mdownGPos;
    var select = r2.selection;
    var near = null;
    if (!r2.hoverData.draggingEles && !r2.hoverData.dragging && !r2.hoverData.selecting) {
      near = r2.findNearestElement(pos[0], pos[1], true, false);
    }
    var last2 = r2.hoverData.last;
    var down = r2.hoverData.down;
    var disp = [pos[0] - select[2], pos[1] - select[3]];
    var draggedElements = r2.dragData.possibleDragElements;
    var isOverThresholdDrag;
    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist22 = dx2 + dy2;
      r2.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist22 >= r2.desktopTapThreshold2;
    }
    var multSelKeyDown = isMultSelKeyDown(e);
    if (isOverThresholdDrag) {
      r2.hoverData.tapholdCancelled = true;
    }
    var updateDragDelta = /* @__PURE__ */ __name(function updateDragDelta2() {
      var dragDelta2 = r2.hoverData.dragDelta = r2.hoverData.dragDelta || [];
      if (dragDelta2.length === 0) {
        dragDelta2.push(disp[0]);
        dragDelta2.push(disp[1]);
      } else {
        dragDelta2[0] += disp[0];
        dragDelta2[1] += disp[1];
      }
    }, "updateDragDelta2");
    preventDefault22 = true;
    triggerEvents(near, ["mousemove", "vmousemove", "tapdrag"], e, {
      x: pos[0],
      y: pos[1]
    });
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: pos[0],
          y: pos[1]
        }
      };
    }, "makeEvent2");
    var goIntoBoxMode = /* @__PURE__ */ __name(function goIntoBoxMode2() {
      r2.data.bgActivePosistion = void 0;
      if (!r2.hoverData.selecting) {
        cy.emit(makeEvent("boxstart"));
      }
      select[4] = 1;
      r2.hoverData.selecting = true;
      r2.redrawHint("select", true);
      r2.redraw();
    }, "goIntoBoxMode2");
    if (r2.hoverData.which === 3) {
      if (isOverThresholdDrag) {
        var cxtEvt = makeEvent("cxtdrag");
        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }
        r2.hoverData.cxtDragged = true;
        if (!r2.hoverData.cxtOver || near !== r2.hoverData.cxtOver) {
          if (r2.hoverData.cxtOver) {
            r2.hoverData.cxtOver.emit(makeEvent("cxtdragout"));
          }
          r2.hoverData.cxtOver = near;
          if (near) {
            near.emit(makeEvent("cxtdragover"));
          }
        }
      }
    } else if (r2.hoverData.dragging) {
      preventDefault22 = true;
      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;
        if (r2.hoverData.justStartedPan) {
          var mdPos = r2.hoverData.mdownPos;
          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom2,
            y: (pos[1] - mdPos[1]) * zoom2
          };
          r2.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom2,
            y: disp[1] * zoom2
          };
        }
        cy.panBy(deltaP);
        cy.emit(makeEvent("dragpan"));
        r2.hoverData.dragged = true;
      }
      pos = r2.projectIntoViewport(e.clientX, e.clientY);
    } else if (select[4] == 1 && (down == null || down.pannable())) {
      if (isOverThresholdDrag) {
        if (!r2.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r2.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r2.hoverData.downs);
          if (allowPassthrough) {
            r2.hoverData.dragging = true;
            r2.hoverData.justStartedPan = true;
            select[4] = 0;
            r2.data.bgActivePosistion = array2point(mdownPos);
            r2.redrawHint("select", true);
            r2.redraw();
          }
        }
        if (down && down.pannable() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.pannable() && down.active()) {
        down.unactivate();
      }
      if ((!down || !down.grabbed()) && near != last2) {
        if (last2) {
          triggerEvents(last2, ["mouseout", "tapdragout"], e, {
            x: pos[0],
            y: pos[1]
          });
        }
        if (near) {
          triggerEvents(near, ["mouseover", "tapdragover"], e, {
            x: pos[0],
            y: pos[1]
          });
        }
        r2.hoverData.last = near;
      }
      if (down) {
        if (isOverThresholdDrag) {
          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);
              down.emit(makeEvent("freeon"));
              draggedElements.emit(makeEvent("free"));
              if (r2.dragData.didDrag) {
                down.emit(makeEvent("dragfreeon"));
                draggedElements.emit(makeEvent("dragfree"));
              }
            }
            goIntoBoxMode();
          } else if (down && down.grabbed() && r2.nodeIsDraggable(down)) {
            var justStartedDrag = !r2.dragData.didDrag;
            if (justStartedDrag) {
              r2.redrawHint("eles", true);
            }
            r2.dragData.didDrag = true;
            if (!r2.hoverData.draggingEles) {
              addNodesToDrag(draggedElements, {
                inDragLayer: true
              });
            }
            var totalShift = {
              x: 0,
              y: 0
            };
            if (number$1(disp[0]) && number$1(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];
              if (justStartedDrag) {
                var dragDelta = r2.hoverData.dragDelta;
                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }
            r2.hoverData.draggingEles = true;
            draggedElements.silentShift(totalShift).emit(makeEvent("position")).emit(makeEvent("drag"));
            r2.redrawHint("drag", true);
            r2.redraw();
          }
        } else {
          updateDragDelta();
        }
      }
      preventDefault22 = true;
    }
    select[2] = pos[0];
    select[3] = pos[1];
    if (preventDefault22) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, "mousemoveHandler"), false);
  var clickTimeout, didDoubleClick, prevClickTimeStamp;
  r2.registerBinding(containerWindow, "mouseup", /* @__PURE__ */ __name(function mouseupHandler(e) {
    if (r2.hoverData.which === 1 && e.which !== 1 && r2.hoverData.capture) {
      return;
    }
    var capture2 = r2.hoverData.capture;
    if (!capture2) {
      return;
    }
    r2.hoverData.capture = false;
    var cy = r2.cy;
    var pos = r2.projectIntoViewport(e.clientX, e.clientY);
    var select = r2.selection;
    var near = r2.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r2.dragData.possibleDragElements;
    var down = r2.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);
    if (r2.data.bgActivePosistion) {
      r2.redrawHint("select", true);
      r2.redraw();
    }
    r2.hoverData.tapholdCancelled = true;
    r2.data.bgActivePosistion = void 0;
    if (down) {
      down.unactivate();
    }
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: pos[0],
          y: pos[1]
        }
      };
    }, "makeEvent2");
    if (r2.hoverData.which === 3) {
      var cxtEvt = makeEvent("cxttapend");
      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }
      if (!r2.hoverData.cxtDragged) {
        var cxtTap = makeEvent("cxttap");
        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }
      r2.hoverData.cxtDragged = false;
      r2.hoverData.which = null;
    } else if (r2.hoverData.which === 1) {
      triggerEvents(near, ["mouseup", "tapend", "vmouseup"], e, {
        x: pos[0],
        y: pos[1]
      });
      if (!r2.dragData.didDrag && // didn't move a node around
      !r2.hoverData.dragged && // didn't pan
      !r2.hoverData.selecting && // not box selection
      !r2.hoverData.isOverThresholdDrag) {
        triggerEvents(down, ["click", "tap", "vclick"], e, {
          x: pos[0],
          y: pos[1]
        });
        didDoubleClick = false;
        if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {
          clickTimeout && clearTimeout(clickTimeout);
          didDoubleClick = true;
          prevClickTimeStamp = null;
          triggerEvents(down, ["dblclick", "dbltap", "vdblclick"], e, {
            x: pos[0],
            y: pos[1]
          });
        } else {
          clickTimeout = setTimeout(function() {
            if (didDoubleClick) return;
            triggerEvents(down, ["oneclick", "onetap", "voneclick"], e, {
              x: pos[0],
              y: pos[1]
            });
          }, cy.multiClickDebounceTime());
          prevClickTimeStamp = e.timeStamp;
        }
      }
      if (down == null && !r2.dragData.didDrag && !r2.hoverData.selecting && !r2.hoverData.dragged && !isMultSelKeyDown(e)) {
        cy.$(isSelected).unselect(["tapunselect"]);
        if (draggedElements.length > 0) {
          r2.redrawHint("eles", true);
        }
        r2.dragData.possibleDragElements = draggedElements = cy.collection();
      }
      if (near == down && !r2.dragData.didDrag && !r2.hoverData.selecting) {
        if (near != null && near._private.selectable) {
          if (r2.hoverData.dragging) ;
          else if (cy.selectionType() === "additive" || multSelKeyDown) {
            if (near.selected()) {
              near.unselect(["tapunselect"]);
            } else {
              near.select(["tapselect"]);
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(isSelected).unmerge(near).unselect(["tapunselect"]);
              near.select(["tapselect"]);
            }
          }
          r2.redrawHint("eles", true);
        }
      }
      if (r2.hoverData.selecting) {
        var box = cy.collection(r2.getAllInBox(select[0], select[1], select[2], select[3]));
        r2.redrawHint("select", true);
        if (box.length > 0) {
          r2.redrawHint("eles", true);
        }
        cy.emit(makeEvent("boxend"));
        var eleWouldBeSelected = /* @__PURE__ */ __name(function eleWouldBeSelected2(ele) {
          return ele.selectable() && !ele.selected();
        }, "eleWouldBeSelected2");
        if (cy.selectionType() === "additive") {
          box.emit(makeEvent("box")).stdFilter(eleWouldBeSelected).select().emit(makeEvent("boxselect"));
        } else {
          if (!multSelKeyDown) {
            cy.$(isSelected).unmerge(box).unselect();
          }
          box.emit(makeEvent("box")).stdFilter(eleWouldBeSelected).select().emit(makeEvent("boxselect"));
        }
        r2.redraw();
      }
      if (r2.hoverData.dragging) {
        r2.hoverData.dragging = false;
        r2.redrawHint("select", true);
        r2.redrawHint("eles", true);
        r2.redraw();
      }
      if (!select[4]) {
        r2.redrawHint("drag", true);
        r2.redrawHint("eles", true);
        var downWasGrabbed = down && down.grabbed();
        freeDraggedElements(draggedElements);
        if (downWasGrabbed) {
          down.emit(makeEvent("freeon"));
          draggedElements.emit(makeEvent("free"));
          if (r2.dragData.didDrag) {
            down.emit(makeEvent("dragfreeon"));
            draggedElements.emit(makeEvent("dragfree"));
          }
        }
      }
    }
    select[4] = 0;
    r2.hoverData.down = null;
    r2.hoverData.cxtStarted = false;
    r2.hoverData.draggingEles = false;
    r2.hoverData.selecting = false;
    r2.hoverData.isOverThresholdDrag = false;
    r2.dragData.didDrag = false;
    r2.hoverData.dragged = false;
    r2.hoverData.dragDelta = [];
    r2.hoverData.mdownPos = null;
    r2.hoverData.mdownGPos = null;
    r2.hoverData.which = null;
  }, "mouseupHandler"), false);
  var wheelDeltas = [];
  var wheelDeltaN = 4;
  var inaccurateScrollDevice;
  var inaccurateScrollFactor = 1e5;
  var allAreDivisibleBy = /* @__PURE__ */ __name(function allAreDivisibleBy2(list, factor) {
    for (var i = 0; i < list.length; i++) {
      if (list[i] % factor !== 0) {
        return false;
      }
    }
    return true;
  }, "allAreDivisibleBy2");
  var allAreSameMagnitude = /* @__PURE__ */ __name(function allAreSameMagnitude2(list) {
    var firstMag = Math.abs(list[0]);
    for (var i = 1; i < list.length; i++) {
      if (Math.abs(list[i]) !== firstMag) {
        return false;
      }
    }
    return true;
  }, "allAreSameMagnitude2");
  var wheelHandler = /* @__PURE__ */ __name(function wheelHandler2(e) {
    var clamp = false;
    var delta = e.deltaY;
    if (delta == null) {
      if (e.wheelDeltaY != null) {
        delta = e.wheelDeltaY / 4;
      } else if (e.wheelDelta != null) {
        delta = e.wheelDelta / 4;
      }
    }
    if (delta === 0) {
      return;
    }
    if (inaccurateScrollDevice == null) {
      if (wheelDeltas.length >= wheelDeltaN) {
        var wds = wheelDeltas;
        inaccurateScrollDevice = allAreDivisibleBy(wds, 5);
        if (!inaccurateScrollDevice) {
          var firstMag = Math.abs(wds[0]);
          inaccurateScrollDevice = allAreSameMagnitude(wds) && firstMag > 5;
        }
        if (inaccurateScrollDevice) {
          for (var i = 0; i < wds.length; i++) {
            inaccurateScrollFactor = Math.min(Math.abs(wds[i]), inaccurateScrollFactor);
          }
        }
      } else {
        wheelDeltas.push(delta);
        clamp = true;
      }
    } else if (inaccurateScrollDevice) {
      inaccurateScrollFactor = Math.min(Math.abs(delta), inaccurateScrollFactor);
    }
    if (r2.scrollingPage) {
      return;
    }
    var cy = r2.cy;
    var zoom2 = cy.zoom();
    var pan2 = cy.pan();
    var pos = r2.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * zoom2 + pan2.x, pos[1] * zoom2 + pan2.y];
    if (r2.hoverData.draggingEles || r2.hoverData.dragging || r2.hoverData.cxtStarted || inBoxSelection()) {
      e.preventDefault();
      return;
    }
    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();
      r2.data.wheelZooming = true;
      clearTimeout(r2.data.wheelTimeout);
      r2.data.wheelTimeout = setTimeout(function() {
        r2.data.wheelZooming = false;
        r2.redrawHint("eles", true);
        r2.redraw();
      }, 150);
      var diff2;
      if (clamp && Math.abs(delta) > 5) {
        delta = signum(delta) * 5;
      }
      diff2 = delta / -250;
      if (inaccurateScrollDevice) {
        diff2 /= inaccurateScrollFactor;
        diff2 *= 3;
      }
      diff2 = diff2 * r2.wheelSensitivity;
      var needsWheelFix = e.deltaMode === 1;
      if (needsWheelFix) {
        diff2 *= 33;
      }
      var newZoom = cy.zoom() * Math.pow(10, diff2);
      if (e.type === "gesturechange") {
        newZoom = r2.gestureStartZoom * e.scale;
      }
      cy.zoom({
        level: newZoom,
        renderedPosition: {
          x: rpos[0],
          y: rpos[1]
        }
      });
      cy.emit({
        type: e.type === "gesturechange" ? "pinchzoom" : "scrollzoom",
        originalEvent: e,
        position: {
          x: pos[0],
          y: pos[1]
        }
      });
    }
  }, "wheelHandler2");
  r2.registerBinding(r2.container, "wheel", wheelHandler, true);
  r2.registerBinding(containerWindow, "scroll", /* @__PURE__ */ __name(function scrollHandler(e) {
    r2.scrollingPage = true;
    clearTimeout(r2.scrollingPageTimeout);
    r2.scrollingPageTimeout = setTimeout(function() {
      r2.scrollingPage = false;
    }, 250);
  }, "scrollHandler"), true);
  r2.registerBinding(r2.container, "gesturestart", /* @__PURE__ */ __name(function gestureStartHandler(e) {
    r2.gestureStartZoom = r2.cy.zoom();
    if (!r2.hasTouchStarted) {
      e.preventDefault();
    }
  }, "gestureStartHandler"), true);
  r2.registerBinding(r2.container, "gesturechange", function(e) {
    if (!r2.hasTouchStarted) {
      wheelHandler(e);
    }
  }, true);
  r2.registerBinding(r2.container, "mouseout", /* @__PURE__ */ __name(function mouseOutHandler(e) {
    var pos = r2.projectIntoViewport(e.clientX, e.clientY);
    r2.cy.emit({
      originalEvent: e,
      type: "mouseout",
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, "mouseOutHandler"), false);
  r2.registerBinding(r2.container, "mouseover", /* @__PURE__ */ __name(function mouseOverHandler(e) {
    var pos = r2.projectIntoViewport(e.clientX, e.clientY);
    r2.cy.emit({
      originalEvent: e,
      type: "mouseover",
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, "mouseOverHandler"), false);
  var f1x1, f1y1, f2x1, f2y1;
  var distance1, distance1Sq;
  var center1, modelCenter1;
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;
  var distance = /* @__PURE__ */ __name(function distance2(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }, "distance2");
  var distanceSq = /* @__PURE__ */ __name(function distanceSq2(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  }, "distanceSq2");
  var touchstartHandler;
  r2.registerBinding(r2.container, "touchstart", touchstartHandler = /* @__PURE__ */ __name(function touchstartHandler2(e) {
    r2.hasTouchStarted = true;
    if (!eventInContainer(e)) {
      return;
    }
    blurActiveDomElement();
    r2.touchData.capture = true;
    r2.data.bgActivePosistion = void 0;
    var cy = r2.cy;
    var now2 = r2.touchData.now;
    var earlier = r2.touchData.earlier;
    if (e.touches[0]) {
      var pos = r2.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now2[0] = pos[0];
      now2[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r2.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now2[2] = pos[0];
      now2[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r2.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now2[4] = pos[0];
      now2[5] = pos[1];
    }
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: now2[0],
          y: now2[1]
        }
      };
    }, "makeEvent2");
    if (e.touches[1]) {
      r2.touchData.singleTouchMoved = true;
      freeDraggedElements(r2.dragData.touchDragEles);
      var offsets = r2.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];
      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;
      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;
      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
      var pan2 = cy.pan();
      var zoom2 = cy.zoom();
      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan2.x) / zoom2, (center1[1] - pan2.y) / zoom2];
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
        var near1 = r2.findNearestElement(now2[0], now2[1], true, true);
        var near2 = r2.findNearestElement(now2[2], now2[3], true, true);
        if (near1 && near1.isNode()) {
          near1.activate().emit(makeEvent("cxttapstart"));
          r2.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit(makeEvent("cxttapstart"));
          r2.touchData.start = near2;
        } else {
          cy.emit(makeEvent("cxttapstart"));
        }
        if (r2.touchData.start) {
          r2.touchData.start._private.grabbed = false;
        }
        r2.touchData.cxt = true;
        r2.touchData.cxtDragged = false;
        r2.data.bgActivePosistion = void 0;
        r2.redraw();
        return;
      }
    }
    if (e.touches[2]) {
      if (cy.boxSelectionEnabled()) {
        e.preventDefault();
      }
    } else if (e.touches[1]) ;
    else if (e.touches[0]) {
      var nears = r2.findNearestElements(now2[0], now2[1], true, true);
      var near = nears[0];
      if (near != null) {
        near.activate();
        r2.touchData.start = near;
        r2.touchData.starts = nears;
        if (r2.nodeIsGrabbable(near)) {
          var draggedEles = r2.dragData.touchDragEles = cy.collection();
          var selectedNodes = null;
          r2.redrawHint("eles", true);
          r2.redrawHint("drag", true);
          if (near.selected()) {
            selectedNodes = cy.$(function(ele) {
              return ele.selected() && r2.nodeIsGrabbable(ele);
            });
            addNodesToDrag(selectedNodes, {
              addToList: draggedEles
            });
          } else {
            addNodeToDrag(near, {
              addToList: draggedEles
            });
          }
          setGrabTarget(near);
          near.emit(makeEvent("grabon"));
          if (selectedNodes) {
            selectedNodes.forEach(function(n) {
              n.emit(makeEvent("grab"));
            });
          } else {
            near.emit(makeEvent("grab"));
          }
        }
      }
      triggerEvents(near, ["touchstart", "tapstart", "vmousedown"], e, {
        x: now2[0],
        y: now2[1]
      });
      if (near == null) {
        r2.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r2.redrawHint("select", true);
        r2.redraw();
      }
      r2.touchData.singleTouchMoved = false;
      r2.touchData.singleTouchStartTime = +/* @__PURE__ */ new Date();
      clearTimeout(r2.touchData.tapholdTimeout);
      r2.touchData.tapholdTimeout = setTimeout(function() {
        if (r2.touchData.singleTouchMoved === false && !r2.pinching && !r2.touchData.selecting) {
          triggerEvents(r2.touchData.start, ["taphold"], e, {
            x: now2[0],
            y: now2[1]
          });
        }
      }, r2.tapholdDuration);
    }
    if (e.touches.length >= 1) {
      var sPos = r2.touchData.startPosition = [null, null, null, null, null, null];
      for (var i = 0; i < now2.length; i++) {
        sPos[i] = earlier[i] = now2[i];
      }
      var touch0 = e.touches[0];
      r2.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, "touchstartHandler2"), false);
  var touchmoveHandler;
  r2.registerBinding(containerWindow, "touchmove", touchmoveHandler = /* @__PURE__ */ __name(function touchmoveHandler2(e) {
    var capture2 = r2.touchData.capture;
    if (!capture2 && !eventInContainer(e)) {
      return;
    }
    var select = r2.selection;
    var cy = r2.cy;
    var now2 = r2.touchData.now;
    var earlier = r2.touchData.earlier;
    var zoom2 = cy.zoom();
    if (e.touches[0]) {
      var pos = r2.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now2[0] = pos[0];
      now2[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r2.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now2[2] = pos[0];
      now2[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r2.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now2[4] = pos[0];
      now2[5] = pos[1];
    }
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: now2[0],
          y: now2[1]
        }
      };
    }, "makeEvent2");
    var startGPos = r2.touchData.startGPosition;
    var isOverThresholdDrag;
    if (capture2 && e.touches[0] && startGPos) {
      var disp = [];
      for (var j = 0; j < now2.length; j++) {
        disp[j] = now2[j] - earlier[j];
      }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist22 = dx2 + dy2;
      isOverThresholdDrag = dist22 >= r2.touchTapThreshold2;
    }
    if (capture2 && r2.touchData.cxt) {
      e.preventDefault();
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;
      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;
      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r2.touchData.cxt = false;
        r2.data.bgActivePosistion = void 0;
        r2.redrawHint("select", true);
        var cxtEvt = makeEvent("cxttapend");
        if (r2.touchData.start) {
          r2.touchData.start.unactivate().emit(cxtEvt);
          r2.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    }
    if (capture2 && r2.touchData.cxt) {
      var cxtEvt = makeEvent("cxtdrag");
      r2.data.bgActivePosistion = void 0;
      r2.redrawHint("select", true);
      if (r2.touchData.start) {
        r2.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }
      if (r2.touchData.start) {
        r2.touchData.start._private.grabbed = false;
      }
      r2.touchData.cxtDragged = true;
      var near = r2.findNearestElement(now2[0], now2[1], true, true);
      if (!r2.touchData.cxtOver || near !== r2.touchData.cxtOver) {
        if (r2.touchData.cxtOver) {
          r2.touchData.cxtOver.emit(makeEvent("cxtdragout"));
        }
        r2.touchData.cxtOver = near;
        if (near) {
          near.emit(makeEvent("cxtdragover"));
        }
      }
    } else if (capture2 && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();
      r2.data.bgActivePosistion = void 0;
      this.lastThreeTouch = +/* @__PURE__ */ new Date();
      if (!r2.touchData.selecting) {
        cy.emit(makeEvent("boxstart"));
      }
      r2.touchData.selecting = true;
      r2.touchData.didSelect = true;
      select[4] = 1;
      if (!select || select.length === 0 || select[0] === void 0) {
        select[0] = (now2[0] + now2[2] + now2[4]) / 3;
        select[1] = (now2[1] + now2[3] + now2[5]) / 3;
        select[2] = (now2[0] + now2[2] + now2[4]) / 3 + 1;
        select[3] = (now2[1] + now2[3] + now2[5]) / 3 + 1;
      } else {
        select[2] = (now2[0] + now2[2] + now2[4]) / 3;
        select[3] = (now2[1] + now2[3] + now2[5]) / 3;
      }
      r2.redrawHint("select", true);
      r2.redraw();
    } else if (capture2 && e.touches[1] && !r2.touchData.didSelect && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      e.preventDefault();
      r2.data.bgActivePosistion = void 0;
      r2.redrawHint("select", true);
      var draggedEles = r2.dragData.touchDragEles;
      if (draggedEles) {
        r2.redrawHint("drag", true);
        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;
          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }
      var _start = r2.touchData.start;
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);
      var factor = distance2 / distance1;
      if (twoFingersStartInside) {
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;
        var zoom1 = cy.zoom();
        var zoom22 = zoom1 * factor;
        var pan1 = cy.pan();
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;
        var pan2 = {
          x: -zoom22 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom22 / zoom1 * (ctry - pan1.y - ty) + ctry
        };
        if (_start && _start.active()) {
          var draggedEles = r2.dragData.touchDragEles;
          freeDraggedElements(draggedEles);
          r2.redrawHint("drag", true);
          r2.redrawHint("eles", true);
          _start.unactivate().emit(makeEvent("freeon"));
          draggedEles.emit(makeEvent("free"));
          if (r2.dragData.didDrag) {
            _start.emit(makeEvent("dragfreeon"));
            draggedEles.emit(makeEvent("dragfree"));
          }
        }
        cy.viewport({
          zoom: zoom22,
          pan: pan2,
          cancelOnFailedZoom: true
        });
        cy.emit(makeEvent("pinchzoom"));
        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;
        r2.pinching = true;
      }
      if (e.touches[0]) {
        var pos = r2.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now2[0] = pos[0];
        now2[1] = pos[1];
      }
      if (e.touches[1]) {
        var pos = r2.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
        now2[2] = pos[0];
        now2[3] = pos[1];
      }
      if (e.touches[2]) {
        var pos = r2.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
        now2[4] = pos[0];
        now2[5] = pos[1];
      }
    } else if (e.touches[0] && !r2.touchData.didSelect) {
      var start = r2.touchData.start;
      var last2 = r2.touchData.last;
      var near;
      if (!r2.hoverData.draggingEles && !r2.swipePanning) {
        near = r2.findNearestElement(now2[0], now2[1], true, true);
      }
      if (capture2 && start != null) {
        e.preventDefault();
      }
      if (capture2 && start != null && r2.nodeIsDraggable(start)) {
        if (isOverThresholdDrag) {
          var draggedEles = r2.dragData.touchDragEles;
          var justStartedDrag = !r2.dragData.didDrag;
          if (justStartedDrag) {
            addNodesToDrag(draggedEles, {
              inDragLayer: true
            });
          }
          r2.dragData.didDrag = true;
          var totalShift = {
            x: 0,
            y: 0
          };
          if (number$1(disp[0]) && number$1(disp[1])) {
            totalShift.x += disp[0];
            totalShift.y += disp[1];
            if (justStartedDrag) {
              r2.redrawHint("eles", true);
              var dragDelta = r2.touchData.dragDelta;
              if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {
                totalShift.x += dragDelta[0];
                totalShift.y += dragDelta[1];
              }
            }
          }
          r2.hoverData.draggingEles = true;
          draggedEles.silentShift(totalShift).emit(makeEvent("position")).emit(makeEvent("drag"));
          r2.redrawHint("drag", true);
          if (r2.touchData.startPosition[0] == earlier[0] && r2.touchData.startPosition[1] == earlier[1]) {
            r2.redrawHint("eles", true);
          }
          r2.redraw();
        } else {
          var dragDelta = r2.touchData.dragDelta = r2.touchData.dragDelta || [];
          if (dragDelta.length === 0) {
            dragDelta.push(disp[0]);
            dragDelta.push(disp[1]);
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }
      {
        triggerEvents(start || near, ["touchmove", "tapdrag", "vmousemove"], e, {
          x: now2[0],
          y: now2[1]
        });
        if ((!start || !start.grabbed()) && near != last2) {
          if (last2) {
            last2.emit(makeEvent("tapdragout"));
          }
          if (near) {
            near.emit(makeEvent("tapdragover"));
          }
        }
        r2.touchData.last = near;
      }
      if (capture2) {
        for (var i = 0; i < now2.length; i++) {
          if (now2[i] && r2.touchData.startPosition[i] && isOverThresholdDrag) {
            r2.touchData.singleTouchMoved = true;
          }
        }
      }
      if (capture2 && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
        var allowPassthrough = allowPanningPassthrough(start, r2.touchData.starts);
        if (allowPassthrough) {
          e.preventDefault();
          if (!r2.data.bgActivePosistion) {
            r2.data.bgActivePosistion = array2point(r2.touchData.startPosition);
          }
          if (r2.swipePanning) {
            cy.panBy({
              x: disp[0] * zoom2,
              y: disp[1] * zoom2
            });
            cy.emit(makeEvent("dragpan"));
          } else if (isOverThresholdDrag) {
            r2.swipePanning = true;
            cy.panBy({
              x: dx * zoom2,
              y: dy * zoom2
            });
            cy.emit(makeEvent("dragpan"));
            if (start) {
              start.unactivate();
              r2.redrawHint("select", true);
              r2.touchData.start = null;
            }
          }
        }
        var pos = r2.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now2[0] = pos[0];
        now2[1] = pos[1];
      }
    }
    for (var j = 0; j < now2.length; j++) {
      earlier[j] = now2[j];
    }
    if (capture2 && e.touches.length > 0 && !r2.hoverData.draggingEles && !r2.swipePanning && r2.data.bgActivePosistion != null) {
      r2.data.bgActivePosistion = void 0;
      r2.redrawHint("select", true);
      r2.redraw();
    }
  }, "touchmoveHandler2"), false);
  var touchcancelHandler;
  r2.registerBinding(containerWindow, "touchcancel", touchcancelHandler = /* @__PURE__ */ __name(function touchcancelHandler2(e) {
    var start = r2.touchData.start;
    r2.touchData.capture = false;
    if (start) {
      start.unactivate();
    }
  }, "touchcancelHandler2"));
  var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;
  r2.registerBinding(containerWindow, "touchend", touchendHandler = /* @__PURE__ */ __name(function touchendHandler2(e) {
    var start = r2.touchData.start;
    var capture2 = r2.touchData.capture;
    if (capture2) {
      if (e.touches.length === 0) {
        r2.touchData.capture = false;
      }
      e.preventDefault();
    } else {
      return;
    }
    var select = r2.selection;
    r2.swipePanning = false;
    r2.hoverData.draggingEles = false;
    var cy = r2.cy;
    var zoom2 = cy.zoom();
    var now2 = r2.touchData.now;
    var earlier = r2.touchData.earlier;
    if (e.touches[0]) {
      var pos = r2.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now2[0] = pos[0];
      now2[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r2.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now2[2] = pos[0];
      now2[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r2.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now2[4] = pos[0];
      now2[5] = pos[1];
    }
    var makeEvent = /* @__PURE__ */ __name(function makeEvent2(type) {
      return {
        originalEvent: e,
        type,
        position: {
          x: now2[0],
          y: now2[1]
        }
      };
    }, "makeEvent2");
    if (start) {
      start.unactivate();
    }
    var ctxTapend;
    if (r2.touchData.cxt) {
      ctxTapend = makeEvent("cxttapend");
      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }
      if (!r2.touchData.cxtDragged) {
        var ctxTap = makeEvent("cxttap");
        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }
      if (r2.touchData.start) {
        r2.touchData.start._private.grabbed = false;
      }
      r2.touchData.cxt = false;
      r2.touchData.start = null;
      r2.redraw();
      return;
    }
    if (!e.touches[2] && cy.boxSelectionEnabled() && r2.touchData.selecting) {
      r2.touchData.selecting = false;
      var box = cy.collection(r2.getAllInBox(select[0], select[1], select[2], select[3]));
      select[0] = void 0;
      select[1] = void 0;
      select[2] = void 0;
      select[3] = void 0;
      select[4] = 0;
      r2.redrawHint("select", true);
      cy.emit(makeEvent("boxend"));
      var eleWouldBeSelected = /* @__PURE__ */ __name(function eleWouldBeSelected2(ele) {
        return ele.selectable() && !ele.selected();
      }, "eleWouldBeSelected2");
      box.emit(makeEvent("box")).stdFilter(eleWouldBeSelected).select().emit(makeEvent("boxselect"));
      if (box.nonempty()) {
        r2.redrawHint("eles", true);
      }
      r2.redraw();
    }
    if (start != null) {
      start.unactivate();
    }
    if (e.touches[2]) {
      r2.data.bgActivePosistion = void 0;
      r2.redrawHint("select", true);
    } else if (e.touches[1]) ;
    else if (e.touches[0]) ;
    else if (!e.touches[0]) {
      r2.data.bgActivePosistion = void 0;
      r2.redrawHint("select", true);
      var draggedEles = r2.dragData.touchDragEles;
      if (start != null) {
        var startWasGrabbed = start._private.grabbed;
        freeDraggedElements(draggedEles);
        r2.redrawHint("drag", true);
        r2.redrawHint("eles", true);
        if (startWasGrabbed) {
          start.emit(makeEvent("freeon"));
          draggedEles.emit(makeEvent("free"));
          if (r2.dragData.didDrag) {
            start.emit(makeEvent("dragfreeon"));
            draggedEles.emit(makeEvent("dragfree"));
          }
        }
        triggerEvents(start, ["touchend", "tapend", "vmouseup", "tapdragout"], e, {
          x: now2[0],
          y: now2[1]
        });
        start.unactivate();
        r2.touchData.start = null;
      } else {
        var near = r2.findNearestElement(now2[0], now2[1], true, true);
        triggerEvents(near, ["touchend", "tapend", "vmouseup", "tapdragout"], e, {
          x: now2[0],
          y: now2[1]
        });
      }
      var dx = r2.touchData.startPosition[0] - now2[0];
      var dx2 = dx * dx;
      var dy = r2.touchData.startPosition[1] - now2[1];
      var dy2 = dy * dy;
      var dist22 = dx2 + dy2;
      var rdist2 = dist22 * zoom2 * zoom2;
      if (!r2.touchData.singleTouchMoved) {
        if (!start) {
          cy.$(":selected").unselect(["tapunselect"]);
        }
        triggerEvents(start, ["tap", "vclick"], e, {
          x: now2[0],
          y: now2[1]
        });
        didDoubleTouch = false;
        if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {
          touchTimeout && clearTimeout(touchTimeout);
          didDoubleTouch = true;
          prevTouchTimeStamp = null;
          triggerEvents(start, ["dbltap", "vdblclick"], e, {
            x: now2[0],
            y: now2[1]
          });
        } else {
          touchTimeout = setTimeout(function() {
            if (didDoubleTouch) return;
            triggerEvents(start, ["onetap", "voneclick"], e, {
              x: now2[0],
              y: now2[1]
            });
          }, cy.multiClickDebounceTime());
          prevTouchTimeStamp = e.timeStamp;
        }
      }
      if (start != null && !r2.dragData.didDrag && start._private.selectable && rdist2 < r2.touchTapThreshold2 && !r2.pinching) {
        if (cy.selectionType() === "single") {
          cy.$(isSelected).unmerge(start).unselect(["tapunselect"]);
          start.select(["tapselect"]);
        } else {
          if (start.selected()) {
            start.unselect(["tapunselect"]);
          } else {
            start.select(["tapselect"]);
          }
        }
        r2.redrawHint("eles", true);
      }
      r2.touchData.singleTouchMoved = true;
    }
    for (var j = 0; j < now2.length; j++) {
      earlier[j] = now2[j];
    }
    r2.dragData.didDrag = false;
    if (e.touches.length === 0) {
      r2.touchData.dragDelta = [];
      r2.touchData.startPosition = [null, null, null, null, null, null];
      r2.touchData.startGPosition = null;
      r2.touchData.didSelect = false;
    }
    if (e.touches.length < 2) {
      if (e.touches.length === 1) {
        r2.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
      }
      r2.pinching = false;
      r2.redrawHint("eles", true);
      r2.redraw();
    }
  }, "touchendHandler2"), false);
  if (typeof TouchEvent === "undefined") {
    var pointers = [];
    var makeTouch = /* @__PURE__ */ __name(function makeTouch2(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    }, "makeTouch2");
    var makePointer = /* @__PURE__ */ __name(function makePointer2(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    }, "makePointer2");
    var addPointer = /* @__PURE__ */ __name(function addPointer2(e) {
      pointers.push(makePointer(e));
    }, "addPointer2");
    var removePointer = /* @__PURE__ */ __name(function removePointer2(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p2 = pointers[i];
        if (p2.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }, "removePointer2");
    var updatePointer = /* @__PURE__ */ __name(function updatePointer2(e) {
      var p2 = pointers.filter(function(p3) {
        return p3.event.pointerId === e.pointerId;
      })[0];
      p2.event = e;
      p2.touch = makeTouch(e);
    }, "updatePointer2");
    var addTouchesToEvent = /* @__PURE__ */ __name(function addTouchesToEvent2(e) {
      e.touches = pointers.map(function(p2) {
        return p2.touch;
      });
    }, "addTouchesToEvent2");
    var pointerIsMouse = /* @__PURE__ */ __name(function pointerIsMouse2(e) {
      return e.pointerType === "mouse" || e.pointerType === 4;
    }, "pointerIsMouse2");
    r2.registerBinding(r2.container, "pointerdown", function(e) {
      if (pointerIsMouse(e)) {
        return;
      }
      e.preventDefault();
      addPointer(e);
      addTouchesToEvent(e);
      touchstartHandler(e);
    });
    r2.registerBinding(r2.container, "pointerup", function(e) {
      if (pointerIsMouse(e)) {
        return;
      }
      removePointer(e);
      addTouchesToEvent(e);
      touchendHandler(e);
    });
    r2.registerBinding(r2.container, "pointercancel", function(e) {
      if (pointerIsMouse(e)) {
        return;
      }
      removePointer(e);
      addTouchesToEvent(e);
      touchcancelHandler(e);
    });
    r2.registerBinding(r2.container, "pointermove", function(e) {
      if (pointerIsMouse(e)) {
        return;
      }
      e.preventDefault();
      updatePointer(e);
      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};
var BRp$2 = {};
BRp$2.generatePolygon = function(name, points) {
  return this.nodeShapes[name] = {
    renderer: this,
    name,
    points,
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl("polygon", context, centerX, centerY, width2, height2, this.points);
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      return polygonIntersectLine(x2, y2, this.points, nodeX, nodeY, width2 / 2, height2 / 2, padding);
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      return pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2, height2, [0, -1], padding);
    }, "checkPoint"),
    hasMiterBounds: name !== "rectangle",
    miterBounds: /* @__PURE__ */ __name(function miterBounds(centerX, centerY, width2, height2, strokeWidth, strokePosition) {
      return miterBox(this.points, centerX, centerY, width2, height2, strokeWidth);
    }, "miterBounds")
  };
};
BRp$2.generateEllipse = function() {
  return this.nodeShapes["ellipse"] = {
    renderer: this,
    name: "ellipse",
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width2, height2);
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      return intersectLineEllipse(x2, y2, nodeX, nodeY, width2 / 2 + padding, height2 / 2 + padding);
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      return checkInEllipse(x2, y2, width2, height2, centerX, centerY, padding);
    }, "checkPoint")
  };
};
BRp$2.generateRoundPolygon = function(name, points) {
  return this.nodeShapes[name] = {
    renderer: this,
    name,
    points,
    getOrCreateCorners: /* @__PURE__ */ __name(function getOrCreateCorners(centerX, centerY, width2, height2, cornerRadius, rs, field) {
      if (rs[field] !== void 0 && rs[field + "-cx"] === centerX && rs[field + "-cy"] === centerY) {
        return rs[field];
      }
      rs[field] = new Array(points.length / 2);
      rs[field + "-cx"] = centerX;
      rs[field + "-cy"] = centerY;
      var halfW = width2 / 2;
      var halfH = height2 / 2;
      cornerRadius = cornerRadius === "auto" ? getRoundPolygonRadius(width2, height2) : cornerRadius;
      var p2 = new Array(points.length / 2);
      for (var _i = 0; _i < points.length / 2; _i++) {
        p2[_i] = {
          x: centerX + halfW * points[_i * 2],
          y: centerY + halfH * points[_i * 2 + 1]
        };
      }
      var i, p1, p22, p3, len = p2.length;
      p1 = p2[len - 1];
      for (i = 0; i < len; i++) {
        p22 = p2[i % len];
        p3 = p2[(i + 1) % len];
        rs[field][i] = getRoundCorner(p1, p22, p3, cornerRadius);
        p1 = p22;
        p22 = p3;
      }
      return rs[field];
    }, "getOrCreateCorners"),
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius, rs) {
      this.renderer.nodeShapeImpl("round-polygon", context, centerX, centerY, width2, height2, this.points, this.getOrCreateCorners(centerX, centerY, width2, height2, cornerRadius, rs, "drawCorners"));
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius, rs) {
      return roundPolygonIntersectLine(x2, y2, this.points, nodeX, nodeY, width2, height2, padding, this.getOrCreateCorners(nodeX, nodeY, width2, height2, cornerRadius, rs, "corners"));
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius, rs) {
      return pointInsideRoundPolygon(x2, y2, this.points, centerX, centerY, width2, height2, this.getOrCreateCorners(centerX, centerY, width2, height2, cornerRadius, rs, "corners"));
    }, "checkPoint")
  };
};
BRp$2.generateRoundRectangle = function() {
  return this.nodeShapes["round-rectangle"] = this.nodeShapes["roundrectangle"] = {
    renderer: this,
    name: "round-rectangle",
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width2, height2, this.points, cornerRadius);
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      return roundRectangleIntersectLine(x2, y2, nodeX, nodeY, width2, height2, padding, cornerRadius);
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      var halfWidth = width2 / 2;
      var halfHeight = height2 / 2;
      cornerRadius = cornerRadius === "auto" ? getRoundRectangleRadius(width2, height2) : cornerRadius;
      cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);
      var diam = cornerRadius * 2;
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2, height2 - diam, [0, -1], padding)) {
        return true;
      }
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2 - diam, height2, [0, -1], padding)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {
        return true;
      }
      return false;
    }, "checkPoint")
  };
};
BRp$2.generateCutRectangle = function() {
  return this.nodeShapes["cut-rectangle"] = this.nodeShapes["cutrectangle"] = {
    renderer: this,
    name: "cut-rectangle",
    cornerLength: getCutRectangleCornerLength(),
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width2, height2, null, cornerRadius);
    }, "draw"),
    generateCutTrianglePts: /* @__PURE__ */ __name(function generateCutTrianglePts(width2, height2, centerX, centerY, cornerRadius) {
      var cl = cornerRadius === "auto" ? this.cornerLength : cornerRadius;
      var hh = height2 / 2;
      var hw = width2 / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;
      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    }, "generateCutTrianglePts"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      var cPts = this.generateCutTrianglePts(width2 + 2 * padding, height2 + 2 * padding, nodeX, nodeY, cornerRadius);
      var pts2 = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
      return polygonIntersectLine(x2, y2, pts2, nodeX, nodeY);
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      var cl = cornerRadius === "auto" ? this.cornerLength : cornerRadius;
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2, height2 - 2 * cl, [0, -1], padding)) {
        return true;
      }
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2 - 2 * cl, height2, [0, -1], padding)) {
        return true;
      }
      var cutTrianglePts = this.generateCutTrianglePts(width2, height2, centerX, centerY);
      return pointInsidePolygonPoints(x2, y2, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x2, y2, cutTrianglePts.topRight) || pointInsidePolygonPoints(x2, y2, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x2, y2, cutTrianglePts.bottomLeft);
    }, "checkPoint")
  };
};
BRp$2.generateBarrel = function() {
  return this.nodeShapes["barrel"] = {
    renderer: this,
    name: "barrel",
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width2, height2);
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      var t0 = 0.15;
      var t1 = 0.5;
      var t2 = 0.85;
      var bPts = this.generateBarrelBezierPts(width2 + 2 * padding, height2 + 2 * padding, nodeX, nodeY);
      var approximateBarrelCurvePts = /* @__PURE__ */ __name(function approximateBarrelCurvePts2(pts3) {
        var m0 = qbezierPtAt({
          x: pts3[0],
          y: pts3[1]
        }, {
          x: pts3[2],
          y: pts3[3]
        }, {
          x: pts3[4],
          y: pts3[5]
        }, t0);
        var m1 = qbezierPtAt({
          x: pts3[0],
          y: pts3[1]
        }, {
          x: pts3[2],
          y: pts3[3]
        }, {
          x: pts3[4],
          y: pts3[5]
        }, t1);
        var m2 = qbezierPtAt({
          x: pts3[0],
          y: pts3[1]
        }, {
          x: pts3[2],
          y: pts3[3]
        }, {
          x: pts3[4],
          y: pts3[5]
        }, t2);
        return [pts3[0], pts3[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts3[4], pts3[5]];
      }, "approximateBarrelCurvePts2");
      var pts2 = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
      return polygonIntersectLine(x2, y2, pts2, nodeX, nodeY);
    }, "intersectLine"),
    generateBarrelBezierPts: /* @__PURE__ */ __name(function generateBarrelBezierPts(width2, height2, centerX, centerY) {
      var hh = height2 / 2;
      var hw = width2 / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;
      var curveConstants = getBarrelCurveConstants(width2, height2);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width2;
      var pts2 = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };
      pts2.topLeft.isTop = true;
      pts2.topRight.isTop = true;
      pts2.bottomLeft.isBottom = true;
      pts2.bottomRight.isBottom = true;
      return pts2;
    }, "generateBarrelBezierPts"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      var curveConstants = getBarrelCurveConstants(width2, height2);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2, height2 - 2 * hOffset, [0, -1], padding)) {
        return true;
      }
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2 - 2 * wOffset, height2, [0, -1], padding)) {
        return true;
      }
      var barrelCurvePts = this.generateBarrelBezierPts(width2, height2, centerX, centerY);
      var getCurveT = /* @__PURE__ */ __name(function getCurveT2(x3, y3, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x22 = curvePts[0];
        var y02 = curvePts[5];
        var y23 = curvePts[1];
        var xMin = Math.min(x0, x22);
        var xMax = Math.max(x0, x22);
        var yMin = Math.min(y02, y23);
        var yMax = Math.max(y02, y23);
        if (xMin <= x3 && x3 <= xMax && yMin <= y3 && y3 <= yMax) {
          var coeff = bezierPtsToQuadCoeff(x0, x1, x22);
          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x3);
          var validRoots = roots.filter(function(r2) {
            return 0 <= r2 && r2 <= 1;
          });
          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }
        return null;
      }, "getCurveT2");
      var curveRegions = Object.keys(barrelCurvePts);
      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x2, y2, cornerPts);
        if (t == null) {
          continue;
        }
        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y22 = cornerPts[1];
        var bezY = qbezierAt(y0, y1, y22, t);
        if (cornerPts.isTop && bezY <= y2) {
          return true;
        }
        if (cornerPts.isBottom && y2 <= bezY) {
          return true;
        }
      }
      return false;
    }, "checkPoint")
  };
};
BRp$2.generateBottomRoundrectangle = function() {
  return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes["bottomroundrectangle"] = {
    renderer: this,
    name: "bottom-round-rectangle",
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: /* @__PURE__ */ __name(function draw(context, centerX, centerY, width2, height2, cornerRadius) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width2, height2, this.points, cornerRadius);
    }, "draw"),
    intersectLine: /* @__PURE__ */ __name(function intersectLine(nodeX, nodeY, width2, height2, x2, y2, padding, cornerRadius) {
      var topStartX = nodeX - (width2 / 2 + padding);
      var topStartY = nodeY - (height2 / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width2 / 2 + padding);
      var topIntersections = finiteLinesIntersect(x2, y2, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      if (topIntersections.length > 0) {
        return topIntersections;
      }
      return roundRectangleIntersectLine(x2, y2, nodeX, nodeY, width2, height2, padding, cornerRadius);
    }, "intersectLine"),
    checkPoint: /* @__PURE__ */ __name(function checkPoint(x2, y2, padding, width2, height2, centerX, centerY, cornerRadius) {
      cornerRadius = cornerRadius === "auto" ? getRoundRectangleRadius(width2, height2) : cornerRadius;
      var diam = 2 * cornerRadius;
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2, height2 - diam, [0, -1], padding)) {
        return true;
      }
      if (pointInsidePolygon(x2, y2, this.points, centerX, centerY, width2 - diam, height2, [0, -1], padding)) {
        return true;
      }
      var outerWidth = width2 / 2 + 2 * padding;
      var outerHeight = height2 / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
      if (pointInsidePolygonPoints(x2, y2, points)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX + width2 / 2 - cornerRadius, centerY + height2 / 2 - cornerRadius, padding)) {
        return true;
      }
      if (checkInEllipse(x2, y2, diam, diam, centerX - width2 / 2 + cornerRadius, centerY + height2 / 2 - cornerRadius, padding)) {
        return true;
      }
      return false;
    }, "checkPoint")
  };
};
BRp$2.registerNodeShapes = function() {
  var nodeShapes = this.nodeShapes = {};
  var renderer3 = this;
  this.generateEllipse();
  this.generatePolygon("triangle", generateUnitNgonPointsFitToSquare(3, 0));
  this.generateRoundPolygon("round-triangle", generateUnitNgonPointsFitToSquare(3, 0));
  this.generatePolygon("rectangle", generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes["square"] = nodeShapes["rectangle"];
  this.generateRoundRectangle();
  this.generateCutRectangle();
  this.generateBarrel();
  this.generateBottomRoundrectangle();
  {
    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon("diamond", diamondPoints);
    this.generateRoundPolygon("round-diamond", diamondPoints);
  }
  this.generatePolygon("pentagon", generateUnitNgonPointsFitToSquare(5, 0));
  this.generateRoundPolygon("round-pentagon", generateUnitNgonPointsFitToSquare(5, 0));
  this.generatePolygon("hexagon", generateUnitNgonPointsFitToSquare(6, 0));
  this.generateRoundPolygon("round-hexagon", generateUnitNgonPointsFitToSquare(6, 0));
  this.generatePolygon("heptagon", generateUnitNgonPointsFitToSquare(7, 0));
  this.generateRoundPolygon("round-heptagon", generateUnitNgonPointsFitToSquare(7, 0));
  this.generatePolygon("octagon", generateUnitNgonPointsFitToSquare(8, 0));
  this.generateRoundPolygon("round-octagon", generateUnitNgonPointsFitToSquare(8, 0));
  var star5Points = new Array(20);
  {
    var outerPoints = generateUnitNgonPoints(5, 0);
    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }
    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }
  star5Points = fitPolygonToSquare(star5Points);
  this.generatePolygon("star", star5Points);
  this.generatePolygon("vee", [-1, -1, 0, -0.333, 1, -1, 0, 1]);
  this.generatePolygon("rhomboid", [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
  this.generatePolygon("right-rhomboid", [-0.333, -1, 1, -1, 0.333, 1, -1, 1]);
  this.nodeShapes["concavehexagon"] = this.generatePolygon("concave-hexagon", [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon("tag", tagPoints);
    this.generateRoundPolygon("round-tag", tagPoints);
  }
  nodeShapes.makePolygon = function(points) {
    var key2 = points.join("$");
    var name = "polygon-" + key2;
    var shape;
    if (shape = this[name]) {
      return shape;
    }
    return renderer3.generatePolygon(name, points);
  };
};
var BRp$1 = {};
BRp$1.timeToRender = function() {
  return this.redrawTotalTime / this.redrawCount;
};
BRp$1.redraw = function(options2) {
  options2 = options2 || staticEmptyObject();
  var r2 = this;
  if (r2.averageRedrawTime === void 0) {
    r2.averageRedrawTime = 0;
  }
  if (r2.lastRedrawTime === void 0) {
    r2.lastRedrawTime = 0;
  }
  if (r2.lastDrawTime === void 0) {
    r2.lastDrawTime = 0;
  }
  r2.requestedFrame = true;
  r2.renderOptions = options2;
};
BRp$1.beforeRender = function(fn3, priority3) {
  if (this.destroyed) {
    return;
  }
  if (priority3 == null) {
    error("Priority is not optional for beforeRender");
  }
  var cbs = this.beforeRenderCallbacks;
  cbs.push({
    fn: fn3,
    priority: priority3
  });
  cbs.sort(function(a, b) {
    return b.priority - a.priority;
  });
};
var beforeRenderCallbacks = /* @__PURE__ */ __name(function beforeRenderCallbacks2(r2, willDraw, startTime) {
  var cbs = r2.beforeRenderCallbacks;
  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
}, "beforeRenderCallbacks2");
BRp$1.startRenderLoop = function() {
  var r2 = this;
  var cy = r2.cy;
  if (r2.renderLoopStarted) {
    return;
  } else {
    r2.renderLoopStarted = true;
  }
  var _renderFn = /* @__PURE__ */ __name(function renderFn(requestTime) {
    if (r2.destroyed) {
      return;
    }
    if (cy.batching()) ;
    else if (r2.requestedFrame && !r2.skipFrame) {
      beforeRenderCallbacks(r2, true, requestTime);
      var startTime = performanceNow();
      r2.render(r2.renderOptions);
      var endTime = r2.lastDrawTime = performanceNow();
      if (r2.averageRedrawTime === void 0) {
        r2.averageRedrawTime = endTime - startTime;
      }
      if (r2.redrawCount === void 0) {
        r2.redrawCount = 0;
      }
      r2.redrawCount++;
      if (r2.redrawTotalTime === void 0) {
        r2.redrawTotalTime = 0;
      }
      var duration = endTime - startTime;
      r2.redrawTotalTime += duration;
      r2.lastRedrawTime = duration;
      r2.averageRedrawTime = r2.averageRedrawTime / 2 + duration / 2;
      r2.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r2, false, requestTime);
    }
    r2.skipFrame = false;
    requestAnimationFrame$1(_renderFn);
  }, "renderFn");
  requestAnimationFrame$1(_renderFn);
};
var BaseRenderer = /* @__PURE__ */ __name(function BaseRenderer2(options2) {
  this.init(options2);
}, "BaseRenderer2");
var BR = BaseRenderer;
var BRp = BR.prototype;
BRp.clientFunctions = ["redrawHint", "render", "renderTo", "matchCanvasSize", "nodeShapeImpl", "arrowShapeImpl"];
BRp.init = function(options2) {
  var r2 = this;
  r2.options = options2;
  r2.cy = options2.cy;
  var ctr = r2.container = options2.cy.container();
  var containerWindow = r2.cy.window();
  if (containerWindow) {
    var document2 = containerWindow.document;
    var head2 = document2.head;
    var stylesheetId = "__________cytoscape_stylesheet";
    var className = "__________cytoscape_container";
    var stylesheetAlreadyExists = document2.getElementById(stylesheetId) != null;
    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || "") + " " + className;
    }
    if (!stylesheetAlreadyExists) {
      var stylesheet3 = document2.createElement("style");
      stylesheet3.id = stylesheetId;
      stylesheet3.textContent = "." + className + " { position: relative; }";
      head2.insertBefore(stylesheet3, head2.children[0]);
    }
    var computedStyle = containerWindow.getComputedStyle(ctr);
    var position3 = computedStyle.getPropertyValue("position");
    if (position3 === "static") {
      warn("A Cytoscape container has style position:static and so can not use UI extensions properly");
    }
  }
  r2.selection = [void 0, void 0, void 0, void 0, 0];
  r2.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];
  r2.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: false,
    initialPan: [null, null],
    capture: false
  };
  r2.dragData = {
    possibleDragElements: []
  };
  r2.touchData = {
    start: null,
    capture: false,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };
  r2.redraws = 0;
  r2.showFps = options2.showFps;
  r2.debug = options2.debug;
  r2.webgl = options2.webgl;
  r2.hideEdgesOnViewport = options2.hideEdgesOnViewport;
  r2.textureOnViewport = options2.textureOnViewport;
  r2.wheelSensitivity = options2.wheelSensitivity;
  r2.motionBlurEnabled = options2.motionBlur;
  r2.forcedPixelRatio = number$1(options2.pixelRatio) ? options2.pixelRatio : null;
  r2.motionBlur = options2.motionBlur;
  r2.motionBlurOpacity = options2.motionBlurOpacity;
  r2.motionBlurTransparency = 1 - r2.motionBlurOpacity;
  r2.motionBlurPxRatio = 1;
  r2.mbPxRBlurry = 1;
  r2.minMbLowQualFrames = 4;
  r2.fullQualityMb = false;
  r2.clearedForMotionBlur = [];
  r2.desktopTapThreshold = options2.desktopTapThreshold;
  r2.desktopTapThreshold2 = options2.desktopTapThreshold * options2.desktopTapThreshold;
  r2.touchTapThreshold = options2.touchTapThreshold;
  r2.touchTapThreshold2 = options2.touchTapThreshold * options2.touchTapThreshold;
  r2.tapholdDuration = 500;
  r2.bindings = [];
  r2.beforeRenderCallbacks = [];
  r2.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  };
  r2.registerNodeShapes();
  r2.registerArrowShapes();
  r2.registerCalculationListeners();
};
BRp.notify = function(eventName, eles) {
  var r2 = this;
  var cy = r2.cy;
  if (this.destroyed) {
    return;
  }
  if (eventName === "init") {
    r2.load();
    return;
  }
  if (eventName === "destroy") {
    r2.destroy();
    return;
  }
  if (eventName === "add" || eventName === "remove" || eventName === "move" && cy.hasCompoundNodes() || eventName === "load" || eventName === "zorder" || eventName === "mount") {
    r2.invalidateCachedZSortedEles();
  }
  if (eventName === "viewport") {
    r2.redrawHint("select", true);
  }
  if (eventName === "gc") {
    r2.redrawHint("gc", true);
  }
  if (eventName === "load" || eventName === "resize" || eventName === "mount") {
    r2.invalidateContainerClientCoordsCache();
    r2.matchCanvasSize(r2.container);
  }
  r2.redrawHint("eles", true);
  r2.redrawHint("drag", true);
  this.startRenderLoop();
  this.redraw();
};
BRp.destroy = function() {
  var r2 = this;
  r2.destroyed = true;
  r2.cy.stopAnimationLoop();
  for (var i = 0; i < r2.bindings.length; i++) {
    var binding = r2.bindings[i];
    var b = binding;
    var tgt = b.target;
    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }
  r2.bindings = [];
  r2.beforeRenderCallbacks = [];
  r2.onUpdateEleCalcsFns = [];
  if (r2.removeObserver) {
    r2.removeObserver.disconnect();
  }
  if (r2.styleObserver) {
    r2.styleObserver.disconnect();
  }
  if (r2.resizeObserver) {
    r2.resizeObserver.disconnect();
  }
  if (r2.labelCalcDiv) {
    try {
      document.body.removeChild(r2.labelCalcDiv);
    } catch (e) {
    }
  }
};
BRp.isHeadless = function() {
  return false;
};
[BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function(props) {
  extend(BRp, props);
});
var fullFpsTime = 1e3 / 60;
var defs = {
  setupDequeueing: /* @__PURE__ */ __name(function setupDequeueing(opts) {
    return /* @__PURE__ */ __name(function setupDequeueingImpl() {
      var self2 = this;
      var r2 = this.renderer;
      if (self2.dequeueingSetup) {
        return;
      } else {
        self2.dequeueingSetup = true;
      }
      var queueRedraw = debounce(function() {
        r2.redrawHint("eles", true);
        r2.redrawHint("drag", true);
        r2.redraw();
      }, opts.deqRedrawThreshold);
      var dequeue = /* @__PURE__ */ __name(function dequeue2(willDraw, frameStartTime) {
        var startTime = performanceNow();
        var avgRenderTime = r2.averageRedrawTime;
        var renderTime = r2.lastRedrawTime;
        var deqd = [];
        var extent2 = r2.cy.extent();
        var pixelRatio = r2.getPixelRatio();
        if (!willDraw) {
          r2.flushRenderedStyleQueue();
        }
        while (true) {
          var now2 = performanceNow();
          var duration = now2 - startTime;
          var frameDuration = now2 - frameStartTime;
          if (renderTime < fullFpsTime) {
            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);
            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }
          var thisDeqd = opts.deq(self2, pixelRatio, extent2);
          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        }
        if (deqd.length > 0) {
          opts.onDeqd(self2, deqd);
          if (!willDraw && opts.shouldRedraw(self2, deqd, pixelRatio, extent2)) {
            queueRedraw();
          }
        }
      }, "dequeue2");
      var priority3 = opts.priority || noop$1;
      r2.beforeRender(dequeue, priority3(self2));
    }, "setupDequeueingImpl");
  }, "setupDequeueing")
};
var ElementTextureCacheLookup = /* @__PURE__ */ (function() {
  function ElementTextureCacheLookup2(getKey3) {
    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : falsify;
    _classCallCheck(this, ElementTextureCacheLookup2);
    this.idsByKey = new Map$1();
    this.keyForId = new Map$1();
    this.cachesByLvl = new Map$1();
    this.lvls = [];
    this.getKey = getKey3;
    this.doesEleInvalidateKey = doesEleInvalidateKey;
  }
  __name(ElementTextureCacheLookup2, "ElementTextureCacheLookup2");
  return _createClass(ElementTextureCacheLookup2, [{
    key: "getIdsFor",
    value: /* @__PURE__ */ __name(function getIdsFor(key2) {
      if (key2 == null) {
        error("Can not get id list for null key");
      }
      var idsByKey = this.idsByKey;
      var ids = this.idsByKey.get(key2);
      if (!ids) {
        ids = new Set$1();
        idsByKey.set(key2, ids);
      }
      return ids;
    }, "getIdsFor")
  }, {
    key: "addIdForKey",
    value: /* @__PURE__ */ __name(function addIdForKey(key2, id2) {
      if (key2 != null) {
        this.getIdsFor(key2).add(id2);
      }
    }, "addIdForKey")
  }, {
    key: "deleteIdForKey",
    value: /* @__PURE__ */ __name(function deleteIdForKey(key2, id2) {
      if (key2 != null) {
        this.getIdsFor(key2)["delete"](id2);
      }
    }, "deleteIdForKey")
  }, {
    key: "getNumberOfIdsForKey",
    value: /* @__PURE__ */ __name(function getNumberOfIdsForKey(key2) {
      if (key2 == null) {
        return 0;
      } else {
        return this.getIdsFor(key2).size;
      }
    }, "getNumberOfIdsForKey")
  }, {
    key: "updateKeyMappingFor",
    value: /* @__PURE__ */ __name(function updateKeyMappingFor(ele) {
      var id2 = ele.id();
      var prevKey = this.keyForId.get(id2);
      var currKey = this.getKey(ele);
      this.deleteIdForKey(prevKey, id2);
      this.addIdForKey(currKey, id2);
      this.keyForId.set(id2, currKey);
    }, "updateKeyMappingFor")
  }, {
    key: "deleteKeyMappingFor",
    value: /* @__PURE__ */ __name(function deleteKeyMappingFor(ele) {
      var id2 = ele.id();
      var prevKey = this.keyForId.get(id2);
      this.deleteIdForKey(prevKey, id2);
      this.keyForId["delete"](id2);
    }, "deleteKeyMappingFor")
  }, {
    key: "keyHasChangedFor",
    value: /* @__PURE__ */ __name(function keyHasChangedFor(ele) {
      var id2 = ele.id();
      var prevKey = this.keyForId.get(id2);
      var newKey = this.getKey(ele);
      return prevKey !== newKey;
    }, "keyHasChangedFor")
  }, {
    key: "isInvalid",
    value: /* @__PURE__ */ __name(function isInvalid(ele) {
      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
    }, "isInvalid")
  }, {
    key: "getCachesAt",
    value: /* @__PURE__ */ __name(function getCachesAt(lvl) {
      var cachesByLvl = this.cachesByLvl, lvls = this.lvls;
      var caches = cachesByLvl.get(lvl);
      if (!caches) {
        caches = new Map$1();
        cachesByLvl.set(lvl, caches);
        lvls.push(lvl);
      }
      return caches;
    }, "getCachesAt")
  }, {
    key: "getCache",
    value: /* @__PURE__ */ __name(function getCache(key2, lvl) {
      return this.getCachesAt(lvl).get(key2);
    }, "getCache")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(ele, lvl) {
      var key2 = this.getKey(ele);
      var cache3 = this.getCache(key2, lvl);
      if (cache3 != null) {
        this.updateKeyMappingFor(ele);
      }
      return cache3;
    }, "get2")
  }, {
    key: "getForCachedKey",
    value: /* @__PURE__ */ __name(function getForCachedKey(ele, lvl) {
      var key2 = this.keyForId.get(ele.id());
      var cache3 = this.getCache(key2, lvl);
      return cache3;
    }, "getForCachedKey")
  }, {
    key: "hasCache",
    value: /* @__PURE__ */ __name(function hasCache(key2, lvl) {
      return this.getCachesAt(lvl).has(key2);
    }, "hasCache")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function has(ele, lvl) {
      var key2 = this.getKey(ele);
      return this.hasCache(key2, lvl);
    }, "has")
  }, {
    key: "setCache",
    value: /* @__PURE__ */ __name(function setCache(key2, lvl, cache3) {
      cache3.key = key2;
      this.getCachesAt(lvl).set(key2, cache3);
    }, "setCache")
  }, {
    key: "set",
    value: /* @__PURE__ */ __name(function set2(ele, lvl, cache3) {
      var key2 = this.getKey(ele);
      this.setCache(key2, lvl, cache3);
      this.updateKeyMappingFor(ele);
    }, "set2")
  }, {
    key: "deleteCache",
    value: /* @__PURE__ */ __name(function deleteCache(key2, lvl) {
      this.getCachesAt(lvl)["delete"](key2);
    }, "deleteCache")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(ele, lvl) {
      var key2 = this.getKey(ele);
      this.deleteCache(key2, lvl);
    }, "_delete")
  }, {
    key: "invalidateKey",
    value: /* @__PURE__ */ __name(function invalidateKey(key2) {
      var _this = this;
      this.lvls.forEach(function(lvl) {
        return _this.deleteCache(key2, lvl);
      });
    }, "invalidateKey")
    // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
  }, {
    key: "invalidate",
    value: /* @__PURE__ */ __name(function invalidate(ele) {
      var id2 = ele.id();
      var key2 = this.keyForId.get(id2);
      this.deleteKeyMappingFor(ele);
      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);
      if (entireKeyInvalidated) {
        this.invalidateKey(key2);
      }
      return entireKeyInvalidated || this.getNumberOfIdsForKey(key2) === 0;
    }, "invalidate")
  }]);
})();
var minTxrH = 25;
var txrStepH = 50;
var minLvl$1 = -4;
var maxLvl$1 = 3;
var maxZoom$1 = 7.99;
var eleTxrSpacing = 8;
var defTxrWidth = 1024;
var maxTxrW = 1024;
var maxTxrH = 1024;
var minUtility = 0.2;
var maxFullness = 0.8;
var maxFullnessChecks = 10;
var deqCost$1 = 0.15;
var deqAvgCost$1 = 0.1;
var deqNoDrawCost$1 = 0.9;
var deqFastCost$1 = 0.9;
var deqRedrawThreshold$1 = 100;
var maxDeqSize$1 = 1;
var getTxrReasons = {
  dequeue: "dequeue",
  downscale: "downscale",
  highQuality: "highQuality"
};
var initDefaults = defaults$g({
  getKey: null,
  doesEleInvalidateKey: falsify,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: trueify,
  allowEdgeTxrCaching: true,
  allowParentTxrCaching: true
});
var ElementTextureCache = /* @__PURE__ */ __name(function ElementTextureCache2(renderer3, initOptions) {
  var self2 = this;
  self2.renderer = renderer3;
  self2.onDequeues = [];
  var opts = initDefaults(initOptions);
  extend(self2, opts);
  self2.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
  self2.setupDequeueing();
}, "ElementTextureCache2");
var ETCp = ElementTextureCache.prototype;
ETCp.reasons = getTxrReasons;
ETCp.getTextureQueue = function(txrH) {
  var self2 = this;
  self2.eleImgCaches = self2.eleImgCaches || {};
  return self2.eleImgCaches[txrH] = self2.eleImgCaches[txrH] || [];
};
ETCp.getRetiredTextureQueue = function(txrH) {
  var self2 = this;
  var rtxtrQs = self2.eleImgCaches.retired = self2.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
  return rtxtrQ;
};
ETCp.getElementQueue = function() {
  var self2 = this;
  var q = self2.eleCacheQueue = self2.eleCacheQueue || new Heap(function(a, b) {
    return b.reqs - a.reqs;
  });
  return q;
};
ETCp.getElementKeyToQueue = function() {
  var self2 = this;
  var k2q = self2.eleKeyToCacheQueue = self2.eleKeyToCacheQueue || {};
  return k2q;
};
ETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {
  var self2 = this;
  var r2 = this.renderer;
  var zoom2 = r2.cy.zoom();
  var lookup2 = this.lookup;
  if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {
    return null;
  }
  if (!self2.allowEdgeTxrCaching && ele.isEdge() || !self2.allowParentTxrCaching && ele.isParent()) {
    return null;
  }
  if (lvl == null) {
    lvl = Math.ceil(log2(zoom2 * pxRatio));
  }
  if (lvl < minLvl$1) {
    lvl = minLvl$1;
  } else if (zoom2 >= maxZoom$1 || lvl > maxLvl$1) {
    return null;
  }
  var scale2 = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale2;
  var eleScaledW = bb.w * scale2;
  var scaledLabelShown = r2.eleTextBiggerThanMin(ele, scale2);
  if (!this.isVisible(ele, scaledLabelShown)) {
    return null;
  }
  var eleCache = lookup2.get(ele, lvl);
  if (eleCache && eleCache.invalidated) {
    eleCache.invalidated = false;
    eleCache.texture.invalidatedWidth -= eleCache.width;
  }
  if (eleCache) {
    return eleCache;
  }
  var txrH;
  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }
  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
    return null;
  }
  var txrQ = self2.getTextureQueue(txrH);
  var txr = txrQ[txrQ.length - 2];
  var addNewTxr = /* @__PURE__ */ __name(function addNewTxr2() {
    return self2.recycleTexture(txrH, eleScaledW) || self2.addTexture(txrH, eleScaledW);
  }, "addNewTxr2");
  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  }
  if (!txr) {
    txr = addNewTxr();
  }
  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }
  var scalableFrom = /* @__PURE__ */ __name(function scalableFrom2(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  }, "scalableFrom2");
  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;
  var higherCache;
  for (var l = lvl + 1; l <= maxLvl$1; l++) {
    var c = lookup2.get(ele, l);
    if (c) {
      higherCache = c;
      break;
    }
  }
  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;
  var downscale = /* @__PURE__ */ __name(function downscale2() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  }, "downscale2");
  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);
  if (scalableFrom(oneUpCache)) {
    downscale();
  } else if (scalableFrom(higherCache)) {
    if (highQualityReq) {
      for (var _l = higherCache.level; _l > lvl; _l--) {
        oneUpCache = self2.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
      }
      downscale();
    } else {
      self2.queueElement(ele, higherCache.level - 1);
      return higherCache;
    }
  } else {
    var lowerCache;
    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--) {
        var _c2 = lookup2.get(ele, _l2);
        if (_c2) {
          lowerCache = _c2;
          break;
        }
      }
    }
    if (scalableFrom(lowerCache)) {
      self2.queueElement(ele, lvl);
      return lowerCache;
    }
    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale2, scale2);
    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
    txr.context.scale(1 / scale2, 1 / scale2);
    txr.context.translate(-txr.usedWidth, 0);
  }
  eleCache = {
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale2,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown
  };
  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
  txr.eleCaches.push(eleCache);
  lookup2.set(ele, lvl, eleCache);
  self2.checkTextureFullness(txr);
  return eleCache;
};
ETCp.invalidateElements = function(eles) {
  for (var i = 0; i < eles.length; i++) {
    this.invalidateElement(eles[i]);
  }
};
ETCp.invalidateElement = function(ele) {
  var self2 = this;
  var lookup2 = self2.lookup;
  var caches = [];
  var invalid = lookup2.isInvalid(ele);
  if (!invalid) {
    return;
  }
  for (var lvl = minLvl$1; lvl <= maxLvl$1; lvl++) {
    var cache3 = lookup2.getForCachedKey(ele, lvl);
    if (cache3) {
      caches.push(cache3);
    }
  }
  var noOtherElesUseCache = lookup2.invalidate(ele);
  if (noOtherElesUseCache) {
    for (var i = 0; i < caches.length; i++) {
      var _cache = caches[i];
      var txr = _cache.texture;
      txr.invalidatedWidth += _cache.width;
      _cache.invalidated = true;
      self2.checkTextureUtility(txr);
    }
  }
  self2.removeFromQueue(ele);
};
ETCp.checkTextureUtility = function(txr) {
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};
ETCp.checkTextureFullness = function(txr) {
  var self2 = this;
  var txrQ = self2.getTextureQueue(txr.height);
  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};
ETCp.retireTexture = function(txr) {
  var self2 = this;
  var txrH = txr.height;
  var txrQ = self2.getTextureQueue(txrH);
  var lookup2 = this.lookup;
  removeFromArray(txrQ, txr);
  txr.retired = true;
  var eleCaches = txr.eleCaches;
  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    lookup2.deleteCache(eleCache.key, eleCache.level);
  }
  clearArray(eleCaches);
  var rtxtrQ = self2.getRetiredTextureQueue(txrH);
  rtxtrQ.push(txr);
};
ETCp.addTexture = function(txrH, minW) {
  var self2 = this;
  var txrQ = self2.getTextureQueue(txrH);
  var txr = {};
  txrQ.push(txr);
  txr.eleCaches = [];
  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;
  txr.canvas = self2.renderer.makeOffscreenCanvas(txr.width, txr.height);
  txr.context = txr.canvas.getContext("2d");
  return txr;
};
ETCp.recycleTexture = function(txrH, minW) {
  var self2 = this;
  var txrQ = self2.getTextureQueue(txrH);
  var rtxtrQ = self2.getRetiredTextureQueue(txrH);
  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];
    if (txr.width >= minW) {
      txr.retired = false;
      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;
      clearArray(txr.eleCaches);
      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);
      removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);
      return txr;
    }
  }
};
ETCp.queueElement = function(ele, lvl) {
  var self2 = this;
  var q = self2.getElementQueue();
  var k2q = self2.getElementKeyToQueue();
  var key2 = this.getKey(ele);
  var existingReq = k2q[key2];
  if (existingReq) {
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.eles.merge(ele);
    existingReq.reqs++;
    q.updateItem(existingReq);
  } else {
    var req = {
      eles: ele.spawn().merge(ele),
      level: lvl,
      reqs: 1,
      key: key2
    };
    q.push(req);
    k2q[key2] = req;
  }
};
ETCp.dequeue = function(pxRatio) {
  var self2 = this;
  var q = self2.getElementQueue();
  var k2q = self2.getElementKeyToQueue();
  var dequeued = [];
  var lookup2 = self2.lookup;
  for (var i = 0; i < maxDeqSize$1; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var key2 = req.key;
      var ele = req.eles[0];
      var cacheExists = lookup2.hasCache(ele, req.level);
      k2q[key2] = null;
      if (cacheExists) {
        continue;
      }
      dequeued.push(req);
      var bb = self2.getBoundingBox(ele);
      self2.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }
  return dequeued;
};
ETCp.removeFromQueue = function(ele) {
  var self2 = this;
  var q = self2.getElementQueue();
  var k2q = self2.getElementKeyToQueue();
  var key2 = this.getKey(ele);
  var req = k2q[key2];
  if (req != null) {
    if (req.eles.length === 1) {
      req.reqs = MAX_INT$1;
      q.updateItem(req);
      q.pop();
      k2q[key2] = null;
    } else {
      req.eles.unmerge(ele);
    }
  }
};
ETCp.onDequeue = function(fn3) {
  this.onDequeues.push(fn3);
};
ETCp.offDequeue = function(fn3) {
  removeFromArray(this.onDequeues, fn3);
};
ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold$1,
  deqCost: deqCost$1,
  deqAvgCost: deqAvgCost$1,
  deqNoDrawCost: deqNoDrawCost$1,
  deqFastCost: deqFastCost$1,
  deq: /* @__PURE__ */ __name(function deq(self2, pxRatio, extent2) {
    return self2.dequeue(pxRatio, extent2);
  }, "deq"),
  onDeqd: /* @__PURE__ */ __name(function onDeqd(self2, deqd) {
    for (var i = 0; i < self2.onDequeues.length; i++) {
      var fn3 = self2.onDequeues[i];
      fn3(deqd);
    }
  }, "onDeqd"),
  shouldRedraw: /* @__PURE__ */ __name(function shouldRedraw(self2, deqd, pxRatio, extent2) {
    for (var i = 0; i < deqd.length; i++) {
      var eles = deqd[i].eles;
      for (var j = 0; j < eles.length; j++) {
        var bb = eles[j].boundingBox();
        if (boundingBoxesIntersect(bb, extent2)) {
          return true;
        }
      }
    }
    return false;
  }, "shouldRedraw"),
  priority: /* @__PURE__ */ __name(function priority(self2) {
    return self2.renderer.beforeRenderPriorities.eleTxrDeq;
  }, "priority")
});
var defNumLayers = 1;
var minLvl = -4;
var maxLvl = 2;
var maxZoom2 = 3.99;
var deqRedrawThreshold = 50;
var refineEleDebounceTime = 50;
var deqCost = 0.15;
var deqAvgCost = 0.1;
var deqNoDrawCost = 0.9;
var deqFastCost = 0.9;
var maxDeqSize = 1;
var invalidThreshold = 250;
var maxLayerArea = 4e3 * 4e3;
var maxLayerDim = 32767;
var useHighQualityEleTxrReqs = true;
var LayeredTextureCache = /* @__PURE__ */ __name(function LayeredTextureCache2(renderer3) {
  var self2 = this;
  var r2 = self2.renderer = renderer3;
  var cy = r2.cy;
  self2.layersByLevel = {};
  self2.firstGet = true;
  self2.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
  self2.skipping = false;
  self2.eleTxrDeqs = cy.collection();
  self2.scheduleElementRefinement = debounce(function() {
    self2.refineElementTextures(self2.eleTxrDeqs);
    self2.eleTxrDeqs.unmerge(self2.eleTxrDeqs);
  }, refineEleDebounceTime);
  r2.beforeRender(function(willDraw, now2) {
    if (now2 - self2.lastInvalidationTime <= invalidThreshold) {
      self2.skipping = true;
    } else {
      self2.skipping = false;
    }
  }, r2.beforeRenderPriorities.lyrTxrSkip);
  var qSort = /* @__PURE__ */ __name(function qSort2(a, b) {
    return b.reqs - a.reqs;
  }, "qSort2");
  self2.layersQueue = new Heap(qSort);
  self2.setupDequeueing();
}, "LayeredTextureCache2");
var LTCp = LayeredTextureCache.prototype;
var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;
LTCp.makeLayer = function(bb, lvl) {
  var scale2 = Math.pow(2, lvl);
  var w = Math.ceil(bb.w * scale2);
  var h = Math.ceil(bb.h * scale2);
  var canvas = this.renderer.makeOffscreenCanvas(w, h);
  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT,
    bb,
    level: lvl,
    width: w,
    height: h,
    canvas,
    context: canvas.getContext("2d"),
    eles: [],
    elesQueue: [],
    reqs: 0
  };
  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;
  cxt.scale(scale2, scale2);
  cxt.translate(dx, dy);
  return layer;
};
LTCp.getLayers = function(eles, pxRatio, lvl) {
  var self2 = this;
  var r2 = self2.renderer;
  var cy = r2.cy;
  var zoom2 = cy.zoom();
  var firstGet = self2.firstGet;
  self2.firstGet = false;
  if (lvl == null) {
    lvl = Math.ceil(log2(zoom2 * pxRatio));
    if (lvl < minLvl) {
      lvl = minLvl;
    } else if (zoom2 >= maxZoom2 || lvl > maxLvl) {
      return null;
    }
  }
  self2.validateLayersElesOrdering(lvl, eles);
  var layersByLvl = self2.layersByLevel;
  var scale2 = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;
  var lvlComplete = self2.levelIsComplete(lvl, eles);
  var tmpLayers;
  var checkTempLevels = /* @__PURE__ */ __name(function checkTempLevels2() {
    var canUseAsTmpLvl = /* @__PURE__ */ __name(function canUseAsTmpLvl2(l) {
      self2.validateLayersElesOrdering(l, eles);
      if (self2.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    }, "canUseAsTmpLvl2");
    var checkLvls = /* @__PURE__ */ __name(function checkLvls2(dir) {
      if (tmpLayers) {
        return;
      }
      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    }, "checkLvls2");
    checkLvls(1);
    checkLvls(-1);
    for (var i2 = layers.length - 1; i2 >= 0; i2--) {
      var layer2 = layers[i2];
      if (layer2.invalid) {
        removeFromArray(layers, layer2);
      }
    }
  }, "checkTempLevels2");
  if (!lvlComplete) {
    checkTempLevels();
  } else {
    return layers;
  }
  var getBb = /* @__PURE__ */ __name(function getBb2() {
    if (!bb) {
      bb = makeBoundingBox();
      for (var i2 = 0; i2 < eles.length; i2++) {
        updateBoundingBox(bb, eles[i2].boundingBox());
      }
    }
    return bb;
  }, "getBb2");
  var makeLayer = /* @__PURE__ */ __name(function makeLayer2(opts) {
    opts = opts || {};
    var after = opts.after;
    getBb();
    var w = Math.ceil(bb.w * scale2);
    var h = Math.ceil(bb.h * scale2);
    if (w > maxLayerDim || h > maxLayerDim) {
      return null;
    }
    var area = w * h;
    if (area > maxLayerArea) {
      return null;
    }
    var layer2 = self2.makeLayer(bb, lvl);
    if (after != null) {
      var index2 = layers.indexOf(after) + 1;
      layers.splice(index2, 0, layer2);
    } else if (opts.insert === void 0 || opts.insert) {
      layers.unshift(layer2);
    }
    return layer2;
  }, "makeLayer2");
  if (self2.skipping && !firstGet) {
    return null;
  }
  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = !firstGet;
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};
    var existingLayer = caches[lvl];
    if (existingLayer) {
      layer = existingLayer;
      continue;
    }
    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      layer = makeLayer({
        insert: true,
        after: layer
      });
      if (!layer) {
        return null;
      }
    }
    if (tmpLayers || allowLazyQueueing) {
      self2.queueLayer(layer, ele);
    } else {
      self2.drawEleInLayer(layer, ele, lvl, pxRatio);
    }
    layer.eles.push(ele);
    caches[lvl] = layer;
  }
  if (tmpLayers) {
    return tmpLayers;
  }
  if (allowLazyQueueing) {
    return null;
  }
  return layers;
};
LTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {
  return lvl;
};
LTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {
  var self2 = this;
  var r2 = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();
  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }
  lvl = self2.getEleLevelForLayerLevel(lvl, pxRatio);
  {
    r2.setImgSmoothing(context, false);
  }
  {
    r2.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
  }
  {
    r2.setImgSmoothing(context, true);
  }
};
LTCp.levelIsComplete = function(lvl, eles) {
  var self2 = this;
  var layers = self2.layersByLevel[lvl];
  if (!layers || layers.length === 0) {
    return false;
  }
  var numElesInLayers = 0;
  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    if (layer.reqs > 0) {
      return false;
    }
    if (layer.invalid) {
      return false;
    }
    numElesInLayers += layer.eles.length;
  }
  if (numElesInLayers !== eles.length) {
    return false;
  }
  return true;
};
LTCp.validateLayersElesOrdering = function(lvl, eles) {
  var layers = this.layersByLevel[lvl];
  if (!layers) {
    return;
  }
  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1;
    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }
    if (offset < 0) {
      this.invalidateLayer(layer);
      continue;
    }
    var o = offset;
    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        this.invalidateLayer(layer);
        break;
      }
    }
  }
};
LTCp.updateElementsInLayers = function(eles, update2) {
  var self2 = this;
  var isEles = element(eles[0]);
  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};
    for (var l = minLvl; l <= maxLvl; l++) {
      var layer = caches[l];
      if (!layer) {
        continue;
      }
      if (req && self2.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }
      update2(layer, ele, req);
    }
  }
};
LTCp.haveLayers = function() {
  var self2 = this;
  var haveLayers = false;
  for (var l = minLvl; l <= maxLvl; l++) {
    var layers = self2.layersByLevel[l];
    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }
  return haveLayers;
};
LTCp.invalidateElements = function(eles) {
  var self2 = this;
  if (eles.length === 0) {
    return;
  }
  self2.lastInvalidationTime = performanceNow();
  if (eles.length === 0 || !self2.haveLayers()) {
    return;
  }
  self2.updateElementsInLayers(eles, /* @__PURE__ */ __name(function invalAssocLayers(layer, ele, req) {
    self2.invalidateLayer(layer);
  }, "invalAssocLayers"));
};
LTCp.invalidateLayer = function(layer) {
  this.lastInvalidationTime = performanceNow();
  if (layer.invalid) {
    return;
  }
  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl];
  removeFromArray(layers, layer);
  layer.elesQueue = [];
  layer.invalid = true;
  if (layer.replacement) {
    layer.replacement.invalid = true;
  }
  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;
    if (caches) {
      caches[lvl] = null;
    }
  }
};
LTCp.refineElementTextures = function(eles) {
  var self2 = this;
  self2.updateElementsInLayers(eles, /* @__PURE__ */ __name(function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;
    if (!rLyr) {
      rLyr = layer.replacement = self2.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;
    }
    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self2.queueLayer(rLyr, rLyr.eles[i]);
      }
    }
  }, "refineEachEle"));
};
LTCp.enqueueElementRefinement = function(ele) {
  this.eleTxrDeqs.merge(ele);
  this.scheduleElementRefinement();
};
LTCp.queueLayer = function(layer, ele) {
  var self2 = this;
  var q = self2.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};
  if (layer.replacement) {
    return;
  }
  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }
    elesQ.push(ele);
    hasId[ele.id()] = true;
  }
  if (layer.reqs) {
    layer.reqs++;
    q.updateItem(layer);
  } else {
    layer.reqs = 1;
    q.push(layer);
  }
};
LTCp.dequeue = function(pxRatio) {
  var self2 = this;
  var q = self2.layersQueue;
  var deqd = [];
  var eleDeqs = 0;
  while (eleDeqs < maxDeqSize) {
    if (q.size() === 0) {
      break;
    }
    var layer = q.peek();
    if (layer.replacement) {
      q.pop();
      continue;
    }
    if (layer.replaces && layer !== layer.replaces.replacement) {
      q.pop();
      continue;
    }
    if (layer.invalid) {
      q.pop();
      continue;
    }
    var ele = layer.elesQueue.shift();
    if (ele) {
      self2.drawEleInLayer(layer, ele, layer.level, pxRatio);
      eleDeqs++;
    }
    if (deqd.length === 0) {
      deqd.push(true);
    }
    if (layer.elesQueue.length === 0) {
      q.pop();
      layer.reqs = 0;
      if (layer.replaces) {
        self2.applyLayerReplacement(layer);
      }
      self2.requestRedraw();
    }
  }
  return deqd;
};
LTCp.applyLayerReplacement = function(layer) {
  var self2 = this;
  var layersInLevel = self2.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index2 = layersInLevel.indexOf(replaced);
  if (index2 < 0 || replaced.invalid) {
    return;
  }
  layersInLevel[index2] = layer;
  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache3 = _p.imgLayerCaches = _p.imgLayerCaches || {};
    if (cache3) {
      cache3[layer.level] = layer;
    }
  }
  self2.requestRedraw();
};
LTCp.requestRedraw = debounce(function() {
  var r2 = this.renderer;
  r2.redrawHint("eles", true);
  r2.redrawHint("drag", true);
  r2.redraw();
}, 100);
LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold,
  deqCost,
  deqAvgCost,
  deqNoDrawCost,
  deqFastCost,
  deq: /* @__PURE__ */ __name(function deq2(self2, pxRatio) {
    return self2.dequeue(pxRatio);
  }, "deq2"),
  onDeqd: noop$1,
  shouldRedraw: trueify,
  priority: /* @__PURE__ */ __name(function priority2(self2) {
    return self2.renderer.beforeRenderPriorities.lyrTxrDeq;
  }, "priority2")
});
var CRp$b = {};
var impl;
function polygon(context, points) {
  for (var i = 0; i < points.length; i++) {
    var pt = points[i];
    context.lineTo(pt.x, pt.y);
  }
}
__name(polygon, "polygon");
function triangleBackcurve(context, points, controlPoint) {
  var firstPt;
  for (var i = 0; i < points.length; i++) {
    var pt = points[i];
    if (i === 0) {
      firstPt = pt;
    }
    context.lineTo(pt.x, pt.y);
  }
  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
}
__name(triangleBackcurve, "triangleBackcurve");
function triangleTee(context, trianglePoints, teePoints) {
  if (context.beginPath) {
    context.beginPath();
  }
  var triPts = trianglePoints;
  for (var i = 0; i < triPts.length; i++) {
    var pt = triPts[i];
    context.lineTo(pt.x, pt.y);
  }
  var teePts = teePoints;
  var firstTeePt = teePoints[0];
  context.moveTo(firstTeePt.x, firstTeePt.y);
  for (var i = 1; i < teePts.length; i++) {
    var pt = teePts[i];
    context.lineTo(pt.x, pt.y);
  }
  if (context.closePath) {
    context.closePath();
  }
}
__name(triangleTee, "triangleTee");
function circleTriangle(context, trianglePoints, rx, ry, r2) {
  if (context.beginPath) {
    context.beginPath();
  }
  context.arc(rx, ry, r2, 0, Math.PI * 2, false);
  var triPts = trianglePoints;
  var firstTrPt = triPts[0];
  context.moveTo(firstTrPt.x, firstTrPt.y);
  for (var i = 0; i < triPts.length; i++) {
    var pt = triPts[i];
    context.lineTo(pt.x, pt.y);
  }
  if (context.closePath) {
    context.closePath();
  }
}
__name(circleTriangle, "circleTriangle");
function circle$1(context, rx, ry, r2) {
  context.arc(rx, ry, r2, 0, Math.PI * 2, false);
}
__name(circle$1, "circle$1");
CRp$b.arrowShapeImpl = function(name) {
  return (impl || (impl = {
    "polygon": polygon,
    "triangle-backcurve": triangleBackcurve,
    "triangle-tee": triangleTee,
    "circle-triangle": circleTriangle,
    "triangle-cross": triangleTee,
    "circle": circle$1
  }))[name];
};
var CRp$a = {};
CRp$a.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
  var r2 = this;
  if (ele.isNode()) {
    r2.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  } else {
    r2.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  }
};
CRp$a.drawElementOverlay = function(context, ele) {
  var r2 = this;
  if (ele.isNode()) {
    r2.drawNodeOverlay(context, ele);
  } else {
    r2.drawEdgeOverlay(context, ele);
  }
};
CRp$a.drawElementUnderlay = function(context, ele) {
  var r2 = this;
  if (ele.isNode()) {
    r2.drawNodeUnderlay(context, ele);
  } else {
    r2.drawEdgeUnderlay(context, ele);
  }
};
CRp$a.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity3) {
  var r2 = this;
  var bb = eleTxrCache.getBoundingBox(ele);
  if (bb.w === 0 || bb.h === 0) {
    return;
  }
  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);
  if (eleCache != null) {
    var opacity = getOpacity3(r2, ele);
    if (opacity === 0) {
      return;
    }
    var theta = getRotation(r2, ele);
    var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;
    var x2, y2, sx, sy, smooth;
    if (theta !== 0) {
      var rotPt = eleTxrCache.getRotationPoint(ele);
      sx = rotPt.x;
      sy = rotPt.y;
      context.translate(sx, sy);
      context.rotate(theta);
      smooth = r2.getImgSmoothing(context);
      if (!smooth) {
        r2.setImgSmoothing(context, true);
      }
      var off = eleTxrCache.getRotationOffset(ele);
      x2 = off.x;
      y2 = off.y;
    } else {
      x2 = x1;
      y2 = y1;
    }
    var oldGlobalAlpha;
    if (opacity !== 1) {
      oldGlobalAlpha = context.globalAlpha;
      context.globalAlpha = oldGlobalAlpha * opacity;
    }
    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x2, y2, w, h);
    if (opacity !== 1) {
      context.globalAlpha = oldGlobalAlpha;
    }
    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-sx, -sy);
      if (!smooth) {
        r2.setImgSmoothing(context, false);
      }
    }
  } else {
    eleTxrCache.drawElement(context, ele);
  }
};
var getZeroRotation = /* @__PURE__ */ __name(function getZeroRotation2() {
  return 0;
}, "getZeroRotation2");
var getLabelRotation = /* @__PURE__ */ __name(function getLabelRotation2(r2, ele) {
  return r2.getTextAngle(ele, null);
}, "getLabelRotation2");
var getSourceLabelRotation = /* @__PURE__ */ __name(function getSourceLabelRotation2(r2, ele) {
  return r2.getTextAngle(ele, "source");
}, "getSourceLabelRotation2");
var getTargetLabelRotation = /* @__PURE__ */ __name(function getTargetLabelRotation2(r2, ele) {
  return r2.getTextAngle(ele, "target");
}, "getTargetLabelRotation2");
var getOpacity = /* @__PURE__ */ __name(function getOpacity2(r2, ele) {
  return ele.effectiveOpacity();
}, "getOpacity2");
var getTextOpacity = /* @__PURE__ */ __name(function getTextOpacity2(e, ele) {
  return ele.pstyle("text-opacity").pfValue * ele.effectiveOpacity();
}, "getTextOpacity2");
CRp$a.drawCachedElement = function(context, ele, pxRatio, extent2, lvl, requestHighQuality) {
  var r2 = this;
  var _r$data = r2.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;
  var bb = ele.boundingBox();
  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;
  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }
  if (!extent2 || boundingBoxesIntersect(bb, extent2)) {
    var isEdge2 = ele.isEdge();
    var badLine = ele.element()._private.rscratch.badLine;
    r2.drawElementUnderlay(context, ele);
    r2.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);
    if (!isEdge2 || !badLine) {
      r2.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
    }
    if (isEdge2 && !badLine) {
      r2.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
      r2.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
    }
    r2.drawElementOverlay(context, ele);
  }
};
CRp$a.drawElements = function(context, eles) {
  var r2 = this;
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r2.drawElement(context, ele);
  }
};
CRp$a.drawCachedElements = function(context, eles, pxRatio, extent2) {
  var r2 = this;
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r2.drawCachedElement(context, ele, pxRatio, extent2);
  }
};
CRp$a.drawCachedNodes = function(context, eles, pxRatio, extent2) {
  var r2 = this;
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    if (!ele.isNode()) {
      continue;
    }
    r2.drawCachedElement(context, ele, pxRatio, extent2);
  }
};
CRp$a.drawLayeredElements = function(context, eles, pxRatio, extent2) {
  var r2 = this;
  var layers = r2.data.lyrTxrCache.getLayers(eles, pxRatio);
  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;
      if (bb.w === 0 || bb.h === 0) {
        continue;
      }
      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    r2.drawCachedElements(context, eles, pxRatio, extent2);
  }
};
var CRp$9 = {};
CRp$9.drawEdge = function(context, edge, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var r2 = this;
  var rs = edge._private.rscratch;
  if (shouldDrawOpacity && !edge.visible()) {
    return;
  }
  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    return;
  }
  var bb;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }
  var opacity = shouldDrawOpacity ? edge.pstyle("opacity").value : 1;
  var lineOpacity = shouldDrawOpacity ? edge.pstyle("line-opacity").value : 1;
  var curveStyle = edge.pstyle("curve-style").value;
  var lineStyle = edge.pstyle("line-style").value;
  var edgeWidth = edge.pstyle("width").pfValue;
  var lineCap = edge.pstyle("line-cap").value;
  var lineOutlineWidth = edge.pstyle("line-outline-width").value;
  var lineOutlineColor = edge.pstyle("line-outline-color").value;
  var effectiveLineOpacity = opacity * lineOpacity;
  var effectiveArrowOpacity = opacity * lineOpacity;
  var drawLine = /* @__PURE__ */ __name(function drawLine2() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : effectiveLineOpacity;
    if (curveStyle === "straight-triangle") {
      r2.eleStrokeStyle(context, edge, strokeOpacity);
      r2.drawEdgeTrianglePath(edge, context, rs.allpts);
    } else {
      context.lineWidth = edgeWidth;
      context.lineCap = lineCap;
      r2.eleStrokeStyle(context, edge, strokeOpacity);
      r2.drawEdgePath(edge, context, rs.allpts, lineStyle);
      context.lineCap = "butt";
    }
  }, "drawLine2");
  var drawLineOutline = /* @__PURE__ */ __name(function drawLineOutline2() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : effectiveLineOpacity;
    context.lineWidth = edgeWidth + lineOutlineWidth;
    context.lineCap = lineCap;
    if (lineOutlineWidth > 0) {
      r2.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);
    } else {
      context.lineCap = "butt";
      return;
    }
    if (curveStyle === "straight-triangle") {
      r2.drawEdgeTrianglePath(edge, context, rs.allpts);
    } else {
      r2.drawEdgePath(edge, context, rs.allpts, lineStyle);
      context.lineCap = "butt";
    }
  }, "drawLineOutline2");
  var drawOverlay = /* @__PURE__ */ __name(function drawOverlay2() {
    if (!shouldDrawOverlay) {
      return;
    }
    r2.drawEdgeOverlay(context, edge);
  }, "drawOverlay2");
  var drawUnderlay = /* @__PURE__ */ __name(function drawUnderlay2() {
    if (!shouldDrawOverlay) {
      return;
    }
    r2.drawEdgeUnderlay(context, edge);
  }, "drawUnderlay2");
  var drawArrows = /* @__PURE__ */ __name(function drawArrows2() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : effectiveArrowOpacity;
    r2.drawArrowheads(context, edge, arrowOpacity);
  }, "drawArrows2");
  var drawText = /* @__PURE__ */ __name(function drawText2() {
    r2.drawElementText(context, edge, null, drawLabel);
  }, "drawText2");
  context.lineJoin = "round";
  var ghost = edge.pstyle("ghost").value === "yes";
  if (ghost) {
    var gx = edge.pstyle("ghost-offset-x").pfValue;
    var gy = edge.pstyle("ghost-offset-y").pfValue;
    var ghostOpacity = edge.pstyle("ghost-opacity").value;
    var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;
    context.translate(gx, gy);
    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);
    context.translate(-gx, -gy);
  } else {
    drawLineOutline();
  }
  drawUnderlay();
  drawLine();
  drawArrows();
  drawOverlay();
  drawText();
  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};
var drawEdgeOverlayUnderlay = /* @__PURE__ */ __name(function drawEdgeOverlayUnderlay2(overlayOrUnderlay) {
  if (!["overlay", "underlay"].includes(overlayOrUnderlay)) {
    throw new Error("Invalid state");
  }
  return function(context, edge) {
    if (!edge.visible()) {
      return;
    }
    var opacity = edge.pstyle("".concat(overlayOrUnderlay, "-opacity")).value;
    if (opacity === 0) {
      return;
    }
    var r2 = this;
    var usePaths = r2.usePaths();
    var rs = edge._private.rscratch;
    var padding = edge.pstyle("".concat(overlayOrUnderlay, "-padding")).pfValue;
    var width2 = 2 * padding;
    var color = edge.pstyle("".concat(overlayOrUnderlay, "-color")).value;
    context.lineWidth = width2;
    if (rs.edgeType === "self" && !usePaths) {
      context.lineCap = "butt";
    } else {
      context.lineCap = "round";
    }
    r2.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
    r2.drawEdgePath(edge, context, rs.allpts, "solid");
  };
}, "drawEdgeOverlayUnderlay2");
CRp$9.drawEdgeOverlay = drawEdgeOverlayUnderlay("overlay");
CRp$9.drawEdgeUnderlay = drawEdgeOverlayUnderlay("underlay");
CRp$9.drawEdgePath = function(edge, context, pts2, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();
  var lineDashPattern = edge.pstyle("line-dash-pattern").pfValue;
  var lineDashOffset = edge.pstyle("line-dash-offset").pfValue;
  if (usePaths) {
    var pathCacheKey = pts2.join("$");
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;
    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }
  if (canvasCxt.setLineDash) {
    switch (type) {
      case "dotted":
        canvasCxt.setLineDash([1, 1]);
        break;
      case "dashed":
        canvasCxt.setLineDash(lineDashPattern);
        canvasCxt.lineDashOffset = lineDashOffset;
        break;
      case "solid":
        canvasCxt.setLineDash([]);
        break;
    }
  }
  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }
    context.moveTo(pts2[0], pts2[1]);
    switch (rs.edgeType) {
      case "bezier":
      case "self":
      case "compound":
      case "multibezier":
        for (var i = 2; i + 3 < pts2.length; i += 4) {
          context.quadraticCurveTo(pts2[i], pts2[i + 1], pts2[i + 2], pts2[i + 3]);
        }
        break;
      case "straight":
      case "haystack":
        for (var _i = 2; _i + 1 < pts2.length; _i += 2) {
          context.lineTo(pts2[_i], pts2[_i + 1]);
        }
        break;
      case "segments":
        if (rs.isRound) {
          var _iterator = _createForOfIteratorHelper(rs.roundCorners), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var corner = _step.value;
              drawPreparedRoundCorner(context, corner);
            }
          } catch (err2) {
            _iterator.e(err2);
          } finally {
            _iterator.f();
          }
          context.lineTo(pts2[pts2.length - 2], pts2[pts2.length - 1]);
        } else {
          for (var _i2 = 2; _i2 + 1 < pts2.length; _i2 += 2) {
            context.lineTo(pts2[_i2], pts2[_i2 + 1]);
          }
        }
        break;
    }
  }
  context = canvasCxt;
  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  }
  if (context.setLineDash) {
    context.setLineDash([]);
  }
};
CRp$9.drawEdgeTrianglePath = function(edge, context, pts2) {
  context.fillStyle = context.strokeStyle;
  var edgeWidth = edge.pstyle("width").pfValue;
  for (var i = 0; i + 1 < pts2.length; i += 2) {
    var vector = [pts2[i + 2] - pts2[i], pts2[i + 3] - pts2[i + 1]];
    var length2 = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
    var normal2 = [vector[1] / length2, -vector[0] / length2];
    var triangleHead = [normal2[0] * edgeWidth / 2, normal2[1] * edgeWidth / 2];
    context.beginPath();
    context.moveTo(pts2[i] - triangleHead[0], pts2[i + 1] - triangleHead[1]);
    context.lineTo(pts2[i] + triangleHead[0], pts2[i + 1] + triangleHead[1]);
    context.lineTo(pts2[i + 2], pts2[i + 3]);
    context.closePath();
    context.fill();
  }
};
CRp$9.drawArrowheads = function(context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === "haystack";
  if (!isHaystack) {
    this.drawArrowhead(context, edge, "source", rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }
  this.drawArrowhead(context, edge, "mid-target", rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
  this.drawArrowhead(context, edge, "mid-source", rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);
  if (!isHaystack) {
    this.drawArrowhead(context, edge, "target", rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};
CRp$9.drawArrowhead = function(context, edge, prefix, x2, y2, angle2, opacity) {
  if (isNaN(x2) || x2 == null || isNaN(y2) || y2 == null || isNaN(angle2) || angle2 == null) {
    return;
  }
  var self2 = this;
  var arrowShape = edge.pstyle(prefix + "-arrow-shape").value;
  if (arrowShape === "none") {
    return;
  }
  var arrowClearFill = edge.pstyle(prefix + "-arrow-fill").value === "hollow" ? "both" : "filled";
  var arrowFill = edge.pstyle(prefix + "-arrow-fill").value;
  var edgeWidth = edge.pstyle("width").pfValue;
  var pArrowWidth = edge.pstyle(prefix + "-arrow-width");
  var arrowWidth = pArrowWidth.value === "match-line" ? edgeWidth : pArrowWidth.pfValue;
  if (pArrowWidth.units === "%") arrowWidth *= edgeWidth;
  var edgeOpacity = edge.pstyle("opacity").value;
  if (opacity === void 0) {
    opacity = edgeOpacity;
  }
  var gco = context.globalCompositeOperation;
  if (opacity !== 1 || arrowFill === "hollow") {
    context.globalCompositeOperation = "destination-out";
    self2.colorFillStyle(context, 255, 255, 255, 1);
    self2.colorStrokeStyle(context, 255, 255, 255, 1);
    self2.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x2, y2, angle2);
    context.globalCompositeOperation = gco;
  }
  var color = edge.pstyle(prefix + "-arrow-color").value;
  self2.colorFillStyle(context, color[0], color[1], color[2], opacity);
  self2.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
  self2.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x2, y2, angle2);
};
CRp$9.drawArrowShape = function(edge, context, fill, edgeWidth, shape, shapeWidth, x2, y2, angle2) {
  var r2 = this;
  var usePaths = this.usePaths() && shape !== "triangle-cross";
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = {
    x: x2,
    y: y2
  };
  var scale2 = edge.pstyle("arrow-scale").value;
  var size3 = this.getArrowWidth(edgeWidth, scale2);
  var shapeImpl = r2.arrowShapes[shape];
  if (usePaths) {
    var cache3 = r2.arrowPathCache = r2.arrowPathCache || [];
    var key2 = hashString(shape);
    var cachedPath = cache3[key2];
    if (cachedPath != null) {
      path = context = cachedPath;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      cache3[key2] = path;
    }
  }
  if (!pathCacheHit) {
    if (context.beginPath) {
      context.beginPath();
    }
    if (usePaths) {
      shapeImpl.draw(context, 1, 0, {
        x: 0,
        y: 0
      }, 1);
    } else {
      shapeImpl.draw(context, size3, angle2, translation, edgeWidth);
    }
    if (context.closePath) {
      context.closePath();
    }
  }
  context = canvasContext;
  if (usePaths) {
    context.translate(x2, y2);
    context.rotate(angle2);
    context.scale(size3, size3);
  }
  if (fill === "filled" || fill === "both") {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }
  if (fill === "hollow" || fill === "both") {
    context.lineWidth = shapeWidth / (usePaths ? size3 : 1);
    context.lineJoin = "miter";
    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }
  if (usePaths) {
    context.scale(1 / size3, 1 / size3);
    context.rotate(-angle2);
    context.translate(-x2, -y2);
  }
};
var CRp$8 = {};
CRp$8.safeDrawImage = function(context, img, ix, iy, iw, ih, x2, y2, w, h) {
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }
  try {
    context.drawImage(img, ix, iy, iw, ih, x2, y2, w, h);
  } catch (e) {
    warn(e);
  }
};
CRp$8.drawInscribedImage = function(context, img, node, index2, nodeOpacity) {
  var r2 = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit2 = getIndexedStyle(node, "background-fit", "value", index2);
  var repeat = getIndexedStyle(node, "background-repeat", "value", index2);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, "background-width-relative-to", "value", index2) === "inner" ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, "background-height-relative-to", "value", index2) === "inner" ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = getIndexedStyle(node, "background-clip", "value", index2);
  var shouldClip = clip === "node";
  var imgOpacity = getIndexedStyle(node, "background-image-opacity", "value", index2) * nodeOpacity;
  var smooth = getIndexedStyle(node, "background-image-smoothing", "value", index2);
  var cornerRadius = node.pstyle("corner-radius").value;
  if (cornerRadius !== "auto") cornerRadius = node.pstyle("corner-radius").pfValue;
  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;
  if (null == imgW || null == imgH) {
    document.body.appendChild(img);
    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;
    document.body.removeChild(img);
  }
  var w = imgW;
  var h = imgH;
  if (getIndexedStyle(node, "background-width", "value", index2) !== "auto") {
    if (getIndexedStyle(node, "background-width", "units", index2) === "%") {
      w = getIndexedStyle(node, "background-width", "pfValue", index2) * nodeTW;
    } else {
      w = getIndexedStyle(node, "background-width", "pfValue", index2);
    }
  }
  if (getIndexedStyle(node, "background-height", "value", index2) !== "auto") {
    if (getIndexedStyle(node, "background-height", "units", index2) === "%") {
      h = getIndexedStyle(node, "background-height", "pfValue", index2) * nodeTH;
    } else {
      h = getIndexedStyle(node, "background-height", "pfValue", index2);
    }
  }
  if (w === 0 || h === 0) {
    return;
  }
  if (fit2 === "contain") {
    var scale2 = Math.min(nodeTW / w, nodeTH / h);
    w *= scale2;
    h *= scale2;
  } else if (fit2 === "cover") {
    var scale2 = Math.max(nodeTW / w, nodeTH / h);
    w *= scale2;
    h *= scale2;
  }
  var x2 = nodeX - nodeTW / 2;
  var posXUnits = getIndexedStyle(node, "background-position-x", "units", index2);
  var posXPfVal = getIndexedStyle(node, "background-position-x", "pfValue", index2);
  if (posXUnits === "%") {
    x2 += (nodeTW - w) * posXPfVal;
  } else {
    x2 += posXPfVal;
  }
  var offXUnits = getIndexedStyle(node, "background-offset-x", "units", index2);
  var offXPfVal = getIndexedStyle(node, "background-offset-x", "pfValue", index2);
  if (offXUnits === "%") {
    x2 += (nodeTW - w) * offXPfVal;
  } else {
    x2 += offXPfVal;
  }
  var y2 = nodeY - nodeTH / 2;
  var posYUnits = getIndexedStyle(node, "background-position-y", "units", index2);
  var posYPfVal = getIndexedStyle(node, "background-position-y", "pfValue", index2);
  if (posYUnits === "%") {
    y2 += (nodeTH - h) * posYPfVal;
  } else {
    y2 += posYPfVal;
  }
  var offYUnits = getIndexedStyle(node, "background-offset-y", "units", index2);
  var offYPfVal = getIndexedStyle(node, "background-offset-y", "pfValue", index2);
  if (offYUnits === "%") {
    y2 += (nodeTH - h) * offYPfVal;
  } else {
    y2 += offYPfVal;
  }
  if (rs.pathCache) {
    x2 -= nodeX;
    y2 -= nodeY;
    nodeX = 0;
    nodeY = 0;
  }
  var gAlpha = context.globalAlpha;
  context.globalAlpha = imgOpacity;
  var smoothingEnabled = r2.getImgSmoothing(context);
  var isSmoothingSwitched = false;
  if (smooth === "no" && smoothingEnabled) {
    r2.setImgSmoothing(context, false);
    isSmoothingSwitched = true;
  } else if (smooth === "yes" && !smoothingEnabled) {
    r2.setImgSmoothing(context, true);
    isSmoothingSwitched = true;
  }
  if (repeat === "no-repeat") {
    if (shouldClip) {
      context.save();
      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r2.nodeShapes[r2.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);
        context.clip();
      }
    }
    r2.safeDrawImage(context, img, 0, 0, imgW, imgH, x2, y2, w, h);
    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;
    r2.nodeShapes[r2.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);
    context.translate(x2, y2);
    context.fill();
    context.translate(-x2, -y2);
  }
  context.globalAlpha = gAlpha;
  if (isSmoothingSwitched) {
    r2.setImgSmoothing(context, smoothingEnabled);
  }
};
var CRp$7 = {};
CRp$7.eleTextBiggerThanMin = function(ele, scale2) {
  if (!scale2) {
    var zoom2 = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(log2(zoom2 * pxRatio));
    scale2 = Math.pow(2, lvl);
  }
  var computedSize = ele.pstyle("font-size").pfValue * scale2;
  var minSize2 = ele.pstyle("min-zoomed-font-size").pfValue;
  if (computedSize < minSize2) {
    return false;
  }
  return true;
};
CRp$7.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {
  var useEleOpacity = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var r2 = this;
  if (force == null) {
    if (useEleOpacity && !r2.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else if (force === false) {
    return;
  }
  if (ele.isNode()) {
    var label2 = ele.pstyle("label");
    if (!label2 || !label2.value) {
      return;
    }
    var justification = r2.getLabelJustification(ele);
    context.textAlign = justification;
    context.textBaseline = "bottom";
  } else {
    var badLine = ele.element()._private.rscratch.badLine;
    var _label = ele.pstyle("label");
    var srcLabel = ele.pstyle("source-label");
    var tgtLabel = ele.pstyle("target-label");
    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }
    context.textAlign = "center";
    context.textBaseline = "bottom";
  }
  var applyRotation = !shiftToOriginWithBb;
  var bb;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }
  if (prefix == null) {
    r2.drawText(context, ele, null, applyRotation, useEleOpacity);
    if (ele.isEdge()) {
      r2.drawText(context, ele, "source", applyRotation, useEleOpacity);
      r2.drawText(context, ele, "target", applyRotation, useEleOpacity);
    }
  } else {
    r2.drawText(context, ele, prefix, applyRotation, useEleOpacity);
  }
  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};
CRp$7.getFontCache = function(context) {
  var cache3;
  this.fontCaches = this.fontCaches || [];
  for (var i = 0; i < this.fontCaches.length; i++) {
    cache3 = this.fontCaches[i];
    if (cache3.context === context) {
      return cache3;
    }
  }
  cache3 = {
    context
  };
  this.fontCaches.push(cache3);
  return cache3;
};
CRp$7.setupTextStyle = function(context, ele) {
  var useEleOpacity = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var labelStyle = ele.pstyle("font-style").strValue;
  var labelSize = ele.pstyle("font-size").pfValue + "px";
  var labelFamily = ele.pstyle("font-family").strValue;
  var labelWeight = ele.pstyle("font-weight").strValue;
  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle("text-opacity").value : 1;
  var outlineOpacity = ele.pstyle("text-outline-opacity").value * opacity;
  var color = ele.pstyle("color").value;
  var outlineColor = ele.pstyle("text-outline-color").value;
  context.font = labelStyle + " " + labelWeight + " " + labelSize + " " + labelFamily;
  context.lineJoin = "round";
  this.colorFillStyle(context, color[0], color[1], color[2], opacity);
  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
};
function circle(ctx, x2, y2, width2, height2) {
  var diameter = Math.min(width2, height2);
  var radius2 = diameter / 2;
  var centerX = x2 + width2 / 2;
  var centerY = y2 + height2 / 2;
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius2, 0, Math.PI * 2);
  ctx.closePath();
}
__name(circle, "circle");
function roundRect(ctx, x2, y2, width2, height2) {
  var radius2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 5;
  var r2 = Math.min(radius2, width2 / 2, height2 / 2);
  ctx.beginPath();
  ctx.moveTo(x2 + r2, y2);
  ctx.lineTo(x2 + width2 - r2, y2);
  ctx.quadraticCurveTo(x2 + width2, y2, x2 + width2, y2 + r2);
  ctx.lineTo(x2 + width2, y2 + height2 - r2);
  ctx.quadraticCurveTo(x2 + width2, y2 + height2, x2 + width2 - r2, y2 + height2);
  ctx.lineTo(x2 + r2, y2 + height2);
  ctx.quadraticCurveTo(x2, y2 + height2, x2, y2 + height2 - r2);
  ctx.lineTo(x2, y2 + r2);
  ctx.quadraticCurveTo(x2, y2, x2 + r2, y2);
  ctx.closePath();
}
__name(roundRect, "roundRect");
CRp$7.getTextAngle = function(ele, prefix) {
  var theta;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var pdash = prefix ? prefix + "-" : "";
  var rotation = ele.pstyle(pdash + "text-rotation");
  if (rotation.strValue === "autorotate") {
    var textAngle = getPrefixedProperty(rscratch, "labelAngle", prefix);
    theta = ele.isEdge() ? textAngle : 0;
  } else if (rotation.strValue === "none") {
    theta = 0;
  } else {
    theta = rotation.pfValue;
  }
  return theta;
};
CRp$7.drawText = function(context, ele, prefix) {
  var applyRotation = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var useEleOpacity = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;
  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle("text-opacity").value === 0)) {
    return;
  }
  if (prefix === "main") {
    prefix = null;
  }
  var textX = getPrefixedProperty(rscratch, "labelX", prefix);
  var textY = getPrefixedProperty(rscratch, "labelY", prefix);
  var orgTextX, orgTextY;
  var text2 = this.getLabelText(ele, prefix);
  if (text2 != null && text2 !== "" && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele, useEleOpacity);
    var pdash = prefix ? prefix + "-" : "";
    var textW = getPrefixedProperty(rscratch, "labelWidth", prefix);
    var textH = getPrefixedProperty(rscratch, "labelHeight", prefix);
    var marginX = ele.pstyle(pdash + "text-margin-x").pfValue;
    var marginY = ele.pstyle(pdash + "text-margin-y").pfValue;
    var isEdge2 = ele.isEdge();
    var halign = ele.pstyle("text-halign").value;
    var valign = ele.pstyle("text-valign").value;
    if (isEdge2) {
      halign = "center";
      valign = "center";
    }
    textX += marginX;
    textY += marginY;
    var theta;
    if (!applyRotation) {
      theta = 0;
    } else {
      theta = this.getTextAngle(ele, prefix);
    }
    if (theta !== 0) {
      orgTextX = textX;
      orgTextY = textY;
      context.translate(orgTextX, orgTextY);
      context.rotate(theta);
      textX = 0;
      textY = 0;
    }
    switch (valign) {
      case "top":
        break;
      case "center":
        textY += textH / 2;
        break;
      case "bottom":
        textY += textH;
        break;
    }
    var backgroundOpacity = ele.pstyle("text-background-opacity").value;
    var borderOpacity = ele.pstyle("text-border-opacity").value;
    var textBorderWidth = ele.pstyle("text-border-width").pfValue;
    var backgroundPadding = ele.pstyle("text-background-padding").pfValue;
    var styleShape = ele.pstyle("text-background-shape").strValue;
    var rounded = styleShape === "round-rectangle" || styleShape === "roundrectangle";
    var circled = styleShape === "circle";
    var roundRadius = 2;
    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var textFill = context.fillStyle;
      var textStroke = context.strokeStyle;
      var textLineWidth = context.lineWidth;
      var textBackgroundColor = ele.pstyle("text-background-color").value;
      var textBorderColor = ele.pstyle("text-border-color").value;
      var textBorderStyle = ele.pstyle("text-border-style").value;
      var doFill = backgroundOpacity > 0;
      var doStroke = textBorderWidth > 0 && borderOpacity > 0;
      var bgX = textX - backgroundPadding;
      switch (halign) {
        case "left":
          bgX -= textW;
          break;
        case "center":
          bgX -= textW / 2;
          break;
      }
      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;
      if (doFill) {
        context.fillStyle = "rgba(".concat(textBackgroundColor[0], ",").concat(textBackgroundColor[1], ",").concat(textBackgroundColor[2], ",").concat(backgroundOpacity * parentOpacity, ")");
      }
      if (doStroke) {
        context.strokeStyle = "rgba(".concat(textBorderColor[0], ",").concat(textBorderColor[1], ",").concat(textBorderColor[2], ",").concat(borderOpacity * parentOpacity, ")");
        context.lineWidth = textBorderWidth;
        if (context.setLineDash) {
          switch (textBorderStyle) {
            case "dotted":
              context.setLineDash([1, 1]);
              break;
            case "dashed":
              context.setLineDash([4, 2]);
              break;
            case "double":
              context.lineWidth = textBorderWidth / 4;
              context.setLineDash([]);
              break;
            case "solid":
            default:
              context.setLineDash([]);
              break;
          }
        }
      }
      if (rounded) {
        context.beginPath();
        roundRect(context, bgX, bgY, bgW, bgH, roundRadius);
      } else if (circled) {
        context.beginPath();
        circle(context, bgX, bgY, bgW, bgH);
      } else {
        context.beginPath();
        context.rect(bgX, bgY, bgW, bgH);
      }
      if (doFill) context.fill();
      if (doStroke) context.stroke();
      if (doStroke && textBorderStyle === "double") {
        var whiteWidth = textBorderWidth / 2;
        context.beginPath();
        if (rounded) {
          roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth, roundRadius);
        } else {
          context.rect(bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth);
        }
        context.stroke();
      }
      context.fillStyle = textFill;
      context.strokeStyle = textStroke;
      context.lineWidth = textLineWidth;
      if (context.setLineDash) context.setLineDash([]);
    }
    var lineWidth = 2 * ele.pstyle("text-outline-width").pfValue;
    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }
    if (ele.pstyle("text-wrap").value === "wrap") {
      var lines = getPrefixedProperty(rscratch, "labelWrapCachedLines", prefix);
      var lineHeight = getPrefixedProperty(rscratch, "labelLineHeight", prefix);
      var halfTextW = textW / 2;
      var justification = this.getLabelJustification(ele);
      if (justification === "auto") ;
      else if (halign === "left") {
        if (justification === "left") {
          textX += -textW;
        } else if (justification === "center") {
          textX += -halfTextW;
        }
      } else if (halign === "center") {
        if (justification === "left") {
          textX += -halfTextW;
        } else if (justification === "right") {
          textX += halfTextW;
        }
      } else if (halign === "right") {
        if (justification === "center") {
          textX += halfTextW;
        } else if (justification === "right") {
          textX += textW;
        }
      }
      switch (valign) {
        case "top":
          textY -= (lines.length - 1) * lineHeight;
          break;
        case "center":
        case "bottom":
          textY -= (lines.length - 1) * lineHeight;
          break;
      }
      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }
        context.fillText(lines[l], textX, textY);
        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text2, textX, textY);
      }
      context.fillText(text2, textX, textY);
    }
    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};
var CRp$6 = {};
CRp$6.drawNode = function(context, node, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var r2 = this;
  var nodeWidth, nodeHeight;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();
  if (!number$1(pos.x) || !number$1(pos.y)) {
    return;
  }
  if (shouldDrawOpacity && !node.visible()) {
    return;
  }
  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
  var usePaths = r2.usePaths();
  var path;
  var pathCacheHit = false;
  var padding = node.padding();
  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;
  var bb;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }
  var bgImgProp = node.pstyle("background-image");
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;
  for (var i = 0; i < urls.length; i++) {
    var url2 = urls[i];
    var defd = urlDefined[i] = url2 != null && url2 !== "none";
    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, "background-image-crossorigin", "value", i);
      numImages++;
      image[i] = r2.getCachedImage(url2, bgImgCrossOrigin, function() {
        _p.backgroundTimestamp = Date.now();
        node.emitAndNotify("background");
      });
    }
  }
  var darkness = node.pstyle("background-blacken").value;
  var borderWidth = node.pstyle("border-width").pfValue;
  var bgOpacity = node.pstyle("background-opacity").value * eleOpacity;
  var borderColor = node.pstyle("border-color").value;
  var borderStyle = node.pstyle("border-style").value;
  var borderJoin = node.pstyle("border-join").value;
  var borderCap = node.pstyle("border-cap").value;
  var borderPosition = node.pstyle("border-position").value;
  var borderPattern = node.pstyle("border-dash-pattern").pfValue;
  var borderOffset = node.pstyle("border-dash-offset").pfValue;
  var borderOpacity = node.pstyle("border-opacity").value * eleOpacity;
  var outlineWidth = node.pstyle("outline-width").pfValue;
  var outlineColor = node.pstyle("outline-color").value;
  var outlineStyle = node.pstyle("outline-style").value;
  var outlineOpacity = node.pstyle("outline-opacity").value * eleOpacity;
  var outlineOffset = node.pstyle("outline-offset").value;
  var cornerRadius = node.pstyle("corner-radius").value;
  if (cornerRadius !== "auto") cornerRadius = node.pstyle("corner-radius").pfValue;
  var setupShapeColor = /* @__PURE__ */ __name(function setupShapeColor2() {
    var bgOpy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bgOpacity;
    r2.eleFillStyle(context, node, bgOpy);
  }, "setupShapeColor2");
  var setupBorderColor = /* @__PURE__ */ __name(function setupBorderColor2() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : borderOpacity;
    r2.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  }, "setupBorderColor2");
  var setupOutlineColor = /* @__PURE__ */ __name(function setupOutlineColor2() {
    var otlnOpy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : outlineOpacity;
    r2.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);
  }, "setupOutlineColor2");
  var getPath = /* @__PURE__ */ __name(function getPath2(width2, height2, shape, points) {
    var pathCache = r2.nodePathCache = r2.nodePathCache || [];
    var key2 = hashStrings(shape === "polygon" ? shape + "," + points.join(",") : shape, "" + height2, "" + width2, "" + cornerRadius);
    var cachedPath = pathCache[key2];
    var path2;
    var cacheHit = false;
    if (cachedPath != null) {
      path2 = cachedPath;
      cacheHit = true;
      rs.pathCache = path2;
    } else {
      path2 = new Path2D();
      pathCache[key2] = rs.pathCache = path2;
    }
    return {
      path: path2,
      cacheHit
    };
  }, "getPath2");
  var styleShape = node.pstyle("shape").strValue;
  var shapePts = node.pstyle("shape-polygon-points").pfValue;
  if (usePaths) {
    context.translate(pos.x, pos.y);
    var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);
    path = shapePath.path;
    pathCacheHit = shapePath.cacheHit;
  }
  var drawShape = /* @__PURE__ */ __name(function drawShape2() {
    if (!pathCacheHit) {
      var npos = pos;
      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }
      r2.nodeShapes[r2.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);
    }
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }, "drawShape2");
  var drawImages = /* @__PURE__ */ __name(function drawImages2() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : eleOpacity;
    var inside = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var prevBging = _p.backgrounding;
    var totalCompleted = 0;
    for (var _i = 0; _i < image.length; _i++) {
      var bgContainment = node.cy().style().getIndexedStyle(node, "background-image-containment", "value", _i);
      if (inside && bgContainment === "over" || !inside && bgContainment === "inside") {
        totalCompleted++;
        continue;
      }
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r2.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }
    _p.backgrounding = !(totalCompleted === numImages);
    if (prevBging !== _p.backgrounding) {
      node.updateStyle(false);
    }
  }, "drawImages2");
  var drawPie = /* @__PURE__ */ __name(function drawPie2() {
    var redrawShape = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : eleOpacity;
    if (r2.hasPie(node)) {
      r2.drawPie(context, node, pieOpacity);
      if (redrawShape) {
        if (!usePaths) {
          r2.nodeShapes[r2.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);
        }
      }
    }
  }, "drawPie2");
  var drawStripe = /* @__PURE__ */ __name(function drawStripe2() {
    var redrawShape = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var stripeOpacity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : eleOpacity;
    if (r2.hasStripe(node)) {
      context.save();
      if (usePaths) {
        context.clip(rs.pathCache);
      } else {
        r2.nodeShapes[r2.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);
        context.clip();
      }
      r2.drawStripe(context, node, stripeOpacity);
      context.restore();
      if (redrawShape) {
        if (!usePaths) {
          r2.nodeShapes[r2.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);
        }
      }
    }
  }, "drawStripe2");
  var darken = /* @__PURE__ */ __name(function darken2() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : eleOpacity;
    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;
    if (darkness !== 0) {
      r2.colorFillStyle(context, c, c, c, opacity);
      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  }, "darken2");
  var drawBorder = /* @__PURE__ */ __name(function drawBorder2() {
    if (borderWidth > 0) {
      context.lineWidth = borderWidth;
      context.lineCap = borderCap;
      context.lineJoin = borderJoin;
      if (context.setLineDash) {
        switch (borderStyle) {
          case "dotted":
            context.setLineDash([1, 1]);
            break;
          case "dashed":
            context.setLineDash(borderPattern);
            context.lineDashOffset = borderOffset;
            break;
          case "solid":
          case "double":
            context.setLineDash([]);
            break;
        }
      }
      if (borderPosition !== "center") {
        context.save();
        context.lineWidth *= 2;
        if (borderPosition === "inside") {
          usePaths ? context.clip(path) : context.clip();
        } else {
          var region = new Path2D();
          region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);
          region.addPath(path);
          context.clip(region, "evenodd");
        }
        usePaths ? context.stroke(path) : context.stroke();
        context.restore();
      } else {
        usePaths ? context.stroke(path) : context.stroke();
      }
      if (borderStyle === "double") {
        context.lineWidth = borderWidth / 3;
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = "destination-out";
        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }
        context.globalCompositeOperation = gco;
      }
      if (context.setLineDash) {
        context.setLineDash([]);
      }
    }
  }, "drawBorder2");
  var drawOutline = /* @__PURE__ */ __name(function drawOutline2() {
    if (outlineWidth > 0) {
      context.lineWidth = outlineWidth;
      context.lineCap = "butt";
      if (context.setLineDash) {
        switch (outlineStyle) {
          case "dotted":
            context.setLineDash([1, 1]);
            break;
          case "dashed":
            context.setLineDash([4, 2]);
            break;
          case "solid":
          case "double":
            context.setLineDash([]);
            break;
        }
      }
      var npos = pos;
      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }
      var shape = r2.getNodeShape(node);
      var bWidth = borderWidth;
      if (borderPosition === "inside") bWidth = 0;
      if (borderPosition === "outside") bWidth *= 2;
      var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;
      var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;
      var sWidth = nodeWidth * scaleX;
      var sHeight = nodeHeight * scaleY;
      var points = r2.nodeShapes[shape].points;
      var _path;
      if (usePaths) {
        var outlinePath = getPath(sWidth, sHeight, shape, points);
        _path = outlinePath.path;
      }
      if (shape === "ellipse") {
        r2.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);
      } else if (["round-diamond", "round-heptagon", "round-hexagon", "round-octagon", "round-pentagon", "round-polygon", "round-triangle", "round-tag"].includes(shape)) {
        var sMult = 0;
        var offsetX = 0;
        var offsetY = 0;
        if (shape === "round-diamond") {
          sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;
        } else if (shape === "round-heptagon") {
          sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;
          offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;
        } else if (shape === "round-hexagon") {
          sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;
        } else if (shape === "round-pentagon") {
          sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;
          offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;
        } else if (shape === "round-tag") {
          sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;
          offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * 0.07;
        } else if (shape === "round-triangle") {
          sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);
          offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;
        }
        if (sMult !== 0) {
          scaleX = (nodeWidth + sMult) / nodeWidth;
          sWidth = nodeWidth * scaleX;
          if (!["round-hexagon", "round-tag"].includes(shape)) {
            scaleY = (nodeHeight + sMult) / nodeHeight;
            sHeight = nodeHeight * scaleY;
          }
        }
        cornerRadius = cornerRadius === "auto" ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;
        var halfW = sWidth / 2;
        var halfH = sHeight / 2;
        var radius2 = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;
        var p2 = new Array(points.length / 2);
        var corners = new Array(points.length / 2);
        for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
          p2[_i2] = {
            x: npos.x + offsetX + halfW * points[_i2 * 2],
            y: npos.y + offsetY + halfH * points[_i2 * 2 + 1]
          };
        }
        var _i3, p1, p22, p3, len = p2.length;
        p1 = p2[len - 1];
        for (_i3 = 0; _i3 < len; _i3++) {
          p22 = p2[_i3 % len];
          p3 = p2[(_i3 + 1) % len];
          corners[_i3] = getRoundCorner(p1, p22, p3, radius2);
          p1 = p22;
          p22 = p3;
        }
        r2.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);
      } else if (["roundrectangle", "round-rectangle"].includes(shape)) {
        cornerRadius = cornerRadius === "auto" ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;
        r2.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);
      } else if (["cutrectangle", "cut-rectangle"].includes(shape)) {
        cornerRadius = cornerRadius === "auto" ? getCutRectangleCornerLength() : cornerRadius;
        r2.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);
      } else if (["bottomroundrectangle", "bottom-round-rectangle"].includes(shape)) {
        cornerRadius = cornerRadius === "auto" ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;
        r2.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);
      } else if (shape === "barrel") {
        r2.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);
      } else if (shape.startsWith("polygon") || ["rhomboid", "right-rhomboid", "round-tag", "tag", "vee"].includes(shape)) {
        var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;
        points = joinLines(expandPolygon(points, pad));
        r2.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);
      } else {
        var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;
        points = joinLines(expandPolygon(points, -_pad));
        r2.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);
      }
      if (usePaths) {
        context.stroke(_path);
      } else {
        context.stroke();
      }
      if (outlineStyle === "double") {
        context.lineWidth = bWidth / 3;
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = "destination-out";
        if (usePaths) {
          context.stroke(_path);
        } else {
          context.stroke();
        }
        context.globalCompositeOperation = gco;
      }
      if (context.setLineDash) {
        context.setLineDash([]);
      }
    }
  }, "drawOutline2");
  var drawOverlay = /* @__PURE__ */ __name(function drawOverlay2() {
    if (shouldDrawOverlay) {
      r2.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
    }
  }, "drawOverlay2");
  var drawUnderlay = /* @__PURE__ */ __name(function drawUnderlay2() {
    if (shouldDrawOverlay) {
      r2.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);
    }
  }, "drawUnderlay2");
  var drawText = /* @__PURE__ */ __name(function drawText2() {
    r2.drawElementText(context, node, null, drawLabel);
  }, "drawText2");
  var ghost = node.pstyle("ghost").value === "yes";
  if (ghost) {
    var gx = node.pstyle("ghost-offset-x").pfValue;
    var gy = node.pstyle("ghost-offset-y").pfValue;
    var ghostOpacity = node.pstyle("ghost-opacity").value;
    var effGhostOpacity = ghostOpacity * eleOpacity;
    context.translate(gx, gy);
    setupOutlineColor();
    drawOutline();
    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity, true);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();
    drawPie(darkness !== 0 || borderWidth !== 0);
    drawStripe(darkness !== 0 || borderWidth !== 0);
    drawImages(effGhostOpacity, false);
    darken(effGhostOpacity);
    context.translate(-gx, -gy);
  }
  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }
  drawUnderlay();
  if (usePaths) {
    context.translate(pos.x, pos.y);
  }
  setupOutlineColor();
  drawOutline();
  setupShapeColor();
  drawShape();
  drawImages(eleOpacity, true);
  setupBorderColor();
  drawBorder();
  drawPie(darkness !== 0 || borderWidth !== 0);
  drawStripe(darkness !== 0 || borderWidth !== 0);
  drawImages(eleOpacity, false);
  darken();
  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }
  drawText();
  drawOverlay();
  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};
var drawNodeOverlayUnderlay = /* @__PURE__ */ __name(function drawNodeOverlayUnderlay2(overlayOrUnderlay) {
  if (!["overlay", "underlay"].includes(overlayOrUnderlay)) {
    throw new Error("Invalid state");
  }
  return function(context, node, pos, nodeWidth, nodeHeight) {
    var r2 = this;
    if (!node.visible()) {
      return;
    }
    var padding = node.pstyle("".concat(overlayOrUnderlay, "-padding")).pfValue;
    var opacity = node.pstyle("".concat(overlayOrUnderlay, "-opacity")).value;
    var color = node.pstyle("".concat(overlayOrUnderlay, "-color")).value;
    var shape = node.pstyle("".concat(overlayOrUnderlay, "-shape")).value;
    var radius2 = node.pstyle("".concat(overlayOrUnderlay, "-corner-radius")).value;
    if (opacity > 0) {
      pos = pos || node.position();
      if (nodeWidth == null || nodeHeight == null) {
        var _padding = node.padding();
        nodeWidth = node.width() + 2 * _padding;
        nodeHeight = node.height() + 2 * _padding;
      }
      r2.colorFillStyle(context, color[0], color[1], color[2], opacity);
      r2.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius2);
      context.fill();
    }
  };
}, "drawNodeOverlayUnderlay2");
CRp$6.drawNodeOverlay = drawNodeOverlayUnderlay("overlay");
CRp$6.drawNodeUnderlay = drawNodeOverlayUnderlay("underlay");
CRp$6.hasPie = function(node) {
  node = node[0];
  return node._private.hasPie;
};
CRp$6.hasStripe = function(node) {
  node = node[0];
  return node._private.hasStripe;
};
CRp$6.drawPie = function(context, node, nodeOpacity, pos) {
  node = node[0];
  pos = pos || node.position();
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle("pie-size");
  var hole = node.pstyle("pie-hole");
  var overallStartAngle = node.pstyle("pie-start-angle").pfValue;
  var x2 = pos.x;
  var y2 = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius2 = Math.min(nodeW, nodeH) / 2;
  var holeRadius;
  var lastPercent = 0;
  var usePaths = this.usePaths();
  if (usePaths) {
    x2 = 0;
    y2 = 0;
  }
  if (pieSize.units === "%") {
    radius2 = radius2 * pieSize.pfValue;
  } else if (pieSize.pfValue !== void 0) {
    radius2 = pieSize.pfValue / 2;
  }
  if (hole.units === "%") {
    holeRadius = radius2 * hole.pfValue;
  } else if (hole.pfValue !== void 0) {
    holeRadius = hole.pfValue / 2;
  }
  if (holeRadius >= radius2) {
    return;
  }
  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    var size3 = node.pstyle("pie-" + i + "-background-size").value;
    var color = node.pstyle("pie-" + i + "-background-color").value;
    var opacity = node.pstyle("pie-" + i + "-background-opacity").value * nodeOpacity;
    var percent = size3 / 100;
    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }
    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent;
    angleStart += overallStartAngle;
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;
    if (size3 === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }
    if (holeRadius === 0) {
      context.beginPath();
      context.moveTo(x2, y2);
      context.arc(x2, y2, radius2, angleStart, angleEnd);
      context.closePath();
    } else {
      context.beginPath();
      context.arc(x2, y2, radius2, angleStart, angleEnd);
      context.arc(x2, y2, holeRadius, angleEnd, angleStart, true);
      context.closePath();
    }
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    context.fill();
    lastPercent += percent;
  }
};
CRp$6.drawStripe = function(context, node, nodeOpacity, pos) {
  node = node[0];
  pos = pos || node.position();
  var cyStyle = node.cy().style();
  var x2 = pos.x;
  var y2 = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var lastPercent = 0;
  var usePaths = this.usePaths();
  context.save();
  var direction = node.pstyle("stripe-direction").value;
  var stripeSize = node.pstyle("stripe-size");
  switch (direction) {
    case "vertical":
      break;
    // default
    case "righward":
      context.rotate(-Math.PI / 2);
      break;
  }
  var stripeW = nodeW;
  var stripeH = nodeH;
  if (stripeSize.units === "%") {
    stripeW = stripeW * stripeSize.pfValue;
    stripeH = stripeH * stripeSize.pfValue;
  } else if (stripeSize.pfValue !== void 0) {
    stripeW = stripeSize.pfValue;
    stripeH = stripeSize.pfValue;
  }
  if (usePaths) {
    x2 = 0;
    y2 = 0;
  }
  y2 -= stripeW / 2;
  x2 -= stripeH / 2;
  for (var i = 1; i <= cyStyle.stripeBackgroundN; i++) {
    var size3 = node.pstyle("stripe-" + i + "-background-size").value;
    var color = node.pstyle("stripe-" + i + "-background-color").value;
    var opacity = node.pstyle("stripe-" + i + "-background-opacity").value * nodeOpacity;
    var percent = size3 / 100;
    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }
    if (size3 === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }
    context.beginPath();
    context.rect(x2, y2 + stripeH * lastPercent, stripeW, stripeH * percent);
    context.closePath();
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    context.fill();
    lastPercent += percent;
  }
  context.restore();
};
var CRp$5 = {};
var motionBlurDelay = 100;
CRp$5.getPixelRatio = function() {
  var context = this.data.contexts[0];
  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }
  var containerWindow = this.cy.window();
  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (containerWindow.devicePixelRatio || 1) / backingStore;
};
CRp$5.paintCache = function(context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache3;
  for (var i = 0; i < caches.length; i++) {
    cache3 = caches[i];
    if (cache3.context === context) {
      needToCreateCache = false;
      break;
    }
  }
  if (needToCreateCache) {
    cache3 = {
      context
    };
    caches.push(cache3);
  }
  return cache3;
};
CRp$5.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {
  var gradientStyle;
  var usePaths = this.usePaths();
  var colors2 = ele.pstyle(shapeStyleName + "-gradient-stop-colors").value, positions2 = ele.pstyle(shapeStyleName + "-gradient-stop-positions").pfValue;
  if (fill === "radial-gradient") {
    if (ele.isEdge()) {
      var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();
      var d1 = dist(start, mid);
      var d2 = dist(end, mid);
      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
    } else {
      var pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(), width2 = ele.paddedWidth(), height2 = ele.paddedHeight();
      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width2, height2));
    }
  } else {
    if (ele.isEdge()) {
      var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();
      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
    } else {
      var _pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;
      var direction = ele.pstyle("background-gradient-direction").value;
      switch (direction) {
        case "to-bottom":
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
          break;
        case "to-top":
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
          break;
        case "to-left":
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
          break;
        case "to-right":
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
          break;
        case "to-bottom-right":
        case "to-right-bottom":
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
          break;
        case "to-top-right":
        case "to-right-top":
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
          break;
        case "to-bottom-left":
        case "to-left-bottom":
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
          break;
        case "to-top-left":
        case "to-left-top":
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
          break;
      }
    }
  }
  if (!gradientStyle) return null;
  var hasPositions = positions2.length === colors2.length;
  var length2 = colors2.length;
  for (var i = 0; i < length2; i++) {
    gradientStyle.addColorStop(hasPositions ? positions2[i] : i / (length2 - 1), "rgba(" + colors2[i][0] + "," + colors2[i][1] + "," + colors2[i][2] + "," + opacity + ")");
  }
  return gradientStyle;
};
CRp$5.gradientFillStyle = function(context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, "background", ele, fill, opacity);
  if (!gradientStyle) return null;
  context.fillStyle = gradientStyle;
};
CRp$5.colorFillStyle = function(context, r2, g, b, a) {
  context.fillStyle = "rgba(" + r2 + "," + g + "," + b + "," + a + ")";
};
CRp$5.eleFillStyle = function(context, ele, opacity) {
  var backgroundFill = ele.pstyle("background-fill").value;
  if (backgroundFill === "linear-gradient" || backgroundFill === "radial-gradient") {
    this.gradientFillStyle(context, ele, backgroundFill, opacity);
  } else {
    var backgroundColor = ele.pstyle("background-color").value;
    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
  }
};
CRp$5.gradientStrokeStyle = function(context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, "line", ele, fill, opacity);
  if (!gradientStyle) return null;
  context.strokeStyle = gradientStyle;
};
CRp$5.colorStrokeStyle = function(context, r2, g, b, a) {
  context.strokeStyle = "rgba(" + r2 + "," + g + "," + b + "," + a + ")";
};
CRp$5.eleStrokeStyle = function(context, ele, opacity) {
  var lineFill = ele.pstyle("line-fill").value;
  if (lineFill === "linear-gradient" || lineFill === "radial-gradient") {
    this.gradientStrokeStyle(context, ele, lineFill, opacity);
  } else {
    var lineColor = ele.pstyle("line-color").value;
    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
  }
};
CRp$5.matchCanvasSize = function(container2) {
  var r2 = this;
  var data4 = r2.data;
  var bb = r2.findContainerClientCoords();
  var width2 = bb[2];
  var height2 = bb[3];
  var pixelRatio = r2.getPixelRatio();
  var mbPxRatio = r2.motionBlurPxRatio;
  if (container2 === r2.data.bufferCanvases[r2.MOTIONBLUR_BUFFER_NODE] || container2 === r2.data.bufferCanvases[r2.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }
  var canvasWidth = width2 * pixelRatio;
  var canvasHeight = height2 * pixelRatio;
  var canvas;
  if (canvasWidth === r2.canvasWidth && canvasHeight === r2.canvasHeight) {
    return;
  }
  r2.fontCaches = null;
  var canvasContainer = data4.canvasContainer;
  canvasContainer.style.width = width2 + "px";
  canvasContainer.style.height = height2 + "px";
  for (var i = 0; i < r2.CANVAS_LAYERS; i++) {
    canvas = data4.canvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  for (var i = 0; i < r2.BUFFER_COUNT; i++) {
    canvas = data4.bufferCanvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  r2.textureMult = 1;
  if (pixelRatio <= 1) {
    canvas = data4.bufferCanvases[r2.TEXTURE_BUFFER];
    r2.textureMult = 2;
    canvas.width = canvasWidth * r2.textureMult;
    canvas.height = canvasHeight * r2.textureMult;
  }
  r2.canvasWidth = canvasWidth;
  r2.canvasHeight = canvasHeight;
  r2.pixelRatio = pixelRatio;
};
CRp$5.renderTo = function(cxt, zoom2, pan2, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom2,
    forcedPan: pan2,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};
CRp$5.clearCanvas = function() {
  var r2 = this;
  var data4 = r2.data;
  function clear2(context) {
    context.clearRect(0, 0, r2.canvasWidth, r2.canvasHeight);
  }
  __name(clear2, "clear");
  clear2(data4.contexts[r2.NODE]);
  clear2(data4.contexts[r2.DRAG]);
};
CRp$5.render = function(options2) {
  var r2 = this;
  options2 = options2 || staticEmptyObject();
  var cy = r2.cy;
  var forcedContext = options2.forcedContext;
  var drawAllLayers = options2.drawAllLayers;
  var drawOnlyNodeLayer = options2.drawOnlyNodeLayer;
  var forcedZoom = options2.forcedZoom;
  var forcedPan = options2.forcedPan;
  var pixelRatio = options2.forcedPxRatio === void 0 ? this.getPixelRatio() : options2.forcedPxRatio;
  var data4 = r2.data;
  var needDraw = data4.canvasNeedsRedraw;
  var textureDraw = r2.textureOnViewport && !forcedContext && (r2.pinching || r2.hoverData.dragging || r2.swipePanning || r2.data.wheelZooming);
  var motionBlur = options2.motionBlur !== void 0 ? options2.motionBlur : r2.motionBlur;
  var mbPxRatio = r2.motionBlurPxRatio;
  var hasCompoundNodes2 = cy.hasCompoundNodes();
  var inNodeDragGesture = r2.hoverData.draggingEles;
  var inBoxSelection = r2.hoverData.selecting || r2.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r2.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;
  if (!forcedContext) {
    if (r2.prevPxRatio !== pixelRatio) {
      r2.invalidateContainerClientCoordsCache();
      r2.matchCanvasSize(r2.container);
      r2.redrawHint("eles", true);
      r2.redrawHint("drag", true);
    }
    r2.prevPxRatio = pixelRatio;
  }
  if (!forcedContext && r2.motionBlurTimeout) {
    clearTimeout(r2.motionBlurTimeout);
  }
  if (motionBlur) {
    if (r2.mbFrames == null) {
      r2.mbFrames = 0;
    }
    r2.mbFrames++;
    if (r2.mbFrames < 3) {
      motionBlurFadeEffect = false;
    }
    if (r2.mbFrames > r2.minMbLowQualFrames) {
      r2.motionBlurPxRatio = r2.mbPxRBlurry;
    }
  }
  if (r2.clearingMotionBlur) {
    r2.motionBlurPxRatio = 1;
  }
  if (r2.textureDrawLastFrame && !textureDraw) {
    needDraw[r2.NODE] = true;
    needDraw[r2.SELECT_BOX] = true;
  }
  var style3 = cy.style();
  var zoom2 = cy.zoom();
  var effectiveZoom = forcedZoom !== void 0 ? forcedZoom : zoom2;
  var pan2 = cy.pan();
  var effectivePan = {
    x: pan2.x,
    y: pan2.y
  };
  var vp = {
    zoom: zoom2,
    pan: {
      x: pan2.x,
      y: pan2.y
    }
  };
  var prevVp = r2.prevViewport;
  var viewportIsDiff = prevVp === void 0 || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;
  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes2)) {
    r2.motionBlurPxRatio = 1;
  }
  if (forcedPan) {
    effectivePan = forcedPan;
  }
  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;
  var eles = r2.getCachedZSortedEles();
  function mbclear(context2, x2, y2, w, h) {
    var gco = context2.globalCompositeOperation;
    context2.globalCompositeOperation = "destination-out";
    r2.colorFillStyle(context2, 255, 255, 255, r2.motionBlurTransparency);
    context2.fillRect(x2, y2, w, h);
    context2.globalCompositeOperation = gco;
  }
  __name(mbclear, "mbclear");
  function setContextTransform2(context2, clear22) {
    var ePan, eZoom, w, h;
    if (!r2.clearingMotionBlur && (context2 === data4.bufferContexts[r2.MOTIONBLUR_BUFFER_NODE] || context2 === data4.bufferContexts[r2.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan2.x * mbPxRatio,
        y: pan2.y * mbPxRatio
      };
      eZoom = zoom2 * mbPxRatio;
      w = r2.canvasWidth * mbPxRatio;
      h = r2.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;
      w = r2.canvasWidth;
      h = r2.canvasHeight;
    }
    context2.setTransform(1, 0, 0, 1, 0, 0);
    if (clear22 === "motionBlur") {
      mbclear(context2, 0, 0, w, h);
    } else if (!forcedContext && (clear22 === void 0 || clear22)) {
      context2.clearRect(0, 0, w, h);
    }
    if (!drawAllLayers) {
      context2.translate(ePan.x, ePan.y);
      context2.scale(eZoom, eZoom);
    }
    if (forcedPan) {
      context2.translate(forcedPan.x, forcedPan.y);
    }
    if (forcedZoom) {
      context2.scale(forcedZoom, forcedZoom);
    }
  }
  __name(setContextTransform2, "setContextTransform2");
  if (!textureDraw) {
    r2.textureDrawLastFrame = false;
  }
  if (textureDraw) {
    r2.textureDrawLastFrame = true;
    if (!r2.textureCache) {
      r2.textureCache = {};
      r2.textureCache.bb = cy.mutableElements().boundingBox();
      r2.textureCache.texture = r2.data.bufferCanvases[r2.TEXTURE_BUFFER];
      var cxt = r2.data.bufferContexts[r2.TEXTURE_BUFFER];
      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r2.canvasWidth * r2.textureMult, r2.canvasHeight * r2.textureMult);
      r2.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r2.textureMult
      });
      var vp = r2.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r2.canvasWidth,
        height: r2.canvasHeight
      };
      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }
    needDraw[r2.DRAG] = false;
    needDraw[r2.NODE] = false;
    var context = data4.contexts[r2.NODE];
    var texture = r2.textureCache.texture;
    var vp = r2.textureCache.viewport;
    context.setTransform(1, 0, 0, 1, 0, 0);
    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }
    var outsideBgColor = style3.core("outside-texture-bg-color").value;
    var outsideBgOpacity = style3.core("outside-texture-bg-opacity").value;
    r2.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);
    var zoom2 = cy.zoom();
    setContextTransform2(context, false);
    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r2.textureOnViewport && !forcedContext) {
    r2.textureCache = null;
  }
  var extent2 = cy.extent();
  var vpManip = r2.pinching || r2.hoverData.dragging || r2.swipePanning || r2.data.wheelZooming || r2.hoverData.draggingEles || r2.cy.animated();
  var hideEdges = r2.hideEdgesOnViewport && vpManip;
  var needMbClear = [];
  needMbClear[r2.NODE] = !needDraw[r2.NODE] && motionBlur && !r2.clearedForMotionBlur[r2.NODE] || r2.clearingMotionBlur;
  if (needMbClear[r2.NODE]) {
    r2.clearedForMotionBlur[r2.NODE] = true;
  }
  needMbClear[r2.DRAG] = !needDraw[r2.DRAG] && motionBlur && !r2.clearedForMotionBlur[r2.DRAG] || r2.clearingMotionBlur;
  if (needMbClear[r2.DRAG]) {
    r2.clearedForMotionBlur[r2.DRAG] = true;
  }
  if (needDraw[r2.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r2.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r2.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r2.data.bufferContexts[r2.MOTIONBLUR_BUFFER_NODE] : data4.contexts[r2.NODE]);
    var clear2 = motionBlur && !useBuffer ? "motionBlur" : void 0;
    setContextTransform2(context, clear2);
    if (hideEdges) {
      r2.drawCachedNodes(context, eles.nondrag, pixelRatio, extent2);
    } else {
      r2.drawLayeredElements(context, eles.nondrag, pixelRatio, extent2);
    }
    if (r2.debug) {
      r2.drawDebugPoints(context, eles.nondrag);
    }
    if (!drawAllLayers && !motionBlur) {
      needDraw[r2.NODE] = false;
    }
  }
  if (!drawOnlyNodeLayer && (needDraw[r2.DRAG] || drawAllLayers || needMbClear[r2.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r2.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r2.data.bufferContexts[r2.MOTIONBLUR_BUFFER_DRAG] : data4.contexts[r2.DRAG]);
    setContextTransform2(context, motionBlur && !useBuffer ? "motionBlur" : void 0);
    if (hideEdges) {
      r2.drawCachedNodes(context, eles.drag, pixelRatio, extent2);
    } else {
      r2.drawCachedElements(context, eles.drag, pixelRatio, extent2);
    }
    if (r2.debug) {
      r2.drawDebugPoints(context, eles.drag);
    }
    if (!drawAllLayers && !motionBlur) {
      needDraw[r2.DRAG] = false;
    }
  }
  this.drawSelectionRectangle(options2, setContextTransform2);
  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data4.contexts[r2.NODE];
    var txtNode = r2.data.bufferCanvases[r2.MOTIONBLUR_BUFFER_NODE];
    var cxtDrag = data4.contexts[r2.DRAG];
    var txtDrag = r2.data.bufferCanvases[r2.MOTIONBLUR_BUFFER_DRAG];
    var drawMotionBlur = /* @__PURE__ */ __name(function drawMotionBlur2(cxt2, txt, needClear) {
      cxt2.setTransform(1, 0, 0, 1, 0, 0);
      if (needClear || !motionBlurFadeEffect) {
        cxt2.clearRect(0, 0, r2.canvasWidth, r2.canvasHeight);
      } else {
        mbclear(cxt2, 0, 0, r2.canvasWidth, r2.canvasHeight);
      }
      var pxr = mbPxRatio;
      cxt2.drawImage(
        txt,
        // img
        0,
        0,
        // sx, sy
        r2.canvasWidth * pxr,
        r2.canvasHeight * pxr,
        // sw, sh
        0,
        0,
        // x, y
        r2.canvasWidth,
        r2.canvasHeight
        // w, h
      );
    }, "drawMotionBlur2");
    if (needDraw[r2.NODE] || needMbClear[r2.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r2.NODE]);
      needDraw[r2.NODE] = false;
    }
    if (needDraw[r2.DRAG] || needMbClear[r2.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r2.DRAG]);
      needDraw[r2.DRAG] = false;
    }
  }
  r2.prevViewport = vp;
  if (r2.clearingMotionBlur) {
    r2.clearingMotionBlur = false;
    r2.motionBlurCleared = true;
    r2.motionBlur = true;
  }
  if (motionBlur) {
    r2.motionBlurTimeout = setTimeout(function() {
      r2.motionBlurTimeout = null;
      r2.clearedForMotionBlur[r2.NODE] = false;
      r2.clearedForMotionBlur[r2.DRAG] = false;
      r2.motionBlur = false;
      r2.clearingMotionBlur = !textureDraw;
      r2.mbFrames = 0;
      needDraw[r2.NODE] = true;
      needDraw[r2.DRAG] = true;
      r2.redraw();
    }, motionBlurDelay);
  }
  if (!forcedContext) {
    cy.emit("render");
  }
};
var fpsHeight;
CRp$5.drawSelectionRectangle = function(options2, setContextTransform2) {
  var r2 = this;
  var cy = r2.cy;
  var data4 = r2.data;
  var style3 = cy.style();
  var drawOnlyNodeLayer = options2.drawOnlyNodeLayer;
  var drawAllLayers = options2.drawAllLayers;
  var needDraw = data4.canvasNeedsRedraw;
  var forcedContext = options2.forcedContext;
  if (r2.showFps || !drawOnlyNodeLayer && needDraw[r2.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data4.contexts[r2.SELECT_BOX];
    setContextTransform2(context);
    if (r2.selection[4] == 1 && (r2.hoverData.selecting || r2.touchData.selecting)) {
      var zoom2 = r2.cy.zoom();
      var borderWidth = style3.core("selection-box-border-width").value / zoom2;
      context.lineWidth = borderWidth;
      context.fillStyle = "rgba(" + style3.core("selection-box-color").value[0] + "," + style3.core("selection-box-color").value[1] + "," + style3.core("selection-box-color").value[2] + "," + style3.core("selection-box-opacity").value + ")";
      context.fillRect(r2.selection[0], r2.selection[1], r2.selection[2] - r2.selection[0], r2.selection[3] - r2.selection[1]);
      if (borderWidth > 0) {
        context.strokeStyle = "rgba(" + style3.core("selection-box-border-color").value[0] + "," + style3.core("selection-box-border-color").value[1] + "," + style3.core("selection-box-border-color").value[2] + "," + style3.core("selection-box-opacity").value + ")";
        context.strokeRect(r2.selection[0], r2.selection[1], r2.selection[2] - r2.selection[0], r2.selection[3] - r2.selection[1]);
      }
    }
    if (data4.bgActivePosistion && !r2.hoverData.selecting) {
      var zoom2 = r2.cy.zoom();
      var pos = data4.bgActivePosistion;
      context.fillStyle = "rgba(" + style3.core("active-bg-color").value[0] + "," + style3.core("active-bg-color").value[1] + "," + style3.core("active-bg-color").value[2] + "," + style3.core("active-bg-opacity").value + ")";
      context.beginPath();
      context.arc(pos.x, pos.y, style3.core("active-bg-size").pfValue / zoom2, 0, 2 * Math.PI);
      context.fill();
    }
    var timeToRender = r2.lastRedrawTime;
    if (r2.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1e3 / timeToRender);
      var text2 = "1 frame = " + timeToRender + " ms = " + fps + " fps";
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.fillStyle = "rgba(255, 0, 0, 0.75)";
      context.strokeStyle = "rgba(255, 0, 0, 0.75)";
      context.font = "30px Arial";
      if (!fpsHeight) {
        var dims = context.measureText(text2);
        fpsHeight = dims.actualBoundingBoxAscent;
      }
      context.fillText(text2, 0, fpsHeight);
      var maxFps = 60;
      context.strokeRect(0, fpsHeight + 10, 250, 20);
      context.fillRect(0, fpsHeight + 10, 250 * Math.min(fps / maxFps, 1), 20);
    }
    if (!drawAllLayers) {
      needDraw[r2.SELECT_BOX] = false;
    }
  }
};
function compileShader(gl, type, source2) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source2);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}
__name(compileShader, "compileShader");
function createProgram(gl, vertexSource, fragementSource) {
  var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);
  var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragementSource);
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("Could not initialize shaders");
  }
  return program;
}
__name(createProgram, "createProgram");
function createTextureCanvas(r2, width2, height2) {
  if (height2 === void 0) {
    height2 = width2;
  }
  var canvas = r2.makeOffscreenCanvas(width2, height2);
  var ctx = canvas.context = canvas.getContext("2d");
  canvas.clear = function() {
    return ctx.clearRect(0, 0, canvas.width, canvas.height);
  };
  canvas.clear();
  return canvas;
}
__name(createTextureCanvas, "createTextureCanvas");
function getEffectivePanZoom(r2) {
  var pixelRatio = r2.pixelRatio;
  var zoom2 = r2.cy.zoom();
  var pan2 = r2.cy.pan();
  return {
    zoom: zoom2 * pixelRatio,
    pan: {
      x: pan2.x * pixelRatio,
      y: pan2.y * pixelRatio
    }
  };
}
__name(getEffectivePanZoom, "getEffectivePanZoom");
function getEffectiveZoom(r2) {
  var pixelRatio = r2.pixelRatio;
  var zoom2 = r2.cy.zoom();
  return zoom2 * pixelRatio;
}
__name(getEffectiveZoom, "getEffectiveZoom");
function modelToRenderedPosition2(r2, pan2, zoom2, x2, y2) {
  var rx = x2 * zoom2 + pan2.x;
  var ry = y2 * zoom2 + pan2.y;
  ry = Math.round(r2.canvasHeight - ry);
  return [rx, ry];
}
__name(modelToRenderedPosition2, "modelToRenderedPosition2");
function isSimpleShape(node) {
  if (node.pstyle("background-fill").value !== "solid") return false;
  if (node.pstyle("background-image").strValue !== "none") return false;
  if (node.pstyle("border-width").value === 0) return true;
  if (node.pstyle("border-opacity").value === 0) return true;
  if (node.pstyle("border-style").value !== "solid") return false;
  return true;
}
__name(isSimpleShape, "isSimpleShape");
function arrayEqual(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (var i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
__name(arrayEqual, "arrayEqual");
function toWebGLColor(color, opacity, outArray) {
  var r2 = color[0] / 255;
  var g = color[1] / 255;
  var b = color[2] / 255;
  var a = opacity;
  var arr = outArray || new Array(4);
  arr[0] = r2 * a;
  arr[1] = g * a;
  arr[2] = b * a;
  arr[3] = a;
  return arr;
}
__name(toWebGLColor, "toWebGLColor");
function indexToVec4(index2, outArray) {
  var arr = outArray || new Array(4);
  arr[0] = (index2 >> 0 & 255) / 255;
  arr[1] = (index2 >> 8 & 255) / 255;
  arr[2] = (index2 >> 16 & 255) / 255;
  arr[3] = (index2 >> 24 & 255) / 255;
  return arr;
}
__name(indexToVec4, "indexToVec4");
function vec4ToIndex(vec4) {
  return vec4[0] + (vec4[1] << 8) + (vec4[2] << 16) + (vec4[3] << 24);
}
__name(vec4ToIndex, "vec4ToIndex");
function createTexture(gl, debugID) {
  var texture = gl.createTexture();
  texture.buffer = function(offscreenCanvas) {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
  };
  texture.deleteTexture = function() {
    gl.deleteTexture(texture);
  };
  return texture;
}
__name(createTexture, "createTexture");
function getTypeInfo(gl, glslType) {
  switch (glslType) {
    case "float":
      return [1, gl.FLOAT, 4];
    case "vec2":
      return [2, gl.FLOAT, 4];
    case "vec3":
      return [3, gl.FLOAT, 4];
    case "vec4":
      return [4, gl.FLOAT, 4];
    case "int":
      return [1, gl.INT, 4];
    case "ivec2":
      return [2, gl.INT, 4];
  }
}
__name(getTypeInfo, "getTypeInfo");
function createTypedArray(gl, glType, dataOrSize) {
  switch (glType) {
    case gl.FLOAT:
      return new Float32Array(dataOrSize);
    case gl.INT:
      return new Int32Array(dataOrSize);
  }
}
__name(createTypedArray, "createTypedArray");
function createTypedArrayView(gl, glType, array3, stride, size3, i) {
  switch (glType) {
    case gl.FLOAT:
      return new Float32Array(array3.buffer, i * stride, size3);
    case gl.INT:
      return new Int32Array(array3.buffer, i * stride, size3);
  }
}
__name(createTypedArrayView, "createTypedArrayView");
function createBufferStaticDraw(gl, type, attributeLoc, dataArray) {
  var _getTypeInfo = getTypeInfo(gl, type), _getTypeInfo2 = _slicedToArray(_getTypeInfo, 2), size3 = _getTypeInfo2[0], glType = _getTypeInfo2[1];
  var data4 = createTypedArray(gl, glType, dataArray);
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data4, gl.STATIC_DRAW);
  if (glType === gl.FLOAT) {
    gl.vertexAttribPointer(attributeLoc, size3, glType, false, 0, 0);
  } else if (glType === gl.INT) {
    gl.vertexAttribIPointer(attributeLoc, size3, glType, 0, 0);
  }
  gl.enableVertexAttribArray(attributeLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return buffer;
}
__name(createBufferStaticDraw, "createBufferStaticDraw");
function createBufferDynamicDraw(gl, instances, type, attributeLoc) {
  var _getTypeInfo3 = getTypeInfo(gl, type), _getTypeInfo4 = _slicedToArray(_getTypeInfo3, 3), size3 = _getTypeInfo4[0], glType = _getTypeInfo4[1], bytes2 = _getTypeInfo4[2];
  var dataArray = createTypedArray(gl, glType, instances * size3);
  var stride = size3 * bytes2;
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, instances * stride, gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(attributeLoc);
  if (glType === gl.FLOAT) {
    gl.vertexAttribPointer(attributeLoc, size3, glType, false, stride, 0);
  } else if (glType === gl.INT) {
    gl.vertexAttribIPointer(attributeLoc, size3, glType, stride, 0);
  }
  gl.vertexAttribDivisor(attributeLoc, 1);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  var views = new Array(instances);
  for (var i = 0; i < instances; i++) {
    views[i] = createTypedArrayView(gl, glType, dataArray, stride, size3, i);
  }
  buffer.dataArray = dataArray;
  buffer.stride = stride;
  buffer.size = size3;
  buffer.getView = function(i2) {
    return views[i2];
  };
  buffer.setPoint = function(i2, x2, y2) {
    var view = views[i2];
    view[0] = x2;
    view[1] = y2;
  };
  buffer.bufferSubData = function(count) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    if (count) {
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray, 0, count * size3);
    } else {
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray);
    }
  };
  return buffer;
}
__name(createBufferDynamicDraw, "createBufferDynamicDraw");
function create3x3MatrixBufferDynamicDraw(gl, instances, attributeLoc) {
  var matrixSize = 9;
  var matrixData = new Float32Array(instances * matrixSize);
  var matrixViews = new Array(instances);
  for (var i = 0; i < instances; i++) {
    var byteOffset = i * matrixSize * 4;
    matrixViews[i] = new Float32Array(matrixData.buffer, byteOffset, matrixSize);
  }
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);
  for (var _i = 0; _i < 3; _i++) {
    var loc = attributeLoc + _i;
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 3 * 12, _i * 12);
    gl.vertexAttribDivisor(loc, 1);
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  buffer.getMatrixView = function(i2) {
    return matrixViews[i2];
  };
  buffer.setData = function(matrix, i2) {
    matrixViews[i2].set(matrix, 0);
  };
  buffer.bufferSubData = function() {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);
  };
  return buffer;
}
__name(create3x3MatrixBufferDynamicDraw, "create3x3MatrixBufferDynamicDraw");
function createPickingFrameBuffer(gl) {
  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  var targetTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  fb.setFramebufferAttachmentSizes = function(width2, height2) {
    gl.bindTexture(gl.TEXTURE_2D, targetTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width2, height2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  };
  return fb;
}
__name(createPickingFrameBuffer, "createPickingFrameBuffer");
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function() {
  var y2 = 0, i = arguments.length;
  while (i--) {
    y2 += arguments[i] * arguments[i];
  }
  return Math.sqrt(y2);
};
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
__name(create, "create");
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
__name(identity2, "identity2");
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
__name(multiply, "multiply");
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x2 = v[0], y2 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
__name(translate, "translate");
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
__name(rotate, "rotate");
function scale(out, a, v) {
  var x2 = v[0], y2 = v[1];
  out[0] = x2 * a[0];
  out[1] = x2 * a[1];
  out[2] = x2 * a[2];
  out[3] = y2 * a[3];
  out[4] = y2 * a[4];
  out[5] = y2 * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
__name(scale, "scale");
function projection(out, width2, height2) {
  out[0] = 2 / width2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height2;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
__name(projection, "projection");
var Atlas = /* @__PURE__ */ (function() {
  function Atlas2(r2, texSize, texRows, createTextureCanvas2) {
    _classCallCheck(this, Atlas2);
    this.debugID = Math.floor(Math.random() * 1e4);
    this.r = r2;
    this.texSize = texSize;
    this.texRows = texRows;
    this.texHeight = Math.floor(texSize / texRows);
    this.enableWrapping = true;
    this.locked = false;
    this.texture = null;
    this.needsBuffer = true;
    this.freePointer = {
      x: 0,
      row: 0
    };
    this.keyToLocation = /* @__PURE__ */ new Map();
    this.canvas = createTextureCanvas2(r2, texSize, texSize);
    this.scratch = createTextureCanvas2(r2, texSize, this.texHeight, "scratch");
  }
  __name(Atlas2, "Atlas2");
  return _createClass(Atlas2, [{
    key: "lock",
    value: /* @__PURE__ */ __name(function lock() {
      this.locked = true;
    }, "lock")
  }, {
    key: "getKeys",
    value: /* @__PURE__ */ __name(function getKeys() {
      return new Set(this.keyToLocation.keys());
    }, "getKeys")
  }, {
    key: "getScale",
    value: /* @__PURE__ */ __name(function getScale(_ref) {
      var w = _ref.w, h = _ref.h;
      var texHeight = this.texHeight, maxTexWidth = this.texSize;
      var scale2 = texHeight / h;
      var texW = w * scale2;
      var texH = h * scale2;
      if (texW > maxTexWidth) {
        scale2 = maxTexWidth / w;
        texW = w * scale2;
        texH = h * scale2;
      }
      return {
        scale: scale2,
        texW,
        texH
      };
    }, "getScale")
  }, {
    key: "draw",
    value: /* @__PURE__ */ __name(function draw(key2, bb, doDrawing) {
      var _this = this;
      if (this.locked) throw new Error("can't draw, atlas is locked");
      var texSize = this.texSize, texRows = this.texRows, texHeight = this.texHeight;
      var _this$getScale = this.getScale(bb), scale2 = _this$getScale.scale, texW = _this$getScale.texW, texH = _this$getScale.texH;
      var drawAt = /* @__PURE__ */ __name(function drawAt2(location, canvas) {
        if (doDrawing && canvas) {
          var context = canvas.context;
          var x2 = location.x, row = location.row;
          var xOffset = x2;
          var yOffset = texHeight * row;
          context.save();
          context.translate(xOffset, yOffset);
          context.scale(scale2, scale2);
          doDrawing(context, bb);
          context.restore();
        }
      }, "drawAt2");
      var locations = [null, null];
      var drawNormal = /* @__PURE__ */ __name(function drawNormal2() {
        drawAt(_this.freePointer, _this.canvas);
        locations[0] = {
          x: _this.freePointer.x,
          y: _this.freePointer.row * texHeight,
          w: texW,
          h: texH
        };
        locations[1] = {
          // create a second location with a width of 0, for convenience
          x: _this.freePointer.x + texW,
          y: _this.freePointer.row * texHeight,
          w: 0,
          h: texH
        };
        _this.freePointer.x += texW;
        if (_this.freePointer.x == texSize) {
          _this.freePointer.x = 0;
          _this.freePointer.row++;
        }
      }, "drawNormal2");
      var drawWrapped = /* @__PURE__ */ __name(function drawWrapped2() {
        var scratch = _this.scratch, canvas = _this.canvas;
        scratch.clear();
        drawAt({
          x: 0,
          row: 0
        }, scratch);
        var firstTexW = texSize - _this.freePointer.x;
        var secondTexW = texW - firstTexW;
        var h = texHeight;
        {
          var dx = _this.freePointer.x;
          var dy = _this.freePointer.row * texHeight;
          var w = firstTexW;
          canvas.context.drawImage(scratch, 0, 0, w, h, dx, dy, w, h);
          locations[0] = {
            x: dx,
            y: dy,
            w,
            h: texH
          };
        }
        {
          var sx = firstTexW;
          var _dy = (_this.freePointer.row + 1) * texHeight;
          var _w = secondTexW;
          if (canvas) {
            canvas.context.drawImage(scratch, sx, 0, _w, h, 0, _dy, _w, h);
          }
          locations[1] = {
            x: 0,
            y: _dy,
            w: _w,
            h: texH
          };
        }
        _this.freePointer.x = secondTexW;
        _this.freePointer.row++;
      }, "drawWrapped2");
      var moveToStartOfNextRow = /* @__PURE__ */ __name(function moveToStartOfNextRow2() {
        _this.freePointer.x = 0;
        _this.freePointer.row++;
      }, "moveToStartOfNextRow2");
      if (this.freePointer.x + texW <= texSize) {
        drawNormal();
      } else if (this.freePointer.row >= texRows - 1) {
        return false;
      } else if (this.freePointer.x === texSize) {
        moveToStartOfNextRow();
        drawNormal();
      } else if (this.enableWrapping) {
        drawWrapped();
      } else {
        moveToStartOfNextRow();
        drawNormal();
      }
      this.keyToLocation.set(key2, locations);
      this.needsBuffer = true;
      return locations;
    }, "draw")
  }, {
    key: "getOffsets",
    value: /* @__PURE__ */ __name(function getOffsets(key2) {
      return this.keyToLocation.get(key2);
    }, "getOffsets")
  }, {
    key: "isEmpty",
    value: /* @__PURE__ */ __name(function isEmpty() {
      return this.freePointer.x === 0 && this.freePointer.row === 0;
    }, "isEmpty")
  }, {
    key: "canFit",
    value: /* @__PURE__ */ __name(function canFit(bb) {
      if (this.locked) return false;
      var texSize = this.texSize, texRows = this.texRows;
      var _this$getScale2 = this.getScale(bb), texW = _this$getScale2.texW;
      if (this.freePointer.x + texW > texSize) {
        return this.freePointer.row < texRows - 1;
      }
      return true;
    }, "canFit")
    // called on every frame
  }, {
    key: "bufferIfNeeded",
    value: /* @__PURE__ */ __name(function bufferIfNeeded(gl) {
      if (!this.texture) {
        this.texture = createTexture(gl, this.debugID);
      }
      if (this.needsBuffer) {
        this.texture.buffer(this.canvas);
        this.needsBuffer = false;
        if (this.locked) {
          this.canvas = null;
          this.scratch = null;
        }
      }
    }, "bufferIfNeeded")
  }, {
    key: "dispose",
    value: /* @__PURE__ */ __name(function dispose() {
      if (this.texture) {
        this.texture.deleteTexture();
        this.texture = null;
      }
      this.canvas = null;
      this.scratch = null;
      this.locked = true;
    }, "dispose")
  }]);
})();
var AtlasCollection = /* @__PURE__ */ (function() {
  function AtlasCollection2(r2, texSize, texRows, createTextureCanvas2) {
    _classCallCheck(this, AtlasCollection2);
    this.r = r2;
    this.texSize = texSize;
    this.texRows = texRows;
    this.createTextureCanvas = createTextureCanvas2;
    this.atlases = [];
    this.styleKeyToAtlas = /* @__PURE__ */ new Map();
    this.markedKeys = /* @__PURE__ */ new Set();
  }
  __name(AtlasCollection2, "AtlasCollection2");
  return _createClass(AtlasCollection2, [{
    key: "getKeys",
    value: /* @__PURE__ */ __name(function getKeys() {
      return new Set(this.styleKeyToAtlas.keys());
    }, "getKeys")
  }, {
    key: "_createAtlas",
    value: /* @__PURE__ */ __name(function _createAtlas() {
      var r2 = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas2 = this.createTextureCanvas;
      return new Atlas(r2, texSize, texRows, createTextureCanvas2);
    }, "_createAtlas")
  }, {
    key: "_getScratchCanvas",
    value: /* @__PURE__ */ __name(function _getScratchCanvas() {
      if (!this.scratch) {
        var r2 = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas2 = this.createTextureCanvas;
        var texHeight = Math.floor(texSize / texRows);
        this.scratch = createTextureCanvas2(r2, texSize, texHeight, "scratch");
      }
      return this.scratch;
    }, "_getScratchCanvas")
  }, {
    key: "draw",
    value: /* @__PURE__ */ __name(function draw(key2, bb, doDrawing) {
      var atlas = this.styleKeyToAtlas.get(key2);
      if (!atlas) {
        atlas = this.atlases[this.atlases.length - 1];
        if (!atlas || !atlas.canFit(bb)) {
          if (atlas) atlas.lock();
          atlas = this._createAtlas();
          this.atlases.push(atlas);
        }
        atlas.draw(key2, bb, doDrawing);
        this.styleKeyToAtlas.set(key2, atlas);
      }
      return atlas;
    }, "draw")
  }, {
    key: "getAtlas",
    value: /* @__PURE__ */ __name(function getAtlas(key2) {
      return this.styleKeyToAtlas.get(key2);
    }, "getAtlas")
  }, {
    key: "hasAtlas",
    value: /* @__PURE__ */ __name(function hasAtlas(key2) {
      return this.styleKeyToAtlas.has(key2);
    }, "hasAtlas")
  }, {
    key: "markKeyForGC",
    value: /* @__PURE__ */ __name(function markKeyForGC(key2) {
      this.markedKeys.add(key2);
    }, "markKeyForGC")
  }, {
    key: "gc",
    value: /* @__PURE__ */ __name(function gc2() {
      var _this2 = this;
      var markedKeys = this.markedKeys;
      if (markedKeys.size === 0) {
        console.log("nothing to garbage collect");
        return;
      }
      var newAtlases = [];
      var newStyleKeyToAtlas = /* @__PURE__ */ new Map();
      var newAtlas = null;
      var _iterator = _createForOfIteratorHelper(this.atlases), _step;
      try {
        var _loop = /* @__PURE__ */ __name(function _loop2() {
          var atlas = _step.value;
          var keys = atlas.getKeys();
          var keysToCollect = intersection(markedKeys, keys);
          if (keysToCollect.size === 0) {
            newAtlases.push(atlas);
            keys.forEach(function(k) {
              return newStyleKeyToAtlas.set(k, atlas);
            });
            return 1;
          }
          if (!newAtlas) {
            newAtlas = _this2._createAtlas();
            newAtlases.push(newAtlas);
          }
          var _iterator2 = _createForOfIteratorHelper(keys), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var key2 = _step2.value;
              if (!keysToCollect.has(key2)) {
                var _atlas$getOffsets = atlas.getOffsets(key2), _atlas$getOffsets2 = _slicedToArray(_atlas$getOffsets, 2), s1 = _atlas$getOffsets2[0], s2 = _atlas$getOffsets2[1];
                if (!newAtlas.canFit({
                  w: s1.w + s2.w,
                  h: s1.h
                })) {
                  newAtlas.lock();
                  newAtlas = _this2._createAtlas();
                  newAtlases.push(newAtlas);
                }
                if (atlas.canvas) {
                  _this2._copyTextureToNewAtlas(key2, atlas, newAtlas);
                  newStyleKeyToAtlas.set(key2, newAtlas);
                }
              }
            }
          } catch (err2) {
            _iterator2.e(err2);
          } finally {
            _iterator2.f();
          }
          atlas.dispose();
        }, "_loop2");
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          if (_loop()) continue;
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
      this.atlases = newAtlases;
      this.styleKeyToAtlas = newStyleKeyToAtlas;
      this.markedKeys = /* @__PURE__ */ new Set();
    }, "gc2")
  }, {
    key: "_copyTextureToNewAtlas",
    value: /* @__PURE__ */ __name(function _copyTextureToNewAtlas(key2, oldAtlas, newAtlas) {
      var _oldAtlas$getOffsets = oldAtlas.getOffsets(key2), _oldAtlas$getOffsets2 = _slicedToArray(_oldAtlas$getOffsets, 2), s1 = _oldAtlas$getOffsets2[0], s2 = _oldAtlas$getOffsets2[1];
      if (s2.w === 0) {
        newAtlas.draw(key2, s1, function(context) {
          context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);
        });
      } else {
        var scratch = this._getScratchCanvas();
        scratch.clear();
        scratch.context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);
        scratch.context.drawImage(oldAtlas.canvas, s2.x, s2.y, s2.w, s2.h, s1.w, 0, s2.w, s2.h);
        var w = s1.w + s2.w;
        var h = s1.h;
        newAtlas.draw(key2, {
          w,
          h
        }, function(context) {
          context.drawImage(
            scratch,
            0,
            0,
            w,
            h,
            0,
            0,
            w,
            h
            // the destination context has already been translated to the correct position
          );
        });
      }
    }, "_copyTextureToNewAtlas")
  }, {
    key: "getCounts",
    value: /* @__PURE__ */ __name(function getCounts() {
      return {
        keyCount: this.styleKeyToAtlas.size,
        atlasCount: new Set(this.styleKeyToAtlas.values()).size
      };
    }, "getCounts")
  }]);
})();
function intersection(set1, set2) {
  if (set1.intersection) return set1.intersection(set2);
  else return new Set(_toConsumableArray(set1).filter(function(x2) {
    return set2.has(x2);
  }));
}
__name(intersection, "intersection");
var AtlasManager = /* @__PURE__ */ (function() {
  function AtlasManager2(r2, globalOptions) {
    _classCallCheck(this, AtlasManager2);
    this.r = r2;
    this.globalOptions = globalOptions;
    this.atlasSize = globalOptions.webglTexSize;
    this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;
    this.renderTypes = /* @__PURE__ */ new Map();
    this.collections = /* @__PURE__ */ new Map();
    this.typeAndIdToKey = /* @__PURE__ */ new Map();
  }
  __name(AtlasManager2, "AtlasManager2");
  return _createClass(AtlasManager2, [{
    key: "getAtlasSize",
    value: /* @__PURE__ */ __name(function getAtlasSize() {
      return this.atlasSize;
    }, "getAtlasSize")
  }, {
    key: "addAtlasCollection",
    value: /* @__PURE__ */ __name(function addAtlasCollection(collectionName, atlasCollectionOptions) {
      var _this$globalOptions = this.globalOptions, webglTexSize = _this$globalOptions.webglTexSize, createTextureCanvas2 = _this$globalOptions.createTextureCanvas;
      var texRows = atlasCollectionOptions.texRows;
      var cachedCreateTextureCanvas = this._cacheScratchCanvas(createTextureCanvas2);
      var atlasCollection = new AtlasCollection(this.r, webglTexSize, texRows, cachedCreateTextureCanvas);
      this.collections.set(collectionName, atlasCollection);
    }, "addAtlasCollection")
  }, {
    key: "addRenderType",
    value: /* @__PURE__ */ __name(function addRenderType(type, renderTypeOptions) {
      var collection4 = renderTypeOptions.collection;
      if (!this.collections.has(collection4)) throw new Error("invalid atlas collection name '".concat(collection4, "'"));
      var atlasCollection = this.collections.get(collection4);
      var opts = extend({
        type,
        atlasCollection
      }, renderTypeOptions);
      this.renderTypes.set(type, opts);
    }, "addRenderType")
  }, {
    key: "getRenderTypeOpts",
    value: /* @__PURE__ */ __name(function getRenderTypeOpts(type) {
      return this.renderTypes.get(type);
    }, "getRenderTypeOpts")
  }, {
    key: "getAtlasCollection",
    value: /* @__PURE__ */ __name(function getAtlasCollection(name) {
      return this.collections.get(name);
    }, "getAtlasCollection")
  }, {
    key: "_cacheScratchCanvas",
    value: /* @__PURE__ */ __name(function _cacheScratchCanvas(createTextureCanvas2) {
      var prevW = -1;
      var prevH = -1;
      var scratchCanvas = null;
      return function(r2, w, h, scratch) {
        if (scratch) {
          if (!scratchCanvas || w != prevW || h != prevH) {
            prevW = w;
            prevH = h;
            scratchCanvas = createTextureCanvas2(r2, w, h);
          }
          return scratchCanvas;
        } else {
          return createTextureCanvas2(r2, w, h);
        }
      };
    }, "_cacheScratchCanvas")
  }, {
    key: "_key",
    value: /* @__PURE__ */ __name(function _key(renderType, id2) {
      return "".concat(renderType, "-").concat(id2);
    }, "_key")
    /** Marks textues associated with the element for garbage collection. */
  }, {
    key: "invalidate",
    value: /* @__PURE__ */ __name(function invalidate(eles) {
      var _this3 = this;
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$forceRedraw = _ref2.forceRedraw, forceRedraw = _ref2$forceRedraw === void 0 ? false : _ref2$forceRedraw, _ref2$filterEle = _ref2.filterEle, filterEle = _ref2$filterEle === void 0 ? function() {
        return true;
      } : _ref2$filterEle, _ref2$filterType = _ref2.filterType, filterType = _ref2$filterType === void 0 ? function() {
        return true;
      } : _ref2$filterType;
      var needGC = false;
      var runGCNow = false;
      var _iterator3 = _createForOfIteratorHelper(eles), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var ele = _step3.value;
          if (filterEle(ele)) {
            var _iterator4 = _createForOfIteratorHelper(this.renderTypes.values()), _step4;
            try {
              var _loop2 = /* @__PURE__ */ __name(function _loop22() {
                var opts = _step4.value;
                var renderType = opts.type;
                if (filterType(renderType)) {
                  var atlasCollection = _this3.collections.get(opts.collection);
                  var key2 = opts.getKey(ele);
                  var keyArray = Array.isArray(key2) ? key2 : [key2];
                  if (forceRedraw) {
                    keyArray.forEach(function(key22) {
                      return atlasCollection.markKeyForGC(key22);
                    });
                    runGCNow = true;
                  } else {
                    var id2 = opts.getID ? opts.getID(ele) : ele.id();
                    var mapKey = _this3._key(renderType, id2);
                    var oldKeyArray = _this3.typeAndIdToKey.get(mapKey);
                    if (oldKeyArray !== void 0 && !arrayEqual(keyArray, oldKeyArray)) {
                      needGC = true;
                      _this3.typeAndIdToKey["delete"](mapKey);
                      oldKeyArray.forEach(function(oldKey) {
                        return atlasCollection.markKeyForGC(oldKey);
                      });
                    }
                  }
                }
              }, "_loop22");
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                _loop2();
              }
            } catch (err2) {
              _iterator4.e(err2);
            } finally {
              _iterator4.f();
            }
          }
        }
      } catch (err2) {
        _iterator3.e(err2);
      } finally {
        _iterator3.f();
      }
      if (runGCNow) {
        this.gc();
        needGC = false;
      }
      return needGC;
    }, "invalidate")
    /** Garbage collect */
  }, {
    key: "gc",
    value: /* @__PURE__ */ __name(function gc2() {
      var _iterator5 = _createForOfIteratorHelper(this.collections.values()), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var collection4 = _step5.value;
          collection4.gc();
        }
      } catch (err2) {
        _iterator5.e(err2);
      } finally {
        _iterator5.f();
      }
    }, "gc2")
  }, {
    key: "getOrCreateAtlas",
    value: /* @__PURE__ */ __name(function getOrCreateAtlas(ele, type, bb, styleKey) {
      var opts = this.renderTypes.get(type);
      var atlasCollection = this.collections.get(opts.collection);
      var drawn = false;
      var atlas = atlasCollection.draw(styleKey, bb, function(context) {
        if (opts.drawClipped) {
          context.save();
          context.beginPath();
          context.rect(0, 0, bb.w, bb.h);
          context.clip();
          opts.drawElement(context, ele, bb, true, true);
          context.restore();
        } else {
          opts.drawElement(context, ele, bb, true, true);
        }
        drawn = true;
      });
      if (drawn) {
        var id2 = opts.getID ? opts.getID(ele) : ele.id();
        var mapKey = this._key(type, id2);
        if (this.typeAndIdToKey.has(mapKey)) {
          this.typeAndIdToKey.get(mapKey).push(styleKey);
        } else {
          this.typeAndIdToKey.set(mapKey, [styleKey]);
        }
      }
      return atlas;
    }, "getOrCreateAtlas")
  }, {
    key: "getAtlasInfo",
    value: /* @__PURE__ */ __name(function getAtlasInfo(ele, type) {
      var _this4 = this;
      var opts = this.renderTypes.get(type);
      var key2 = opts.getKey(ele);
      var keyArray = Array.isArray(key2) ? key2 : [key2];
      return keyArray.map(function(styleKey) {
        var bb = opts.getBoundingBox(ele, styleKey);
        var atlas = _this4.getOrCreateAtlas(ele, type, bb, styleKey);
        var _atlas$getOffsets3 = atlas.getOffsets(styleKey), _atlas$getOffsets4 = _slicedToArray(_atlas$getOffsets3, 2), tex1 = _atlas$getOffsets4[0], tex2 = _atlas$getOffsets4[1];
        return {
          atlas,
          tex: tex1,
          tex1,
          tex2,
          bb
        };
      });
    }, "getAtlasInfo")
  }, {
    key: "getDebugInfo",
    value: /* @__PURE__ */ __name(function getDebugInfo() {
      var debugInfo = [];
      var _iterator6 = _createForOfIteratorHelper(this.collections), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var _step6$value = _slicedToArray(_step6.value, 2), name = _step6$value[0], collection4 = _step6$value[1];
          var _collection$getCounts = collection4.getCounts(), keyCount = _collection$getCounts.keyCount, atlasCount = _collection$getCounts.atlasCount;
          debugInfo.push({
            type: name,
            keyCount,
            atlasCount
          });
        }
      } catch (err2) {
        _iterator6.e(err2);
      } finally {
        _iterator6.f();
      }
      return debugInfo;
    }, "getDebugInfo")
  }]);
})();
var AtlasBatchManager = /* @__PURE__ */ (function() {
  function AtlasBatchManager2(globalOptions) {
    _classCallCheck(this, AtlasBatchManager2);
    this.globalOptions = globalOptions;
    this.atlasSize = globalOptions.webglTexSize;
    this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;
    this.batchAtlases = [];
  }
  __name(AtlasBatchManager2, "AtlasBatchManager2");
  return _createClass(AtlasBatchManager2, [{
    key: "getMaxAtlasesPerBatch",
    value: /* @__PURE__ */ __name(function getMaxAtlasesPerBatch() {
      return this.maxAtlasesPerBatch;
    }, "getMaxAtlasesPerBatch")
  }, {
    key: "getAtlasSize",
    value: /* @__PURE__ */ __name(function getAtlasSize() {
      return this.atlasSize;
    }, "getAtlasSize")
  }, {
    key: "getIndexArray",
    value: /* @__PURE__ */ __name(function getIndexArray() {
      return Array.from({
        length: this.maxAtlasesPerBatch
      }, function(v, i) {
        return i;
      });
    }, "getIndexArray")
  }, {
    key: "startBatch",
    value: /* @__PURE__ */ __name(function startBatch2() {
      this.batchAtlases = [];
    }, "startBatch2")
  }, {
    key: "getAtlasCount",
    value: /* @__PURE__ */ __name(function getAtlasCount() {
      return this.batchAtlases.length;
    }, "getAtlasCount")
  }, {
    key: "getAtlases",
    value: /* @__PURE__ */ __name(function getAtlases() {
      return this.batchAtlases;
    }, "getAtlases")
  }, {
    key: "canAddToCurrentBatch",
    value: /* @__PURE__ */ __name(function canAddToCurrentBatch(atlas) {
      if (this.batchAtlases.length === this.maxAtlasesPerBatch) {
        return this.batchAtlases.includes(atlas);
      }
      return true;
    }, "canAddToCurrentBatch")
  }, {
    key: "getAtlasIndexForBatch",
    value: /* @__PURE__ */ __name(function getAtlasIndexForBatch(atlas) {
      var atlasID = this.batchAtlases.indexOf(atlas);
      if (atlasID < 0) {
        if (this.batchAtlases.length === this.maxAtlasesPerBatch) {
          throw new Error("cannot add more atlases to batch");
        }
        this.batchAtlases.push(atlas);
        atlasID = this.batchAtlases.length - 1;
      }
      return atlasID;
    }, "getAtlasIndexForBatch")
  }]);
})();
var circleSD = "\n  float circleSD(vec2 p, float r) {\n    return distance(vec2(0), p) - r; // signed distance\n  }\n";
var rectangleSD = "\n  float rectangleSD(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n";
var roundRectangleSD = "\n  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {\n    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;\n    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;\n    vec2 q = abs(p) - b + cr.x;\n    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;\n  }\n";
var ellipseSD = "\n  float ellipseSD(vec2 p, vec2 ab) {\n    p = abs( p ); // symmetry\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n    float w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ ) {\n      vec2 cs = vec2(cos(w),sin(w));\n      vec2 u = ab*vec2( cs.x,cs.y);\n      vec2 v = ab*vec2(-cs.y,cs.x);\n      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n  }\n";
var RENDER_TARGET = {
  SCREEN: {
    name: "screen",
    screen: true
  },
  PICKING: {
    name: "picking",
    picking: true
  }
};
var TEX_PICKING_MODE = {
  // render the texture just like in RENDER_TARGET.SCREEN mode
  IGNORE: 1,
  // don't render the texture at all
  USE_BB: 2
  // render the bounding box as an opaque rectangle
};
var TEXTURE = 0;
var EDGE_STRAIGHT = 1;
var EDGE_CURVE_SEGMENT = 2;
var EDGE_ARROW = 3;
var RECTANGLE = 4;
var ROUND_RECTANGLE = 5;
var BOTTOM_ROUND_RECTANGLE = 6;
var ELLIPSE = 7;
var ElementDrawingWebGL = /* @__PURE__ */ (function() {
  function ElementDrawingWebGL2(r2, gl, opts) {
    _classCallCheck(this, ElementDrawingWebGL2);
    this.r = r2;
    this.gl = gl;
    this.maxInstances = opts.webglBatchSize;
    this.atlasSize = opts.webglTexSize;
    this.bgColor = opts.bgColor;
    this.debug = opts.webglDebug;
    this.batchDebugInfo = [];
    opts.enableWrapping = true;
    opts.createTextureCanvas = createTextureCanvas;
    this.atlasManager = new AtlasManager(r2, opts);
    this.batchManager = new AtlasBatchManager(opts);
    this.simpleShapeOptions = /* @__PURE__ */ new Map();
    this.program = this._createShaderProgram(RENDER_TARGET.SCREEN);
    this.pickingProgram = this._createShaderProgram(RENDER_TARGET.PICKING);
    this.vao = this._createVAO();
  }
  __name(ElementDrawingWebGL2, "ElementDrawingWebGL2");
  return _createClass(ElementDrawingWebGL2, [{
    key: "addAtlasCollection",
    value: /* @__PURE__ */ __name(function addAtlasCollection(collectionName, opts) {
      this.atlasManager.addAtlasCollection(collectionName, opts);
    }, "addAtlasCollection")
    /**
     * @typedef { Object } TextureRenderTypeOpts
     * @property { string } collection - name of atlas collection to render textures to
     * @property { function } getKey - returns the "style key" for an element, may be a single value or an array for multi-line lables
     * @property { function } drawElement - uses a canvas renderer to draw the element to the texture atlas
     * @property { boolean  } drawClipped - if true the context will be clipped to the bounding box before drawElement() is called, may affect performance
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } getRotation
     * @property { function } getRotationPoint
     * @property { function } getRotationOffset
     * @property { function } isVisible - an extra check for visibility in addition to ele.visible()
     * @property { function } getTexPickingMode - returns a value from the TEX_PICKING_MODE enum
     */
    /**
     * @param { string } typeName
     * @param { TextureRenderTypeOpts } opts
     */
  }, {
    key: "addTextureAtlasRenderType",
    value: /* @__PURE__ */ __name(function addTextureAtlasRenderType(typeName, opts) {
      this.atlasManager.addRenderType(typeName, opts);
    }, "addTextureAtlasRenderType")
    /**
     * @typedef { Object } SimpleShapeRenderTypeOpts
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } isVisible - this is an extra check for visibility in addition to ele.visible()
     * @property { function } isSimple - check if element is a simple shape, or if it needs to fall back to texture rendering
     * @property { ShapeVisualProperties } shapeProps
     */
    /**
     * @typedef { Object } ShapeVisualProperties
     * @property { string } shape
     * @property { string } color
     * @property { string } opacity
     * @property { string } padding
     * @property { string } radius
     * @property { boolean } border
    */
    /**
     * @param { string } typeName
     * @param { SimpleShapeRenderTypeOpts } opts
     */
  }, {
    key: "addSimpleShapeRenderType",
    value: /* @__PURE__ */ __name(function addSimpleShapeRenderType(typeName, opts) {
      this.simpleShapeOptions.set(typeName, opts);
    }, "addSimpleShapeRenderType")
    /**
     * Inform the atlasManager when element style keys may have changed.
     * The atlasManager can then mark unused textures for "garbage collection".
     */
  }, {
    key: "invalidate",
    value: /* @__PURE__ */ __name(function invalidate(eles) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, type = _ref.type;
      var atlasManager = this.atlasManager;
      if (type) {
        return atlasManager.invalidate(eles, {
          filterType: /* @__PURE__ */ __name(function filterType(t) {
            return t === type;
          }, "filterType"),
          forceRedraw: true
        });
      } else {
        return atlasManager.invalidate(eles);
      }
    }, "invalidate")
    /**
     * Run texture garbage collection.
     */
  }, {
    key: "gc",
    value: /* @__PURE__ */ __name(function gc2() {
      this.atlasManager.gc();
    }, "gc2")
  }, {
    key: "_createShaderProgram",
    value: /* @__PURE__ */ __name(function _createShaderProgram(renderTarget) {
      var gl = this.gl;
      var vertexShaderSource = "#version 300 es\n      precision highp float;\n\n      uniform mat3 uPanZoomMatrix;\n      uniform int  uAtlasSize;\n      \n      // instanced\n      in vec2 aPosition; // a vertex from the unit square\n      \n      in mat3 aTransform; // used to transform verticies, eg into a bounding box\n      in int aVertType; // the type of thing we are rendering\n\n      // the z-index that is output when using picking mode\n      in vec4 aIndex;\n      \n      // For textures\n      in int aAtlasId; // which shader unit/atlas to use\n      in vec4 aTex; // x/y/w/h of texture in atlas\n\n      // for edges\n      in vec4 aPointAPointB;\n      in vec4 aPointCPointD;\n      in vec2 aLineWidth; // also used for node border width\n\n      // simple shapes\n      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]\n      in vec4 aColor; // also used for edges\n      in vec4 aBorderColor; // aLineWidth is used for border width\n\n      // output values passed to the fragment shader\n      out vec2 vTexCoord;\n      out vec4 vColor;\n      out vec2 vPosition;\n      // flat values are not interpolated\n      flat out int vAtlasId; \n      flat out int vVertType;\n      flat out vec2 vTopRight;\n      flat out vec2 vBotLeft;\n      flat out vec4 vCornerRadius;\n      flat out vec4 vBorderColor;\n      flat out vec2 vBorderWidth;\n      flat out vec4 vIndex;\n      \n      void main(void) {\n        int vid = gl_VertexID;\n        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below\n\n        if(aVertType == ".concat(TEXTURE, ") {\n          float texX = aTex.x; // texture coordinates\n          float texY = aTex.y;\n          float texW = aTex.z;\n          float texH = aTex.w;\n\n          if(vid == 1 || vid == 2 || vid == 4) {\n            texX += texW;\n          }\n          if(vid == 2 || vid == 4 || vid == 5) {\n            texY += texH;\n          }\n\n          float d = float(uAtlasSize);\n          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1\n\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\n        }\n        else if(aVertType == ").concat(RECTANGLE, " || aVertType == ").concat(ELLIPSE, " \n             || aVertType == ").concat(ROUND_RECTANGLE, " || aVertType == ").concat(BOTTOM_ROUND_RECTANGLE, ") { // simple shapes\n\n          // the bounding box is needed by the fragment shader\n          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat\n          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat\n          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated\n\n          // calculations are done in the fragment shader, just pass these along\n          vColor = aColor;\n          vCornerRadius = aCornerRadius;\n          vBorderColor = aBorderColor;\n          vBorderWidth = aLineWidth;\n\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\n        }\n        else if(aVertType == ").concat(EDGE_STRAIGHT, ") {\n          vec2 source = aPointAPointB.xy;\n          vec2 target = aPointAPointB.zw;\n\n          // adjust the geometry so that the line is centered on the edge\n          position.y = position.y - 0.5;\n\n          // stretch the unit square into a long skinny rectangle\n          vec2 xBasis = target - source;\n          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;\n\n          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);\n          vColor = aColor;\n        } \n        else if(aVertType == ").concat(EDGE_CURVE_SEGMENT, ") {\n          vec2 pointA = aPointAPointB.xy;\n          vec2 pointB = aPointAPointB.zw;\n          vec2 pointC = aPointCPointD.xy;\n          vec2 pointD = aPointCPointD.zw;\n\n          // adjust the geometry so that the line is centered on the edge\n          position.y = position.y - 0.5;\n\n          vec2 p0, p1, p2, pos;\n          if(position.x == 0.0) { // The left side of the unit square\n            p0 = pointA;\n            p1 = pointB;\n            p2 = pointC;\n            pos = position;\n          } else { // The right side of the unit square, use same approach but flip the geometry upside down\n            p0 = pointD;\n            p1 = pointC;\n            p2 = pointB;\n            pos = vec2(0.0, -position.y);\n          }\n\n          vec2 p01 = p1 - p0;\n          vec2 p12 = p2 - p1;\n          vec2 p21 = p1 - p2;\n\n          // Find the normal vector.\n          vec2 tangent = normalize(normalize(p12) + normalize(p01));\n          vec2 normal = vec2(-tangent.y, tangent.x);\n\n          // Find the vector perpendicular to p0 -> p1.\n          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));\n\n          // Determine the bend direction.\n          float sigma = sign(dot(p01 + p21, normal));\n          float width = aLineWidth[0];\n\n          if(sign(pos.y) == -sigma) {\n            // This is an intersecting vertex. Adjust the position so that there's no overlap.\n            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\n          } else {\n            // This is a non-intersecting vertex. Treat it like a mitre join.\n            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\n          }\n\n          vColor = aColor;\n        } \n        else if(aVertType == ").concat(EDGE_ARROW, " && vid < 3) {\n          // massage the first triangle into an edge arrow\n          if(vid == 0)\n            position = vec2(-0.15, -0.3);\n          if(vid == 1)\n            position = vec2(  0.0,  0.0);\n          if(vid == 2)\n            position = vec2( 0.15, -0.3);\n\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\n          vColor = aColor;\n        }\n        else {\n          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space\n        }\n\n        vAtlasId = aAtlasId;\n        vVertType = aVertType;\n        vIndex = aIndex;\n      }\n    ");
      var idxs = this.batchManager.getIndexArray();
      var fragmentShaderSource = "#version 300 es\n      precision highp float;\n\n      // declare texture unit for each texture atlas in the batch\n      ".concat(idxs.map(function(i2) {
        return "uniform sampler2D uTexture".concat(i2, ";");
      }).join("\n	"), "\n\n      uniform vec4 uBGColor;\n      uniform float uZoom;\n\n      in vec2 vTexCoord;\n      in vec4 vColor;\n      in vec2 vPosition; // model coordinates\n\n      flat in int vAtlasId;\n      flat in vec4 vIndex;\n      flat in int vVertType;\n      flat in vec2 vTopRight;\n      flat in vec2 vBotLeft;\n      flat in vec4 vCornerRadius;\n      flat in vec4 vBorderColor;\n      flat in vec2 vBorderWidth;\n\n      out vec4 outColor;\n\n      ").concat(circleSD, "\n      ").concat(rectangleSD, "\n      ").concat(roundRectangleSD, "\n      ").concat(ellipseSD, "\n\n      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha\n        return vec4( \n          top.rgb + (bot.rgb * (1.0 - top.a)),\n          top.a   + (bot.a   * (1.0 - top.a)) \n        );\n      }\n\n      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance\n        // scale to the zoom level so that borders don't look blurry when zoomed in\n        // note 1.5 is an aribitrary value chosen because it looks good\n        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); \n      }\n\n      void main(void) {\n        if(vVertType == ").concat(TEXTURE, ") {\n          // look up the texel from the texture unit\n          ").concat(idxs.map(function(i2) {
        return "if(vAtlasId == ".concat(i2, ") outColor = texture(uTexture").concat(i2, ", vTexCoord);");
      }).join("\n	else "), "\n        } \n        else if(vVertType == ").concat(EDGE_ARROW, ") {\n          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';\n          outColor = blend(vColor, uBGColor);\n          outColor.a = 1.0; // make opaque, masks out line under arrow\n        }\n        else if(vVertType == ").concat(RECTANGLE, " && vBorderWidth == vec2(0.0)) { // simple rectangle with no border\n          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done\n        }\n        else if(vVertType == ").concat(RECTANGLE, " || vVertType == ").concat(ELLIPSE, " \n          || vVertType == ").concat(ROUND_RECTANGLE, " || vVertType == ").concat(BOTTOM_ROUND_RECTANGLE, ") { // use SDF\n\n          float outerBorder = vBorderWidth[0];\n          float innerBorder = vBorderWidth[1];\n          float borderPadding = outerBorder * 2.0;\n          float w = vTopRight.x - vBotLeft.x - borderPadding;\n          float h = vTopRight.y - vBotLeft.y - borderPadding;\n          vec2 b = vec2(w/2.0, h/2.0); // half width, half height\n          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center\n\n          float d; // signed distance\n          if(vVertType == ").concat(RECTANGLE, ") {\n            d = rectangleSD(p, b);\n          } else if(vVertType == ").concat(ELLIPSE, " && w == h) {\n            d = circleSD(p, b.x); // faster than ellipse\n          } else if(vVertType == ").concat(ELLIPSE, ") {\n            d = ellipseSD(p, b);\n          } else {\n            d = roundRectangleSD(p, b, vCornerRadius.wzyx);\n          }\n\n          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling\n          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box\n          if(d > 0.0) {\n            if(d > outerBorder) {\n              discard;\n            } else {\n              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);\n            }\n          } else {\n            if(d > innerBorder) {\n              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;\n              vec4 innerBorderColor = blend(vBorderColor, vColor);\n              outColor = distInterp(innerBorderColor, outerColor, d);\n            } \n            else {\n              vec4 outerColor;\n              if(innerBorder == 0.0 && outerBorder == 0.0) {\n                outerColor = vec4(0);\n              } else if(innerBorder == 0.0) {\n                outerColor = vBorderColor;\n              } else {\n                outerColor = blend(vBorderColor, vColor);\n              }\n              outColor = distInterp(vColor, outerColor, d - innerBorder);\n            }\n          }\n        }\n        else {\n          outColor = vColor;\n        }\n\n        ").concat(renderTarget.picking ? "if(outColor.a == 0.0) discard;\n             else outColor = vIndex;" : "", "\n      }\n    ");
      var program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
      program.aPosition = gl.getAttribLocation(program, "aPosition");
      program.aIndex = gl.getAttribLocation(program, "aIndex");
      program.aVertType = gl.getAttribLocation(program, "aVertType");
      program.aTransform = gl.getAttribLocation(program, "aTransform");
      program.aAtlasId = gl.getAttribLocation(program, "aAtlasId");
      program.aTex = gl.getAttribLocation(program, "aTex");
      program.aPointAPointB = gl.getAttribLocation(program, "aPointAPointB");
      program.aPointCPointD = gl.getAttribLocation(program, "aPointCPointD");
      program.aLineWidth = gl.getAttribLocation(program, "aLineWidth");
      program.aColor = gl.getAttribLocation(program, "aColor");
      program.aCornerRadius = gl.getAttribLocation(program, "aCornerRadius");
      program.aBorderColor = gl.getAttribLocation(program, "aBorderColor");
      program.uPanZoomMatrix = gl.getUniformLocation(program, "uPanZoomMatrix");
      program.uAtlasSize = gl.getUniformLocation(program, "uAtlasSize");
      program.uBGColor = gl.getUniformLocation(program, "uBGColor");
      program.uZoom = gl.getUniformLocation(program, "uZoom");
      program.uTextures = [];
      for (var i = 0; i < this.batchManager.getMaxAtlasesPerBatch(); i++) {
        program.uTextures.push(gl.getUniformLocation(program, "uTexture".concat(i)));
      }
      return program;
    }, "_createShaderProgram")
  }, {
    key: "_createVAO",
    value: /* @__PURE__ */ __name(function _createVAO() {
      var unitSquare = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];
      this.vertexCount = unitSquare.length / 2;
      var n = this.maxInstances;
      var gl = this.gl, program = this.program;
      var vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      createBufferStaticDraw(gl, "vec2", program.aPosition, unitSquare);
      this.transformBuffer = create3x3MatrixBufferDynamicDraw(gl, n, program.aTransform);
      this.indexBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aIndex);
      this.vertTypeBuffer = createBufferDynamicDraw(gl, n, "int", program.aVertType);
      this.atlasIdBuffer = createBufferDynamicDraw(gl, n, "int", program.aAtlasId);
      this.texBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aTex);
      this.pointAPointBBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aPointAPointB);
      this.pointCPointDBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aPointCPointD);
      this.lineWidthBuffer = createBufferDynamicDraw(gl, n, "vec2", program.aLineWidth);
      this.colorBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aColor);
      this.cornerRadiusBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aCornerRadius);
      this.borderColorBuffer = createBufferDynamicDraw(gl, n, "vec4", program.aBorderColor);
      gl.bindVertexArray(null);
      return vao;
    }, "_createVAO")
  }, {
    key: "buffers",
    get: /* @__PURE__ */ __name(function get2() {
      var _this = this;
      if (!this._buffers) {
        this._buffers = Object.keys(this).filter(function(k) {
          return endsWith(k, "Buffer");
        }).map(function(k) {
          return _this[k];
        });
      }
      return this._buffers;
    }, "get2")
  }, {
    key: "startFrame",
    value: /* @__PURE__ */ __name(function startFrame(panZoomMatrix) {
      var renderTarget = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : RENDER_TARGET.SCREEN;
      this.panZoomMatrix = panZoomMatrix;
      this.renderTarget = renderTarget;
      this.batchDebugInfo = [];
      this.wrappedCount = 0;
      this.simpleCount = 0;
      this.startBatch();
    }, "startFrame")
  }, {
    key: "startBatch",
    value: /* @__PURE__ */ __name(function startBatch2() {
      this.instanceCount = 0;
      this.batchManager.startBatch();
    }, "startBatch2")
  }, {
    key: "endFrame",
    value: /* @__PURE__ */ __name(function endFrame() {
      this.endBatch();
    }, "endFrame")
  }, {
    key: "_isVisible",
    value: /* @__PURE__ */ __name(function _isVisible(ele, opts) {
      if (ele.visible()) {
        if (opts && opts.isVisible) {
          return opts.isVisible(ele);
        }
        return true;
      }
      return false;
    }, "_isVisible")
    /**
     * Draws a texture using the texture atlas.
     */
  }, {
    key: "drawTexture",
    value: /* @__PURE__ */ __name(function drawTexture(ele, eleIndex, type) {
      var atlasManager = this.atlasManager, batchManager = this.batchManager;
      var opts = atlasManager.getRenderTypeOpts(type);
      if (!this._isVisible(ele, opts)) {
        return;
      }
      if (ele.isEdge() && !this._isValidEdge(ele)) {
        return;
      }
      if (this.renderTarget.picking && opts.getTexPickingMode) {
        var mode = opts.getTexPickingMode(ele);
        if (mode === TEX_PICKING_MODE.IGNORE) {
          return;
        } else if (mode == TEX_PICKING_MODE.USE_BB) {
          this.drawPickingRectangle(ele, eleIndex, type);
          return;
        }
      }
      var atlasInfoArray = atlasManager.getAtlasInfo(ele, type);
      var _iterator = _createForOfIteratorHelper(atlasInfoArray), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var atlasInfo = _step.value;
          var atlas = atlasInfo.atlas, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2;
          if (!batchManager.canAddToCurrentBatch(atlas)) {
            this.endBatch();
          }
          var atlasIndex = batchManager.getAtlasIndexForBatch(atlas);
          for (var _i = 0, _arr = [[tex1, true], [tex2, false]]; _i < _arr.length; _i++) {
            var _arr$_i = _slicedToArray(_arr[_i], 2), tex = _arr$_i[0], first2 = _arr$_i[1];
            if (tex.w != 0) {
              var instance2 = this.instanceCount;
              this.vertTypeBuffer.getView(instance2)[0] = TEXTURE;
              var indexView = this.indexBuffer.getView(instance2);
              indexToVec4(eleIndex, indexView);
              var atlasIdView = this.atlasIdBuffer.getView(instance2);
              atlasIdView[0] = atlasIndex;
              var texView = this.texBuffer.getView(instance2);
              texView[0] = tex.x;
              texView[1] = tex.y;
              texView[2] = tex.w;
              texView[3] = tex.h;
              var matrixView = this.transformBuffer.getMatrixView(instance2);
              this.setTransformMatrix(ele, matrixView, opts, atlasInfo, first2);
              this.instanceCount++;
              if (!first2) this.wrappedCount++;
              if (this.instanceCount >= this.maxInstances) {
                this.endBatch();
              }
            }
          }
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
    }, "drawTexture")
    /**
     * matrix is expected to be a 9 element array
     * this function follows same pattern as CRp.drawCachedElementPortion(...)
     */
  }, {
    key: "setTransformMatrix",
    value: /* @__PURE__ */ __name(function setTransformMatrix(ele, matrix, opts, atlasInfo) {
      var first2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      var padding = 0;
      if (opts.shapeProps && opts.shapeProps.padding) {
        padding = ele.pstyle(opts.shapeProps.padding).pfValue;
      }
      if (atlasInfo) {
        var bb = atlasInfo.bb, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2;
        var ratio = tex1.w / (tex1.w + tex2.w);
        if (!first2) {
          ratio = 1 - ratio;
        }
        var adjBB = this._getAdjustedBB(bb, padding, first2, ratio);
        this._applyTransformMatrix(matrix, adjBB, opts, ele);
      } else {
        var _bb = opts.getBoundingBox(ele);
        var _adjBB = this._getAdjustedBB(_bb, padding, true, 1);
        this._applyTransformMatrix(matrix, _adjBB, opts, ele);
      }
    }, "setTransformMatrix")
  }, {
    key: "_applyTransformMatrix",
    value: /* @__PURE__ */ __name(function _applyTransformMatrix(matrix, adjBB, opts, ele) {
      var x2, y2;
      identity2(matrix);
      var theta = opts.getRotation ? opts.getRotation(ele) : 0;
      if (theta !== 0) {
        var _opts$getRotationPoin = opts.getRotationPoint(ele), sx = _opts$getRotationPoin.x, sy = _opts$getRotationPoin.y;
        translate(matrix, matrix, [sx, sy]);
        rotate(matrix, matrix, theta);
        var offset = opts.getRotationOffset(ele);
        x2 = offset.x + (adjBB.xOffset || 0);
        y2 = offset.y + (adjBB.yOffset || 0);
      } else {
        x2 = adjBB.x1;
        y2 = adjBB.y1;
      }
      translate(matrix, matrix, [x2, y2]);
      scale(matrix, matrix, [adjBB.w, adjBB.h]);
    }, "_applyTransformMatrix")
    /**
     * Adjusts a node or label BB to accomodate padding and split for wrapped textures.
     * @param bb - the original bounding box
     * @param padding - the padding to add to the bounding box
     * @param first - whether this is the first part of a wrapped texture
     * @param ratio - the ratio of the texture width of part of the text to the entire texture
     */
  }, {
    key: "_getAdjustedBB",
    value: /* @__PURE__ */ __name(function _getAdjustedBB(bb, padding, first2, ratio) {
      var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h, yOffset = bb.yOffset;
      if (padding) {
        x1 -= padding;
        y1 -= padding;
        w += 2 * padding;
        h += 2 * padding;
      }
      var xOffset = 0;
      var adjW = w * ratio;
      if (first2 && ratio < 1) {
        w = adjW;
      } else if (!first2 && ratio < 1) {
        xOffset = w - adjW;
        x1 += xOffset;
        w = adjW;
      }
      return {
        x1,
        y1,
        w,
        h,
        xOffset,
        yOffset
      };
    }, "_getAdjustedBB")
    /**
     * Draw a solid opaque rectangle matching the element's Bounding Box.
     * Used by the PICKING mode to make the entire BB of a label clickable.
     */
  }, {
    key: "drawPickingRectangle",
    value: /* @__PURE__ */ __name(function drawPickingRectangle(ele, eleIndex, type) {
      var opts = this.atlasManager.getRenderTypeOpts(type);
      var instance2 = this.instanceCount;
      this.vertTypeBuffer.getView(instance2)[0] = RECTANGLE;
      var indexView = this.indexBuffer.getView(instance2);
      indexToVec4(eleIndex, indexView);
      var colorView = this.colorBuffer.getView(instance2);
      toWebGLColor([0, 0, 0], 1, colorView);
      var matrixView = this.transformBuffer.getMatrixView(instance2);
      this.setTransformMatrix(ele, matrixView, opts);
      this.simpleCount++;
      this.instanceCount++;
      if (this.instanceCount >= this.maxInstances) {
        this.endBatch();
      }
    }, "drawPickingRectangle")
    /**
     * Draw a node using either a texture or a "simple shape".
     */
  }, {
    key: "drawNode",
    value: /* @__PURE__ */ __name(function drawNode(node, eleIndex, type) {
      var opts = this.simpleShapeOptions.get(type);
      if (!this._isVisible(node, opts)) {
        return;
      }
      var props = opts.shapeProps;
      var vertType = this._getVertTypeForShape(node, props.shape);
      if (vertType === void 0 || opts.isSimple && !opts.isSimple(node)) {
        this.drawTexture(node, eleIndex, type);
        return;
      }
      var instance2 = this.instanceCount;
      this.vertTypeBuffer.getView(instance2)[0] = vertType;
      if (vertType === ROUND_RECTANGLE || vertType === BOTTOM_ROUND_RECTANGLE) {
        var bb = opts.getBoundingBox(node);
        var radius2 = this._getCornerRadius(node, props.radius, bb);
        var radiusView = this.cornerRadiusBuffer.getView(instance2);
        radiusView[0] = radius2;
        radiusView[1] = radius2;
        radiusView[2] = radius2;
        radiusView[3] = radius2;
        if (vertType === BOTTOM_ROUND_RECTANGLE) {
          radiusView[0] = 0;
          radiusView[2] = 0;
        }
      }
      var indexView = this.indexBuffer.getView(instance2);
      indexToVec4(eleIndex, indexView);
      var color = node.pstyle(props.color).value;
      var opacity = node.pstyle(props.opacity).value;
      var colorView = this.colorBuffer.getView(instance2);
      toWebGLColor(color, opacity, colorView);
      var lineWidthView = this.lineWidthBuffer.getView(instance2);
      lineWidthView[0] = 0;
      lineWidthView[1] = 0;
      if (props.border) {
        var borderWidth = node.pstyle("border-width").value;
        if (borderWidth > 0) {
          var borderColor = node.pstyle("border-color").value;
          var borderOpacity = node.pstyle("border-opacity").value;
          var borderColorView = this.borderColorBuffer.getView(instance2);
          toWebGLColor(borderColor, borderOpacity, borderColorView);
          var borderPos = node.pstyle("border-position").value;
          if (borderPos === "inside") {
            lineWidthView[0] = 0;
            lineWidthView[1] = -borderWidth;
          } else if (borderPos === "outside") {
            lineWidthView[0] = borderWidth;
            lineWidthView[1] = 0;
          } else {
            var halfWidth = borderWidth / 2;
            lineWidthView[0] = halfWidth;
            lineWidthView[1] = -halfWidth;
          }
        }
      }
      var matrixView = this.transformBuffer.getMatrixView(instance2);
      this.setTransformMatrix(node, matrixView, opts);
      this.simpleCount++;
      this.instanceCount++;
      if (this.instanceCount >= this.maxInstances) {
        this.endBatch();
      }
    }, "drawNode")
  }, {
    key: "_getVertTypeForShape",
    value: /* @__PURE__ */ __name(function _getVertTypeForShape(node, shapeProp) {
      var shape = node.pstyle(shapeProp).value;
      switch (shape) {
        case "rectangle":
          return RECTANGLE;
        case "ellipse":
          return ELLIPSE;
        case "roundrectangle":
        case "round-rectangle":
          return ROUND_RECTANGLE;
        case "bottom-round-rectangle":
          return BOTTOM_ROUND_RECTANGLE;
        default:
          return void 0;
      }
    }, "_getVertTypeForShape")
  }, {
    key: "_getCornerRadius",
    value: /* @__PURE__ */ __name(function _getCornerRadius(node, radiusProp, _ref2) {
      var w = _ref2.w, h = _ref2.h;
      if (node.pstyle(radiusProp).value === "auto") {
        return getRoundRectangleRadius(w, h);
      } else {
        var radius2 = node.pstyle(radiusProp).pfValue;
        var halfWidth = w / 2;
        var halfHeight = h / 2;
        return Math.min(radius2, halfHeight, halfWidth);
      }
    }, "_getCornerRadius")
    /**
     * Only supports drawing triangles at the moment.
     */
  }, {
    key: "drawEdgeArrow",
    value: /* @__PURE__ */ __name(function drawEdgeArrow(edge, eleIndex, prefix) {
      if (!edge.visible()) {
        return;
      }
      var rs = edge._private.rscratch;
      var x2, y2, angle2;
      if (prefix === "source") {
        x2 = rs.arrowStartX;
        y2 = rs.arrowStartY;
        angle2 = rs.srcArrowAngle;
      } else {
        x2 = rs.arrowEndX;
        y2 = rs.arrowEndY;
        angle2 = rs.tgtArrowAngle;
      }
      if (isNaN(x2) || x2 == null || isNaN(y2) || y2 == null || isNaN(angle2) || angle2 == null) {
        return;
      }
      var arrowShape = edge.pstyle(prefix + "-arrow-shape").value;
      if (arrowShape === "none") {
        return;
      }
      var color = edge.pstyle(prefix + "-arrow-color").value;
      var baseOpacity = edge.pstyle("opacity").value;
      var lineOpacity = edge.pstyle("line-opacity").value;
      var opacity = baseOpacity * lineOpacity;
      var lineWidth = edge.pstyle("width").pfValue;
      var scale$1 = edge.pstyle("arrow-scale").value;
      var size3 = this.r.getArrowWidth(lineWidth, scale$1);
      var instance2 = this.instanceCount;
      var transform7 = this.transformBuffer.getMatrixView(instance2);
      identity2(transform7);
      translate(transform7, transform7, [x2, y2]);
      scale(transform7, transform7, [size3, size3]);
      rotate(transform7, transform7, angle2);
      this.vertTypeBuffer.getView(instance2)[0] = EDGE_ARROW;
      var indexView = this.indexBuffer.getView(instance2);
      indexToVec4(eleIndex, indexView);
      var colorView = this.colorBuffer.getView(instance2);
      toWebGLColor(color, opacity, colorView);
      this.instanceCount++;
      if (this.instanceCount >= this.maxInstances) {
        this.endBatch();
      }
    }, "drawEdgeArrow")
    /**
     * Draw straight-line or bezier curve edges.
     */
  }, {
    key: "drawEdgeLine",
    value: /* @__PURE__ */ __name(function drawEdgeLine(edge, eleIndex) {
      if (!edge.visible()) {
        return;
      }
      var points = this._getEdgePoints(edge);
      if (!points) {
        return;
      }
      var baseOpacity = edge.pstyle("opacity").value;
      var lineOpacity = edge.pstyle("line-opacity").value;
      var width2 = edge.pstyle("width").pfValue;
      var color = edge.pstyle("line-color").value;
      var opacity = baseOpacity * lineOpacity;
      if (points.length / 2 + this.instanceCount > this.maxInstances) {
        this.endBatch();
      }
      if (points.length == 4) {
        var instance2 = this.instanceCount;
        this.vertTypeBuffer.getView(instance2)[0] = EDGE_STRAIGHT;
        var indexView = this.indexBuffer.getView(instance2);
        indexToVec4(eleIndex, indexView);
        var colorView = this.colorBuffer.getView(instance2);
        toWebGLColor(color, opacity, colorView);
        var lineWidthBuffer = this.lineWidthBuffer.getView(instance2);
        lineWidthBuffer[0] = width2;
        var sourceTargetView = this.pointAPointBBuffer.getView(instance2);
        sourceTargetView[0] = points[0];
        sourceTargetView[1] = points[1];
        sourceTargetView[2] = points[2];
        sourceTargetView[3] = points[3];
        this.instanceCount++;
        if (this.instanceCount >= this.maxInstances) {
          this.endBatch();
        }
      } else {
        for (var i = 0; i < points.length - 2; i += 2) {
          var _instance2 = this.instanceCount;
          this.vertTypeBuffer.getView(_instance2)[0] = EDGE_CURVE_SEGMENT;
          var _indexView = this.indexBuffer.getView(_instance2);
          indexToVec4(eleIndex, _indexView);
          var _colorView = this.colorBuffer.getView(_instance2);
          toWebGLColor(color, opacity, _colorView);
          var _lineWidthBuffer = this.lineWidthBuffer.getView(_instance2);
          _lineWidthBuffer[0] = width2;
          var pAx = points[i - 2], pAy = points[i - 1];
          var pBx = points[i], pBy = points[i + 1];
          var pCx = points[i + 2], pCy = points[i + 3];
          var pDx = points[i + 4], pDy = points[i + 5];
          if (i == 0) {
            pAx = 2 * pBx - pCx + 1e-3;
            pAy = 2 * pBy - pCy + 1e-3;
          }
          if (i == points.length - 4) {
            pDx = 2 * pCx - pBx + 1e-3;
            pDy = 2 * pCy - pBy + 1e-3;
          }
          var pointABView = this.pointAPointBBuffer.getView(_instance2);
          pointABView[0] = pAx;
          pointABView[1] = pAy;
          pointABView[2] = pBx;
          pointABView[3] = pBy;
          var pointCDView = this.pointCPointDBuffer.getView(_instance2);
          pointCDView[0] = pCx;
          pointCDView[1] = pCy;
          pointCDView[2] = pDx;
          pointCDView[3] = pDy;
          this.instanceCount++;
          if (this.instanceCount >= this.maxInstances) {
            this.endBatch();
          }
        }
      }
    }, "drawEdgeLine")
  }, {
    key: "_isValidEdge",
    value: /* @__PURE__ */ __name(function _isValidEdge(edge) {
      var rs = edge._private.rscratch;
      if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
        return false;
      }
      return true;
    }, "_isValidEdge")
  }, {
    key: "_getEdgePoints",
    value: /* @__PURE__ */ __name(function _getEdgePoints(edge) {
      var rs = edge._private.rscratch;
      if (!this._isValidEdge(edge)) {
        return;
      }
      var controlPoints3 = rs.allpts;
      if (controlPoints3.length == 4) {
        return controlPoints3;
      }
      var numSegments = this._getNumSegments(edge);
      return this._getCurveSegmentPoints(controlPoints3, numSegments);
    }, "_getEdgePoints")
  }, {
    key: "_getNumSegments",
    value: /* @__PURE__ */ __name(function _getNumSegments(edge) {
      var numSegments = 15;
      return Math.min(Math.max(numSegments, 5), this.maxInstances);
    }, "_getNumSegments")
  }, {
    key: "_getCurveSegmentPoints",
    value: /* @__PURE__ */ __name(function _getCurveSegmentPoints(controlPoints3, segments) {
      if (controlPoints3.length == 4) {
        return controlPoints3;
      }
      var curvePoints = Array((segments + 1) * 2);
      for (var i = 0; i <= segments; i++) {
        if (i == 0) {
          curvePoints[0] = controlPoints3[0];
          curvePoints[1] = controlPoints3[1];
        } else if (i == segments) {
          curvePoints[i * 2] = controlPoints3[controlPoints3.length - 2];
          curvePoints[i * 2 + 1] = controlPoints3[controlPoints3.length - 1];
        } else {
          var t = i / segments;
          this._setCurvePoint(controlPoints3, t, curvePoints, i * 2);
        }
      }
      return curvePoints;
    }, "_getCurveSegmentPoints")
  }, {
    key: "_setCurvePoint",
    value: /* @__PURE__ */ __name(function _setCurvePoint(points, t, curvePoints, cpi) {
      if (points.length <= 2) {
        curvePoints[cpi] = points[0];
        curvePoints[cpi + 1] = points[1];
      } else {
        var newpoints = Array(points.length - 2);
        for (var i = 0; i < newpoints.length; i += 2) {
          var x2 = (1 - t) * points[i] + t * points[i + 2];
          var y2 = (1 - t) * points[i + 1] + t * points[i + 3];
          newpoints[i] = x2;
          newpoints[i + 1] = y2;
        }
        return this._setCurvePoint(newpoints, t, curvePoints, cpi);
      }
    }, "_setCurvePoint")
  }, {
    key: "endBatch",
    value: /* @__PURE__ */ __name(function endBatch2() {
      var gl = this.gl, vao = this.vao, vertexCount = this.vertexCount, count = this.instanceCount;
      if (count === 0) return;
      var program = this.renderTarget.picking ? this.pickingProgram : this.program;
      gl.useProgram(program);
      gl.bindVertexArray(vao);
      var _iterator2 = _createForOfIteratorHelper(this.buffers), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var buffer = _step2.value;
          buffer.bufferSubData(count);
        }
      } catch (err2) {
        _iterator2.e(err2);
      } finally {
        _iterator2.f();
      }
      var atlases = this.batchManager.getAtlases();
      for (var i = 0; i < atlases.length; i++) {
        atlases[i].bufferIfNeeded(gl);
      }
      for (var _i2 = 0; _i2 < atlases.length; _i2++) {
        gl.activeTexture(gl.TEXTURE0 + _i2);
        gl.bindTexture(gl.TEXTURE_2D, atlases[_i2].texture);
        gl.uniform1i(program.uTextures[_i2], _i2);
      }
      gl.uniform1f(program.uZoom, getEffectiveZoom(this.r));
      gl.uniformMatrix3fv(program.uPanZoomMatrix, false, this.panZoomMatrix);
      gl.uniform1i(program.uAtlasSize, this.batchManager.getAtlasSize());
      var webglBgColor = toWebGLColor(this.bgColor, 1);
      gl.uniform4fv(program.uBGColor, webglBgColor);
      gl.drawArraysInstanced(gl.TRIANGLES, 0, vertexCount, count);
      gl.bindVertexArray(null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (this.debug) {
        this.batchDebugInfo.push({
          count,
          // instance count
          atlasCount: atlases.length
        });
      }
      this.startBatch();
    }, "endBatch2")
  }, {
    key: "getDebugInfo",
    value: /* @__PURE__ */ __name(function getDebugInfo() {
      var atlasInfo = this.atlasManager.getDebugInfo();
      var totalAtlases = atlasInfo.reduce(function(count, info) {
        return count + info.atlasCount;
      }, 0);
      var batchInfo = this.batchDebugInfo;
      var totalInstances = batchInfo.reduce(function(count, info) {
        return count + info.count;
      }, 0);
      return {
        atlasInfo,
        totalAtlases,
        wrappedCount: this.wrappedCount,
        simpleCount: this.simpleCount,
        batchCount: batchInfo.length,
        batchInfo,
        totalInstances
      };
    }, "getDebugInfo")
  }]);
})();
var CRp$4 = {};
CRp$4.initWebgl = function(opts, fns) {
  var r2 = this;
  var gl = r2.data.contexts[r2.WEBGL];
  opts.bgColor = getBGColor(r2);
  opts.webglTexSize = Math.min(opts.webglTexSize, gl.getParameter(gl.MAX_TEXTURE_SIZE));
  opts.webglTexRows = Math.min(opts.webglTexRows, 54);
  opts.webglTexRowsNodes = Math.min(opts.webglTexRowsNodes, 54);
  opts.webglBatchSize = Math.min(opts.webglBatchSize, 16384);
  opts.webglTexPerBatch = Math.min(opts.webglTexPerBatch, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
  r2.webglDebug = opts.webglDebug;
  r2.webglDebugShowAtlases = opts.webglDebugShowAtlases;
  r2.pickingFrameBuffer = createPickingFrameBuffer(gl);
  r2.pickingFrameBuffer.needsDraw = true;
  r2.drawing = new ElementDrawingWebGL(r2, gl, opts);
  var getLabelRotation3 = /* @__PURE__ */ __name(function getLabelRotation4(prop2) {
    return function(ele) {
      return r2.getTextAngle(ele, prop2);
    };
  }, "getLabelRotation4");
  var isLabelVisible = /* @__PURE__ */ __name(function isLabelVisible2(prop2) {
    return function(ele) {
      var label2 = ele.pstyle(prop2);
      return label2 && label2.value;
    };
  }, "isLabelVisible2");
  var isLayerVisible = /* @__PURE__ */ __name(function isLayerVisible2(prefix) {
    return function(node) {
      return node.pstyle("".concat(prefix, "-opacity")).value > 0;
    };
  }, "isLayerVisible2");
  var getTexPickingMode = /* @__PURE__ */ __name(function getTexPickingMode2(ele) {
    var enabled = ele.pstyle("text-events").strValue === "yes";
    return enabled ? TEX_PICKING_MODE.USE_BB : TEX_PICKING_MODE.IGNORE;
  }, "getTexPickingMode2");
  var getBBForSimpleShape = /* @__PURE__ */ __name(function getBBForSimpleShape2(node) {
    var _node$position = node.position(), x2 = _node$position.x, y2 = _node$position.y;
    var w = node.outerWidth();
    var h = node.outerHeight();
    return {
      w,
      h,
      x1: x2 - w / 2,
      y1: y2 - h / 2
    };
  }, "getBBForSimpleShape2");
  r2.drawing.addAtlasCollection("node", {
    texRows: opts.webglTexRowsNodes
  });
  r2.drawing.addAtlasCollection("label", {
    texRows: opts.webglTexRows
  });
  r2.drawing.addTextureAtlasRenderType("node-body", {
    collection: "node",
    getKey: fns.getStyleKey,
    getBoundingBox: fns.getElementBox,
    drawElement: fns.drawElement
  });
  r2.drawing.addSimpleShapeRenderType("node-body", {
    getBoundingBox: getBBForSimpleShape,
    isSimple: isSimpleShape,
    shapeProps: {
      shape: "shape",
      color: "background-color",
      opacity: "background-opacity",
      radius: "corner-radius",
      border: true
    }
  });
  r2.drawing.addSimpleShapeRenderType("node-overlay", {
    getBoundingBox: getBBForSimpleShape,
    isVisible: isLayerVisible("overlay"),
    shapeProps: {
      shape: "overlay-shape",
      color: "overlay-color",
      opacity: "overlay-opacity",
      padding: "overlay-padding",
      radius: "overlay-corner-radius"
    }
  });
  r2.drawing.addSimpleShapeRenderType("node-underlay", {
    getBoundingBox: getBBForSimpleShape,
    isVisible: isLayerVisible("underlay"),
    shapeProps: {
      shape: "underlay-shape",
      color: "underlay-color",
      opacity: "underlay-opacity",
      padding: "underlay-padding",
      radius: "underlay-corner-radius"
    }
  });
  r2.drawing.addTextureAtlasRenderType("label", {
    // node label or edge mid label
    collection: "label",
    getTexPickingMode,
    getKey: getStyleKeysForLabel(fns.getLabelKey, null),
    getBoundingBox: getBoundingBoxForLabel(fns.getLabelBox, null),
    drawClipped: true,
    drawElement: fns.drawLabel,
    getRotation: getLabelRotation3(null),
    getRotationPoint: fns.getLabelRotationPoint,
    getRotationOffset: fns.getLabelRotationOffset,
    isVisible: isLabelVisible("label")
  });
  r2.drawing.addTextureAtlasRenderType("edge-source-label", {
    collection: "label",
    getTexPickingMode,
    getKey: getStyleKeysForLabel(fns.getSourceLabelKey, "source"),
    getBoundingBox: getBoundingBoxForLabel(fns.getSourceLabelBox, "source"),
    drawClipped: true,
    drawElement: fns.drawSourceLabel,
    getRotation: getLabelRotation3("source"),
    getRotationPoint: fns.getSourceLabelRotationPoint,
    getRotationOffset: fns.getSourceLabelRotationOffset,
    isVisible: isLabelVisible("source-label")
  });
  r2.drawing.addTextureAtlasRenderType("edge-target-label", {
    collection: "label",
    getTexPickingMode,
    getKey: getStyleKeysForLabel(fns.getTargetLabelKey, "target"),
    getBoundingBox: getBoundingBoxForLabel(fns.getTargetLabelBox, "target"),
    drawClipped: true,
    drawElement: fns.drawTargetLabel,
    getRotation: getLabelRotation3("target"),
    getRotationPoint: fns.getTargetLabelRotationPoint,
    getRotationOffset: fns.getTargetLabelRotationOffset,
    isVisible: isLabelVisible("target-label")
  });
  var setGCFlag = debounce(function() {
    console.log("garbage collect flag set");
    r2.data.gc = true;
  }, 1e4);
  r2.onUpdateEleCalcs(function(willDraw, eles) {
    var gcNeeded = false;
    if (eles && eles.length > 0) {
      gcNeeded |= r2.drawing.invalidate(eles);
    }
    if (gcNeeded) {
      setGCFlag();
    }
  });
  overrideCanvasRendererFunctions(r2);
};
function getBGColor(r2) {
  var container2 = r2.cy.container();
  var cssColor = container2 && container2.style && container2.style.backgroundColor || "white";
  return color2tuple(cssColor);
}
__name(getBGColor, "getBGColor");
function getLabelLines(ele, prefix) {
  var rs = ele._private.rscratch;
  return getPrefixedProperty(rs, "labelWrapCachedLines", prefix) || [];
}
__name(getLabelLines, "getLabelLines");
var getStyleKeysForLabel = /* @__PURE__ */ __name(function getStyleKeysForLabel2(getKey3, prefix) {
  return function(ele) {
    var key2 = getKey3(ele);
    var lines = getLabelLines(ele, prefix);
    if (lines.length > 1) {
      return lines.map(function(line, index2) {
        return "".concat(key2, "_").concat(index2);
      });
    }
    return key2;
  };
}, "getStyleKeysForLabel2");
var getBoundingBoxForLabel = /* @__PURE__ */ __name(function getBoundingBoxForLabel2(getBoundingBox, prefix) {
  return function(ele, styleKey) {
    var bb = getBoundingBox(ele);
    if (typeof styleKey === "string") {
      var ui2 = styleKey.indexOf("_");
      if (ui2 > 0) {
        var lineIndex = Number(styleKey.substring(ui2 + 1));
        var lines = getLabelLines(ele, prefix);
        var h = bb.h / lines.length;
        var yOffset = h * lineIndex;
        var y1 = bb.y1 + yOffset;
        return {
          x1: bb.x1,
          w: bb.w,
          y1,
          h,
          yOffset
        };
      }
    }
    return bb;
  };
}, "getBoundingBoxForLabel2");
function overrideCanvasRendererFunctions(r2) {
  {
    var renderCanvas = r2.render;
    r2.render = function(options2) {
      options2 = options2 || {};
      var cy = r2.cy;
      if (r2.webgl) {
        if (cy.zoom() > maxZoom$1) {
          clearWebgl(r2);
          renderCanvas.call(r2, options2);
        } else {
          clearCanvas(r2);
          renderWebgl(r2, options2, RENDER_TARGET.SCREEN);
        }
      }
    };
  }
  {
    var baseFunc = r2.matchCanvasSize;
    r2.matchCanvasSize = function(container2) {
      baseFunc.call(r2, container2);
      r2.pickingFrameBuffer.setFramebufferAttachmentSizes(r2.canvasWidth, r2.canvasHeight);
      r2.pickingFrameBuffer.needsDraw = true;
    };
  }
  {
    r2.findNearestElements = function(x2, y2, interactiveElementsOnly, isTouch) {
      return findNearestElementsWebgl(r2, x2, y2);
    };
  }
  {
    var _baseFunc = r2.invalidateCachedZSortedEles;
    r2.invalidateCachedZSortedEles = function() {
      _baseFunc.call(r2);
      r2.pickingFrameBuffer.needsDraw = true;
    };
  }
  {
    var _baseFunc2 = r2.notify;
    r2.notify = function(eventName, eles) {
      _baseFunc2.call(r2, eventName, eles);
      if (eventName === "viewport" || eventName === "bounds") {
        r2.pickingFrameBuffer.needsDraw = true;
      } else if (eventName === "background") {
        r2.drawing.invalidate(eles, {
          type: "node-body"
        });
      }
    };
  }
}
__name(overrideCanvasRendererFunctions, "overrideCanvasRendererFunctions");
function clearWebgl(r2) {
  var gl = r2.data.contexts[r2.WEBGL];
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
__name(clearWebgl, "clearWebgl");
function clearCanvas(r2) {
  var clear2 = /* @__PURE__ */ __name(function clear22(context) {
    context.save();
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, r2.canvasWidth, r2.canvasHeight);
    context.restore();
  }, "clear2");
  clear2(r2.data.contexts[r2.NODE]);
  clear2(r2.data.contexts[r2.DRAG]);
}
__name(clearCanvas, "clearCanvas");
function createPanZoomMatrix(r2) {
  var width2 = r2.canvasWidth;
  var height2 = r2.canvasHeight;
  var _util$getEffectivePan = getEffectivePanZoom(r2), pan2 = _util$getEffectivePan.pan, zoom2 = _util$getEffectivePan.zoom;
  var transform7 = create();
  translate(transform7, transform7, [pan2.x, pan2.y]);
  scale(transform7, transform7, [zoom2, zoom2]);
  var projection$1 = create();
  projection(projection$1, width2, height2);
  var product = create();
  multiply(product, projection$1, transform7);
  return product;
}
__name(createPanZoomMatrix, "createPanZoomMatrix");
function setContextTransform(r2, context) {
  var width2 = r2.canvasWidth;
  var height2 = r2.canvasHeight;
  var _util$getEffectivePan2 = getEffectivePanZoom(r2), pan2 = _util$getEffectivePan2.pan, zoom2 = _util$getEffectivePan2.zoom;
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.clearRect(0, 0, width2, height2);
  context.translate(pan2.x, pan2.y);
  context.scale(zoom2, zoom2);
}
__name(setContextTransform, "setContextTransform");
function drawSelectionRectangle(r2, options2) {
  r2.drawSelectionRectangle(options2, function(context) {
    return setContextTransform(r2, context);
  });
}
__name(drawSelectionRectangle, "drawSelectionRectangle");
function drawAxes(r2) {
  var context = r2.data.contexts[r2.NODE];
  context.save();
  setContextTransform(r2, context);
  context.strokeStyle = "rgba(0, 0, 0, 0.3)";
  context.beginPath();
  context.moveTo(-1e3, 0);
  context.lineTo(1e3, 0);
  context.stroke();
  context.beginPath();
  context.moveTo(0, -1e3);
  context.lineTo(0, 1e3);
  context.stroke();
  context.restore();
}
__name(drawAxes, "drawAxes");
function drawAtlases(r2) {
  var draw = /* @__PURE__ */ __name(function draw2(drawing, name, row) {
    var collection4 = drawing.atlasManager.getAtlasCollection(name);
    var context = r2.data.contexts[r2.NODE];
    var atlases = collection4.atlases;
    for (var _i = 0; _i < atlases.length; _i++) {
      var atlas = atlases[_i];
      var canvas = atlas.canvas;
      if (canvas) {
        var w = canvas.width;
        var h = canvas.height;
        var x2 = w * _i;
        var y2 = canvas.height * row;
        var scale2 = 0.4;
        context.save();
        context.scale(scale2, scale2);
        context.drawImage(canvas, x2, y2);
        context.strokeStyle = "black";
        context.rect(x2, y2, w, h);
        context.stroke();
        context.restore();
      }
    }
  }, "draw2");
  var i = 0;
  draw(r2.drawing, "node", i++);
  draw(r2.drawing, "label", i++);
}
__name(drawAtlases, "drawAtlases");
function getPickingIndexes(r2, mX1, mY1, mX2, mY2) {
  var x2, y2, w, h;
  var _util$getEffectivePan3 = getEffectivePanZoom(r2), pan2 = _util$getEffectivePan3.pan, zoom2 = _util$getEffectivePan3.zoom;
  {
    var _util$modelToRendered = modelToRenderedPosition2(r2, pan2, zoom2, mX1, mY1), _util$modelToRendered2 = _slicedToArray(_util$modelToRendered, 2), cX1 = _util$modelToRendered2[0], cY1 = _util$modelToRendered2[1];
    var t = 6;
    x2 = cX1 - t / 2;
    y2 = cY1 - t / 2;
    w = t;
    h = t;
  }
  if (w === 0 || h === 0) {
    return [];
  }
  var gl = r2.data.contexts[r2.WEBGL];
  gl.bindFramebuffer(gl.FRAMEBUFFER, r2.pickingFrameBuffer);
  if (r2.pickingFrameBuffer.needsDraw) {
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    renderWebgl(r2, null, RENDER_TARGET.PICKING);
    r2.pickingFrameBuffer.needsDraw = false;
  }
  var n = w * h;
  var data4 = new Uint8Array(n * 4);
  gl.readPixels(x2, y2, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  var indexes = /* @__PURE__ */ new Set();
  for (var i = 0; i < n; i++) {
    var pixel = data4.slice(i * 4, i * 4 + 4);
    var index2 = vec4ToIndex(pixel) - 1;
    if (index2 >= 0) {
      indexes.add(index2);
    }
  }
  return indexes;
}
__name(getPickingIndexes, "getPickingIndexes");
function findNearestElementsWebgl(r2, x2, y2) {
  var indexes = getPickingIndexes(r2, x2, y2);
  var eles = r2.getCachedZSortedEles();
  var node, edge;
  var _iterator = _createForOfIteratorHelper(indexes), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var index2 = _step.value;
      var ele = eles[index2];
      if (!node && ele.isNode()) {
        node = ele;
      }
      if (!edge && ele.isEdge()) {
        edge = ele;
      }
      if (node && edge) {
        break;
      }
    }
  } catch (err2) {
    _iterator.e(err2);
  } finally {
    _iterator.f();
  }
  return [node, edge].filter(Boolean);
}
__name(findNearestElementsWebgl, "findNearestElementsWebgl");
function drawEle(r2, index2, ele) {
  var drawing = r2.drawing;
  index2 += 1;
  if (ele.isNode()) {
    drawing.drawNode(ele, index2, "node-underlay");
    drawing.drawNode(ele, index2, "node-body");
    drawing.drawTexture(ele, index2, "label");
    drawing.drawNode(ele, index2, "node-overlay");
  } else {
    drawing.drawEdgeLine(ele, index2);
    drawing.drawEdgeArrow(ele, index2, "source");
    drawing.drawEdgeArrow(ele, index2, "target");
    drawing.drawTexture(ele, index2, "label");
    drawing.drawTexture(ele, index2, "edge-source-label");
    drawing.drawTexture(ele, index2, "edge-target-label");
  }
}
__name(drawEle, "drawEle");
function renderWebgl(r2, options2, renderTarget) {
  var start;
  if (r2.webglDebug) {
    start = performance.now();
  }
  var drawing = r2.drawing;
  var eleCount = 0;
  if (renderTarget.screen) {
    if (r2.data.canvasNeedsRedraw[r2.SELECT_BOX]) {
      drawSelectionRectangle(r2, options2);
    }
  }
  if (r2.data.canvasNeedsRedraw[r2.NODE] || renderTarget.picking) {
    var gl = r2.data.contexts[r2.WEBGL];
    if (renderTarget.screen) {
      gl.clearColor(0, 0, 0, 0);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.disable(gl.BLEND);
    }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    var panZoomMatrix = createPanZoomMatrix(r2);
    var eles = r2.getCachedZSortedEles();
    eleCount = eles.length;
    drawing.startFrame(panZoomMatrix, renderTarget);
    if (renderTarget.screen) {
      for (var i = 0; i < eles.nondrag.length; i++) {
        drawEle(r2, i, eles.nondrag[i]);
      }
      for (var _i2 = 0; _i2 < eles.drag.length; _i2++) {
        drawEle(r2, _i2, eles.drag[_i2]);
      }
    } else if (renderTarget.picking) {
      for (var _i3 = 0; _i3 < eles.length; _i3++) {
        drawEle(r2, _i3, eles[_i3]);
      }
    }
    drawing.endFrame();
    if (renderTarget.screen && r2.webglDebugShowAtlases) {
      drawAxes(r2);
      drawAtlases(r2);
    }
    r2.data.canvasNeedsRedraw[r2.NODE] = false;
    r2.data.canvasNeedsRedraw[r2.DRAG] = false;
  }
  if (r2.webglDebug) {
    var end = performance.now();
    var compact = false;
    var time2 = Math.ceil(end - start);
    var debugInfo = drawing.getDebugInfo();
    var report = ["".concat(eleCount, " elements"), "".concat(debugInfo.totalInstances, " instances"), "".concat(debugInfo.batchCount, " batches"), "".concat(debugInfo.totalAtlases, " atlases"), "".concat(debugInfo.wrappedCount, " wrapped textures"), "".concat(debugInfo.simpleCount, " simple shapes")].join(", ");
    if (compact) {
      console.log("WebGL (".concat(renderTarget.name, ") - time ").concat(time2, "ms, ").concat(report));
    } else {
      console.log("WebGL (".concat(renderTarget.name, ") - frame time ").concat(time2, "ms"));
      console.log("Totals:");
      console.log("  ".concat(report));
      console.log("Texture Atlases Used:");
      var atlasInfo = debugInfo.atlasInfo;
      var _iterator2 = _createForOfIteratorHelper(atlasInfo), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var info = _step2.value;
          console.log("  ".concat(info.type, ": ").concat(info.keyCount, " keys, ").concat(info.atlasCount, " atlases"));
        }
      } catch (err2) {
        _iterator2.e(err2);
      } finally {
        _iterator2.f();
      }
      console.log("");
    }
  }
  if (r2.data.gc) {
    console.log("Garbage Collect!");
    r2.data.gc = false;
    drawing.gc();
  }
}
__name(renderWebgl, "renderWebgl");
var CRp$3 = {};
CRp$3.drawPolygonPath = function(context, x2, y2, width2, height2, points) {
  var halfW = width2 / 2;
  var halfH = height2 / 2;
  if (context.beginPath) {
    context.beginPath();
  }
  context.moveTo(x2 + halfW * points[0], y2 + halfH * points[1]);
  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x2 + halfW * points[i * 2], y2 + halfH * points[i * 2 + 1]);
  }
  context.closePath();
};
CRp$3.drawRoundPolygonPath = function(context, x2, y2, width2, height2, points, corners) {
  corners.forEach(function(corner) {
    return drawPreparedRoundCorner(context, corner);
  });
  context.closePath();
};
CRp$3.drawRoundRectanglePath = function(context, x2, y2, width2, height2, radius2) {
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  var cornerRadius = radius2 === "auto" ? getRoundRectangleRadius(width2, height2) : Math.min(radius2, halfHeight, halfWidth);
  if (context.beginPath) {
    context.beginPath();
  }
  context.moveTo(x2, y2 - halfHeight);
  context.arcTo(x2 + halfWidth, y2 - halfHeight, x2 + halfWidth, y2, cornerRadius);
  context.arcTo(x2 + halfWidth, y2 + halfHeight, x2, y2 + halfHeight, cornerRadius);
  context.arcTo(x2 - halfWidth, y2 + halfHeight, x2 - halfWidth, y2, cornerRadius);
  context.arcTo(x2 - halfWidth, y2 - halfHeight, x2, y2 - halfHeight, cornerRadius);
  context.lineTo(x2, y2 - halfHeight);
  context.closePath();
};
CRp$3.drawBottomRoundRectanglePath = function(context, x2, y2, width2, height2, radius2) {
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  var cornerRadius = radius2 === "auto" ? getRoundRectangleRadius(width2, height2) : radius2;
  if (context.beginPath) {
    context.beginPath();
  }
  context.moveTo(x2, y2 - halfHeight);
  context.lineTo(x2 + halfWidth, y2 - halfHeight);
  context.lineTo(x2 + halfWidth, y2);
  context.arcTo(x2 + halfWidth, y2 + halfHeight, x2, y2 + halfHeight, cornerRadius);
  context.arcTo(x2 - halfWidth, y2 + halfHeight, x2 - halfWidth, y2, cornerRadius);
  context.lineTo(x2 - halfWidth, y2 - halfHeight);
  context.lineTo(x2, y2 - halfHeight);
  context.closePath();
};
CRp$3.drawCutRectanglePath = function(context, x2, y2, width2, height2, points, corners) {
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  var cornerLength = corners === "auto" ? getCutRectangleCornerLength() : corners;
  if (context.beginPath) {
    context.beginPath();
  }
  context.moveTo(x2 - halfWidth + cornerLength, y2 - halfHeight);
  context.lineTo(x2 + halfWidth - cornerLength, y2 - halfHeight);
  context.lineTo(x2 + halfWidth, y2 - halfHeight + cornerLength);
  context.lineTo(x2 + halfWidth, y2 + halfHeight - cornerLength);
  context.lineTo(x2 + halfWidth - cornerLength, y2 + halfHeight);
  context.lineTo(x2 - halfWidth + cornerLength, y2 + halfHeight);
  context.lineTo(x2 - halfWidth, y2 + halfHeight - cornerLength);
  context.lineTo(x2 - halfWidth, y2 - halfHeight + cornerLength);
  context.closePath();
};
CRp$3.drawBarrelPath = function(context, x2, y2, width2, height2) {
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  var xBegin = x2 - halfWidth;
  var xEnd = x2 + halfWidth;
  var yBegin = y2 - halfHeight;
  var yEnd = y2 + halfHeight;
  var barrelCurveConstants = getBarrelCurveConstants(width2, height2);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;
  if (context.beginPath) {
    context.beginPath();
  }
  context.moveTo(xBegin, yBegin + hOffset);
  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
  context.closePath();
};
var sin0 = Math.sin(0);
var cos0 = Math.cos(0);
var sin = {};
var cos = {};
var ellipseStepSize = Math.PI / 40;
for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}
CRp$3.drawEllipsePath = function(context, centerX, centerY, width2, height2) {
  if (context.beginPath) {
    context.beginPath();
  }
  if (context.ellipse) {
    context.ellipse(centerX, centerY, width2 / 2, height2 / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width2 / 2;
    var rh = height2 / 2;
    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;
      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }
  context.closePath();
};
var CRp$2 = {};
CRp$2.createBuffer = function(w, h) {
  var buffer = document.createElement("canvas");
  buffer.width = w;
  buffer.height = h;
  return [buffer, buffer.getContext("2d")];
};
CRp$2.bufferCanvasImage = function(options2) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width2 = options2.full ? Math.ceil(bb.w) : ctrRect[2];
  var height2 = options2.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = number$1(options2.maxWidth) || number$1(options2.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale2 = 1;
  if (options2.scale !== void 0) {
    width2 *= options2.scale;
    height2 *= options2.scale;
    scale2 = options2.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;
    if (number$1(options2.maxWidth)) {
      maxScaleW = scale2 * options2.maxWidth / width2;
    }
    if (number$1(options2.maxHeight)) {
      maxScaleH = scale2 * options2.maxHeight / height2;
    }
    scale2 = Math.min(maxScaleW, maxScaleH);
    width2 *= scale2;
    height2 *= scale2;
  }
  if (!specdMaxDims) {
    width2 *= pxRatio;
    height2 *= pxRatio;
    scale2 *= pxRatio;
  }
  var buffCanvas = document.createElement("canvas");
  buffCanvas.width = width2;
  buffCanvas.height = height2;
  buffCanvas.style.width = width2 + "px";
  buffCanvas.style.height = height2 + "px";
  var buffCxt = buffCanvas.getContext("2d");
  if (width2 > 0 && height2 > 0) {
    buffCxt.clearRect(0, 0, width2, height2);
    buffCxt.globalCompositeOperation = "source-over";
    var zsortedEles = this.getCachedZSortedEles();
    if (options2.full) {
      buffCxt.translate(-bb.x1 * scale2, -bb.y1 * scale2);
      buffCxt.scale(scale2, scale2);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale2, 1 / scale2);
      buffCxt.translate(bb.x1 * scale2, bb.y1 * scale2);
    } else {
      var pan2 = cy.pan();
      var translation = {
        x: pan2.x * scale2,
        y: pan2.y * scale2
      };
      scale2 *= cy.zoom();
      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale2, scale2);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale2, 1 / scale2);
      buffCxt.translate(-translation.x, -translation.y);
    }
    if (options2.bg) {
      buffCxt.globalCompositeOperation = "destination-over";
      buffCxt.fillStyle = options2.bg;
      buffCxt.rect(0, 0, width2, height2);
      buffCxt.fill();
    }
  }
  return buffCanvas;
};
function b64ToBlob(b64, mimeType2) {
  var bytes2 = atob(b64);
  var buff = new ArrayBuffer(bytes2.length);
  var buffUint8 = new Uint8Array(buff);
  for (var i = 0; i < bytes2.length; i++) {
    buffUint8[i] = bytes2.charCodeAt(i);
  }
  return new Blob([buff], {
    type: mimeType2
  });
}
__name(b64ToBlob, "b64ToBlob");
function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(",");
  return b64uri.substr(i + 1);
}
__name(b64UriToB64, "b64UriToB64");
function output(options2, canvas, mimeType2) {
  var getB64Uri = /* @__PURE__ */ __name(function getB64Uri2() {
    return canvas.toDataURL(mimeType2, options2.quality);
  }, "getB64Uri2");
  switch (options2.output) {
    case "blob-promise":
      return new Promise$1(function(resolve2, reject2) {
        try {
          canvas.toBlob(function(blob2) {
            if (blob2 != null) {
              resolve2(blob2);
            } else {
              reject2(new Error("`canvas.toBlob()` sent a null value in its callback"));
            }
          }, mimeType2, options2.quality);
        } catch (err2) {
          reject2(err2);
        }
      });
    case "blob":
      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType2);
    case "base64":
      return b64UriToB64(getB64Uri());
    case "base64uri":
    default:
      return getB64Uri();
  }
}
__name(output, "output");
CRp$2.png = function(options2) {
  return output(options2, this.bufferCanvasImage(options2), "image/png");
};
CRp$2.jpg = function(options2) {
  return output(options2, this.bufferCanvasImage(options2), "image/jpeg");
};
var CRp$1 = {};
CRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width2, height2, points, corners) {
  switch (name) {
    case "ellipse":
      return this.drawEllipsePath(context, centerX, centerY, width2, height2);
    case "polygon":
      return this.drawPolygonPath(context, centerX, centerY, width2, height2, points);
    case "round-polygon":
      return this.drawRoundPolygonPath(context, centerX, centerY, width2, height2, points, corners);
    case "roundrectangle":
    case "round-rectangle":
      return this.drawRoundRectanglePath(context, centerX, centerY, width2, height2, corners);
    case "cutrectangle":
    case "cut-rectangle":
      return this.drawCutRectanglePath(context, centerX, centerY, width2, height2, points, corners);
    case "bottomroundrectangle":
    case "bottom-round-rectangle":
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width2, height2, corners);
    case "barrel":
      return this.drawBarrelPath(context, centerX, centerY, width2, height2);
  }
};
var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;
CRp.CANVAS_LAYERS = 3;
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;
CRp.WEBGL = 3;
CRp.CANVAS_TYPES = ["2d", "2d", "2d", "webgl2"];
CRp.BUFFER_COUNT = 3;
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;
function CanvasRenderer(options2) {
  var r2 = this;
  var containerWindow = r2.cy.window();
  var document2 = containerWindow.document;
  if (options2.webgl) {
    CRp.CANVAS_LAYERS = r2.CANVAS_LAYERS = 4;
    console.log("webgl rendering enabled");
  }
  r2.data = {
    canvases: new Array(CRp.CANVAS_LAYERS),
    contexts: new Array(CRp.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),
    bufferCanvases: new Array(CRp.BUFFER_COUNT),
    bufferContexts: new Array(CRp.CANVAS_LAYERS)
  };
  var tapHlOffAttr = "-webkit-tap-highlight-color";
  var tapHlOffStyle = "rgba(0,0,0,0)";
  r2.data.canvasContainer = document2.createElement("div");
  var containerStyle = r2.data.canvasContainer.style;
  r2.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
  containerStyle.position = "relative";
  containerStyle.zIndex = "0";
  containerStyle.overflow = "hidden";
  var container2 = options2.cy.container();
  container2.appendChild(r2.data.canvasContainer);
  container2.style[tapHlOffAttr] = tapHlOffStyle;
  var styleMap = {
    "-webkit-user-select": "none",
    "-moz-user-select": "-moz-none",
    "user-select": "none",
    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
    "outline-style": "none"
  };
  if (ms()) {
    styleMap["-ms-touch-action"] = "none";
    styleMap["touch-action"] = "none";
  }
  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
    var canvas = r2.data.canvases[i] = document2.createElement("canvas");
    var type = CRp.CANVAS_TYPES[i];
    r2.data.contexts[i] = canvas.getContext(type);
    if (!r2.data.contexts[i]) {
      error("Could not create canvas of type " + type);
    }
    Object.keys(styleMap).forEach(function(k) {
      canvas.style[k] = styleMap[k];
    });
    canvas.style.position = "absolute";
    canvas.setAttribute("data-id", "layer" + i);
    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
    r2.data.canvasContainer.appendChild(canvas);
    r2.data.canvasNeedsRedraw[i] = false;
  }
  r2.data.topCanvas = r2.data.canvases[0];
  r2.data.canvases[CRp.NODE].setAttribute("data-id", "layer" + CRp.NODE + "-node");
  r2.data.canvases[CRp.SELECT_BOX].setAttribute("data-id", "layer" + CRp.SELECT_BOX + "-selectbox");
  r2.data.canvases[CRp.DRAG].setAttribute("data-id", "layer" + CRp.DRAG + "-drag");
  if (r2.data.canvases[CRp.WEBGL]) {
    r2.data.canvases[CRp.WEBGL].setAttribute("data-id", "layer" + CRp.WEBGL + "-webgl");
  }
  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
    r2.data.bufferCanvases[i] = document2.createElement("canvas");
    r2.data.bufferContexts[i] = r2.data.bufferCanvases[i].getContext("2d");
    r2.data.bufferCanvases[i].style.position = "absolute";
    r2.data.bufferCanvases[i].setAttribute("data-id", "buffer" + i);
    r2.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r2.data.bufferCanvases[i].style.visibility = "hidden";
  }
  r2.pathsEnabled = true;
  var emptyBb = makeBoundingBox();
  var getBoxCenter = /* @__PURE__ */ __name(function getBoxCenter2(bb) {
    return {
      x: (bb.x1 + bb.x2) / 2,
      y: (bb.y1 + bb.y2) / 2
    };
  }, "getBoxCenter2");
  var getCenterOffset = /* @__PURE__ */ __name(function getCenterOffset2(bb) {
    return {
      x: -bb.w / 2,
      y: -bb.h / 2
    };
  }, "getCenterOffset2");
  var backgroundTimestampHasChanged = /* @__PURE__ */ __name(function backgroundTimestampHasChanged2(ele) {
    var _p = ele[0]._private;
    var same2 = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
    return !same2;
  }, "backgroundTimestampHasChanged2");
  var getStyleKey = /* @__PURE__ */ __name(function getStyleKey2(ele) {
    return ele[0]._private.nodeKey;
  }, "getStyleKey2");
  var getLabelKey = /* @__PURE__ */ __name(function getLabelKey2(ele) {
    return ele[0]._private.labelStyleKey;
  }, "getLabelKey2");
  var getSourceLabelKey = /* @__PURE__ */ __name(function getSourceLabelKey2(ele) {
    return ele[0]._private.sourceLabelStyleKey;
  }, "getSourceLabelKey2");
  var getTargetLabelKey = /* @__PURE__ */ __name(function getTargetLabelKey2(ele) {
    return ele[0]._private.targetLabelStyleKey;
  }, "getTargetLabelKey2");
  var drawElement = /* @__PURE__ */ __name(function drawElement2(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r2.drawElement(context, ele, bb, false, false, useEleOpacity);
  }, "drawElement2");
  var drawLabel = /* @__PURE__ */ __name(function drawLabel2(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r2.drawElementText(context, ele, bb, scaledLabelShown, "main", useEleOpacity);
  }, "drawLabel2");
  var drawSourceLabel = /* @__PURE__ */ __name(function drawSourceLabel2(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r2.drawElementText(context, ele, bb, scaledLabelShown, "source", useEleOpacity);
  }, "drawSourceLabel2");
  var drawTargetLabel = /* @__PURE__ */ __name(function drawTargetLabel2(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r2.drawElementText(context, ele, bb, scaledLabelShown, "target", useEleOpacity);
  }, "drawTargetLabel2");
  var getElementBox = /* @__PURE__ */ __name(function getElementBox2(ele) {
    ele.boundingBox();
    return ele[0]._private.bodyBounds;
  }, "getElementBox2");
  var getLabelBox = /* @__PURE__ */ __name(function getLabelBox2(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.main || emptyBb;
  }, "getLabelBox2");
  var getSourceLabelBox = /* @__PURE__ */ __name(function getSourceLabelBox2(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.source || emptyBb;
  }, "getSourceLabelBox2");
  var getTargetLabelBox = /* @__PURE__ */ __name(function getTargetLabelBox2(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.target || emptyBb;
  }, "getTargetLabelBox2");
  var isLabelVisibleAtScale = /* @__PURE__ */ __name(function isLabelVisibleAtScale2(ele, scaledLabelShown) {
    return scaledLabelShown;
  }, "isLabelVisibleAtScale2");
  var getElementRotationPoint = /* @__PURE__ */ __name(function getElementRotationPoint2(ele) {
    return getBoxCenter(getElementBox(ele));
  }, "getElementRotationPoint2");
  var addTextMargin = /* @__PURE__ */ __name(function addTextMargin2(prefix, pt, ele) {
    var pre = prefix ? prefix + "-" : "";
    return {
      x: pt.x + ele.pstyle(pre + "text-margin-x").pfValue,
      y: pt.y + ele.pstyle(pre + "text-margin-y").pfValue
    };
  }, "addTextMargin2");
  var getRsPt = /* @__PURE__ */ __name(function getRsPt2(ele, x2, y2) {
    var rs = ele[0]._private.rscratch;
    return {
      x: rs[x2],
      y: rs[y2]
    };
  }, "getRsPt2");
  var getLabelRotationPoint = /* @__PURE__ */ __name(function getLabelRotationPoint2(ele) {
    return addTextMargin("", getRsPt(ele, "labelX", "labelY"), ele);
  }, "getLabelRotationPoint2");
  var getSourceLabelRotationPoint = /* @__PURE__ */ __name(function getSourceLabelRotationPoint2(ele) {
    return addTextMargin("source", getRsPt(ele, "sourceLabelX", "sourceLabelY"), ele);
  }, "getSourceLabelRotationPoint2");
  var getTargetLabelRotationPoint = /* @__PURE__ */ __name(function getTargetLabelRotationPoint2(ele) {
    return addTextMargin("target", getRsPt(ele, "targetLabelX", "targetLabelY"), ele);
  }, "getTargetLabelRotationPoint2");
  var getElementRotationOffset = /* @__PURE__ */ __name(function getElementRotationOffset2(ele) {
    return getCenterOffset(getElementBox(ele));
  }, "getElementRotationOffset2");
  var getSourceLabelRotationOffset = /* @__PURE__ */ __name(function getSourceLabelRotationOffset2(ele) {
    return getCenterOffset(getSourceLabelBox(ele));
  }, "getSourceLabelRotationOffset2");
  var getTargetLabelRotationOffset = /* @__PURE__ */ __name(function getTargetLabelRotationOffset2(ele) {
    return getCenterOffset(getTargetLabelBox(ele));
  }, "getTargetLabelRotationOffset2");
  var getLabelRotationOffset = /* @__PURE__ */ __name(function getLabelRotationOffset2(ele) {
    var bb = getLabelBox(ele);
    var p2 = getCenterOffset(getLabelBox(ele));
    if (ele.isNode()) {
      switch (ele.pstyle("text-halign").value) {
        case "left":
          p2.x = -bb.w - (bb.leftPad || 0);
          break;
        case "right":
          p2.x = -(bb.rightPad || 0);
          break;
      }
      switch (ele.pstyle("text-valign").value) {
        case "top":
          p2.y = -bb.h - (bb.topPad || 0);
          break;
        case "bottom":
          p2.y = -(bb.botPad || 0);
          break;
      }
    }
    return p2;
  }, "getLabelRotationOffset2");
  var eleTxrCache = r2.data.eleTxrCache = new ElementTextureCache(r2, {
    getKey: getStyleKey,
    doesEleInvalidateKey: backgroundTimestampHasChanged,
    drawElement,
    getBoundingBox: getElementBox,
    getRotationPoint: getElementRotationPoint,
    getRotationOffset: getElementRotationOffset,
    allowEdgeTxrCaching: false,
    allowParentTxrCaching: false
  });
  var lblTxrCache = r2.data.lblTxrCache = new ElementTextureCache(r2, {
    getKey: getLabelKey,
    drawElement: drawLabel,
    getBoundingBox: getLabelBox,
    getRotationPoint: getLabelRotationPoint,
    getRotationOffset: getLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var slbTxrCache = r2.data.slbTxrCache = new ElementTextureCache(r2, {
    getKey: getSourceLabelKey,
    drawElement: drawSourceLabel,
    getBoundingBox: getSourceLabelBox,
    getRotationPoint: getSourceLabelRotationPoint,
    getRotationOffset: getSourceLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var tlbTxrCache = r2.data.tlbTxrCache = new ElementTextureCache(r2, {
    getKey: getTargetLabelKey,
    drawElement: drawTargetLabel,
    getBoundingBox: getTargetLabelBox,
    getRotationPoint: getTargetLabelRotationPoint,
    getRotationOffset: getTargetLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var lyrTxrCache = r2.data.lyrTxrCache = new LayeredTextureCache(r2);
  r2.onUpdateEleCalcs(/* @__PURE__ */ __name(function invalidateTextureCaches(willDraw, eles) {
    eleTxrCache.invalidateElements(eles);
    lblTxrCache.invalidateElements(eles);
    slbTxrCache.invalidateElements(eles);
    tlbTxrCache.invalidateElements(eles);
    lyrTxrCache.invalidateElements(eles);
    for (var _i = 0; _i < eles.length; _i++) {
      var _p = eles[_i]._private;
      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
    }
  }, "invalidateTextureCaches"));
  var refineInLayers = /* @__PURE__ */ __name(function refineInLayers2(reqs) {
    for (var i2 = 0; i2 < reqs.length; i2++) {
      lyrTxrCache.enqueueElementRefinement(reqs[i2].ele);
    }
  }, "refineInLayers2");
  eleTxrCache.onDequeue(refineInLayers);
  lblTxrCache.onDequeue(refineInLayers);
  slbTxrCache.onDequeue(refineInLayers);
  tlbTxrCache.onDequeue(refineInLayers);
  if (options2.webgl) {
    r2.initWebgl(options2, {
      getStyleKey,
      getLabelKey,
      getSourceLabelKey,
      getTargetLabelKey,
      drawElement,
      drawLabel,
      drawSourceLabel,
      drawTargetLabel,
      getElementBox,
      getLabelBox,
      getSourceLabelBox,
      getTargetLabelBox,
      getElementRotationPoint,
      getElementRotationOffset,
      getLabelRotationPoint,
      getSourceLabelRotationPoint,
      getTargetLabelRotationPoint,
      getLabelRotationOffset,
      getSourceLabelRotationOffset,
      getTargetLabelRotationOffset
    });
  }
}
__name(CanvasRenderer, "CanvasRenderer");
CRp.redrawHint = function(group2, bool) {
  var r2 = this;
  switch (group2) {
    case "eles":
      r2.data.canvasNeedsRedraw[CRp.NODE] = bool;
      break;
    case "drag":
      r2.data.canvasNeedsRedraw[CRp.DRAG] = bool;
      break;
    case "select":
      r2.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
      break;
    case "gc":
      r2.data.gc = true;
      break;
  }
};
var pathsImpld = typeof Path2D !== "undefined";
CRp.path2dEnabled = function(on3) {
  if (on3 === void 0) {
    return this.pathsEnabled;
  }
  this.pathsEnabled = on3 ? true : false;
};
CRp.usePaths = function() {
  return pathsImpld && this.pathsEnabled;
};
CRp.setImgSmoothing = function(context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
};
CRp.getImgSmoothing = function(context) {
  if (context.imageSmoothingEnabled != null) {
    return context.imageSmoothingEnabled;
  } else {
    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
  }
};
CRp.makeOffscreenCanvas = function(width2, height2) {
  var canvas;
  if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== "undefined") {
    canvas = new OffscreenCanvas(width2, height2);
  } else {
    var containerWindow = this.cy.window();
    var document2 = containerWindow.document;
    canvas = document2.createElement("canvas");
    canvas.width = width2;
    canvas.height = height2;
  }
  return canvas;
};
[CRp$b, CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function(props) {
  extend(CRp, props);
});
var renderer2 = [{
  name: "null",
  impl: NullRenderer
}, {
  name: "base",
  impl: BR
}, {
  name: "canvas",
  impl: CR
}];
var incExts = [{
  type: "layout",
  extensions: layout3
}, {
  type: "renderer",
  extensions: renderer2
}];
var extensions = {};
var modules = {};
function setExtension(type, name, registrant) {
  var ext = registrant;
  var overrideErr = /* @__PURE__ */ __name(function overrideErr2(field) {
    warn("Can not register `" + name + "` for `" + type + "` since `" + field + "` already exists in the prototype and can not be overridden");
  }, "overrideErr2");
  if (type === "core") {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === "collection") {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === "layout") {
    var Layout = /* @__PURE__ */ __name(function Layout2(options2) {
      this.options = options2;
      registrant.call(this, options2);
      if (!plainObject(this._private)) {
        this._private = {};
      }
      this._private.cy = options2.cy;
      this._private.listeners = [];
      this.createEmitter();
    }, "Layout2");
    var layoutProto = Layout.prototype = Object.create(registrant.prototype);
    var optLayoutFns = [];
    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];
      layoutProto[fnName] = layoutProto[fnName] || function() {
        return this;
      };
    }
    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function() {
        this.start();
        return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function() {
        this.run();
        return this;
      };
    }
    var regStop = registrant.prototype.stop;
    layoutProto.stop = function() {
      var opts = this.options;
      if (opts && opts.animate) {
        var anis = this.animations;
        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }
      if (regStop) {
        regStop.call(this);
      } else {
        this.emit("layoutstop");
      }
      return this;
    };
    if (!layoutProto.destroy) {
      layoutProto.destroy = function() {
        return this;
      };
    }
    layoutProto.cy = function() {
      return this._private.cy;
    };
    var getCy = /* @__PURE__ */ __name(function getCy2(layout4) {
      return layout4._private.cy;
    }, "getCy2");
    var emitterOpts = {
      addEventFields: /* @__PURE__ */ __name(function addEventFields4(layout4, evt) {
        evt.layout = layout4;
        evt.cy = getCy(layout4);
        evt.target = layout4;
      }, "addEventFields4"),
      bubble: /* @__PURE__ */ __name(function bubble3() {
        return true;
      }, "bubble3"),
      parent: /* @__PURE__ */ __name(function parent4(layout4) {
        return getCy(layout4);
      }, "parent4")
    };
    extend(layoutProto, {
      createEmitter: /* @__PURE__ */ __name(function createEmitter3() {
        this._private.emitter = new Emitter(emitterOpts, this);
        return this;
      }, "createEmitter3"),
      emitter: /* @__PURE__ */ __name(function emitter3() {
        return this._private.emitter;
      }, "emitter3"),
      on: /* @__PURE__ */ __name(function on3(evt, cb) {
        this.emitter().on(evt, cb);
        return this;
      }, "on3"),
      one: /* @__PURE__ */ __name(function one3(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      }, "one3"),
      once: /* @__PURE__ */ __name(function once3(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      }, "once3"),
      removeListener: /* @__PURE__ */ __name(function removeListener3(evt, cb) {
        this.emitter().removeListener(evt, cb);
        return this;
      }, "removeListener3"),
      removeAllListeners: /* @__PURE__ */ __name(function removeAllListeners3() {
        this.emitter().removeAllListeners();
        return this;
      }, "removeAllListeners3"),
      emit: /* @__PURE__ */ __name(function emit3(evt, params) {
        this.emitter().emit(evt, params);
        return this;
      }, "emit3")
    });
    define.eventAliasesOn(layoutProto);
    ext = Layout;
  } else if (type === "renderer" && name !== "null" && name !== "base") {
    var BaseRenderer3 = getExtension("renderer", "base");
    var bProto = BaseRenderer3.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;
    var Renderer = /* @__PURE__ */ __name(function Renderer2() {
      BaseRenderer3.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    }, "Renderer2");
    var proto = Renderer.prototype;
    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;
      if (existsInR) {
        return overrideErr(pName);
      }
      proto[pName] = pVal;
    }
    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName];
    }
    bProto.clientFunctions.forEach(function(name2) {
      proto[name2] = proto[name2] || function() {
        error("Renderer does not implement `renderer." + name2 + "()` on its prototype");
      };
    });
    ext = Renderer;
  } else if (type === "__proto__" || type === "constructor" || type === "prototype") {
    return error(type + " is an illegal type to be registered, possibly lead to prototype pollutions");
  }
  return setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}
__name(setExtension, "setExtension");
function getExtension(type, name) {
  return getMap({
    map: extensions,
    keys: [type, name]
  });
}
__name(getExtension, "getExtension");
function setModule(type, name, moduleType, moduleName, registrant) {
  return setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}
__name(setModule, "setModule");
function getModule(type, name, moduleType, moduleName) {
  return getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}
__name(getModule, "getModule");
var extension = /* @__PURE__ */ __name(function extension2() {
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  } else if (arguments.length === 3) {
    return setExtension.apply(null, arguments);
  } else if (arguments.length === 4) {
    return getModule.apply(null, arguments);
  } else if (arguments.length === 5) {
    return setModule.apply(null, arguments);
  } else {
    error("Invalid extension access syntax");
  }
}, "extension2");
Core.prototype.extension = extension;
incExts.forEach(function(group2) {
  group2.extensions.forEach(function(ext) {
    setExtension(group2.type, ext.name, ext.impl);
  });
});
var _Stylesheet = /* @__PURE__ */ __name(function Stylesheet() {
  if (!(this instanceof _Stylesheet)) {
    return new _Stylesheet();
  }
  this.length = 0;
}, "Stylesheet");
var sheetfn = _Stylesheet.prototype;
sheetfn.instanceString = function() {
  return "stylesheet";
};
sheetfn.selector = function(selector) {
  var i = this.length++;
  this[i] = {
    selector,
    properties: []
  };
  return this;
};
sheetfn.css = function(name, value2) {
  var i = this.length - 1;
  if (string(name)) {
    this[i].properties.push({
      name,
      value: value2
    });
  } else if (plainObject(name)) {
    var map22 = name;
    var propNames = Object.keys(map22);
    for (var j = 0; j < propNames.length; j++) {
      var key2 = propNames[j];
      var mapVal = map22[key2];
      if (mapVal == null) {
        continue;
      }
      var prop2 = _Style.properties[key2] || _Style.properties[dash2camel(key2)];
      if (prop2 == null) {
        continue;
      }
      var _name = prop2.name;
      var _value = mapVal;
      this[i].properties.push({
        name: _name,
        value: _value
      });
    }
  }
  return this;
};
sheetfn.style = sheetfn.css;
sheetfn.generateStyle = function(cy) {
  var style3 = new _Style(cy);
  return this.appendToStyle(style3);
};
sheetfn.appendToStyle = function(style3) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;
    style3.selector(selector);
    for (var j = 0; j < props.length; j++) {
      var prop2 = props[j];
      style3.css(prop2.name, prop2.value);
    }
  }
  return style3;
};
var version = "3.33.1";
var cytoscape = /* @__PURE__ */ __name(function cytoscape2(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (plainObject(options2)) {
    return new Core(options2);
  } else if (string(options2)) {
    return extension.apply(extension, arguments);
  }
}, "cytoscape2");
cytoscape.use = function(ext) {
  var args2 = Array.prototype.slice.call(arguments, 1);
  args2.unshift(cytoscape);
  ext.apply(null, args2);
  return this;
};
cytoscape.warnings = function(bool) {
  return warnings(bool);
};
cytoscape.version = version;
cytoscape.stylesheet = cytoscape.Stylesheet = _Stylesheet;
var cytoscape_esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: cytoscape
});
//# sourceMappingURL=fvtt_relationship_app_module.js.map
