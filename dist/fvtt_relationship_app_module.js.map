{"version":3,"file":"fvtt_relationship_app_module.js","sources":["../src/polyfills/cytoscape-assign-fix.ts","../src/constants.ts","../src/utils/result.ts","../src/core/init-solid.ts"],"sourcesContent":["/**\r\n * Polyfill für Cytoscape: Object.assign readonly 'equals' fix\r\n *\r\n * ⚠️ WICHTIG: Dieser Polyfill ist ein Legacy-Patch für die Cytoscape-Bibliothek.\r\n * NIEMALS ÄNDERN - könnte das Verhalten der Cytoscape-Integration beeinträchtigen.\r\n */\r\nObject.assign = function (target: any, ...sources: any[]) {\r\n  for (const source of sources) {\r\n    if (source != null) {\r\n      for (const key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key) && key !== \"equals\") {\r\n          try {\r\n            target[key] = source[key];\r\n          } catch {\r\n            // Ignore readonly property errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n};\r\n","/**\r\n * Module-wide constants for the Foundry VTT Relationship App Module.\r\n * Contains metadata and configuration values used throughout the application.\r\n *\r\n * @constant\r\n */\r\nexport const MODULE_CONSTANTS = {\r\n  MODULE: {\r\n    ID: \"fvtt_relationship_app_module\",\r\n    NAME: \"Beziehungsnetzwerke für Foundry\",\r\n    AUTHOR: \"Andreas Rothe\",\r\n    AUTHOR_EMAIL: \"forenadmin.tir@gmail.com\",\r\n    AUTHOR_DISCORD: \"lewellyen\",\r\n  },\r\n  LOG_PREFIX: \"Foundry VTT Relationship App Module |\",\r\n} as const;\r\n","/**\r\n * Utility functions for working with the Result pattern.\r\n * Provides functional error handling with type safety.\r\n *\r\n * This module contains only runtime functions - types are imported from \"../types/result\"\r\n */\r\nimport type { Ok, Err, Result, AsyncResult } from \"../types/result\";\r\n\r\n/**\r\n * Creates a successful Result with a value.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @param value - The successful value to wrap\r\n * @returns A Result indicating success with the provided value\r\n *\r\n * @example\r\n * ```typescript\r\n * const success = ok(42);\r\n * // { ok: true, value: 42 }\r\n * ```\r\n */\r\nexport function ok<SuccessType>(value: SuccessType): Ok<SuccessType> {\r\n  return { ok: true, value };\r\n}\r\n\r\n/**\r\n * Creates an error Result with an error value.\r\n *\r\n * @template ErrorType - The type of the error value\r\n * @param error - The error to wrap\r\n * @returns A Result indicating failure with the provided error\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"Not found\");\r\n * // { ok: false, error: \"Not found\" }\r\n * ```\r\n */\r\nexport function err<ErrorType>(error: ErrorType): Err<ErrorType> {\r\n  return { ok: false, error };\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is successful.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is successful, narrowing the type to Ok<SuccessType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isOk(result)) {\r\n *   console.log(result.value); // Type-safe access to value\r\n * }\r\n * ```\r\n */\r\nexport function isOk<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Ok<SuccessType> {\r\n  return result.ok;\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is an error.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is an error, narrowing the type to Err<ErrorType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isErr(result)) {\r\n *   console.error(result.error); // Type-safe access to error\r\n * }\r\n * ```\r\n */\r\nexport function isErr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Err<ErrorType> {\r\n  return !result.ok;\r\n}\r\n\r\n/**\r\n * Transforms the value of a successful Result.\r\n * If the Result is an error, it is returned unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the success value\r\n * @returns A new Result with the transformed value, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(5);\r\n * const doubled = map(num, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport function map<SuccessType, NewSuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => NewSuccessType\r\n): Result<NewSuccessType, ErrorType> {\r\n  return result.ok ? ok(transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Transforms the error of a failed Result.\r\n * If the Result is successful, it is returned unchanged.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The current error type\r\n * @template NewErrorType - The new error type after transformation\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the error value\r\n * @returns A new Result with the transformed error, or the original success\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"404\");\r\n * const formatted = mapError(failure, msg => `Error: ${msg}`);\r\n * // { ok: false, error: \"Error: 404\" }\r\n * ```\r\n */\r\nexport function mapError<SuccessType, ErrorType, NewErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (error: ErrorType) => NewErrorType\r\n): Result<SuccessType, NewErrorType> {\r\n  return result.ok ? result : err(transform(result.error));\r\n}\r\n\r\n/**\r\n * Chains Result operations. If the Result is successful, applies the function to the value.\r\n * Otherwise, returns the error unchanged. This is also known as \"flatMap\" or \"bind\".\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param result - The Result to chain\r\n * @param next - Function that returns a new Result from the success value\r\n * @returns The next Result, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseNumber = (str: string): Result<number, string> => {\r\n *   const num = parseInt(str);\r\n *   return isNaN(num) ? err(\"Invalid number\") : ok(num);\r\n * };\r\n *\r\n * const doubled = ok(\"5\").pipe(parseNumber).pipe(x => ok(x * 2));\r\n * ```\r\n */\r\nexport function andThen<SuccessType, ErrorType, NextSuccessType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => Result<NextSuccessType, ErrorType>\r\n): Result<NextSuccessType, ErrorType> {\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or returns a fallback value if it's an error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param fallbackValue - The value to return if the Result is an error\r\n * @returns The success value, or the fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * unwrapOr(num, 0); // 42\r\n *\r\n * const err = err(\"Failed\");\r\n * unwrapOr(err, 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  fallbackValue: SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : fallbackValue;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or computes a fallback value from the error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param getFallback - Function that computes a fallback from the error\r\n * @returns The success value, or the computed fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = err(\"Not found\");\r\n * unwrapOrElse(num, error => 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOrElse<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  getFallback: (error: ErrorType) => SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : getFallback(result.error);\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or throws an error if it's a failure.\r\n * Use with caution - this defeats the purpose of using Result pattern.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ThrownError - The type of error to throw (must extend Error)\r\n * @param result - The Result to unwrap\r\n * @param toError - Optional function to convert the error to a thrown Error\r\n * @returns The success value\r\n * @throws ThrownError if the Result is an error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * getOrThrow(num); // 42\r\n *\r\n * const failure = err(\"Not found\");\r\n * getOrThrow(failure); // throws Error(\"Not found\")\r\n * ```\r\n */\r\nexport function getOrThrow<SuccessType, ErrorType, ThrownError extends Error = Error>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  toError?: (error: ErrorType) => ThrownError\r\n): SuccessType {\r\n  if (result.ok) return result.value;\r\n  const e = toError ? toError(result.error) : (new Error(String(result.error)) as ThrownError);\r\n  throw e;\r\n}\r\n\r\n/**\r\n * Executes a function and wraps the result in a Result, catching any thrown errors.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param fn - The function to execute\r\n * @param mapUnknownError - Function to convert caught errors to the ErrorType\r\n * @returns A Result containing either the return value or the caught error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parsed = tryCatch(\r\n *   () => JSON.parse(\"{ invalid json\"),\r\n *   (e) => `Parse error: ${e}`\r\n * );\r\n * // { ok: false, error: \"Parse error: ...\" }\r\n * ```\r\n */\r\nexport function tryCatch<SuccessType, ErrorType>(\r\n  fn: () => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): Result<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(fn());\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error immediately (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param results - Array of Results to combine\r\n * @returns A Result containing an array of values, or the first error encountered\r\n *\r\n * @example\r\n * ```typescript\r\n * const nums = [ok(1), ok(2), ok(3)];\r\n * all(nums); // { ok: true, value: [1, 2, 3] }\r\n *\r\n * const mixed = [ok(1), err(\"error\"), ok(3)];\r\n * all(mixed); // { ok: false, error: \"error\" }\r\n * ```\r\n */\r\nexport function all<SuccessType, ErrorType>(\r\n  results: Array<Result<SuccessType, ErrorType>>\r\n): Result<SuccessType[], ErrorType> {\r\n  const out: SuccessType[] = [];\r\n  for (const r of results) {\r\n    if (!r.ok) return r;\r\n    out.push(r.value);\r\n  }\r\n  return ok(out);\r\n}\r\n\r\n/**\r\n * Pattern matching for Results. Executes different handlers based on success or failure.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ReturnType - The return type of both handlers\r\n * @param result - The Result to match\r\n * @param handlers - Object with onOk and onErr handlers\r\n * @returns The result of the executed handler\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = ok(42);\r\n * match(result, {\r\n *   onOk: value => console.log(`Success: ${value}`),\r\n *   onErr: error => console.error(`Error: ${error}`)\r\n * });\r\n * ```\r\n */\r\nexport function match<SuccessType, ErrorType, ReturnType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  handlers: { onOk: (value: SuccessType) => ReturnType; onErr: (error: ErrorType) => ReturnType }\r\n): ReturnType {\r\n  return result.ok ? handlers.onOk(result.value) : handlers.onErr(result.error);\r\n}\r\n\r\n/**\r\n * Lifts a regular function to work with Results by wrapping it with error handling.\r\n *\r\n * @template ParamType - The function parameter type\r\n * @template SuccessType - The function return type (success type)\r\n * @template ErrorType - The error type\r\n * @param fn - The function to lift\r\n * @param mapUnknownError - Function to convert thrown errors to the ErrorType\r\n * @returns A function that returns a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseJSON = lift(\r\n *   (str: string) => JSON.parse(str),\r\n *   (e) => `Invalid JSON: ${e}`\r\n * );\r\n *\r\n * const result = parseJSON(\"{ invalid }\");\r\n * // { ok: false, error: \"Invalid JSON: ...\" }\r\n * ```\r\n */\r\nexport function lift<ParamType, SuccessType, ErrorType>(\r\n  fn: (param: ParamType) => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): (param: ParamType) => Result<SuccessType, ErrorType> {\r\n  return (param) => tryCatch(() => fn(param), mapUnknownError);\r\n}\r\n\r\n/**\r\n * Transforms the value of an async Result.\r\n * If the Result is an error, returns it unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param asyncResult - The async Result to transform\r\n * @param transform - Async or sync function to transform the success value\r\n * @returns A promise that resolves to a Result with the transformed value or error\r\n *\r\n * @example\r\n * ```typescript\r\n * const asyncNum = Promise.resolve(ok(5));\r\n * const doubled = await asyncMap(asyncNum, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport async function asyncMap<SuccessType, NewSuccessType, ErrorType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => Promise<NewSuccessType> | NewSuccessType\r\n): AsyncResult<NewSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? ok(await transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Chains async Result operations.\r\n * If the Result is successful, applies the async function to the value.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param asyncResult - The async Result to chain\r\n * @param next - Async function that returns a new async Result\r\n * @returns A promise that resolves to the chained Result or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const fetchAndProcess = async (url: string) => {\r\n *   const data = await fromPromise(fetch(url).then(r => r.json()), e => String(e));\r\n *   return asyncAndThen(data, processDataAsync);\r\n * };\r\n * ```\r\n */\r\nexport async function asyncAndThen<SuccessType, ErrorType, NextSuccessType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => AsyncResult<NextSuccessType, ErrorType>\r\n): AsyncResult<NextSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Converts a Promise into an async Result.\r\n * Catches any rejection and converts it to an error Result.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param promise - The Promise to convert\r\n * @param mapUnknownError - Function to convert unknown errors to the ErrorType\r\n * @returns A promise that resolves to a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await fromPromise(\r\n *   fetch(\"/api/data\").then(r => r.json()),\r\n *   (e) => `Fetch failed: ${e}`\r\n * );\r\n * ```\r\n */\r\nexport async function fromPromise<SuccessType, ErrorType>(\r\n  promise: Promise<SuccessType>,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): AsyncResult<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(await promise);\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple async Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param asyncResults - Array of async Results to combine\r\n * @returns A promise that resolves to a Result containing an array of values or the first error\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = [\r\n *   Promise.resolve(ok(1)),\r\n *   Promise.resolve(ok(2)),\r\n *   Promise.resolve(ok(3))\r\n * ];\r\n * const combined = await asyncAll(results);\r\n * // { ok: true, value: [1, 2, 3] }\r\n * ```\r\n */\r\nexport async function asyncAll<SuccessType, ErrorType>(\r\n  asyncResults: Array<AsyncResult<SuccessType, ErrorType>>\r\n): AsyncResult<SuccessType[], ErrorType> {\r\n  const results: Result<SuccessType, ErrorType>[] = await Promise.all(asyncResults);\r\n  return all(results);\r\n}\r\n","import { MODULE_CONSTANTS } from \"../constants\";\r\nimport { ok, err, tryCatch, match } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\n\r\n/**\r\n * Safely gets journal entries that are marked as hidden.\r\n */\r\nfunction getHiddenJournalEntries(): Result<any[], string> {\r\n  return tryCatch(\r\n    () => {\r\n      if (!game?.journal) {\r\n        throw new Error(\"game.journal is not available\");\r\n      }\r\n      return (game as any).journal.filter(\r\n        (j: any) => j.getFlag(MODULE_CONSTANTS.MODULE.ID as any, \"hidden\") === true\r\n      );\r\n    },\r\n    (error) => `Failed to get hidden journal entries: ${error}`\r\n  );\r\n}\r\n\r\n/**\r\n * Safely removes a journal entry from the UI.\r\n */\r\nfunction removeJournalElement(\r\n  journalId: string,\r\n  journalName: string,\r\n  html: HTMLElement\r\n): Result<void, string> {\r\n  const element = html.querySelector(\r\n    `li.directory-item[data-entry-id=\"${journalId}\"]`\r\n  ) as HTMLElement;\r\n\r\n  if (!element) {\r\n    return err(`Could not find element for journal entry: ${journalName} (${journalId})`);\r\n  }\r\n\r\n  element.remove();\r\n  return ok(undefined);\r\n}\r\n\r\n/**\r\n * Initializes the module when Foundry VTT starts.\r\n * Registers hooks for hiding journal entries based on module flags.\r\n */\r\nHooks.on(\"init\", () => {\r\n  console.log(`${MODULE_CONSTANTS.LOG_PREFIX} init`);\r\n\r\n  Hooks.on(\"renderJournalDirectory\", (app, html) => {\r\n    console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} renderJournalDirectory fired`, app);\r\n\r\n    const hiddenResult = getHiddenJournalEntries();\r\n\r\n    match(hiddenResult, {\r\n      onOk: (hidden) => {\r\n        console.debug(\r\n          `${MODULE_CONSTANTS.LOG_PREFIX} Found ${hidden.length} hidden journal entries`\r\n        );\r\n\r\n        for (const journal of hidden) {\r\n          const removeResult = removeJournalElement(journal.id, journal.name, html as HTMLElement);\r\n\r\n          match(removeResult, {\r\n            onOk: () => {\r\n              console.debug(\r\n                `${MODULE_CONSTANTS.LOG_PREFIX} Removing journal entry: ${journal.name}`\r\n              );\r\n            },\r\n            onErr: (error) => {\r\n              console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n            },\r\n          });\r\n        }\r\n      },\r\n      onErr: (error) => {\r\n        console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n      },\r\n    });\r\n  });\r\n});\r\n\r\n/**\r\n * Ready hook: Module initialization complete.\r\n * Executes when Foundry VTT is fully ready.\r\n */\r\nHooks.on(\"ready\", () => {\r\n  console.log(`${MODULE_CONSTANTS.LOG_PREFIX} ready`);\r\n});\r\n"],"names":[],"mappings":"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"}