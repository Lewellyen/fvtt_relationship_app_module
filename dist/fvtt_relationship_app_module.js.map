{"version":3,"file":"fvtt_relationship_app_module.js","sources":["../src/polyfills/cytoscape-assign-fix.ts","../src/constants.ts","../src/utils/result.ts","../src/di_infrastructure/types/servicelifecycle.ts","../src/di_infrastructure/container.ts","../src/di_infrastructure/tokenutilities.ts","../src/tokens/tokenindex.ts","../src/services/consolelogger.ts","../src/foundry/foundrytokens.ts","../src/foundry/versioning/versiondetector.ts","../src/foundry/versioning/portselector.ts","../src/foundry/versioning/portregistry.ts","../src/foundry/services/FoundryGameService.ts","../src/foundry/services/FoundryHooksService.ts","../src/foundry/services/FoundryDocumentService.ts","../src/foundry/services/FoundryUIService.ts","../src/foundry/ports/v13/FoundryGamePort.ts","../src/foundry/ports/v13/FoundryHooksPort.ts","../src/foundry/ports/v13/FoundryDocumentPort.ts","../src/foundry/ports/v13/FoundryUIPort.ts","../src/config/dependencyconfig.ts","../src/core/init-solid.ts"],"sourcesContent":["/**\r\n * Polyfill für Cytoscape: Object.assign readonly 'equals' fix\r\n *\r\n * ⚠️ WICHTIG: Dieser Polyfill ist ein Legacy-Patch für die Cytoscape-Bibliothek.\r\n * NIEMALS ÄNDERN - könnte das Verhalten der Cytoscape-Integration beeinträchtigen.\r\n */\r\nObject.assign = function (target: any, ...sources: any[]) {\r\n  for (const source of sources) {\r\n    if (source != null) {\r\n      for (const key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key) && key !== \"equals\") {\r\n          try {\r\n            target[key] = source[key];\r\n          } catch {\r\n            // Ignore readonly property errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n};\r\n","/**\r\n * Module-wide constants for the Foundry VTT Relationship App Module.\r\n * Contains metadata and configuration values used throughout the application.\r\n *\r\n * @constant\r\n */\r\nexport const MODULE_CONSTANTS = {\r\n  MODULE: {\r\n    ID: \"fvtt_relationship_app_module\",\r\n    NAME: \"Beziehungsnetzwerke für Foundry\",\r\n    AUTHOR: \"Andreas Rothe\",\r\n    AUTHOR_EMAIL: \"forenadmin.tir@gmail.com\",\r\n    AUTHOR_DISCORD: \"lewellyen\",\r\n  },\r\n  LOG_PREFIX: \"Foundry VTT Relationship App Module |\",\r\n} as const;\r\n","/**\r\n * Utility functions for working with the Result pattern.\r\n * Provides functional error handling with type safety.\r\n *\r\n * This module contains only runtime functions - types are imported from \"../types/result\"\r\n */\r\nimport type { Ok, Err, Result, AsyncResult } from \"../types/result\";\r\n\r\n/**\r\n * Creates a successful Result with a value.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @param value - The successful value to wrap\r\n * @returns A Result indicating success with the provided value\r\n *\r\n * @example\r\n * ```typescript\r\n * const success = ok(42);\r\n * // { ok: true, value: 42 }\r\n * ```\r\n */\r\nexport function ok<SuccessType>(value: SuccessType): Ok<SuccessType> {\r\n  return { ok: true, value };\r\n}\r\n\r\n/**\r\n * Creates an error Result with an error value.\r\n *\r\n * @template ErrorType - The type of the error value\r\n * @param error - The error to wrap\r\n * @returns A Result indicating failure with the provided error\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"Not found\");\r\n * // { ok: false, error: \"Not found\" }\r\n * ```\r\n */\r\nexport function err<ErrorType>(error: ErrorType): Err<ErrorType> {\r\n  return { ok: false, error };\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is successful.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is successful, narrowing the type to Ok<SuccessType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isOk(result)) {\r\n *   console.log(result.value); // Type-safe access to value\r\n * }\r\n * ```\r\n */\r\nexport function isOk<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Ok<SuccessType> {\r\n  return result.ok;\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is an error.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is an error, narrowing the type to Err<ErrorType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isErr(result)) {\r\n *   console.error(result.error); // Type-safe access to error\r\n * }\r\n * ```\r\n */\r\nexport function isErr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Err<ErrorType> {\r\n  return !result.ok;\r\n}\r\n\r\n/**\r\n * Transforms the value of a successful Result.\r\n * If the Result is an error, it is returned unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the success value\r\n * @returns A new Result with the transformed value, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(5);\r\n * const doubled = map(num, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport function map<SuccessType, NewSuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => NewSuccessType\r\n): Result<NewSuccessType, ErrorType> {\r\n  return result.ok ? ok(transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Transforms the error of a failed Result.\r\n * If the Result is successful, it is returned unchanged.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The current error type\r\n * @template NewErrorType - The new error type after transformation\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the error value\r\n * @returns A new Result with the transformed error, or the original success\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"404\");\r\n * const formatted = mapError(failure, msg => `Error: ${msg}`);\r\n * // { ok: false, error: \"Error: 404\" }\r\n * ```\r\n */\r\nexport function mapError<SuccessType, ErrorType, NewErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (error: ErrorType) => NewErrorType\r\n): Result<SuccessType, NewErrorType> {\r\n  return result.ok ? result : err(transform(result.error));\r\n}\r\n\r\n/**\r\n * Chains Result operations. If the Result is successful, applies the function to the value.\r\n * Otherwise, returns the error unchanged. This is also known as \"flatMap\" or \"bind\".\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param result - The Result to chain\r\n * @param next - Function that returns a new Result from the success value\r\n * @returns The next Result, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseNumber = (str: string): Result<number, string> => {\r\n *   const num = parseInt(str);\r\n *   return isNaN(num) ? err(\"Invalid number\") : ok(num);\r\n * };\r\n *\r\n * const doubled = ok(\"5\").pipe(parseNumber).pipe(x => ok(x * 2));\r\n * ```\r\n */\r\nexport function andThen<SuccessType, ErrorType, NextSuccessType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => Result<NextSuccessType, ErrorType>\r\n): Result<NextSuccessType, ErrorType> {\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or returns a fallback value if it's an error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param fallbackValue - The value to return if the Result is an error\r\n * @returns The success value, or the fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * unwrapOr(num, 0); // 42\r\n *\r\n * const err = err(\"Failed\");\r\n * unwrapOr(err, 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  fallbackValue: SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : fallbackValue;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or computes a fallback value from the error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param getFallback - Function that computes a fallback from the error\r\n * @returns The success value, or the computed fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = err(\"Not found\");\r\n * unwrapOrElse(num, error => 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOrElse<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  getFallback: (error: ErrorType) => SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : getFallback(result.error);\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or throws an error if it's a failure.\r\n * Use with caution - this defeats the purpose of using Result pattern.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ThrownError - The type of error to throw (must extend Error)\r\n * @param result - The Result to unwrap\r\n * @param toError - Optional function to convert the error to a thrown Error\r\n * @returns The success value\r\n * @throws ThrownError if the Result is an error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * getOrThrow(num); // 42\r\n *\r\n * const failure = err(\"Not found\");\r\n * getOrThrow(failure); // throws Error(\"Not found\")\r\n * ```\r\n */\r\nexport function getOrThrow<SuccessType, ErrorType, ThrownError extends Error = Error>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  toError?: (error: ErrorType) => ThrownError\r\n): SuccessType {\r\n  if (result.ok) return result.value;\r\n  const e = toError ? toError(result.error) : (new Error(String(result.error)) as ThrownError);\r\n  throw e;\r\n}\r\n\r\n/**\r\n * Executes a function and wraps the result in a Result, catching any thrown errors.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param fn - The function to execute\r\n * @param mapUnknownError - Function to convert caught errors to the ErrorType\r\n * @returns A Result containing either the return value or the caught error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parsed = tryCatch(\r\n *   () => JSON.parse(\"{ invalid json\"),\r\n *   (e) => `Parse error: ${e}`\r\n * );\r\n * // { ok: false, error: \"Parse error: ...\" }\r\n * ```\r\n */\r\nexport function tryCatch<SuccessType, ErrorType>(\r\n  fn: () => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): Result<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(fn());\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error immediately (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param results - Array of Results to combine\r\n * @returns A Result containing an array of values, or the first error encountered\r\n *\r\n * @example\r\n * ```typescript\r\n * const nums = [ok(1), ok(2), ok(3)];\r\n * all(nums); // { ok: true, value: [1, 2, 3] }\r\n *\r\n * const mixed = [ok(1), err(\"error\"), ok(3)];\r\n * all(mixed); // { ok: false, error: \"error\" }\r\n * ```\r\n */\r\nexport function all<SuccessType, ErrorType>(\r\n  results: Array<Result<SuccessType, ErrorType>>\r\n): Result<SuccessType[], ErrorType> {\r\n  const out: SuccessType[] = [];\r\n  for (const r of results) {\r\n    if (!r.ok) return r;\r\n    out.push(r.value);\r\n  }\r\n  return ok(out);\r\n}\r\n\r\n/**\r\n * Pattern matching for Results. Executes different handlers based on success or failure.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ReturnType - The return type of both handlers\r\n * @param result - The Result to match\r\n * @param handlers - Object with onOk and onErr handlers\r\n * @returns The result of the executed handler\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = ok(42);\r\n * match(result, {\r\n *   onOk: value => console.log(`Success: ${value}`),\r\n *   onErr: error => console.error(`Error: ${error}`)\r\n * });\r\n * ```\r\n */\r\nexport function match<SuccessType, ErrorType, ReturnType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  handlers: { onOk: (value: SuccessType) => ReturnType; onErr: (error: ErrorType) => ReturnType }\r\n): ReturnType {\r\n  return result.ok ? handlers.onOk(result.value) : handlers.onErr(result.error);\r\n}\r\n\r\n/**\r\n * Lifts a regular function to work with Results by wrapping it with error handling.\r\n *\r\n * @template ParamType - The function parameter type\r\n * @template SuccessType - The function return type (success type)\r\n * @template ErrorType - The error type\r\n * @param fn - The function to lift\r\n * @param mapUnknownError - Function to convert thrown errors to the ErrorType\r\n * @returns A function that returns a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseJSON = lift(\r\n *   (str: string) => JSON.parse(str),\r\n *   (e) => `Invalid JSON: ${e}`\r\n * );\r\n *\r\n * const result = parseJSON(\"{ invalid }\");\r\n * // { ok: false, error: \"Invalid JSON: ...\" }\r\n * ```\r\n */\r\nexport function lift<ParamType, SuccessType, ErrorType>(\r\n  fn: (param: ParamType) => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): (param: ParamType) => Result<SuccessType, ErrorType> {\r\n  return (param) => tryCatch(() => fn(param), mapUnknownError);\r\n}\r\n\r\n/**\r\n * Transforms the value of an async Result.\r\n * If the Result is an error, returns it unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param asyncResult - The async Result to transform\r\n * @param transform - Async or sync function to transform the success value\r\n * @returns A promise that resolves to a Result with the transformed value or error\r\n *\r\n * @example\r\n * ```typescript\r\n * const asyncNum = Promise.resolve(ok(5));\r\n * const doubled = await asyncMap(asyncNum, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport async function asyncMap<SuccessType, NewSuccessType, ErrorType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => Promise<NewSuccessType> | NewSuccessType\r\n): AsyncResult<NewSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? ok(await transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Chains async Result operations.\r\n * If the Result is successful, applies the async function to the value.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param asyncResult - The async Result to chain\r\n * @param next - Async function that returns a new async Result\r\n * @returns A promise that resolves to the chained Result or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const fetchAndProcess = async (url: string) => {\r\n *   const data = await fromPromise(fetch(url).then(r => r.json()), e => String(e));\r\n *   return asyncAndThen(data, processDataAsync);\r\n * };\r\n * ```\r\n */\r\nexport async function asyncAndThen<SuccessType, ErrorType, NextSuccessType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => AsyncResult<NextSuccessType, ErrorType>\r\n): AsyncResult<NextSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Converts a Promise into an async Result.\r\n * Catches any rejection and converts it to an error Result.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param promise - The Promise to convert\r\n * @param mapUnknownError - Function to convert unknown errors to the ErrorType\r\n * @returns A promise that resolves to a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await fromPromise(\r\n *   fetch(\"/api/data\").then(r => r.json()),\r\n *   (e) => `Fetch failed: ${e}`\r\n * );\r\n * ```\r\n */\r\nexport async function fromPromise<SuccessType, ErrorType>(\r\n  promise: Promise<SuccessType>,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): AsyncResult<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(await promise);\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple async Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param asyncResults - Array of async Results to combine\r\n * @returns A promise that resolves to a Result containing an array of values or the first error\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = [\r\n *   Promise.resolve(ok(1)),\r\n *   Promise.resolve(ok(2)),\r\n *   Promise.resolve(ok(3))\r\n * ];\r\n * const combined = await asyncAll(results);\r\n * // { ok: true, value: [1, 2, 3] }\r\n * ```\r\n */\r\nexport async function asyncAll<SuccessType, ErrorType>(\r\n  asyncResults: Array<AsyncResult<SuccessType, ErrorType>>\r\n): AsyncResult<SuccessType[], ErrorType> {\r\n  const results: Result<SuccessType, ErrorType>[] = await Promise.all(asyncResults);\r\n  return all(results);\r\n}\r\n","/**\r\n * Enum for service lifecycle strategies in dependency injection.\r\n *\r\n * - SINGLETON: One shared instance across the entire application\r\n * - TRANSIENT: New instance created on each resolution\r\n * - SCOPED: One instance per container scope\r\n *\r\n * @enum {string}\r\n * @property {string} SINGLETON - One instance for all\r\n * @property {string} TRANSIENT - New instance for each resolve()\r\n * @property {string} SCOPED - One instance per scope\r\n */\r\nexport enum ServiceLifecycle {\r\n  SINGLETON = \"singleton\",\r\n  TRANSIENT = \"transient\",\r\n  SCOPED = \"scoped\",\r\n}\r\n","import type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { FactoryFunction } from \"./types/servicefactory\";\r\nimport type { ServiceClass } from \"./types/serviceclass\";\r\nimport type { ServiceDependencies } from \"./types/servicedependencies\";\r\nimport type { ContainerValidationState } from \"./types/containervalidationstate\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport { ok, err, tryCatch, isErr, isOk } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Container } from \"@/di_infrastructure/interfaces/container\";\r\nimport type { ContainerError } from \"@/di_infrastructure/interfaces/containererror\";\r\nimport type { ContainerErrorCode } from \"@/di_infrastructure/types/containererrorcode\";\r\n\r\n/**\r\n * Fallback factory function type for creating service instances when container resolution fails.\r\n */\r\ntype FallbackFactory<T extends ServiceType> = () => T;\r\n\r\n/**\r\n * Global registry of fallback factories for known tokens.\r\n * Used when container resolution fails and a fallback is available.\r\n */\r\nconst fallbackFactories = new Map<symbol, FallbackFactory<ServiceType>>();\r\n\r\n/**\r\n * Register a fallback factory for a specific token.\r\n * This will be used when container.resolve() fails for that token.\r\n *\r\n * @param token - The injection token\r\n * @param factory - Factory function that creates a fallback instance\r\n *\r\n * @example\r\n * ```typescript\r\n * registerFallback(UserServiceToken, () => new DefaultUserService());\r\n * ```\r\n */\r\nexport function registerFallback<T extends ServiceType>(\r\n  token: InjectionToken<T>,\r\n  factory: FallbackFactory<T>\r\n): void {\r\n  fallbackFactories.set(token, factory as FallbackFactory<ServiceType>);\r\n}\r\n\r\n/**\r\n * Dependency injection container that manages service lifecycles.\r\n * Supports Singleton, Transient, and Scoped service patterns with hierarchical container support.\r\n *\r\n * **Scope Chain Behavior:**\r\n * When a parent container is disposed, all child containers are automatically disposed.\r\n * This ensures proper cleanup of resources across the container hierarchy.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const container = new ServiceContainer();\r\n * container.register(LoggerToken, () => new Logger(), ServiceLifecycle.SINGLETON);\r\n * const logger = container.resolve(LoggerToken);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Scope chain with cascading disposal\r\n * const root = new ServiceContainer();\r\n * const child1 = root.createScope(\"child1\");\r\n * const child2 = root.createScope(\"child2\");\r\n * const grandchild = child1.createScope(\"grandchild\");\r\n *\r\n * // Disposing root automatically disposes all children\r\n * root.dispose();\r\n * // All child containers (child1, child2, grandchild) are now disposed\r\n * ```\r\n */\r\nexport class ServiceContainer implements Container {\r\n  /** Service registrations mapping tokens to factories and lifecycles */\r\n  #serviceRegistrations: Map<\r\n    symbol,\r\n    {\r\n      factory: () => any;\r\n      lifecycle: ServiceLifecycle;\r\n      dependencies: ServiceDependencies;\r\n      providerType: \"class\" | \"factory\" | \"value\" | \"alias\";\r\n      aliasTarget?: symbol;\r\n    }\r\n  > = new Map();\r\n\r\n  /** Current validation state of the container */\r\n  #validationState: ContainerValidationState = \"registering\";\r\n\r\n  /** Cached service instances for Singleton and Scoped lifecycles */\r\n  #serviceInstances: Map<symbol, any> = new Map();\r\n\r\n  /** Reference to parent container in the scope hierarchy */\r\n  readonly #parentContainer: ServiceContainer | null = null;\r\n\r\n  /** Flag indicating if this container has been disposed */\r\n  #disposed: boolean = false;\r\n\r\n  /** Hierarchical name for debugging and error messages (e.g., \"root.child1\") */\r\n  readonly #scopeName: string | null = null;\r\n\r\n  /** Set of all child containers for cascading disposal */\r\n  #children: Set<ServiceContainer> = new Set();\r\n\r\n  /**\r\n   * Creates a new service container.\r\n   * If a parent container is provided, creates a scoped child container.\r\n   *\r\n   * **Important:** Child containers are automatically registered with the parent\r\n   * and will be disposed when the parent is disposed (cascading disposal).\r\n   *\r\n   * @param parentContainer - Optional parent container for hierarchical DI\r\n   * @param scopeName - Optional name for the scope (auto-generated if not provided)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Root container\r\n   * const root = new ServiceContainer();\r\n   *\r\n   * // Scoped container (child) with auto-generated name\r\n   * const scope = new ServiceContainer(root);\r\n   *\r\n   * // Scoped container (child) with custom name\r\n   * const namedScope = new ServiceContainer(root, \"myScope\");\r\n   *\r\n   * // All children are tracked by root for cascading disposal\r\n   * root.dispose(); // Automatically disposes scope and namedScope\r\n   * ```\r\n   */\r\n  constructor(parentContainer: ServiceContainer | null = null, scopeName: string | null = null) {\r\n    if (parentContainer !== null) {\r\n      // Child inherits all service registrations from parent\r\n      // This allows child containers to resolve services registered in parent\r\n      this.#serviceRegistrations = new Map(parentContainer.#serviceRegistrations);\r\n\r\n      // Child starts with empty instances - each child has its own scope\r\n      // Singleton instances are still shared via parent lookup in resolve()\r\n      this.#serviceInstances = new Map();\r\n\r\n      this.#parentContainer = parentContainer;\r\n\r\n      // Build hierarchical scope name for debugging\r\n      // Format: \"root.child1.child2\" etc.\r\n      this.#scopeName =\r\n        parentContainer.#scopeName +\r\n        \".\" +\r\n        (scopeName ?? \"scope\" + crypto.randomUUID() + Date.now());\r\n      this.#disposed = false;\r\n\r\n      // Register this child with parent for cascading disposal\r\n      // When parent is disposed, this child will be automatically disposed too\r\n      parentContainer.#children.add(this);\r\n    } else {\r\n      this.#scopeName = \"root\";\r\n      this.#disposed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a child container with its own scope.\r\n   * Inherits service registrations from parent but maintains separate scoped instances.\r\n   *\r\n   * @param name - Optional name for the scope (auto-generated if not provided)\r\n   * @returns Result containing a new scoped container or an error if this container is disposed\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const rootContainer = new ServiceContainer();\r\n   * const scopedContainer = rootContainer.createScope();\r\n   * if (isErr(scopedContainer)) {\r\n   *   console.error(scopedContainer.error.message);\r\n   * }\r\n   * ```\r\n   */\r\n  createScope(name?: string): Result<ServiceContainer, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot create scope from disposed container: ${this.#scopeName}`,\r\n      });\r\n    }\r\n\r\n    if (this.#validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Parent must be validated before creating scopes. Call validate() first.\",\r\n      });\r\n    }\r\n\r\n    const child = new ServiceContainer(this, name ?? null);\r\n    child.#validationState = \"validated\";\r\n\r\n    return ok(child);\r\n  }\r\n\r\n  /**\r\n   * Check if a service is registered.\r\n   * Recursively checks the entire parent container hierarchy from root to this container.\r\n   *\r\n   * @template TServiceType - The type of service\r\n   * @param token - The injection token to check\r\n   * @returns Result indicating if registered in this container or any parent container\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const root = new ServiceContainer();\r\n   * const scope1 = root.createScope();\r\n   * const scope2 = scope1.createScope();\r\n   *\r\n   * root.register(LoggerToken, () => new Logger(), SINGLETON);\r\n   * const result = scope2.isRegistered(LoggerToken);\r\n   * if (isOk(result) && result.value) {\r\n   *   // Service is registered\r\n   * }\r\n   * ```\r\n   */\r\n  isRegistered<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<boolean, never> {\r\n    if (this.#parentContainer !== null) {\r\n      return this.#parentContainer.isRegistered(token);\r\n    }\r\n    return ok(this.#serviceRegistrations.has(token));\r\n  }\r\n\r\n  /**\r\n   * Dispose this container and clean up all scoped instances.\r\n   * Services implementing Disposable will have their dispose() method called automatically.\r\n   *\r\n   * **Cascading Disposal:** All child containers are automatically disposed recursively.\r\n   * Child disposal errors are logged but do not stop parent disposal.\r\n   *\r\n   * Root container clearing requires manual clear() call.\r\n   *\r\n   * @returns Result indicating success or any disposal errors\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const root = new ServiceContainer();\r\n   * const child = root.createScope();\r\n   * const db = child.resolve(DatabaseToken); // Implements Disposable\r\n   *\r\n   * // Disposing root automatically disposes child (and db.dispose() is called)\r\n   * const result = root.dispose();\r\n   * if (isErr(result)) {\r\n   *   console.error(\"Disposal failed:\", result.error);\r\n   * }\r\n   * ```\r\n   */\r\n  dispose(): Result<void, ContainerError> {\r\n    // Check if already disposed\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Container already disposed: ${this.#scopeName}`,\r\n      });\r\n    }\r\n\r\n    // Mark as disposed immediately BEFORE disposing children\r\n    // This prevents new operations on this container while disposal is in progress\r\n    this.#disposed = true;\r\n\r\n    // Recursively dispose all child containers (cascading disposal)\r\n    // Note: Child disposal errors are caught and logged but don't stop the disposal process\r\n    for (const child of this.#children) {\r\n      const childResult = tryCatch(\r\n        () => child.dispose(),\r\n        (error): ContainerError => ({\r\n          code: \"DisposalFailed\",\r\n          message: `Error disposing child container ${child.#scopeName}: ${String(error)}`,\r\n          cause: error,\r\n        })\r\n      );\r\n      if (isErr(childResult)) {\r\n        // Log error but continue with disposal\r\n        console.warn(`Failed to dispose child container ${child.#scopeName}:`, childResult.error);\r\n      }\r\n    }\r\n\r\n    // Dispose all scoped instances that implement Disposable\r\n    for (const [token, instance] of this.#serviceInstances.entries()) {\r\n      if (this.isDisposable(instance)) {\r\n        const result = tryCatch(\r\n          () => instance.dispose(),\r\n          (error): ContainerError => ({\r\n            code: \"DisposalFailed\",\r\n            message: `Error disposing service ${String(token)}: ${String(error)}`,\r\n            tokenDescription: String(token),\r\n            cause: error,\r\n          })\r\n        );\r\n\r\n        if (isErr(result)) {\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clear all instances\r\n    this.#serviceInstances.clear();\r\n\r\n    // Clean up: Remove this container from parent's children set\r\n    // This breaks the reference to prevent memory leaks\r\n    if (this.#parentContainer !== null) {\r\n      this.#parentContainer.#children.delete(this);\r\n    }\r\n\r\n    // Reset validation state\r\n    this.#validationState = \"registering\";\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Check if an instance implements the Disposable interface.\r\n   *\r\n   * @param instance - The service instance to check\r\n   * @returns True if the instance has a dispose() method\r\n   */\r\n  private isDisposable(instance: ServiceType): instance is ServiceType & { dispose: () => void } {\r\n    return (\r\n      \"dispose\" in instance &&\r\n      typeof (instance as ServiceType & { dispose: unknown }).dispose === \"function\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clear all service registrations and instances.\r\n   * Use with caution - this will remove all configured services.\r\n   * Note: dispose() should be used for scoped containers instead.\r\n   *\r\n   * @returns Result indicating success\r\n   */\r\n  clear(): Result<void, never> {\r\n    this.#serviceRegistrations.clear();\r\n    this.#serviceInstances.clear();\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a service class with automatic dependency injection.\r\n   *\r\n   * @template TServiceType - The type of service to register\r\n   * @param token - The injection token that identifies this service\r\n   * @param serviceClass - The service class to instantiate\r\n   * @param lifecycle - Service lifecycle strategy\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerClass<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    serviceClass: ServiceClass<TServiceType>,\r\n    lifecycle: ServiceLifecycle\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    const dependencies = (serviceClass as any).dependencies ?? [];\r\n\r\n    const factory = () => {\r\n      const resolvedDeps = dependencies.map((dep: InjectionToken<ServiceType>) => {\r\n        const result = this.resolveWithError(dep);\r\n        if (isErr(result)) {\r\n          throw new Error(`Dependency ${String(dep)} could not be resolved`);\r\n        }\r\n        return result.value;\r\n      });\r\n      return new serviceClass(...resolvedDeps);\r\n    };\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory,\r\n      lifecycle,\r\n      dependencies,\r\n      providerType: \"class\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a factory function that creates service instances.\r\n   *\r\n   * @template T - The type this factory creates\r\n   * @param token - The injection token that identifies this service\r\n   * @param factory - Factory function that creates the service instance\r\n   * @param lifecycle - Service lifecycle strategy\r\n   * @param dependencies - Array of tokens this factory depends on\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerFactory<T>(\r\n    token: symbol,\r\n    factory: FactoryFunction<T>,\r\n    lifecycle: ServiceLifecycle,\r\n    dependencies: ServiceDependencies\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory,\r\n      lifecycle,\r\n      dependencies,\r\n      providerType: \"factory\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a constant value (always singleton).\r\n   *\r\n   * @template T - The type of value\r\n   * @param token - The injection token that identifies this value\r\n   * @param value - The value to register\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerValue<T>(token: symbol, value: T): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Runtime check: values must not be functions or classes\r\n    if (typeof value === \"function\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message:\r\n          \"registerValue() only accepts plain values, not classes or functions. Use registerClass() or registerFactory() instead.\",\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory: () => value,\r\n      lifecycle: ServiceLifecycle.SINGLETON,\r\n      dependencies: [],\r\n      providerType: \"value\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register an alias that points to another token.\r\n   *\r\n   * @template TServiceType - The type of service\r\n   * @param aliasToken - The alias token\r\n   * @param targetToken - The token to resolve instead\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerAlias<TServiceType extends ServiceType>(\r\n    aliasToken: InjectionToken<TServiceType>,\r\n    targetToken: InjectionToken<TServiceType>\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(aliasToken)}`,\r\n        tokenDescription: String(aliasToken),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(aliasToken)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(aliasToken)} already registered`,\r\n        tokenDescription: String(aliasToken),\r\n      });\r\n    }\r\n\r\n    const factory = () => {\r\n      const result = this.resolveWithError(targetToken);\r\n      if (isErr(result)) {\r\n        throw new Error(`Alias target ${String(targetToken)} not found`);\r\n      }\r\n      return result.value;\r\n    };\r\n\r\n    this.#serviceRegistrations.set(aliasToken, {\r\n      factory,\r\n      lifecycle: ServiceLifecycle.SINGLETON,\r\n      dependencies: [targetToken],\r\n      providerType: \"alias\",\r\n      aliasTarget: targetToken,\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Validate all registered services and their dependencies.\r\n   */\r\n  validate(): Result<void, ContainerError[]> {\r\n    if (this.#validationState === \"validated\") {\r\n      return ok(undefined);\r\n    }\r\n\r\n    if (this.#validationState === \"validating\") {\r\n      return err([\r\n        {\r\n          code: \"InvalidOperation\",\r\n          message: \"Validation already in progress\",\r\n        },\r\n      ]);\r\n    }\r\n\r\n    this.#validationState = \"validating\";\r\n\r\n    const errors = this.validateAllDependencies();\r\n\r\n    if (errors.length > 0) {\r\n      this.#validationState = \"registering\";\r\n      return err(errors);\r\n    }\r\n\r\n    this.#validationState = \"validated\";\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Get the current validation state of the container.\r\n   */\r\n  getValidationState(): ContainerValidationState {\r\n    return this.#validationState;\r\n  }\r\n\r\n  /**\r\n   * Resolve a service instance from the container with explicit error handling.\r\n   *\r\n   * @template TServiceType - The type of service to resolve\r\n   * @param token - The injection token identifying the service\r\n   * @returns Result containing the service instance or an error\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const result = container.resolveWithError(LoggerToken);\r\n   * if (isOk(result)) {\r\n   *   const logger = result.value;\r\n   *   logger.info(\"Service resolved successfully\");\r\n   * }\r\n   * ```\r\n   */\r\n  resolveWithError<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<TServiceType, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot resolve service from disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Container must be validated before resolving. Call validate() first.\",\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Check if service is registered\r\n    const checkResult = this.isRegistered(token);\r\n    if (isErr(checkResult) || !checkResult.value) {\r\n      return err({\r\n        code: \"TokenNotRegistered\",\r\n        message: `Service ${String(token)} not registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    const service = this.#serviceRegistrations.get(token);\r\n    if (!service) {\r\n      return err({\r\n        code: \"TokenNotRegistered\",\r\n        message: `Service ${String(token)} not registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    return tryCatch(\r\n      () => {\r\n        switch (service.lifecycle) {\r\n          case ServiceLifecycle.SINGLETON:\r\n            // Singleton: Check Parent first (for Child-Container)\r\n            if (this.#parentContainer !== null) {\r\n              const parentResult = this.#parentContainer.resolveWithError(token);\r\n              if (isErr(parentResult)) {\r\n                throw new Error(\"CIRCULAR_DEPENDENCY\");\r\n              }\r\n              return parentResult.value;\r\n            }\r\n            // Singleton: Check current container\r\n            if (!this.#serviceInstances.has(token)) {\r\n              this.#serviceInstances.set(token, service.factory() as TServiceType);\r\n            }\r\n            return this.#serviceInstances.get(token) as TServiceType;\r\n\r\n          case ServiceLifecycle.TRANSIENT:\r\n            // Transient: Always create new instance (no caching)\r\n            return service.factory() as TServiceType;\r\n\r\n          case ServiceLifecycle.SCOPED:\r\n            // Scoped: One instance per child container scope\r\n            // MUST be in child container (not root) to have a parent scope reference\r\n            if (this.#parentContainer === null) {\r\n              throw new Error(\"SCOPED_REQUIRES_CONTAINER\");\r\n            }\r\n            // Create instance on first access, reuse for subsequent resolves in same scope\r\n            if (!this.#serviceInstances.has(token)) {\r\n              this.#serviceInstances.set(token, service.factory() as TServiceType);\r\n            }\r\n            return this.#serviceInstances.get(token) as TServiceType;\r\n\r\n          default:\r\n            throw new Error(\"INVALID_LIFECYCLE\");\r\n        }\r\n      },\r\n      (error): ContainerError => {\r\n        const errorMessage = String(error);\r\n        let code: ContainerErrorCode;\r\n        let message: string;\r\n\r\n        // Classify error based on predefined error message patterns\r\n        // These patterns are thrown in the switch statement above to enable proper categorization\r\n        if (errorMessage.includes(\"CIRCULAR_DEPENDENCY\")) {\r\n          code = \"CircularDependency\";\r\n          message = `Circular dependency detected for service ${String(token)}`;\r\n        } else if (errorMessage.includes(\"SCOPED_REQUIRES_CONTAINER\")) {\r\n          code = \"ScopeRequired\";\r\n          message = `Scoped service ${String(token)} requires a scope container`;\r\n        } else if (errorMessage.includes(\"INVALID_LIFECYCLE\")) {\r\n          code = \"InvalidLifecycle\";\r\n          message = `Invalid service lifecycle: ${String(service.lifecycle)}`;\r\n        } else {\r\n          code = \"FactoryFailed\";\r\n          message = `Error creating service ${String(token)}: ${errorMessage}`;\r\n        }\r\n\r\n        return {\r\n          code,\r\n          message,\r\n          tokenDescription: String(token),\r\n          cause: error,\r\n        };\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Resolve a service instance directly from the container.\r\n   * Uses fallback factory if container resolution fails and a fallback is registered.\r\n   *\r\n   * @template TServiceType - The type of service to resolve\r\n   * @param token - The injection token identifying the service\r\n   * @returns The resolved service instance\r\n   * @throws Error if container resolution fails and no fallback is registered\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Direct resolution with automatic fallback\r\n   * const logger = container.resolve(loggerToken);\r\n   * logger.info(\"This will work even if container resolution fails!\");\r\n   * ```\r\n   */\r\n  resolve<TServiceType extends ServiceType>(token: InjectionToken<TServiceType>): TServiceType {\r\n    const result = this.resolveWithError(token);\r\n\r\n    if (isOk(result)) {\r\n      return result.value;\r\n    }\r\n\r\n    // Try fallback factory if available\r\n    const fallback = fallbackFactories.get(token);\r\n    if (fallback) {\r\n      return fallback() as TServiceType;\r\n    }\r\n\r\n    // No fallback available - throw error with helpful message\r\n    throw new Error(\r\n      `Cannot resolve ${String(token)}: ${result.error.message}. ` +\r\n        `No fallback factory registered for this token.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validate all dependencies and check for circular dependencies.\r\n   */\r\n  private validateAllDependencies(): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n\r\n    // 1. Check that all dependencies are registered\r\n    for (const [token, registration] of this.#serviceRegistrations.entries()) {\r\n      for (const dep of registration.dependencies) {\r\n        if (!this.#serviceRegistrations.has(dep)) {\r\n          errors.push({\r\n            code: \"TokenNotRegistered\",\r\n            message: `${String(token)} depends on ${String(dep)} which is not registered`,\r\n            tokenDescription: String(dep),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 2. Check alias targets\r\n    for (const [token, registration] of this.#serviceRegistrations.entries()) {\r\n      if (registration.providerType === \"alias\" && registration.aliasTarget) {\r\n        if (!this.#serviceRegistrations.has(registration.aliasTarget)) {\r\n          errors.push({\r\n            code: \"AliasTargetNotFound\",\r\n            message: `Alias ${String(token)} points to ${String(registration.aliasTarget)} which is not registered`,\r\n            tokenDescription: String(registration.aliasTarget),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3. Check for circular dependencies\r\n    const circularErrors = this.detectCircularDependencies();\r\n    errors.push(...circularErrors);\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Detect circular dependencies using DFS.\r\n   */\r\n  private detectCircularDependencies(): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n    const visited = new Set<symbol>();\r\n\r\n    for (const token of this.#serviceRegistrations.keys()) {\r\n      const visiting = new Set<symbol>();\r\n      const path: symbol[] = [];\r\n\r\n      const error = this.checkCycleForToken(token, visiting, visited, path);\r\n      if (error) {\r\n        errors.push(error);\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Check for cycles starting from a specific token.\r\n   */\r\n  private checkCycleForToken(\r\n    token: symbol,\r\n    visiting: Set<symbol>,\r\n    visited: Set<symbol>,\r\n    path: symbol[]\r\n  ): ContainerError | null {\r\n    if (visiting.has(token)) {\r\n      const cyclePath = [...path, token].map(String).join(\" → \");\r\n      return {\r\n        code: \"CircularDependency\",\r\n        message: `Circular dependency: ${cyclePath}`,\r\n        tokenDescription: String(token),\r\n      };\r\n    }\r\n\r\n    if (visited.has(token)) {\r\n      return null;\r\n    }\r\n\r\n    visiting.add(token);\r\n    path.push(token);\r\n\r\n    const registration = this.#serviceRegistrations.get(token);\r\n    if (registration) {\r\n      for (const dep of registration.dependencies) {\r\n        const error = this.checkCycleForToken(dep, visiting, visited, path);\r\n        if (error) return error;\r\n      }\r\n    }\r\n\r\n    visiting.delete(token);\r\n    path.pop();\r\n    visited.add(token);\r\n\r\n    return null;\r\n  }\r\n}\r\n","/**\r\n * Utility function to create type-safe injection tokens for dependency injection.\r\n */\r\nimport type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\n\r\n/**\r\n * Creates a unique, type-safe injection token for dependency injection.\r\n * Each call creates a new Symbol, ensuring uniqueness even with the same description.\r\n *\r\n * @template ServiceType - The type of service this token represents\r\n * @param description - A descriptive name for debugging purposes (appears in DevTools)\r\n * @returns A unique Symbol branded with the service type\r\n *\r\n * @example\r\n * // Create tokens for different services\r\n * const LoggerToken = createInjectionToken<Logger>('Logger');\r\n * const DatabaseToken = createInjectionToken<Database>('Database');\r\n *\r\n * // Tokens can be used with a DI container\r\n * container.register(LoggerToken, new Logger());\r\n */\r\nexport function createInjectionToken<TServiceType extends ServiceType>(\r\n  description: string\r\n): InjectionToken<TServiceType> {\r\n  return Symbol(description) as InjectionToken<TServiceType>;\r\n}\r\n","import { createInjectionToken } from \"@/di_infrastructure/tokenutilities\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\n\r\n/**\r\n * Token for resolving Logger service instances.\r\n * Used to inject logging functionality throughout the application.\r\n */\r\nexport const loggerToken = createInjectionToken<Logger>(\"Logger\");\r\n","import type { Logger } from \"@/interfaces/logger\";\r\nimport { MODULE_CONSTANTS } from \"../constants\";\r\n\r\n/**\r\n * Console-based implementation of the Logger interface.\r\n * Writes log messages to the browser console.\r\n *\r\n * @implements {Logger}\r\n */\r\nexport class ConsoleLoggerService implements Logger {\r\n  static dependencies = [] as const;\r\n\r\n  /**\r\n   * Log a message to console\r\n   * @param message - Message to log\r\n   */\r\n  log(message: string): void {\r\n    console.log(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log an error message\r\n   * @param message - Error message to log\r\n   */\r\n  error(message: string): void {\r\n    console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log a warning message\r\n   * @param message - Warning message to log\r\n   */\r\n  warn(message: string): void {\r\n    console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   * @param message - Info message to log\r\n   */\r\n  info(message: string): void {\r\n    console.info(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log a debug message\r\n   * @param message - Debug message to log\r\n   */\r\n  debug(message: string): void {\r\n    console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n}\r\n","import type { InjectionToken } from \"@/di_infrastructure/types/injectiontoken\";\nimport { createInjectionToken } from \"@/di_infrastructure/tokenutilities\";\nimport type { FoundryGame } from \"./interfaces/FoundryGame\";\nimport type { FoundryHooks } from \"./interfaces/FoundryHooks\";\nimport type { FoundryDocument } from \"./interfaces/FoundryDocument\";\nimport type { FoundryUI } from \"./interfaces/FoundryUI\";\nimport type { PortSelector } from \"./versioning/portselector\";\nimport type { PortRegistry } from \"./versioning/portregistry\";\n\n/**\n * Injection token for FoundryGame service.\n */\nexport const foundryGameToken: InjectionToken<FoundryGame> =\n  createInjectionToken<FoundryGame>(\"FoundryGame\");\n\n/**\n * Injection token for FoundryHooks service.\n */\nexport const foundryHooksToken: InjectionToken<FoundryHooks> =\n  createInjectionToken<FoundryHooks>(\"FoundryHooks\");\n\n/**\n * Injection token for FoundryDocument service.\n */\nexport const foundryDocumentToken: InjectionToken<FoundryDocument> =\n  createInjectionToken<FoundryDocument>(\"FoundryDocument\");\n\n/**\n * Injection token for FoundryUI service.\n */\nexport const foundryUIToken: InjectionToken<FoundryUI> =\n  createInjectionToken<FoundryUI>(\"FoundryUI\");\n\n/**\n * Injection token for PortSelector.\n */\nexport const portSelectorToken: InjectionToken<PortSelector> =\n  createInjectionToken<PortSelector>(\"PortSelector\");\n\n/**\n * Injection token for FoundryGame PortRegistry.\n */\nexport const foundryGamePortRegistryToken: InjectionToken<PortRegistry<FoundryGame>> =\n  createInjectionToken<PortRegistry<FoundryGame>>(\"FoundryGamePortRegistry\");\n\n/**\n * Injection token for FoundryHooks PortRegistry.\n */\nexport const foundryHooksPortRegistryToken: InjectionToken<PortRegistry<FoundryHooks>> =\n  createInjectionToken<PortRegistry<FoundryHooks>>(\"FoundryHooksPortRegistry\");\n\n/**\n * Injection token for FoundryDocument PortRegistry.\n */\nexport const foundryDocumentPortRegistryToken: InjectionToken<PortRegistry<FoundryDocument>> =\n  createInjectionToken<PortRegistry<FoundryDocument>>(\"FoundryDocumentPortRegistry\");\n\n/**\n * Injection token for FoundryUI PortRegistry.\n */\nexport const foundryUIPortRegistryToken: InjectionToken<PortRegistry<FoundryUI>> =\n  createInjectionToken<PortRegistry<FoundryUI>>(\"FoundryUIPortRegistry\");\n","/**\r\n * Version detection for Foundry VTT.\r\n * Extracts the major version number from Foundry's version string.\r\n */\r\n\r\n/**\r\n * Gets the major version number of the currently running Foundry VTT instance.\r\n * @returns The major version number (e.g., 13 for \"13.348\")\r\n * @throws Error if game is not available or version cannot be determined\r\n */\r\nexport function getFoundryVersion(): number {\r\n  if (typeof game === \"undefined\") {\r\n    throw new Error(\"Foundry game object is not available or version cannot be determined\");\r\n  }\r\n\r\n  // Prefer modern property if available, fallback to legacy\r\n  const versionString = String((game as any).version ?? (game as any).data?.version);\r\n  if (!versionString) {\r\n    throw new Error(\"Foundry version is not available on the game object\");\r\n  }\r\n  const match = versionString.match(/^(\\d+)/);\r\n\r\n  if (!match) {\r\n    throw new Error(`Could not parse Foundry version from: ${versionString}`);\r\n  }\r\n\r\n  return Number.parseInt(match[1]!, 10);\r\n}\r\n\r\n/**\r\n * Safely gets the Foundry version, returning undefined if it cannot be determined.\r\n * @returns The major version number or undefined if not available\r\n */\r\nexport function tryGetFoundryVersion(): number | undefined {\r\n  try {\r\n    return getFoundryVersion();\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport { err, ok } from \"@/utils/result\";\r\nimport { getFoundryVersion } from \"./versiondetector\";\r\n\r\n/**\r\n * Selects the appropriate port implementation based on Foundry version.\r\n * Implements the logic:\r\n * - Foundry v13 → uses v13 ports\r\n * - Foundry v14 → uses v14 ports (if available), otherwise falls back to v13\r\n * - Never uses ports with version number higher than current Foundry version\r\n */\r\nexport class PortSelector {\r\n  /**\r\n   * Selects the appropriate port from available ports based on Foundry version.\r\n   * Returns the highest available port version that is <= the Foundry version.\r\n   *\r\n   * @template T - The port type\r\n   * @param availablePorts - Map of version numbers to port implementations\r\n   * @param foundryVersion - Optional Foundry version (will be detected if not provided)\r\n   * @returns Result containing the selected port or an error message\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const ports = new Map([\r\n   *   [13, new FoundryGamePortV13()],\r\n   *   [14, new FoundryGamePortV14()]\r\n   * ]);\r\n   * const selector = new PortSelector();\r\n   * const result = selector.selectPort(ports);\r\n   * // On Foundry v14: selects v14 port\r\n   * // On Foundry v13: selects v13 port\r\n   * ```\r\n   */\r\n  selectPort<T>(availablePorts: Map<number, T>, foundryVersion?: number): Result<T, string> {\r\n    // Detect Foundry version if not provided\r\n    let version: number;\r\n    try {\r\n      version = foundryVersion ?? getFoundryVersion();\r\n    } catch (error) {\r\n      return err(\r\n        `Could not determine Foundry version: ${error instanceof Error ? error.message : String(error)}`\r\n      );\r\n    }\r\n\r\n    // Find the highest available port that is <= Foundry version\r\n    let selectedPort: T | undefined;\r\n    let selectedVersion = -1;\r\n\r\n    for (const [portVersion, port] of availablePorts.entries()) {\r\n      // Ignore ports with version higher than Foundry version\r\n      if (portVersion > version) {\r\n        continue;\r\n      }\r\n\r\n      // Select the highest compatible port\r\n      if (portVersion > selectedVersion) {\r\n        selectedVersion = portVersion;\r\n        selectedPort = port;\r\n      }\r\n    }\r\n\r\n    if (selectedPort === undefined) {\r\n      const availableVersions = Array.from(availablePorts.keys())\r\n        .sort((a, b) => a - b)\r\n        .join(\", \");\r\n      return err(\r\n        `No compatible port found for Foundry version ${version}. Available ports: ${availableVersions || \"none\"}`\r\n      );\r\n    }\r\n\r\n    return ok(selectedPort);\r\n  }\r\n}\r\n\r\n","/**\r\n * Registry for managing available port implementations across different Foundry versions.\r\n * Centralizes port registration and discovery.\r\n */\r\n\r\nexport type PortFactory<T> = () => T;\r\n\r\n/**\r\n * Registry that holds port factories organized by version.\r\n * @template T - The port interface type\r\n */\r\nexport class PortRegistry<T> {\r\n  private readonly factories = new Map<number, PortFactory<T>>();\r\n\r\n  /**\r\n   * Registers a port factory for a specific Foundry version.\r\n   * @param version - The Foundry version this port supports\r\n   * @param factory - Factory function that creates the port instance\r\n   */\r\n  register(version: number, factory: PortFactory<T>): void {\r\n    this.factories.set(version, factory);\r\n  }\r\n\r\n  /**\r\n   * Gets all registered port versions.\r\n   * @returns Array of registered version numbers, sorted ascending\r\n   */\r\n  getAvailableVersions(): number[] {\r\n    return Array.from(this.factories.keys()).sort((a, b) => a - b);\r\n  }\r\n\r\n  /**\r\n   * Creates all registered ports. Used for port selection.\r\n   * @returns Map of version numbers to port instances\r\n   */\r\n  createAll(): Map<number, T> {\r\n    const ports = new Map<number, T>();\r\n    for (const [version, factory] of this.factories.entries()) {\r\n      ports.set(version, factory());\r\n    }\r\n    return ports;\r\n  }\r\n\r\n  /**\r\n   * Checks if a port is registered for a specific version.\r\n   * @param version - The version to check\r\n   * @returns True if a port is registered for this version\r\n   */\r\n  hasVersion(version: number): boolean {\r\n    return this.factories.has(version);\r\n  }\r\n\r\n  /**\r\n   * Gets the highest registered port version.\r\n   * @returns The highest version number or undefined if no ports are registered\r\n   */\r\n  getHighestVersion(): number | undefined {\r\n    const versions = this.getAvailableVersions();\r\n    return versions.length > 0 ? versions[versions.length - 1] : undefined;\r\n  }\r\n}\r\n\r\n","import type { Result } from \"@/types/result\";\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\nimport type { PortSelector } from \"@/foundry/versioning/portselector\";\nimport type { PortRegistry } from \"@/foundry/versioning/portregistry\";\nimport { err } from \"@/utils/result\";\nimport { portSelectorToken, foundryGamePortRegistryToken } from \"@/foundry/foundrytokens\";\n\n/**\n * Service wrapper for FoundryGame that automatically selects the appropriate port\n * based on the current Foundry version.\n */\nexport class FoundryGameService implements FoundryGame {\n  static dependencies = [portSelectorToken, foundryGamePortRegistryToken] as const;\n\n  private port: FoundryGame | null = null;\n  private readonly portSelector: PortSelector;\n  private readonly portRegistry: PortRegistry<FoundryGame>;\n\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryGame>) {\n    this.portSelector = portSelector;\n    this.portRegistry = portRegistry;\n  }\n\n  /**\n   * Lazy-loads the appropriate port based on Foundry version.\n   * @throws Error if no compatible port can be selected\n   */\n  private getPort(): FoundryGame {\n    if (this.port === null) {\n      const ports = this.portRegistry.createAll();\n      const result = this.portSelector.selectPort(ports);\n      if (!result.ok) {\n        throw new Error(`Failed to select FoundryGame port: ${result.error}`);\n      }\n      this.port = result.value;\n    }\n    return this.port;\n  }\n\n  getJournalEntries(): Result<FoundryJournalEntry[], string> {\n    try {\n      return this.getPort().getJournalEntries();\n    } catch (error) {\n      return err(\n        error instanceof Error ? error.message : `Failed to get journal entries: ${String(error)}`\n      );\n    }\n  }\n\n  getJournalEntryById(id: string): Result<FoundryJournalEntry | null, string> {\n    try {\n      return this.getPort().getJournalEntryById(id);\n    } catch (error) {\n      return err(\n        error instanceof Error\n          ? error.message\n          : `Failed to get journal entry by ID ${id}: ${String(error)}`\n      );\n    }\n  }\n}\n","import type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\nimport type { FoundryHookCallback } from \"@/foundry/types\";\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\nimport { portSelectorToken, foundryHooksPortRegistryToken } from \"@/foundry/foundrytokens\";\n\n/**\n * Service wrapper for FoundryHooks that automatically selects the appropriate port\n * based on the current Foundry version.\n */\nexport class FoundryHooksService implements FoundryHooks {\n  static dependencies = [portSelectorToken, foundryHooksPortRegistryToken] as const;\n\n  private port: FoundryHooks | null = null;\n  private readonly portSelector: PortSelector;\n  private readonly portRegistry: PortRegistry<FoundryHooks>;\n\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryHooks>) {\n    this.portSelector = portSelector;\n    this.portRegistry = portRegistry;\n  }\n\n  /**\n   * Lazy-loads the appropriate port based on Foundry version.\n   * @throws Error if no compatible port can be selected\n   */\n  private getPort(): FoundryHooks {\n    if (this.port === null) {\n      const ports = this.portRegistry.createAll();\n      const result = this.portSelector.selectPort(ports);\n      if (!result.ok) {\n        throw new Error(`Failed to select FoundryHooks port: ${result.error}`);\n      }\n      this.port = result.value;\n    }\n    return this.port;\n  }\n\n  on(hookName: string, callback: FoundryHookCallback): void {\n    try {\n      this.getPort().on(hookName, callback);\n    } catch (error) {\n      console.error(\n        `Failed to register hook ${hookName}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  off(hookName: string, callback: FoundryHookCallback): void {\n    try {\n      this.getPort().off(hookName, callback);\n    } catch (error) {\n      console.warn(\n        `Failed to unregister hook ${hookName}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","import type { Result } from \"@/types/result\";\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\nimport { err } from \"@/utils/result\";\nimport { portSelectorToken, foundryDocumentPortRegistryToken } from \"@/foundry/foundrytokens\";\n\n/**\n * Service wrapper for FoundryDocument that automatically selects the appropriate port\n * based on the current Foundry version.\n */\nexport class FoundryDocumentService implements FoundryDocument {\n  static dependencies = [portSelectorToken, foundryDocumentPortRegistryToken] as const;\n\n  private port: FoundryDocument | null = null;\n  private readonly portSelector: PortSelector;\n  private readonly portRegistry: PortRegistry<FoundryDocument>;\n\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryDocument>) {\n    this.portSelector = portSelector;\n    this.portRegistry = portRegistry;\n  }\n\n  /**\n   * Lazy-loads the appropriate port based on Foundry version.\n   * @throws Error if no compatible port can be selected\n   */\n  private getPort(): FoundryDocument {\n    if (this.port === null) {\n      const ports = this.portRegistry.createAll();\n      const result = this.portSelector.selectPort(ports);\n      if (!result.ok) {\n        throw new Error(`Failed to select FoundryDocument port: ${result.error}`);\n      }\n      this.port = result.value;\n    }\n    return this.port;\n  }\n\n  getFlag<T = unknown>(\n    document: { getFlag: (scope: string, key: string) => unknown },\n    scope: string,\n    key: string\n  ): Result<T | null, string> {\n    try {\n      return this.getPort().getFlag<T>(document, scope, key);\n    } catch (error) {\n      return err(\n        error instanceof Error\n          ? error.message\n          : `Failed to get flag ${scope}.${key}: ${String(error)}`\n      );\n    }\n  }\n\n  async setFlag<T = unknown>(\n    document: { setFlag: (scope: string, key: string, value: T) => Promise<unknown> },\n    scope: string,\n    key: string,\n    value: T\n  ): Promise<Result<void, string>> {\n    try {\n      return await this.getPort().setFlag(document, scope, key, value);\n    } catch (error) {\n      return err(\n        error instanceof Error\n          ? error.message\n          : `Failed to set flag ${scope}.${key}: ${String(error)}`\n      );\n    }\n  }\n}\n","import type { Result } from \"@/types/result\";\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\nimport { err } from \"@/utils/result\";\nimport { portSelectorToken, foundryUIPortRegistryToken } from \"@/foundry/foundrytokens\";\n\n/**\n * Service wrapper for FoundryUI that automatically selects the appropriate port\n * based on the current Foundry version.\n */\nexport class FoundryUIService implements FoundryUI {\n  static dependencies = [portSelectorToken, foundryUIPortRegistryToken] as const;\n\n  private port: FoundryUI | null = null;\n  private readonly portSelector: PortSelector;\n  private readonly portRegistry: PortRegistry<FoundryUI>;\n\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryUI>) {\n    this.portSelector = portSelector;\n    this.portRegistry = portRegistry;\n  }\n\n  /**\n   * Lazy-loads the appropriate port based on Foundry version.\n   * @throws Error if no compatible port can be selected\n   */\n  private getPort(): FoundryUI {\n    if (this.port === null) {\n      const ports = this.portRegistry.createAll();\n      const result = this.portSelector.selectPort(ports);\n      if (!result.ok) {\n        throw new Error(`Failed to select FoundryUI port: ${result.error}`);\n      }\n      this.port = result.value;\n    }\n    return this.port;\n  }\n\n  removeJournalElement(\n    journalId: string,\n    journalName: string,\n    html: HTMLElement\n  ): Result<void, string> {\n    try {\n      return this.getPort().removeJournalElement(journalId, journalName, html);\n    } catch (error) {\n      return err(\n        error instanceof Error\n          ? error.message\n          : `Failed to remove journal element ${journalId}: ${String(error)}`\n      );\n    }\n  }\n\n  findElement(container: HTMLElement, selector: string): Result<HTMLElement | null, string> {\n    try {\n      return this.getPort().findElement(container, selector);\n    } catch (error) {\n      return err(\n        error instanceof Error\n          ? error.message\n          : `Failed to find element with selector ${selector}: ${String(error)}`\n      );\n    }\n  }\n}\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\r\nimport { tryCatch } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryGame interface.\r\n * Encapsulates Foundry v13-specific game API access.\r\n */\r\nexport class FoundryGamePortV13 implements FoundryGame {\r\n  getJournalEntries(): Result<FoundryJournalEntry[], string> {\r\n    return tryCatch(\r\n      () => {\r\n        debugger;\r\n        if (!game?.journal) {\r\n          throw new Error(\"game.journal is not available\");\r\n        }\r\n        const collection = game.journal as any;\r\n        const entries = Array.isArray(collection)\r\n          ? (collection as unknown as FoundryJournalEntry[]).slice()\r\n          : Array.from(collection.contents ?? []);\r\n        return entries as FoundryJournalEntry[];\r\n      },\r\n      (error) =>\r\n        `Failed to get journal entries: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n\r\n  getJournalEntryById(id: string): Result<FoundryJournalEntry | null, string> {\r\n    return tryCatch(\r\n      () => {\r\n        if (!game?.journal) {\r\n          throw new Error(\"game.journal is not available\");\r\n        }\r\n        const entry = game.journal.get(id);\r\n        return (entry as FoundryJournalEntry | undefined) ?? null;\r\n      },\r\n      (error) =>\r\n        `Failed to get journal entry by ID ${id}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n}\r\n","import type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryHookCallback } from \"@/foundry/types\";\r\n\r\n/**\r\n * v13 implementation of FoundryHooks interface.\r\n * Encapsulates Foundry v13-specific hook system access.\r\n */\r\nexport class FoundryHooksPortV13 implements FoundryHooks {\r\n  on(hookName: string, callback: FoundryHookCallback): void {\r\n    if (typeof Hooks === \"undefined\") {\r\n      console.error(\"Foundry Hooks API is not available\");\r\n      return;\r\n    }\r\n    (Hooks as any).on(hookName as any, callback as any);\r\n  }\r\n\r\n  off(hookName: string, callback: FoundryHookCallback): void {\r\n    if (typeof Hooks === \"undefined\") {\r\n      console.warn(\"Foundry Hooks API is not available\");\r\n      return;\r\n    }\r\n    (Hooks as any).off(hookName as any, callback as any);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport { fromPromise, tryCatch } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryDocument interface.\r\n * Encapsulates Foundry v13-specific document operations.\r\n */\r\nexport class FoundryDocumentPortV13 implements FoundryDocument {\r\n  getFlag<T = unknown>(\r\n    document: { getFlag: (scope: string, key: string) => unknown },\r\n    scope: string,\r\n    key: string\r\n  ): Result<T | null, string> {\r\n    return tryCatch(\r\n      () => {\r\n        if (!document?.getFlag) {\r\n          throw new Error(\"Document does not have getFlag method\");\r\n        }\r\n        const value = document.getFlag(scope, key) as T | null | undefined;\r\n        return value ?? null;\r\n      },\r\n      (error) =>\r\n        `Failed to get flag ${scope}.${key}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n\r\n  async setFlag<T = unknown>(\r\n    document: { setFlag: (scope: string, key: string, value: T) => Promise<unknown> },\r\n    scope: string,\r\n    key: string,\r\n    value: T\r\n  ): Promise<Result<void, string>> {\r\n    return fromPromise<void, string>(\r\n      (async () => {\r\n        if (!document?.setFlag) {\r\n          throw new Error(\"Document does not have setFlag method\");\r\n        }\r\n        await document.setFlag(scope, key, value);\r\n      })(),\r\n      (error) =>\r\n        `Failed to set flag ${scope}.${key}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\nimport { ok, err } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryUI interface.\r\n * Encapsulates Foundry v13-specific UI manipulation.\r\n */\r\nexport class FoundryUIPortV13 implements FoundryUI {\r\n  removeJournalElement(\r\n    journalId: string,\r\n    journalName: string,\r\n    html: HTMLElement\r\n  ): Result<void, string> {\r\n    const element = html.querySelector(\r\n      `li.directory-item[data-entry-id=\"${journalId}\"]`\r\n    ) as HTMLElement | null;\r\n\r\n    if (!element) {\r\n      return err(`Could not find element for journal entry: ${journalName} (${journalId})`);\r\n    }\r\n\r\n    element.remove();\r\n    return ok(undefined);\r\n  }\r\n\r\n  findElement(container: HTMLElement, selector: string): Result<HTMLElement | null, string> {\r\n    const element = container.querySelector(selector) as HTMLElement | null;\r\n    return ok(element);\r\n  }\r\n}\r\n\r\n","import { ServiceContainer, registerFallback } from \"@/di_infrastructure/container\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\nimport { ConsoleLoggerService } from \"@/services/consolelogger\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport { ok, err, isErr } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\nimport {\r\n  foundryGameToken,\r\n  foundryHooksToken,\r\n  foundryDocumentToken,\r\n  foundryUIToken,\r\n  portSelectorToken,\r\n  foundryGamePortRegistryToken,\r\n  foundryHooksPortRegistryToken,\r\n  foundryDocumentPortRegistryToken,\r\n  foundryUIPortRegistryToken,\r\n} from \"@/foundry/foundrytokens\";\r\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { FoundryGameService } from \"@/foundry/services/FoundryGameService\";\r\nimport { FoundryHooksService } from \"@/foundry/services/FoundryHooksService\";\r\nimport { FoundryDocumentService } from \"@/foundry/services/FoundryDocumentService\";\r\nimport { FoundryUIService } from \"@/foundry/services/FoundryUIService\";\r\nimport { FoundryGamePortV13 } from \"@/foundry/ports/v13/FoundryGamePort\";\r\nimport { FoundryHooksPortV13 } from \"@/foundry/ports/v13/FoundryHooksPort\";\r\nimport { FoundryDocumentPortV13 } from \"@/foundry/ports/v13/FoundryDocumentPort\";\r\nimport { FoundryUIPortV13 } from \"@/foundry/ports/v13/FoundryUIPort\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\n\r\n/**\r\n * Configures all dependency injection mappings for the application.\r\n * This is the central place where tokens are connected to their factories.\r\n *\r\n * Also registers fallback factories for critical services that should always be available\r\n * even if container resolution fails.\r\n *\r\n * @param container - The service container to configure\r\n * @returns Result indicating success or configuration errors\r\n *\r\n * @example\r\n * ```typescript\r\n * const container = new ServiceContainer();\r\n * const result = configureDependencies(container);\r\n * if (isOk(result)) {\r\n *   const logger = container.resolve(loggerToken); // Direct resolution with fallback\r\n * }\r\n * ```\r\n */\r\nexport function configureDependencies(container: ServiceContainer): Result<void, string> {\r\n  // Register fallback factories for services that should always be available\r\n  registerFallback<Logger>(loggerToken, () => new ConsoleLoggerService());\r\n\r\n  // Register logger\r\n  const loggerResult = container.registerClass(\r\n    loggerToken,\r\n    ConsoleLoggerService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(loggerResult)) {\r\n    return err(`Failed to register logger: ${loggerResult.error.message}`);\r\n  }\r\n\r\n  // Register PortSelector as singleton\r\n  const portSelectorResult = container.registerFactory(\r\n    portSelectorToken,\r\n    () => new PortSelector(),\r\n    ServiceLifecycle.SINGLETON,\r\n    []\r\n  );\r\n\r\n  if (isErr(portSelectorResult)) {\r\n    return err(`Failed to register PortSelector: ${portSelectorResult.error.message}`);\r\n  }\r\n\r\n  // Register PortRegistries\r\n  const gamePortRegistry = new PortRegistry<FoundryGame>();\r\n  gamePortRegistry.register(13, () => new FoundryGamePortV13());\r\n\r\n  const hooksPortRegistry = new PortRegistry<FoundryHooks>();\r\n  hooksPortRegistry.register(13, () => new FoundryHooksPortV13());\r\n\r\n  const documentPortRegistry = new PortRegistry<FoundryDocument>();\r\n  documentPortRegistry.register(13, () => new FoundryDocumentPortV13());\r\n\r\n  const uiPortRegistry = new PortRegistry<FoundryUI>();\r\n  uiPortRegistry.register(13, () => new FoundryUIPortV13());\r\n\r\n  const gameRegistryResult = container.registerValue(\r\n    foundryGamePortRegistryToken,\r\n    gamePortRegistry\r\n  );\r\n  if (isErr(gameRegistryResult)) {\r\n    return err(`Failed to register FoundryGame PortRegistry: ${gameRegistryResult.error.message}`);\r\n  }\r\n\r\n  const hooksRegistryResult = container.registerValue(\r\n    foundryHooksPortRegistryToken,\r\n    hooksPortRegistry\r\n  );\r\n  if (isErr(hooksRegistryResult)) {\r\n    return err(\r\n      `Failed to register FoundryHooks PortRegistry: ${hooksRegistryResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const documentRegistryResult = container.registerValue(\r\n    foundryDocumentPortRegistryToken,\r\n    documentPortRegistry\r\n  );\r\n  if (isErr(documentRegistryResult)) {\r\n    return err(\r\n      `Failed to register FoundryDocument PortRegistry: ${documentRegistryResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const uiRegistryResult = container.registerValue(foundryUIPortRegistryToken, uiPortRegistry);\r\n  if (isErr(uiRegistryResult)) {\r\n    return err(`Failed to register FoundryUI PortRegistry: ${uiRegistryResult.error.message}`);\r\n  }\r\n\r\n  // Register Foundry Services using registerClass (with static dependencies)\r\n  const gameServiceResult = container.registerClass(\r\n    foundryGameToken,\r\n    FoundryGameService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(gameServiceResult)) {\r\n    return err(`Failed to register FoundryGame service: ${gameServiceResult.error.message}`);\r\n  }\r\n\r\n  const hooksServiceResult = container.registerClass(\r\n    foundryHooksToken,\r\n    FoundryHooksService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(hooksServiceResult)) {\r\n    return err(`Failed to register FoundryHooks service: ${hooksServiceResult.error.message}`);\r\n  }\r\n\r\n  const documentServiceResult = container.registerClass(\r\n    foundryDocumentToken,\r\n    FoundryDocumentService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(documentServiceResult)) {\r\n    return err(\r\n      `Failed to register FoundryDocument service: ${documentServiceResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const uiServiceResult = container.registerClass(\r\n    foundryUIToken,\r\n    FoundryUIService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(uiServiceResult)) {\r\n    return err(`Failed to register FoundryUI service: ${uiServiceResult.error.message}`);\r\n  }\r\n\r\n  // Phase 2: Validate\r\n  const validateResult = container.validate();\r\n  if (isErr(validateResult)) {\r\n    const errorMessages = validateResult.error.map((e) => e.message).join(\", \");\r\n    return err(`Validation failed: ${errorMessages}`);\r\n  }\r\n\r\n  return ok(undefined);\r\n}\r\n","import { MODULE_CONSTANTS } from \"../constants\";\r\nimport { match } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport { ServiceContainer } from \"@/di_infrastructure/container\";\r\nimport { configureDependencies } from \"@/config/dependencyconfig\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\nimport {\r\n  foundryGameToken,\r\n  foundryHooksToken,\r\n  foundryDocumentToken,\r\n  foundryUIToken,\r\n} from \"@/foundry/foundrytokens\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\r\n\r\n/**\r\n * Safely gets journal entries that are marked as hidden using Foundry abstraction layer.\r\n */\r\nfunction getHiddenJournalEntries(\r\n  foundryGame: FoundryGame,\r\n  foundryDocument: FoundryDocument\r\n): Result<FoundryJournalEntry[], string> {\r\n  const allEntriesResult = foundryGame.getJournalEntries();\r\n\r\n  if (!allEntriesResult.ok) {\r\n    return allEntriesResult;\r\n  }\r\n\r\n  const hidden: FoundryJournalEntry[] = [];\r\n  for (const journal of allEntriesResult.value) {\r\n    const flagResult = foundryDocument.getFlag<boolean>(\r\n      journal as { getFlag: (scope: string, key: string) => unknown },\r\n      MODULE_CONSTANTS.MODULE.ID,\r\n      \"hidden\"\r\n    );\r\n\r\n    if (flagResult.ok && flagResult.value === true) {\r\n      hidden.push(journal);\r\n    }\r\n  }\r\n\r\n  return { ok: true, value: hidden };\r\n}\r\n\r\n/**\r\n * Initializes the module when Foundry VTT starts.\r\n * Registers hooks for hiding journal entries based on module flags.\r\n */\r\nexport function initializeModule(container: ServiceContainer): void {\r\n  const foundryHooks = container.resolve<FoundryHooks>(foundryHooksToken);\r\n  const foundryGame = container.resolve<FoundryGame>(foundryGameToken);\r\n  const foundryDocument = container.resolve<FoundryDocument>(foundryDocumentToken);\r\n  const foundryUI = container.resolve<FoundryUI>(foundryUIToken);\r\n\r\n  // Register hook using Foundry abstraction\r\n  foundryHooks.on(\"renderJournalDirectory\", (app, html) => {\r\n    const logger = container.resolve(loggerToken);\r\n    logger.debug(`${MODULE_CONSTANTS.LOG_PREFIX} renderJournalDirectory fired`);\r\n\r\n    const hiddenResult = getHiddenJournalEntries(foundryGame, foundryDocument);\r\n\r\n    match(hiddenResult, {\r\n      onOk: (hidden) => {\r\n        logger.debug(\r\n          `${MODULE_CONSTANTS.LOG_PREFIX} Found ${hidden.length} hidden journal entries`\r\n        );\r\n\r\n        for (const journal of hidden) {\r\n          const removeResult = foundryUI.removeJournalElement(\r\n            journal.id,\r\n            journal.name ?? \"Unknown\",\r\n            html as HTMLElement\r\n          );\r\n\r\n          match(removeResult, {\r\n            onOk: () => {\r\n              logger.debug(\r\n                `${MODULE_CONSTANTS.LOG_PREFIX} Removing journal entry: ${journal.name ?? \"Unknown\"}`\r\n              );\r\n            },\r\n            onErr: (error) => {\r\n              logger.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n            },\r\n          });\r\n        }\r\n      },\r\n      onErr: (error) => {\r\n        const logger = container.resolve(loggerToken);\r\n        logger.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n      },\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Initializes the module when Foundry VTT starts.\r\n * Registers hooks for hiding journal entries based on module flags.\r\n */\r\nconst foundryHooksForInit = {\r\n  on(hookName: string, callback: (...args: unknown[]) => void | Promise<void>): void {\r\n    // During init, Hooks may not be available yet, so we use the global Hooks directly\r\n    // This is only for the init hook itself - after container is set up, use the service\r\n    if (typeof Hooks !== \"undefined\") {\r\n      (Hooks as any).on(hookName as any, callback as any);\r\n    }\r\n  },\r\n} as FoundryHooks;\r\n\r\nfoundryHooksForInit.on(\"init\", () => {\r\n  const loggerForInit = {\r\n    log: (message: string) => console.log(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`),\r\n    error: (message: string) => console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`),\r\n    warn: (message: string) => console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`),\r\n    info: (message: string) => console.info(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`),\r\n    debug: (message: string) => console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`),\r\n  };\r\n\r\n  loggerForInit.log(\"init\");\r\n\r\n  const container = new ServiceContainer();\r\n  const configureResult = configureDependencies(container);\r\n  match(configureResult, {\r\n    onOk: () => {\r\n      loggerForInit.log(\"dependencies configured\");\r\n      (globalThis as any).container = container;\r\n\r\n      // Initialize module with Foundry services\r\n      initializeModule(container);\r\n\r\n      // Direct resolution with automatic fallback - no Result-Check needed\r\n      const logger = container.resolve(loggerToken);\r\n      logger.info(\"Logger resolved\");\r\n      logger.info(\"init completed\");\r\n    },\r\n    onErr: (error) => {\r\n      loggerForInit.error(error);\r\n      (globalThis as any).container = null;\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Ready hook: Module initialization complete.\r\n * Executes when Foundry VTT is fully ready.\r\n */\r\nconst foundryHooksForReady = {\r\n  on(hookName: string, callback: (...args: unknown[]) => void | Promise<void>): void {\r\n    if (typeof Hooks !== \"undefined\") {\r\n      (Hooks as any).on(hookName as any, callback as any);\r\n    }\r\n  },\r\n} as FoundryHooks;\r\n\r\nfoundryHooksForReady.on(\"ready\", () => {\r\n  const container = (globalThis as any).container;\r\n  if (!container) {\r\n    console.error(`${MODULE_CONSTANTS.LOG_PREFIX} Container not available in ready hook`);\r\n    return;\r\n  }\r\n  const logger = container.resolve(loggerToken);\r\n  logger.info(\"Module ready\");\r\n});\r\n"],"names":["ServiceLifecycle","match","logger"],"mappings":"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"}