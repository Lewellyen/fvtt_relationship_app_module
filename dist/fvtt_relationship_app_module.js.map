{"version":3,"file":"fvtt_relationship_app_module.js","sources":["../src/polyfills/cytoscape-assign-fix.ts","../src/constants.ts","../src/utils/result.ts","../src/di_infrastructure/tokenutilities.ts","../src/tokens/tokenindex.ts","../src/di_infrastructure/types/servicelifecycle.ts","../src/di_infrastructure/types/serviceregistration.ts","../src/di_infrastructure/registry/ServiceRegistry.ts","../src/di_infrastructure/validation/ContainerValidator.ts","../src/di_infrastructure/cache/InstanceCache.ts","../src/di_infrastructure/errors/ContainerErrors.ts","../src/di_infrastructure/resolution/ServiceResolver.ts","../src/di_infrastructure/scope/ScopeManager.ts","../src/di_infrastructure/container.ts","../src/services/consolelogger.ts","../src/foundry/foundrytokens.ts","../src/services/JournalVisibilityService.ts","../src/foundry/versioning/versiondetector.ts","../src/foundry/versioning/portselector.ts","../src/foundry/versioning/portregistry.ts","../src/foundry/services/FoundryGameService.ts","../src/foundry/services/FoundryHooksService.ts","../src/foundry/services/FoundryDocumentService.ts","../src/foundry/services/FoundryUIService.ts","../src/foundry/ports/v13/FoundryGamePort.ts","../src/foundry/ports/v13/FoundryHooksPort.ts","../src/foundry/ports/v13/FoundryDocumentPort.ts","../src/foundry/ports/v13/FoundryUIPort.ts","../src/config/dependencyconfig.ts","../src/core/composition-root.ts","../src/core/module-hook-registrar.ts","../src/core/init-solid.ts"],"sourcesContent":["/**\r\n * Polyfill für Cytoscape: Object.assign readonly 'equals' fix\r\n *\r\n * ⚠️ WICHTIG: Dieser Polyfill ist ein Legacy-Patch für die Cytoscape-Bibliothek.\r\n * NIEMALS ÄNDERN - könnte das Verhalten der Cytoscape-Integration beeinträchtigen.\r\n */\r\n// Patch Object.assign only once and keep original semantics wherever possible\r\nconst originalAssignRef = Object.assign as any;\r\nif (!(originalAssignRef && originalAssignRef.__cy_careful_patch)) {\r\n  const patched = function (target: any, ...sources: any[]) {\r\n    const filteredSources = sources.map((source) => {\r\n      if (source == null) return source;\r\n      // Create a shallow copy excluding the problematic 'equals' key\r\n      const out: any = {};\r\n      for (const key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key) && key !== \"equals\") {\r\n          out[key] = (source as any)[key];\r\n        }\r\n      }\r\n      return out;\r\n    });\r\n    try {\r\n      return originalAssignRef(target, ...filteredSources);\r\n    } catch {\r\n      // Fallback to naive assignment filtering readonly errors\r\n      for (const src of filteredSources) {\r\n        if (src != null) {\r\n          for (const k in src) {\r\n            try {\r\n              (target as any)[k] = (src as any)[k];\r\n            } catch {}\r\n          }\r\n        }\r\n      }\r\n      return target;\r\n    }\r\n  } as typeof Object.assign & { __cy_careful_patch?: boolean };\r\n  (patched as any).__cy_careful_patch = true;\r\n  Object.assign = patched as any;\r\n}\r\n","/**\r\n * Module-wide constants for the Foundry VTT Relationship App Module.\r\n * Contains metadata and configuration values used throughout the application.\r\n *\r\n * @constant\r\n *\r\n * @note ENCODING REQUIREMENT\r\n * All source files in this project MUST be saved as UTF-8 without BOM.\r\n * This ensures proper display of German text (ä, ö, ü, ß) and prevents mojibake.\r\n * Configure your editor to use UTF-8 encoding for all .ts, .js, and .svelte files.\r\n */\r\nexport const MODULE_CONSTANTS = {\r\n  MODULE: {\r\n    ID: \"fvtt_relationship_app_module\",\r\n    NAME: \"Beziehungsnetzwerke für Foundry\",\r\n    AUTHOR: \"Andreas Rothe\",\r\n    AUTHOR_EMAIL: \"forenadmin.tir@gmail.com\",\r\n    AUTHOR_DISCORD: \"lewellyen\",\r\n  },\r\n  LOG_PREFIX: \"Foundry VTT Relationship App Module |\",\r\n  FLAGS: {\r\n    HIDDEN: \"hidden\",\r\n  },\r\n  HOOKS: {\r\n    RENDER_JOURNAL_DIRECTORY: \"renderJournalDirectory\",\r\n    INIT: \"init\",\r\n    READY: \"ready\",\r\n  },\r\n  DEFAULTS: {\r\n    UNKNOWN_NAME: \"Unknown\",\r\n  },\r\n} as const;\r\n","/**\r\n * Utility functions for working with the Result pattern.\r\n * Provides functional error handling with type safety.\r\n *\r\n * This module contains only runtime functions - types are imported from \"../types/result\"\r\n */\r\nimport type { Ok, Err, Result, AsyncResult } from \"../types/result\";\r\n\r\n/**\r\n * Creates a successful Result with a value.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @param value - The successful value to wrap\r\n * @returns A Result indicating success with the provided value\r\n *\r\n * @example\r\n * ```typescript\r\n * const success = ok(42);\r\n * // { ok: true, value: 42 }\r\n * ```\r\n */\r\nexport function ok<SuccessType>(value: SuccessType): Ok<SuccessType> {\r\n  return { ok: true, value };\r\n}\r\n\r\n/**\r\n * Creates an error Result with an error value.\r\n *\r\n * @template ErrorType - The type of the error value\r\n * @param error - The error to wrap\r\n * @returns A Result indicating failure with the provided error\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"Not found\");\r\n * // { ok: false, error: \"Not found\" }\r\n * ```\r\n */\r\nexport function err<ErrorType>(error: ErrorType): Err<ErrorType> {\r\n  return { ok: false, error };\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is successful.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is successful, narrowing the type to Ok<SuccessType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isOk(result)) {\r\n *   console.log(result.value); // Type-safe access to value\r\n * }\r\n * ```\r\n */\r\nexport function isOk<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Ok<SuccessType> {\r\n  return result.ok;\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is an error.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is an error, narrowing the type to Err<ErrorType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isErr(result)) {\r\n *   console.error(result.error); // Type-safe access to error\r\n * }\r\n * ```\r\n */\r\nexport function isErr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Err<ErrorType> {\r\n  return !result.ok;\r\n}\r\n\r\n/**\r\n * Transforms the value of a successful Result.\r\n * If the Result is an error, it is returned unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the success value\r\n * @returns A new Result with the transformed value, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(5);\r\n * const doubled = map(num, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport function map<SuccessType, NewSuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => NewSuccessType\r\n): Result<NewSuccessType, ErrorType> {\r\n  return result.ok ? ok(transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Transforms the error of a failed Result.\r\n * If the Result is successful, it is returned unchanged.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The current error type\r\n * @template NewErrorType - The new error type after transformation\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the error value\r\n * @returns A new Result with the transformed error, or the original success\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"404\");\r\n * const formatted = mapError(failure, msg => `Error: ${msg}`);\r\n * // { ok: false, error: \"Error: 404\" }\r\n * ```\r\n */\r\nexport function mapError<SuccessType, ErrorType, NewErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (error: ErrorType) => NewErrorType\r\n): Result<SuccessType, NewErrorType> {\r\n  return result.ok ? result : err(transform(result.error));\r\n}\r\n\r\n/**\r\n * Chains Result operations. If the Result is successful, applies the function to the value.\r\n * Otherwise, returns the error unchanged. This is also known as \"flatMap\" or \"bind\".\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param result - The Result to chain\r\n * @param next - Function that returns a new Result from the success value\r\n * @returns The next Result, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseNumber = (str: string): Result<number, string> => {\r\n *   const num = parseInt(str);\r\n *   return isNaN(num) ? err(\"Invalid number\") : ok(num);\r\n * };\r\n *\r\n * const doubled = ok(\"5\").pipe(parseNumber).pipe(x => ok(x * 2));\r\n * ```\r\n */\r\nexport function andThen<SuccessType, ErrorType, NextSuccessType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => Result<NextSuccessType, ErrorType>\r\n): Result<NextSuccessType, ErrorType> {\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or returns a fallback value if it's an error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param fallbackValue - The value to return if the Result is an error\r\n * @returns The success value, or the fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * unwrapOr(num, 0); // 42\r\n *\r\n * const err = err(\"Failed\");\r\n * unwrapOr(err, 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  fallbackValue: SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : fallbackValue;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or computes a fallback value from the error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param getFallback - Function that computes a fallback from the error\r\n * @returns The success value, or the computed fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = err(\"Not found\");\r\n * unwrapOrElse(num, error => 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOrElse<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  getFallback: (error: ErrorType) => SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : getFallback(result.error);\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or throws an error if it's a failure.\r\n * Use with caution - this defeats the purpose of using Result pattern.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ThrownError - The type of error to throw (must extend Error)\r\n * @param result - The Result to unwrap\r\n * @param toError - Optional function to convert the error to a thrown Error\r\n * @returns The success value\r\n * @throws ThrownError if the Result is an error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * getOrThrow(num); // 42\r\n *\r\n * const failure = err(\"Not found\");\r\n * getOrThrow(failure); // throws Error(\"Not found\")\r\n * ```\r\n */\r\nexport function getOrThrow<SuccessType, ErrorType, ThrownError extends Error = Error>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  toError?: (error: ErrorType) => ThrownError\r\n): SuccessType {\r\n  if (result.ok) return result.value;\r\n  const e = toError ? toError(result.error) : (new Error(String(result.error)) as ThrownError);\r\n  throw e;\r\n}\r\n\r\n/**\r\n * Executes a function and wraps the result in a Result, catching any thrown errors.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param fn - The function to execute\r\n * @param mapUnknownError - Function to convert caught errors to the ErrorType\r\n * @returns A Result containing either the return value or the caught error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parsed = tryCatch(\r\n *   () => JSON.parse(\"{ invalid json\"),\r\n *   (e) => `Parse error: ${e}`\r\n * );\r\n * // { ok: false, error: \"Parse error: ...\" }\r\n * ```\r\n */\r\nexport function tryCatch<SuccessType, ErrorType>(\r\n  fn: () => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): Result<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(fn());\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error immediately (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param results - Array of Results to combine\r\n * @returns A Result containing an array of values, or the first error encountered\r\n *\r\n * @example\r\n * ```typescript\r\n * const nums = [ok(1), ok(2), ok(3)];\r\n * all(nums); // { ok: true, value: [1, 2, 3] }\r\n *\r\n * const mixed = [ok(1), err(\"error\"), ok(3)];\r\n * all(mixed); // { ok: false, error: \"error\" }\r\n * ```\r\n */\r\nexport function all<SuccessType, ErrorType>(\r\n  results: Array<Result<SuccessType, ErrorType>>\r\n): Result<SuccessType[], ErrorType> {\r\n  const out: SuccessType[] = [];\r\n  for (const r of results) {\r\n    if (!r.ok) return r;\r\n    out.push(r.value);\r\n  }\r\n  return ok(out);\r\n}\r\n\r\n/**\r\n * Pattern matching for Results. Executes different handlers based on success or failure.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ReturnType - The return type of both handlers\r\n * @param result - The Result to match\r\n * @param handlers - Object with onOk and onErr handlers\r\n * @returns The result of the executed handler\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = ok(42);\r\n * match(result, {\r\n *   onOk: value => console.log(`Success: ${value}`),\r\n *   onErr: error => console.error(`Error: ${error}`)\r\n * });\r\n * ```\r\n */\r\nexport function match<SuccessType, ErrorType, ReturnType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  handlers: { onOk: (value: SuccessType) => ReturnType; onErr: (error: ErrorType) => ReturnType }\r\n): ReturnType {\r\n  return result.ok ? handlers.onOk(result.value) : handlers.onErr(result.error);\r\n}\r\n\r\n/**\r\n * Lifts a regular function to work with Results by wrapping it with error handling.\r\n *\r\n * @template ParamType - The function parameter type\r\n * @template SuccessType - The function return type (success type)\r\n * @template ErrorType - The error type\r\n * @param fn - The function to lift\r\n * @param mapUnknownError - Function to convert thrown errors to the ErrorType\r\n * @returns A function that returns a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseJSON = lift(\r\n *   (str: string) => JSON.parse(str),\r\n *   (e) => `Invalid JSON: ${e}`\r\n * );\r\n *\r\n * const result = parseJSON(\"{ invalid }\");\r\n * // { ok: false, error: \"Invalid JSON: ...\" }\r\n * ```\r\n */\r\nexport function lift<ParamType, SuccessType, ErrorType>(\r\n  fn: (param: ParamType) => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): (param: ParamType) => Result<SuccessType, ErrorType> {\r\n  return (param) => tryCatch(() => fn(param), mapUnknownError);\r\n}\r\n\r\n/**\r\n * Transforms the value of an async Result.\r\n * If the Result is an error, returns it unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param asyncResult - The async Result to transform\r\n * @param transform - Async or sync function to transform the success value\r\n * @returns A promise that resolves to a Result with the transformed value or error\r\n *\r\n * @example\r\n * ```typescript\r\n * const asyncNum = Promise.resolve(ok(5));\r\n * const doubled = await asyncMap(asyncNum, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport async function asyncMap<SuccessType, NewSuccessType, ErrorType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => Promise<NewSuccessType> | NewSuccessType\r\n): AsyncResult<NewSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? ok(await transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Chains async Result operations.\r\n * If the Result is successful, applies the async function to the value.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param asyncResult - The async Result to chain\r\n * @param next - Async function that returns a new async Result\r\n * @returns A promise that resolves to the chained Result or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const fetchAndProcess = async (url: string) => {\r\n *   const data = await fromPromise(fetch(url).then(r => r.json()), e => String(e));\r\n *   return asyncAndThen(data, processDataAsync);\r\n * };\r\n * ```\r\n */\r\nexport async function asyncAndThen<SuccessType, ErrorType, NextSuccessType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => AsyncResult<NextSuccessType, ErrorType>\r\n): AsyncResult<NextSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Converts a Promise into an async Result.\r\n * Catches any rejection and converts it to an error Result.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param promise - The Promise to convert\r\n * @param mapUnknownError - Function to convert unknown errors to the ErrorType\r\n * @returns A promise that resolves to a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await fromPromise(\r\n *   fetch(\"/api/data\").then(r => r.json()),\r\n *   (e) => `Fetch failed: ${e}`\r\n * );\r\n * ```\r\n */\r\nexport async function fromPromise<SuccessType, ErrorType>(\r\n  promise: Promise<SuccessType>,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): AsyncResult<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(await promise);\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple async Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param asyncResults - Array of async Results to combine\r\n * @returns A promise that resolves to a Result containing an array of values or the first error\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = [\r\n *   Promise.resolve(ok(1)),\r\n *   Promise.resolve(ok(2)),\r\n *   Promise.resolve(ok(3))\r\n * ];\r\n * const combined = await asyncAll(results);\r\n * // { ok: true, value: [1, 2, 3] }\r\n * ```\r\n */\r\nexport async function asyncAll<SuccessType, ErrorType>(\r\n  asyncResults: Array<AsyncResult<SuccessType, ErrorType>>\r\n): AsyncResult<SuccessType[], ErrorType> {\r\n  const results: Result<SuccessType, ErrorType>[] = await Promise.all(asyncResults);\r\n  return all(results);\r\n}\r\n","/**\r\n * Utility function to create type-safe injection tokens for dependency injection.\r\n */\r\nimport type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\n\r\n/**\r\n * Creates a unique, type-safe injection token for dependency injection.\r\n * Each call creates a new Symbol, ensuring uniqueness even with the same description.\r\n *\r\n * @template ServiceType - The type of service this token represents\r\n * @param description - A descriptive name for debugging purposes (appears in DevTools)\r\n * @returns A unique Symbol branded with the service type\r\n *\r\n * @example\r\n * // Create tokens for different services\r\n * const LoggerToken = createInjectionToken<Logger>('Logger');\r\n * const DatabaseToken = createInjectionToken<Database>('Database');\r\n *\r\n * // Tokens can be used with a DI container\r\n * container.register(LoggerToken, new Logger());\r\n */\r\nexport function createInjectionToken<TServiceType extends ServiceType>(\r\n  description: string\r\n): InjectionToken<TServiceType> {\r\n  return Symbol(description) as InjectionToken<TServiceType>;\r\n}\r\n","import { createInjectionToken } from \"@/di_infrastructure/tokenutilities\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\nimport type { JournalVisibilityService } from \"@/services/JournalVisibilityService\";\r\n\r\n/**\r\n * Token for resolving Logger service instances.\r\n * Used to inject logging functionality throughout the application.\r\n */\r\nexport const loggerToken = createInjectionToken<Logger>(\"Logger\");\r\n\r\n/**\r\n * Token for resolving the JournalVisibilityService.\r\n */\r\nexport const journalVisibilityServiceToken =\r\n  createInjectionToken<JournalVisibilityService>(\"JournalVisibilityService\");\r\n","/**\r\n * Enum for service lifecycle strategies in dependency injection.\r\n *\r\n * - SINGLETON: One shared instance across the entire application\r\n * - TRANSIENT: New instance created on each resolution\r\n * - SCOPED: One instance per container scope\r\n *\r\n * @enum {string}\r\n * @property {string} SINGLETON - One instance for all\r\n * @property {string} TRANSIENT - New instance for each resolve()\r\n * @property {string} SCOPED - One instance per scope\r\n */\r\nexport enum ServiceLifecycle {\r\n  SINGLETON = \"singleton\",\r\n  TRANSIENT = \"transient\",\r\n  SCOPED = \"scoped\",\r\n}\r\n","import type { ServiceLifecycle } from \"./servicelifecycle\";\r\nimport type { InjectionToken } from \"./injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport type { ServiceClass } from \"./serviceclass\";\r\nimport type { FactoryFunction } from \"./servicefactory\";\r\n\r\n/**\r\n * Represents a service registration in the DI container.\r\n * Stores all metadata required to create and manage service instances.\r\n * \r\n * Design: Uses separate optional fields instead of union type to:\r\n * - Prevent accidental calls to placeholder alias factories\r\n * - Make provider type clear and type-safe\r\n * - Support proper cloning for child scopes\r\n */\r\nexport class ServiceRegistration {\r\n  constructor(\r\n    public readonly lifecycle: ServiceLifecycle,\r\n    public readonly dependencies: readonly InjectionToken<ServiceType>[], // Immutable array\r\n    public readonly providerType: \"class\" | \"factory\" | \"value\" | \"alias\",\r\n    \r\n    // Exactly one of these must be set based on providerType:\r\n    public readonly serviceClass?: ServiceClass<ServiceType>,\r\n    public readonly factory?: FactoryFunction<ServiceType>,\r\n    public readonly value?: ServiceType,\r\n    public readonly aliasTarget?: InjectionToken<ServiceType>\r\n  ) {\r\n    // Runtime validation: exactly one field must be set\r\n    const setCount = [serviceClass, factory, value, aliasTarget].filter(x => x !== undefined).length;\r\n    \r\n    if (setCount !== 1) {\r\n      throw new Error(\r\n        `Invalid ServiceRegistration: exactly one of serviceClass, factory, value, or aliasTarget must be set. ` +\r\n        `Got ${setCount} set. ProviderType: ${providerType}`\r\n      );\r\n    }\r\n    \r\n    // Validate that the set field matches providerType\r\n    if (providerType === \"class\" && !serviceClass) {\r\n      throw new Error(`ProviderType \"class\" requires serviceClass to be set`);\r\n    }\r\n    if (providerType === \"factory\" && !factory) {\r\n      throw new Error(`ProviderType \"factory\" requires factory to be set`);\r\n    }\r\n    if (providerType === \"value\" && value === undefined) {\r\n      throw new Error(`ProviderType \"value\" requires value to be set`);\r\n    }\r\n    if (providerType === \"alias\" && !aliasTarget) {\r\n      throw new Error(`ProviderType \"alias\" requires aliasTarget to be set`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a clone of this registration.\r\n   * Used when child containers inherit registrations from parent.\r\n   * \r\n   * @returns A new ServiceRegistration instance with cloned dependencies array\r\n   */\r\n  clone(): ServiceRegistration {\r\n    return new ServiceRegistration(\r\n      this.lifecycle,\r\n      [...this.dependencies], // Clone array to prevent shared mutations\r\n      this.providerType,\r\n      this.serviceClass,\r\n      this.factory,\r\n      this.value,\r\n      this.aliasTarget\r\n    );\r\n  }\r\n}\r\n\r\n","import type { Result } from \"@/types/result\";\nimport type { InjectionToken } from \"../types/injectiontoken\";\nimport type { ServiceType } from \"@/types/servicetypeindex\";\nimport type { ServiceClass } from \"../types/serviceclass\";\nimport type { FactoryFunction } from \"../types/servicefactory\";\nimport type { ServiceDependencies } from \"../types/servicedependencies\";\nimport { ServiceLifecycle } from \"../types/servicelifecycle\";\nimport type { ContainerError } from \"../interfaces/containererror\";\nimport { ServiceRegistration } from \"../types/serviceregistration\";\nimport { ok, err } from \"@/utils/result\";\n\n/**\n * Registry for service registrations.\n * \n * Responsibilities:\n * - Manage service registrations (add, retrieve, check existence)\n * - Validate registrations (no duplicates, valid values)\n * - Support cloning for child containers\n * \n * This class does NOT handle:\n * - Service resolution (that's ServiceResolver's job)\n * - Dependency validation (that's ContainerValidator's job)\n */\nexport class ServiceRegistry {\n  private registrations = new Map<InjectionToken<ServiceType>, ServiceRegistration>();\n\n  /**\n   * Registers a service class with automatic dependency injection.\n   * \n   * @template TServiceType - The type of service to register\n   * @param token - The injection token identifying this service\n   * @param serviceClass - The class to instantiate\n   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)\n   * @returns Result indicating success or error\n   */\n  registerClass<TServiceType extends ServiceType>(\n    token: InjectionToken<TServiceType>,\n    serviceClass: ServiceClass<TServiceType>,\n    lifecycle: ServiceLifecycle\n  ): Result<void, ContainerError> {\n    if (this.registrations.has(token)) {\n      return err({\n        code: \"DuplicateRegistration\",\n        message: `Service ${String(token)} already registered`,\n        tokenDescription: String(token),\n      });\n    }\n\n    const dependencies = (serviceClass as any).dependencies ?? [];\n\n    const registration = new ServiceRegistration(\n      lifecycle,\n      dependencies,\n      \"class\",\n      serviceClass,     // Store the class itself\n      undefined,        // factory\n      undefined,        // value\n      undefined         // aliasTarget\n    );\n\n    this.registrations.set(token, registration);\n    return ok(undefined);\n  }\n\n  /**\n   * Registers a factory function for creating service instances.\n   * \n   * @template TServiceType - The type of service this factory creates\n   * @param token - The injection token identifying this service\n   * @param factory - Factory function that creates instances\n   * @param lifecycle - Service lifecycle (SINGLETON, TRANSIENT, SCOPED)\n   * @param dependencies - Array of tokens this factory depends on\n   * @returns Result indicating success or error\n   */\n  registerFactory<TServiceType extends ServiceType>(\n    token: InjectionToken<TServiceType>,\n    factory: FactoryFunction<TServiceType>,\n    lifecycle: ServiceLifecycle,\n    dependencies: ServiceDependencies\n  ): Result<void, ContainerError> {\n    if (this.registrations.has(token)) {\n      return err({\n        code: \"DuplicateRegistration\",\n        message: `Service ${String(token)} already registered`,\n        tokenDescription: String(token),\n      });\n    }\n\n    const registration = new ServiceRegistration(\n      lifecycle,\n      dependencies,\n      \"factory\",\n      undefined,        // serviceClass\n      factory,          // Store the factory function\n      undefined,        // value\n      undefined         // aliasTarget\n    );\n\n    this.registrations.set(token, registration);\n    return ok(undefined);\n  }\n\n  /**\n   * Registers a constant value (always SINGLETON lifecycle).\n   * \n   * @template TServiceType - The type of value to register\n   * @param token - The injection token identifying this value\n   * @param value - The value to register\n   * @returns Result indicating success or error\n   */\n  registerValue<TServiceType extends ServiceType>(\n    token: InjectionToken<TServiceType>,\n    value: TServiceType\n  ): Result<void, ContainerError> {\n    if (this.registrations.has(token)) {\n      return err({\n        code: \"DuplicateRegistration\",\n        message: `Service ${String(token)} already registered`,\n        tokenDescription: String(token),\n      });\n    }\n\n    // Runtime check: values must not be functions or classes\n    if (typeof value === \"function\") {\n      return err({\n        code: \"InvalidOperation\",\n        message:\n          \"registerValue() only accepts plain values, not classes or functions. Use registerClass() or registerFactory() instead.\",\n        tokenDescription: String(token),\n      });\n    }\n\n    const registration = new ServiceRegistration(\n      ServiceLifecycle.SINGLETON,\n      [],\n      \"value\",\n      undefined,        // serviceClass\n      undefined,        // factory\n      value,            // Store the value\n      undefined         // aliasTarget\n    );\n\n    this.registrations.set(token, registration);\n    return ok(undefined);\n  }\n\n  /**\n   * Registers an alias that points to another token.\n   * \n   * @template TServiceType - The type of service\n   * @param aliasToken - The alias token\n   * @param targetToken - The token to resolve instead\n   * @returns Result indicating success or error\n   */\n  registerAlias<TServiceType extends ServiceType>(\n    aliasToken: InjectionToken<TServiceType>,\n    targetToken: InjectionToken<TServiceType>\n  ): Result<void, ContainerError> {\n    if (this.registrations.has(aliasToken)) {\n      return err({\n        code: \"DuplicateRegistration\",\n        message: `Service ${String(aliasToken)} already registered`,\n        tokenDescription: String(aliasToken),\n      });\n    }\n\n    // Alias resolution is handled by ServiceResolver\n    const registration = new ServiceRegistration(\n      ServiceLifecycle.SINGLETON,\n      [targetToken],\n      \"alias\",\n      undefined,        // serviceClass\n      undefined,        // factory\n      undefined,        // value\n      targetToken       // Store alias target\n    );\n\n    this.registrations.set(aliasToken, registration);\n    return ok(undefined);\n  }\n\n  /**\n   * Retrieves a service registration.\n   * \n   * @template TServiceType - The type of service\n   * @param token - The injection token identifying the service\n   * @returns The registration or undefined if not found\n   */\n  getRegistration<TServiceType extends ServiceType>(\n    token: InjectionToken<TServiceType>\n  ): ServiceRegistration | undefined {\n    return this.registrations.get(token);\n  }\n\n  /**\n   * Returns all registrations.\n   * Used by ContainerValidator for dependency validation.\n   * \n   * @returns Map of all registrations\n   */\n  getAllRegistrations(): Map<InjectionToken<ServiceType>, ServiceRegistration> {\n    return new Map(this.registrations); // Defensive copy\n  }\n\n  /**\n   * Checks if a service is registered.\n   * \n   * @template TServiceType - The type of service\n   * @param token - The injection token to check\n   * @returns True if registered, false otherwise\n   */\n  has<TServiceType extends ServiceType>(token: InjectionToken<TServiceType>): boolean {\n    return this.registrations.has(token);\n  }\n\n  /**\n   * Clears all registrations.\n   * Warning: This removes all configured services.\n   */\n  clear(): void {\n    this.registrations.clear();\n  }\n\n  /**\n   * Creates a deep clone of this registry for child containers.\n   * \n   * Important: Creates a new Map instance with cloned ServiceRegistration objects\n   * to prevent child containers from mutating parent registrations.\n   * \n   * @returns A new ServiceRegistry with cloned registrations\n   */\n  clone(): ServiceRegistry {\n    const clonedRegistry = new ServiceRegistry();\n    \n    // Create new Map with cloned ServiceRegistration objects\n    for (const [token, registration] of this.registrations.entries()) {\n      clonedRegistry.registrations.set(token, registration.clone());\n    }\n    \n    return clonedRegistry;\n  }\n}\n\n","import type { Result } from \"@/types/result\";\r\nimport type { ContainerError } from \"../interfaces/containererror\";\r\nimport type { InjectionToken } from \"../types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport type { ServiceRegistry } from \"../registry/ServiceRegistry\";\r\nimport { ok, err } from \"@/utils/result\";\r\n\r\n/**\r\n * Validates service registrations and dependencies.\r\n * \r\n * Responsibilities:\r\n * - Check that all dependencies are registered\r\n * - Detect circular dependencies using DFS\r\n * - Validate alias targets exist\r\n * \r\n * Design:\r\n * - Stateless: can be shared between parent and child containers\r\n * - Returns aggregated errors for comprehensive feedback\r\n * - Can be extended later with granular validator components\r\n * - Performance optimization: Caches validated sub-graphs for large dependency trees\r\n */\r\nexport class ContainerValidator {\r\n  // Performance optimization: Cache for validated sub-graphs\r\n  // Prevents redundant DFS traversals in large dependency trees (>500 services)\r\n  private validatedSubgraphs = new Set<InjectionToken<ServiceType>>();\r\n  /**\r\n   * Validates all registrations in the registry.\r\n   * \r\n   * Performs three checks:\r\n   * 1. All dependencies are registered\r\n   * 2. All alias targets exist\r\n   * 3. No circular dependencies\r\n   * \r\n   * @param registry - The service registry to validate\r\n   * @returns Result with void on success, or array of errors\r\n   */\r\n  validate(registry: ServiceRegistry): Result<void, ContainerError[]> {\r\n    // Clear cache for fresh validation\r\n    this.validatedSubgraphs = new Set<InjectionToken<ServiceType>>();\r\n    \r\n    const errors: ContainerError[] = [\r\n      ...this.validateDependencies(registry),\r\n      ...this.validateAliasTargets(registry),\r\n      ...this.detectCircularDependencies(registry),\r\n    ];\r\n\r\n    return errors.length > 0 ? err(errors) : ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Checks that all declared dependencies are registered.\r\n   * \r\n   * @param registry - The service registry to check\r\n   * @returns Array of errors for missing dependencies\r\n   */\r\n  private validateDependencies(registry: ServiceRegistry): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n    const registrations = registry.getAllRegistrations();\r\n\r\n    for (const [token, registration] of registrations.entries()) {\r\n      for (const dep of registration.dependencies) {\r\n        if (!registry.has(dep)) {\r\n          errors.push({\r\n            code: \"TokenNotRegistered\",\r\n            message: `${String(token)} depends on ${String(dep)} which is not registered`,\r\n            tokenDescription: String(dep),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Checks that all alias targets are registered.\r\n   * \r\n   * @param registry - The service registry to check\r\n   * @returns Array of errors for missing alias targets\r\n   */\r\n  private validateAliasTargets(registry: ServiceRegistry): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n    const registrations = registry.getAllRegistrations();\r\n\r\n    for (const [token, registration] of registrations.entries()) {\r\n      if (registration.providerType === \"alias\" && registration.aliasTarget) {\r\n        if (!registry.has(registration.aliasTarget)) {\r\n          errors.push({\r\n            code: \"AliasTargetNotFound\",\r\n            message: `Alias ${String(token)} points to ${String(registration.aliasTarget)} which is not registered`,\r\n            tokenDescription: String(registration.aliasTarget),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Detects circular dependencies using depth-first search.\r\n   * \r\n   * @param registry - The service registry to check\r\n   * @returns Array of errors for detected cycles\r\n   */\r\n  private detectCircularDependencies(registry: ServiceRegistry): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n    const visited = new Set<InjectionToken<ServiceType>>();\r\n    const registrations = registry.getAllRegistrations();\r\n\r\n    for (const token of registrations.keys()) {\r\n      const visiting = new Set<InjectionToken<ServiceType>>();\r\n      const path: InjectionToken<ServiceType>[] = [];\r\n\r\n      const error = this.checkCycleForToken(registry, token, visiting, visited, path);\r\n      if (error) {\r\n        errors.push(error);\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Recursively checks for cycles starting from a specific token.\r\n   * \r\n   * Uses DFS with visiting/visited sets to detect back edges (cycles).\r\n   * Performance optimization: Uses Set cache to skip already-validated sub-graphs.\r\n   * \r\n   * @param registry - The service registry\r\n   * @param token - Current token being checked\r\n   * @param visiting - Set of tokens in current DFS path\r\n   * @param visited - Set of tokens already fully processed\r\n   * @param path - Current path for error reporting\r\n   * @returns ContainerError if cycle detected, null otherwise\r\n   */\r\n  private checkCycleForToken(\r\n    registry: ServiceRegistry,\r\n    token: InjectionToken<ServiceType>,\r\n    visiting: Set<InjectionToken<ServiceType>>,\r\n    visited: Set<InjectionToken<ServiceType>>,\r\n    path: InjectionToken<ServiceType>[]\r\n  ): ContainerError | null {\r\n    // Cycle detected: token is already in current path\r\n    if (visiting.has(token)) {\r\n      const cyclePath = [...path, token].map(String).join(\" → \");\r\n      return {\r\n        code: \"CircularDependency\",\r\n        message: `Circular dependency: ${cyclePath}`,\r\n        tokenDescription: String(token),\r\n      };\r\n    }\r\n\r\n    // Performance optimization: Skip already validated sub-graphs\r\n    if (this.validatedSubgraphs.has(token)) {\r\n      return null;\r\n    }\r\n\r\n    // Already fully processed this token in current validation run\r\n    if (visited.has(token)) {\r\n      return null;\r\n    }\r\n\r\n    // Mark as visiting and add to path\r\n    visiting.add(token);\r\n    path.push(token);\r\n\r\n    // Check all dependencies\r\n    const registration = registry.getRegistration(token);\r\n    if (registration) {\r\n      for (const dep of registration.dependencies) {\r\n        const error = this.checkCycleForToken(registry, dep, visiting, visited, path);\r\n        if (error) return error;\r\n      }\r\n    }\r\n\r\n    // Done visiting this token - mark as validated\r\n    visiting.delete(token);\r\n    path.pop();\r\n    visited.add(token);\r\n    this.validatedSubgraphs.add(token); // Cache for performance\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n","import type { InjectionToken } from \"../types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\n\r\n/**\r\n * Cache for service instances (Singleton and Scoped lifecycles).\r\n * \r\n * Responsibilities:\r\n * - Store and retrieve service instances by token\r\n * - Provide access to all instances for disposal\r\n * - Simple get/set/has/clear operations\r\n * \r\n * Note: This class does NOT handle disposal logic - that's ScopeManager's responsibility.\r\n */\r\nexport class InstanceCache {\r\n  private instances = new Map<InjectionToken<ServiceType>, ServiceType>();\r\n\r\n  /**\r\n   * Retrieves a cached service instance.\r\n   * \r\n   * @template TServiceType - The type of service to retrieve\r\n   * @param token - The injection token identifying the service\r\n   * @returns The cached instance or undefined if not found\r\n   */\r\n  get<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): TServiceType | undefined {\r\n    return this.instances.get(token) as TServiceType | undefined;\r\n  }\r\n\r\n  /**\r\n   * Stores a service instance in the cache.\r\n   * \r\n   * @template TServiceType - The type of service to store\r\n   * @param token - The injection token identifying the service\r\n   * @param instance - The service instance to cache\r\n   */\r\n  set<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    instance: TServiceType\r\n  ): void {\r\n    this.instances.set(token, instance);\r\n  }\r\n\r\n  /**\r\n   * Checks if a service instance is cached.\r\n   * \r\n   * @template TServiceType - The type of service to check\r\n   * @param token - The injection token identifying the service\r\n   * @returns True if the instance is cached, false otherwise\r\n   */\r\n  has<TServiceType extends ServiceType>(token: InjectionToken<TServiceType>): boolean {\r\n    return this.instances.has(token);\r\n  }\r\n\r\n  /**\r\n   * Clears all cached instances.\r\n   * Note: Does not dispose instances - call getAllInstances() first if disposal is needed.\r\n   */\r\n  clear(): void {\r\n    this.instances.clear();\r\n  }\r\n\r\n  /**\r\n   * Returns all cached instances for disposal purposes.\r\n   * Used by ScopeManager to dispose Disposable services.\r\n   * \r\n   * @returns A map of all cached instances\r\n   */\r\n  getAllInstances(): Map<InjectionToken<ServiceType>, ServiceType> {\r\n    return new Map(this.instances);\r\n  }\r\n}\r\n\r\n","/**\r\n * Dedicated error classes for DI container operations.\r\n * These errors provide precise failure categorization and preserve cause chains.\r\n */\r\n\r\n/**\r\n * Thrown when a circular dependency is detected during service resolution.\r\n */\r\nexport class CircularDependencyError extends Error {\r\n  public readonly errorCause?: unknown;\r\n\r\n  constructor(\r\n    message: string,\r\n    public readonly token: symbol,\r\n    cause?: unknown\r\n  ) {\r\n    super(message);\r\n    this.name = \"CircularDependencyError\";\r\n    this.errorCause = cause;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a scoped service is resolved from a root container (requires child scope).\r\n */\r\nexport class ScopeRequiredError extends Error {\r\n  public readonly errorCause?: unknown;\r\n\r\n  constructor(\r\n    message: string,\r\n    public readonly token: symbol,\r\n    cause?: unknown\r\n  ) {\r\n    super(message);\r\n    this.name = \"ScopeRequiredError\";\r\n    this.errorCause = cause;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when an invalid or unsupported service lifecycle is encountered.\r\n */\r\nexport class InvalidLifecycleError extends Error {\r\n  public readonly errorCause?: unknown;\r\n\r\n  constructor(\r\n    message: string,\r\n    public readonly lifecycle: unknown,\r\n    cause?: unknown\r\n  ) {\r\n    super(message);\r\n    this.name = \"InvalidLifecycleError\";\r\n    this.errorCause = cause;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a factory function fails during service instantiation.\r\n */\r\nexport class FactoryFailedError extends Error {\r\n  public readonly errorCause?: unknown;\r\n\r\n  constructor(\r\n    message: string,\r\n    public readonly token: symbol,\r\n    cause?: unknown\r\n  ) {\r\n    super(message);\r\n    this.name = \"FactoryFailedError\";\r\n    this.errorCause = cause;\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { InjectionToken } from \"../types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport type { ContainerError } from \"../interfaces/containererror\";\r\nimport type { ServiceRegistry } from \"../registry/ServiceRegistry\";\r\nimport type { ServiceRegistration } from \"../types/serviceregistration\";\r\nimport { InstanceCache } from \"../cache/InstanceCache\";\r\nimport { ServiceLifecycle } from \"../types/servicelifecycle\";\r\nimport {\r\n  CircularDependencyError,\r\n  ScopeRequiredError,\r\n  InvalidLifecycleError,\r\n  FactoryFailedError,\r\n} from \"../errors/ContainerErrors\";\r\nimport { ok, err, tryCatch, isErr } from \"@/utils/result\";\r\n\r\n/**\r\n * Resolves service instances based on lifecycle and registration.\r\n * \r\n * Responsibilities:\r\n * - Resolve services by token\r\n * - Handle lifecycle strategies (Singleton, Transient, Scoped)\r\n * - Handle alias resolution\r\n * - Delegate to parent resolver for Singletons\r\n * \r\n * Design:\r\n * - Works with Result pattern (no throws)\r\n * - Wraps factory errors in FactoryFailedError\r\n * - Parent resolver for Singleton sharing across scopes\r\n */\r\nexport class ServiceResolver {\r\n  constructor(\r\n    private readonly registry: ServiceRegistry,\r\n    private readonly cache: InstanceCache,\r\n    private readonly parentResolver: ServiceResolver | null,\r\n    private readonly scopeName: string\r\n  ) {}\r\n\r\n  /**\r\n   * Resolves a service by token.\r\n   * \r\n   * Handles:\r\n   * - Alias resolution (recursive)\r\n   * - Lifecycle-specific resolution (Singleton/Transient/Scoped)\r\n   * - Parent delegation for Singletons\r\n   * - Factory error wrapping\r\n   * \r\n   * @template TServiceType - The type of service to resolve\r\n   * @param token - The injection token identifying the service\r\n   * @returns Result with service instance or error\r\n   */\r\n  resolve<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<TServiceType, ContainerError> {\r\n    // Check if service is registered\r\n    const registration = this.registry.getRegistration(token);\r\n    if (!registration) {\r\n      return err({\r\n        code: \"TokenNotRegistered\",\r\n        message: `Service ${String(token)} not registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Handle alias resolution\r\n    if (registration.providerType === \"alias\" && registration.aliasTarget) {\r\n      return this.resolve(registration.aliasTarget as InjectionToken<TServiceType>);\r\n    }\r\n\r\n    // Resolve based on lifecycle (all methods already return Result)\r\n    switch (registration.lifecycle) {\r\n      case ServiceLifecycle.SINGLETON:\r\n        return this.resolveSingleton(token, registration);\r\n\r\n      case ServiceLifecycle.TRANSIENT:\r\n        return this.resolveTransient(token, registration);\r\n\r\n      case ServiceLifecycle.SCOPED:\r\n        return this.resolveScoped(token, registration);\r\n\r\n      default:\r\n        return err({\r\n          code: \"InvalidLifecycle\",\r\n          message: `Invalid service lifecycle: ${String(registration.lifecycle)}`,\r\n          tokenDescription: String(token),\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Instantiates a service based on registration type.\r\n   * \r\n   * CRITICAL: Returns Result to preserve error context and avoid breaking Result-Contract.\r\n   * Handles dependency resolution for classes, direct factory calls, and value returns.\r\n   * \r\n   * @template TServiceType - The type of service to instantiate\r\n   * @param token - The injection token (used for error messages)\r\n   * @param registration - The service registration metadata\r\n   * @returns Result with instance or detailed error (DependencyResolveFailed, FactoryFailed, etc.)\r\n   */\r\n  private instantiateService<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    registration: ServiceRegistration\r\n  ): Result<TServiceType, ContainerError> {\r\n    \r\n    if (registration.serviceClass) {\r\n      // Class: Resolve all dependencies first\r\n      const resolvedDeps: ServiceType[] = [];\r\n      \r\n      for (const dep of registration.dependencies) {\r\n        const depResult = this.resolve(dep);\r\n        if (!depResult.ok) {\r\n          // Return structured error with cause chain\r\n          return err({\r\n            code: \"DependencyResolveFailed\",\r\n            message: `Cannot resolve dependency ${String(dep)} for ${String(token)}`,\r\n            tokenDescription: String(dep),\r\n            cause: depResult.error,\r\n          });\r\n        }\r\n        resolvedDeps.push(depResult.value);\r\n      }\r\n      \r\n      // Instantiate class with resolved dependencies\r\n      try {\r\n        return ok(new registration.serviceClass(...resolvedDeps) as TServiceType);\r\n      } catch (constructorError) {\r\n        return err({\r\n          code: \"FactoryFailed\",\r\n          message: `Constructor failed for ${String(token)}: ${String(constructorError)}`,\r\n          tokenDescription: String(token),\r\n          cause: constructorError,\r\n        });\r\n      }\r\n      \r\n    } else if (registration.factory) {\r\n      // Factory: Call directly\r\n      try {\r\n        return ok(registration.factory() as TServiceType);\r\n      } catch (factoryError) {\r\n        return err({\r\n          code: \"FactoryFailed\",\r\n          message: `Factory failed for ${String(token)}: ${String(factoryError)}`,\r\n          tokenDescription: String(token),\r\n          cause: factoryError,\r\n        });\r\n      }\r\n      \r\n    } else if (registration.value !== undefined) {\r\n      // Value: Return as-is\r\n      return ok(registration.value as TServiceType);\r\n      \r\n    } else {\r\n      // Invalid registration\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: `Invalid registration for ${String(token)} - no class, factory, or value`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resolves a Singleton service.\r\n   * \r\n   * Strategy:\r\n   * 1. Try parent resolver first (for shared parent singletons)\r\n   * 2. If parent returns error:\r\n   *    - CircularDependency → propagate error\r\n   *    - TokenNotRegistered → fallback to own cache (child-specific singleton)\r\n   * 3. Use own cache for root container or child-specific singletons\r\n   * \r\n   * @template TServiceType - The type of service\r\n   * @param token - The injection token\r\n   * @param registration - The service registration\r\n   * @returns Result with instance or error\r\n   */\r\n  private resolveSingleton<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    registration: ServiceRegistration\r\n  ): Result<TServiceType, ContainerError> {\r\n    // Try parent resolver first for shared singletons\r\n    if (this.parentResolver !== null) {\r\n      const parentResult = this.parentResolver.resolve(token);\r\n      \r\n      if (parentResult.ok) {\r\n        // Parent has it - use parent's singleton instance (shared)\r\n        return parentResult;\r\n      }\r\n      \r\n      // Check error code to determine action\r\n      if (parentResult.error.code === \"CircularDependency\") {\r\n        // Real circular dependency - propagate as-is\r\n        return parentResult;\r\n      }\r\n      \r\n      // TokenNotRegistered or other error -> fallback to own cache\r\n      // This allows child-specific singleton registrations\r\n    }\r\n\r\n    // Root container OR parent doesn't have it: use own cache\r\n    if (!this.cache.has(token)) {\r\n      const instanceResult = this.instantiateService(token, registration);\r\n      if (!instanceResult.ok) {\r\n        return instanceResult; // Propagate error without wrapping\r\n      }\r\n      this.cache.set(token, instanceResult.value);\r\n    }\r\n\r\n    return ok(this.cache.get(token) as TServiceType);\r\n  }\r\n\r\n  /**\r\n   * Resolves a Transient service.\r\n   * \r\n   * Strategy:\r\n   * - Always create new instance (no caching)\r\n   * \r\n   * @template TServiceType - The type of service\r\n   * @param token - The injection token\r\n   * @param registration - The service registration\r\n   * @returns Result with new instance\r\n   */\r\n  private resolveTransient<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    registration: ServiceRegistration\r\n  ): Result<TServiceType, ContainerError> {\r\n    return this.instantiateService(token, registration);\r\n  }\r\n\r\n  /**\r\n   * Resolves a Scoped service.\r\n   * \r\n   * Strategy:\r\n   * - Must be in child scope (not root)\r\n   * - One instance per scope (cached)\r\n   * \r\n   * @template TServiceType - The type of service\r\n   * @param token - The injection token\r\n   * @param registration - The service registration\r\n   * @returns Result with scoped instance\r\n   */\r\n  private resolveScoped<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    registration: ServiceRegistration\r\n  ): Result<TServiceType, ContainerError> {\r\n    // Scoped services require a child scope\r\n    if (this.parentResolver === null) {\r\n      return err({\r\n        code: \"ScopeRequired\",\r\n        message: `Scoped service ${String(token)} requires a scope container`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Check cache (one instance per scope)\r\n    if (!this.cache.has(token)) {\r\n      const instanceResult = this.instantiateService(token, registration);\r\n      if (!instanceResult.ok) {\r\n        return instanceResult; // Propagate error\r\n      }\r\n      this.cache.set(token, instanceResult.value);\r\n    }\r\n\r\n    return ok(this.cache.get(token) as TServiceType);\r\n  }\r\n}\r\n\r\n","import type { Result } from \"@/types/result\";\r\nimport type { ContainerError } from \"../interfaces/containererror\";\r\nimport type { InjectionToken } from \"../types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport { InstanceCache } from \"../cache/InstanceCache\";\r\nimport { ok, err, tryCatch, isErr } from \"@/utils/result\";\r\n\r\n/**\r\n * Helper function to generate unique scope names.\r\n * Tries crypto.randomUUID(), falls back to timestamp + random.\r\n */\r\nfunction generateScopeId(): string {\r\n  try {\r\n    return crypto.randomUUID();\r\n  } catch {\r\n    return Date.now() + \"-\" + Math.random();\r\n  }\r\n}\r\n\r\n/**\r\n * Manages scope hierarchy and disposal lifecycle.\r\n * \r\n * Responsibilities:\r\n * - Track child scopes in hierarchy\r\n * - Generate scope names\r\n * - Dispose instances (including Disposable pattern support)\r\n * - Cascade disposal to children\r\n * \r\n * Design:\r\n * - NO dependency on ServiceResolver (avoids circular dependency)\r\n * - createChild() returns data for facade to build new container\r\n * - Disposal order: children first, then instances (critical!)\r\n */\r\nexport class ScopeManager {\r\n  private children = new Set<ScopeManager>();\r\n  private disposed = false;\r\n\r\n  constructor(\r\n    private readonly scopeName: string,\r\n    private readonly parent: ScopeManager | null,\r\n    private readonly cache: InstanceCache\r\n  ) {}\r\n\r\n  /**\r\n   * Creates a child scope manager.\r\n   * \r\n   * Note: Returns data (scopeName, cache, childManager) instead of full container\r\n   * to avoid circular dependency with ServiceResolver.\r\n   * \r\n   * @param name - Optional custom name for the scope\r\n   * @returns Result with child scope data or error if disposed\r\n   */\r\n  createChild(\r\n    name?: string\r\n  ): Result<{ scopeName: string; cache: InstanceCache; manager: ScopeManager }, ContainerError> {\r\n    if (this.disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot create child scope from disposed scope: ${this.scopeName}`,\r\n      });\r\n    }\r\n\r\n    // Build hierarchical scope name\r\n    const uniqueId = name ?? `scope-${generateScopeId()}`;\r\n    const childScopeName = `${this.scopeName}.${uniqueId}`;\r\n\r\n    // Create new cache for child\r\n    const childCache = new InstanceCache();\r\n\r\n    // Create child manager\r\n    const childManager = new ScopeManager(childScopeName, this, childCache);\r\n\r\n    // Only add to children set AFTER successful creation\r\n    this.children.add(childManager);\r\n\r\n    return ok({\r\n      scopeName: childScopeName,\r\n      cache: childCache,\r\n      manager: childManager,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Disposes this scope and all child scopes.\r\n   * \r\n   * Disposal order (critical):\r\n   * 1. Recursively dispose all children\r\n   * 2. Dispose instances in this scope (if Disposable)\r\n   * 3. Clear instance cache\r\n   * 4. Remove from parent's children set\r\n   * \r\n   * @returns Result indicating success or disposal error\r\n   */\r\n  dispose(): Result<void, ContainerError> {\r\n    if (this.disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Scope already disposed: ${this.scopeName}`,\r\n      });\r\n    }\r\n\r\n    // Mark as disposed BEFORE disposing children to prevent concurrent operations\r\n    this.disposed = true;\r\n\r\n    // Step 1: Recursively dispose all child scopes (children first!)\r\n    for (const child of this.children) {\r\n      const childResult = child.dispose();\r\n\r\n      if (isErr(childResult)) {\r\n        // Log warning but continue disposal\r\n        console.warn(`Failed to dispose child scope ${child.scopeName}:`, childResult.error);\r\n      }\r\n    }\r\n\r\n    // Step 2: Dispose instances in this scope\r\n    const disposeResult = this.disposeInstances();\r\n    if (!disposeResult.ok) {\r\n      return disposeResult;\r\n    }\r\n\r\n    // Step 3: Clear cache\r\n    this.cache.clear();\r\n\r\n    // Step 4: Remove from parent's children set\r\n    if (this.parent !== null) {\r\n      this.parent.children.delete(this);\r\n    }\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Disposes all instances in the cache that implement Disposable.\r\n   * \r\n   * @returns Result indicating success or disposal error\r\n   */\r\n  private disposeInstances(): Result<void, ContainerError> {\r\n    const instances = this.cache.getAllInstances();\r\n\r\n    for (const [token, instance] of instances.entries()) {\r\n      if (this.isDisposable(instance)) {\r\n        const result = tryCatch(\r\n          () => instance.dispose(),\r\n          (error): ContainerError => ({\r\n            code: \"DisposalFailed\",\r\n            message: `Error disposing service ${String(token)}: ${String(error)}`,\r\n            tokenDescription: String(token),\r\n            cause: error,\r\n          })\r\n        );\r\n\r\n        if (isErr(result)) {\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Type guard to check if an instance implements the Disposable pattern.\r\n   * \r\n   * Checks for:\r\n   * - dispose() method (function)\r\n   * - Future: Symbol.dispose support\r\n   * \r\n   * @param instance - The service instance to check\r\n   * @returns True if instance has dispose() method\r\n   */\r\n  private isDisposable(instance: ServiceType): instance is ServiceType & { dispose: () => void } {\r\n    return (\r\n      \"dispose\" in instance &&\r\n      typeof (instance as ServiceType & { dispose: unknown }).dispose === \"function\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Checks if this scope is disposed.\r\n   * \r\n   * @returns True if disposed, false otherwise\r\n   */\r\n  isDisposed(): boolean {\r\n    return this.disposed;\r\n  }\r\n\r\n  /**\r\n   * Gets the hierarchical scope name.\r\n   * \r\n   * @returns The scope name (e.g., \"root.child1.grandchild\")\r\n   */\r\n  getScopeName(): string {\r\n    return this.scopeName;\r\n  }\r\n}\r\n\r\n","import type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { FactoryFunction } from \"./types/servicefactory\";\r\nimport type { ServiceClass } from \"./types/serviceclass\";\r\nimport type { ServiceDependencies } from \"./types/servicedependencies\";\r\nimport type { ContainerValidationState } from \"./types/containervalidationstate\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport { ok, err, isErr, isOk } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Container } from \"@/di_infrastructure/interfaces/container\";\r\nimport type { ContainerError } from \"@/di_infrastructure/interfaces/containererror\";\r\nimport { ServiceRegistry } from \"./registry/ServiceRegistry\";\r\nimport { ContainerValidator } from \"./validation/ContainerValidator\";\r\nimport { InstanceCache } from \"./cache/InstanceCache\";\r\nimport { ServiceResolver } from \"./resolution/ServiceResolver\";\r\nimport { ScopeManager } from \"./scope/ScopeManager\";\r\n\r\n/**\r\n * Fallback factory function type for creating service instances when container resolution fails.\r\n */\r\ntype FallbackFactory<T extends ServiceType> = () => T;\r\n\r\n/**\r\n * Global registry of fallback factories for known tokens.\r\n * Used when container resolution fails and a fallback is available.\r\n */\r\nconst fallbackFactories = new Map<symbol, FallbackFactory<ServiceType>>();\r\n\r\n/**\r\n * Register a fallback factory for a specific token.\r\n * This will be used when container.resolve() fails for that token.\r\n *\r\n * @param token - The injection token\r\n * @param factory - Factory function that creates a fallback instance\r\n *\r\n * @example\r\n * ```typescript\r\n * registerFallback(UserServiceToken, () => new DefaultUserService());\r\n * ```\r\n */\r\nexport function registerFallback<T extends ServiceType>(\r\n  token: InjectionToken<T>,\r\n  factory: FallbackFactory<T>\r\n): void {\r\n  fallbackFactories.set(token, factory as FallbackFactory<ServiceType>);\r\n}\r\n\r\n/**\r\n * Dependency injection container (Facade pattern).\r\n * \r\n * Delegates to specialized components:\r\n * - ServiceRegistry: manages registrations\r\n * - ContainerValidator: validates dependencies\r\n * - InstanceCache: caches instances\r\n * - ServiceResolver: resolves services\r\n * - ScopeManager: manages lifecycle and disposal\r\n *\r\n * **Scope Chain Behavior:**\r\n * When a parent container is disposed, all child containers are automatically disposed.\r\n * This ensures proper cleanup of resources across the container hierarchy.\r\n *\r\n * **Architecture:**\r\n * This is a Facade that coordinates specialized components, adhering to Single Responsibility Principle.\r\n * Each component has a focused responsibility, making the system testable and maintainable.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const container = ServiceContainer.createRoot();\r\n * container.registerClass(LoggerToken, Logger, ServiceLifecycle.SINGLETON);\r\n * container.validate();\r\n * const logger = container.resolve(LoggerToken);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Scope chain with cascading disposal\r\n * const root = ServiceContainer.createRoot();\r\n * root.validate();\r\n * const child1 = root.createScope(\"child1\").value!;\r\n * const child2 = root.createScope(\"child2\").value!;\r\n *\r\n * // Disposing root automatically disposes all children\r\n * root.dispose();\r\n * ```\r\n */\r\nexport class ServiceContainer implements Container {\r\n  private registry: ServiceRegistry;\r\n  private validator: ContainerValidator;\r\n  private cache: InstanceCache;\r\n  private resolver: ServiceResolver;\r\n  private scopeManager: ScopeManager;\r\n  private validationState: ContainerValidationState;\r\n\r\n  /**\r\n   * Private constructor - use ServiceContainer.createRoot() instead.\r\n   * \r\n   * This constructor is private to:\r\n   * - Enforce factory pattern usage\r\n   * - Prevent constructor throws (Result-Contract-breaking)\r\n   * - Make child creation explicit through createScope()\r\n   *\r\n   * @param registry - Service registry\r\n   * @param validator - Container validator (shared for parent/child)\r\n   * @param cache - Instance cache\r\n   * @param resolver - Service resolver\r\n   * @param scopeManager - Scope manager\r\n   * @param validationState - Initial validation state\r\n   */\r\n  private constructor(\r\n    registry: ServiceRegistry,\r\n    validator: ContainerValidator,\r\n    cache: InstanceCache,\r\n    resolver: ServiceResolver,\r\n    scopeManager: ScopeManager,\r\n    validationState: ContainerValidationState\r\n  ) {\r\n    this.registry = registry;\r\n    this.validator = validator;\r\n    this.cache = cache;\r\n    this.resolver = resolver;\r\n    this.scopeManager = scopeManager;\r\n    this.validationState = validationState;\r\n  }\r\n\r\n  /**\r\n   * Creates a new root container.\r\n   * \r\n   * This is the preferred way to create containers.\r\n   * All components are created fresh for the root container.\r\n   * \r\n   * @returns A new root ServiceContainer\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const container = ServiceContainer.createRoot();\r\n   * container.registerClass(LoggerToken, Logger, SINGLETON);\r\n   * container.validate();\r\n   * ```\r\n   */\r\n  static createRoot(): ServiceContainer {\r\n    const registry = new ServiceRegistry();\r\n    const validator = new ContainerValidator();\r\n    const cache = new InstanceCache();\r\n    const scopeManager = new ScopeManager(\"root\", null, cache);\r\n    const resolver = new ServiceResolver(registry, cache, null, \"root\");\r\n    \r\n    return new ServiceContainer(\r\n      registry,\r\n      validator,\r\n      cache,\r\n      resolver,\r\n      scopeManager,\r\n      \"registering\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Register a service class with automatic dependency injection.\r\n   */\r\n  registerClass<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    serviceClass: ServiceClass<TServiceType>,\r\n    lifecycle: ServiceLifecycle\r\n  ): Result<void, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    return this.registry.registerClass(token, serviceClass, lifecycle);\r\n  }\r\n\r\n  /**\r\n   * Register a factory function.\r\n   */\r\n  registerFactory<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    factory: FactoryFunction<TServiceType>,\r\n    lifecycle: ServiceLifecycle,\r\n    dependencies: ServiceDependencies\r\n  ): Result<void, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    return this.registry.registerFactory(token, factory, lifecycle, dependencies);\r\n  }\r\n\r\n  /**\r\n   * Register a constant value.\r\n   */\r\n  registerValue<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    value: TServiceType\r\n  ): Result<void, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    return this.registry.registerValue(token, value);\r\n  }\r\n\r\n  /**\r\n   * Register an alias.\r\n   */\r\n  registerAlias<TServiceType extends ServiceType>(\r\n    aliasToken: InjectionToken<TServiceType>,\r\n    targetToken: InjectionToken<TServiceType>\r\n  ): Result<void, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container`,\r\n        tokenDescription: String(aliasToken),\r\n      });\r\n    }\r\n\r\n    if (this.validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    return this.registry.registerAlias(aliasToken, targetToken);\r\n  }\r\n\r\n  /**\r\n   * Validate all registrations.\r\n   */\r\n  validate(): Result<void, ContainerError[]> {\r\n    if (this.validationState === \"validated\") {\r\n      return ok(undefined);\r\n    }\r\n\r\n    if (this.validationState === \"validating\") {\r\n      return err([\r\n        {\r\n          code: \"InvalidOperation\",\r\n          message: \"Validation already in progress\",\r\n        },\r\n      ]);\r\n    }\r\n\r\n    this.validationState = \"validating\";\r\n\r\n    const result = this.validator.validate(this.registry);\r\n\r\n    if (result.ok) {\r\n      this.validationState = \"validated\";\r\n    } else {\r\n      this.validationState = \"registering\";\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get validation state.\r\n   */\r\n  getValidationState(): ContainerValidationState {\r\n    return this.validationState;\r\n  }\r\n\r\n  /**\r\n   * Creates a child scope container.\r\n   * \r\n   * Child containers:\r\n   * - Inherit parent registrations (cloned)\r\n   * - Can add their own registrations\r\n   * - Must call validate() before resolving\r\n   * - Share parent's singleton instances\r\n   * - Have isolated scoped instances\r\n   * \r\n   * @param name - Optional custom name for the scope\r\n   * @returns Result with child container or error\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const parent = ServiceContainer.createRoot();\r\n   * parent.registerClass(LoggerToken, Logger, SINGLETON);\r\n   * parent.validate();\r\n   * \r\n   * const child = parent.createScope(\"request\").value!;\r\n   * child.registerClass(RequestToken, RequestContext, SCOPED);\r\n   * child.validate();\r\n   * \r\n   * const logger = child.resolve(LoggerToken);   // From parent (shared)\r\n   * const ctx = child.resolve(RequestToken);      // From child (isolated)\r\n   * ```\r\n   */\r\n  createScope(name?: string): Result<ServiceContainer, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot create scope from disposed container`,\r\n      });\r\n    }\r\n\r\n    if (this.validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Parent must be validated before creating scopes. Call validate() first.\",\r\n      });\r\n    }\r\n\r\n    // Create child scope (pure Result, no throws)\r\n    const scopeResult = this.scopeManager.createChild(name);\r\n    if (!scopeResult.ok) {\r\n      return err(scopeResult.error); // Structured error, not exception\r\n    }\r\n\r\n    // Build child container components\r\n    const childRegistry = this.registry.clone();\r\n    const childCache = scopeResult.value.cache;\r\n    const childManager = scopeResult.value.manager;\r\n    const childResolver = new ServiceResolver(\r\n      childRegistry,\r\n      childCache,\r\n      this.resolver, // Parent resolver for singleton delegation\r\n      scopeResult.value.scopeName\r\n    );\r\n\r\n    // Create child using private constructor\r\n    const child = new ServiceContainer(\r\n      childRegistry,\r\n      this.validator, // Shared (stateless)\r\n      childCache,\r\n      childResolver,\r\n      childManager,\r\n      \"registering\" // FIX: Child starts in registering state, not validated!\r\n    );\r\n\r\n    return ok(child);\r\n  }\r\n\r\n  /**\r\n   * Resolve service with Result return.\r\n   */\r\n  resolveWithError<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<TServiceType, ContainerError> {\r\n    if (this.scopeManager.isDisposed()) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot resolve from disposed container`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Container must be validated before resolving. Call validate() first.\",\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    return this.resolver.resolve(token);\r\n  }\r\n\r\n  /**\r\n   * Resolve service (throwing version with fallback support).\r\n   */\r\n  resolve<TServiceType extends ServiceType>(token: InjectionToken<TServiceType>): TServiceType {\r\n    const result = this.resolveWithError(token);\r\n\r\n    if (isOk(result)) {\r\n      return result.value;\r\n    }\r\n\r\n    // Try fallback factory\r\n    const fallback = fallbackFactories.get(token);\r\n    if (fallback) {\r\n      return fallback() as TServiceType;\r\n    }\r\n\r\n    // No fallback - throw\r\n    throw new Error(\r\n      `Cannot resolve ${String(token)}: ${result.error.message}. ` +\r\n        `No fallback factory registered for this token.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if service is registered.\r\n   */\r\n  isRegistered<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<boolean, never> {\r\n    return ok(this.registry.has(token));\r\n  }\r\n\r\n  /**\r\n   * Dispose container and all children.\r\n   */\r\n  dispose(): Result<void, ContainerError> {\r\n    const result = this.scopeManager.dispose();\r\n    \r\n    // Reset validation state after disposal (per review feedback)\r\n    if (result.ok) {\r\n      this.validationState = \"registering\";\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Clear all registrations and instances.\r\n   * \r\n   * IMPORTANT: Resets validation state (per review feedback).\r\n   */\r\n  clear(): Result<void, never> {\r\n    this.registry.clear();\r\n    this.cache.clear();\r\n    this.validationState = \"registering\"; // Critical: reset validation state\r\n    return ok(undefined);\r\n  }\r\n}\r\n","import type { Logger } from \"@/interfaces/logger\";\r\nimport { MODULE_CONSTANTS } from \"../constants\";\r\n\r\n/**\r\n * Console-based implementation of the Logger interface.\r\n * Writes log messages to the browser console with support for interactive object inspection.\r\n *\r\n * @implements {Logger}\r\n */\r\nexport class ConsoleLoggerService implements Logger {\r\n  static dependencies = [] as const;\r\n\r\n  /**\r\n   * Log a message to console\r\n   * @param message - Message to log\r\n   * @param optionalParams - Additional data to log (objects will be interactive in browser console)\r\n   */\r\n  log(message: string, ...optionalParams: any[]): void {\r\n    console.log(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`, ...optionalParams);\r\n  }\r\n\r\n  /**\r\n   * Log an error message\r\n   * @param message - Error message to log\r\n   * @param optionalParams - Additional data to log (e.g., error objects, stack traces)\r\n   */\r\n  error(message: string, ...optionalParams: any[]): void {\r\n    console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`, ...optionalParams);\r\n  }\r\n\r\n  /**\r\n   * Log a warning message\r\n   * @param message - Warning message to log\r\n   * @param optionalParams - Additional data to log\r\n   */\r\n  warn(message: string, ...optionalParams: any[]): void {\r\n    console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`, ...optionalParams);\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   * @param message - Info message to log\r\n   * @param optionalParams - Additional data to log\r\n   */\r\n  info(message: string, ...optionalParams: any[]): void {\r\n    console.info(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`, ...optionalParams);\r\n  }\r\n\r\n  /**\r\n   * Log a debug message\r\n   * @param message - Debug message to log\r\n   * @param optionalParams - Additional data to log (useful for inspecting complex objects)\r\n   */\r\n  debug(message: string, ...optionalParams: any[]): void {\r\n    console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`, ...optionalParams);\r\n  }\r\n}\r\n","/**\r\n * Injection tokens for the Foundry abstraction layer and its versioned ports.\r\n * These tokens allow services to be resolved via the DI container without\r\n * directly depending on concrete implementations.\r\n */\r\nimport type { InjectionToken } from \"@/di_infrastructure/types/injectiontoken\";\r\nimport { createInjectionToken } from \"@/di_infrastructure/tokenutilities\";\r\nimport type { FoundryGame } from \"./interfaces/FoundryGame\";\r\nimport type { FoundryHooks } from \"./interfaces/FoundryHooks\";\r\nimport type { FoundryDocument } from \"./interfaces/FoundryDocument\";\r\nimport type { FoundryUI } from \"./interfaces/FoundryUI\";\r\nimport type { PortSelector } from \"./versioning/portselector\";\r\nimport type { PortRegistry } from \"./versioning/portregistry\";\r\n\r\n/**\r\n * Injection token for FoundryGame service.\r\n */\r\nexport const foundryGameToken: InjectionToken<FoundryGame> =\r\n  createInjectionToken<FoundryGame>(\"FoundryGame\");\r\n\r\n/**\r\n * Injection token for FoundryHooks service.\r\n */\r\nexport const foundryHooksToken: InjectionToken<FoundryHooks> =\r\n  createInjectionToken<FoundryHooks>(\"FoundryHooks\");\r\n\r\n/**\r\n * Injection token for FoundryDocument service.\r\n */\r\nexport const foundryDocumentToken: InjectionToken<FoundryDocument> =\r\n  createInjectionToken<FoundryDocument>(\"FoundryDocument\");\r\n\r\n/**\r\n * Injection token for FoundryUI service.\r\n */\r\nexport const foundryUIToken: InjectionToken<FoundryUI> =\r\n  createInjectionToken<FoundryUI>(\"FoundryUI\");\r\n\r\n/**\r\n * Injection token for PortSelector.\r\n */\r\nexport const portSelectorToken: InjectionToken<PortSelector> =\r\n  createInjectionToken<PortSelector>(\"PortSelector\");\r\n\r\n/**\r\n * Injection token for FoundryGame PortRegistry.\r\n */\r\nexport const foundryGamePortRegistryToken: InjectionToken<PortRegistry<FoundryGame>> =\r\n  createInjectionToken<PortRegistry<FoundryGame>>(\"FoundryGamePortRegistry\");\r\n\r\n/**\r\n * Injection token for FoundryHooks PortRegistry.\r\n */\r\nexport const foundryHooksPortRegistryToken: InjectionToken<PortRegistry<FoundryHooks>> =\r\n  createInjectionToken<PortRegistry<FoundryHooks>>(\"FoundryHooksPortRegistry\");\r\n\r\n/**\r\n * Injection token for FoundryDocument PortRegistry.\r\n */\r\nexport const foundryDocumentPortRegistryToken: InjectionToken<PortRegistry<FoundryDocument>> =\r\n  createInjectionToken<PortRegistry<FoundryDocument>>(\"FoundryDocumentPortRegistry\");\r\n\r\n/**\r\n * Injection token for FoundryUI PortRegistry.\r\n */\r\nexport const foundryUIPortRegistryToken: InjectionToken<PortRegistry<FoundryUI>> =\r\n  createInjectionToken<PortRegistry<FoundryUI>>(\"FoundryUIPortRegistry\");\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\r\nimport { MODULE_CONSTANTS } from \"@/constants\";\r\nimport { match } from \"@/utils/result\";\r\nimport {\r\n  foundryGameToken,\r\n  foundryDocumentToken,\r\n  foundryUIToken,\r\n} from \"@/foundry/foundrytokens\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\n\r\n/**\r\n * Service for managing journal entry visibility based on module flags.\r\n * Handles business logic for hiding/showing journal entries in the UI.\r\n */\r\nexport class JournalVisibilityService {\r\n  static dependencies = [\r\n    foundryGameToken,\r\n    foundryDocumentToken,\r\n    foundryUIToken,\r\n    loggerToken,\r\n  ] as const;\r\n\r\n  constructor(\r\n    private readonly game: FoundryGame,\r\n    private readonly document: FoundryDocument,\r\n    private readonly ui: FoundryUI,\r\n    private readonly logger: Logger\r\n  ) {}\r\n\r\n  /**\r\n   * Gets journal entries marked as hidden via module flag.\r\n   */\r\n  getHiddenJournalEntries(): Result<FoundryJournalEntry[], string> {\r\n    const allEntriesResult = this.game.getJournalEntries();\r\n    if (!allEntriesResult.ok) return allEntriesResult;\r\n\r\n    const hidden: FoundryJournalEntry[] = [];\r\n    for (const journal of allEntriesResult.value) {\r\n      const flagResult = this.document.getFlag<boolean>(\r\n        journal as { getFlag: (scope: string, key: string) => unknown },\r\n        MODULE_CONSTANTS.MODULE.ID,\r\n        MODULE_CONSTANTS.FLAGS.HIDDEN\r\n      );\r\n      if (flagResult.ok && flagResult.value === true) {\r\n        hidden.push(journal);\r\n      }\r\n    }\r\n    return { ok: true, value: hidden };\r\n  }\r\n\r\n  /**\r\n   * Processes journal directory HTML to hide flagged entries.\r\n   */\r\n  processJournalDirectory(htmlElement: HTMLElement): void {\r\n    this.logger.debug(\"Processing journal directory for hidden entries\");\r\n\r\n    const hiddenResult = this.getHiddenJournalEntries();\r\n    match(hiddenResult, {\r\n      onOk: (hidden) => {\r\n        this.logger.debug(`Found ${hidden.length} hidden journal entries`);\r\n        this.hideEntries(hidden, htmlElement);\r\n      },\r\n      onErr: (error) => {\r\n        this.logger.error(`Error getting hidden journal entries: ${error}`);\r\n      },\r\n    });\r\n  }\r\n\r\n  private hideEntries(entries: FoundryJournalEntry[], html: HTMLElement): void {\r\n    for (const journal of entries) {\r\n      const removeResult = this.ui.removeJournalElement(\r\n        journal.id,\r\n        journal.name ?? MODULE_CONSTANTS.DEFAULTS.UNKNOWN_NAME,\r\n        html\r\n      );\r\n      match(removeResult, {\r\n        onOk: () => {\r\n          this.logger.debug(\r\n            `Removing journal entry: ${journal.name ?? MODULE_CONSTANTS.DEFAULTS.UNKNOWN_NAME}`\r\n          );\r\n        },\r\n        onErr: (error) => {\r\n          this.logger.warn(`Error removing journal entry: ${error}`);\r\n        },\r\n      });\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Version detection for Foundry VTT.\r\n * Extracts the major version number from Foundry's version string.\r\n */\r\n\r\n/**\r\n * Gets the major version number of the currently running Foundry VTT instance.\r\n * @returns The major version number (e.g., 13 for \"13.348\")\r\n * @throws Error if game is not available or version cannot be determined\r\n */\r\nexport function getFoundryVersion(): number {\r\n  if (typeof game === \"undefined\") {\r\n    throw new Error(\"Foundry game object is not available or version cannot be determined\");\r\n  }\r\n\r\n  // game.version is typed as string by fvtt-types\r\n  // Format is \"{major}.{minor}\" (e.g., \"13.348\")\r\n  const versionString = game.version;\r\n  if (!versionString) {\r\n    throw new Error(\"Foundry version is not available on the game object\");\r\n  }\r\n  const match = versionString.match(/^(\\d+)/);\r\n\r\n  if (!match) {\r\n    throw new Error(`Could not parse Foundry version from: ${versionString}`);\r\n  }\r\n\r\n  return Number.parseInt(match[1]!, 10);\r\n}\r\n\r\n/**\r\n * Safely gets the Foundry version, returning undefined if it cannot be determined.\r\n * @returns The major version number or undefined if not available\r\n */\r\nexport function tryGetFoundryVersion(): number | undefined {\r\n  try {\r\n    return getFoundryVersion();\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport { err, ok } from \"@/utils/result\";\r\nimport { getFoundryVersion } from \"./versiondetector\";\r\n\r\n/**\r\n * Selects the appropriate port implementation based on Foundry version.\r\n * Implements the logic:\r\n * - Foundry v13 → uses v13 ports\r\n * - Foundry v14 → uses v14 ports (if available), otherwise falls back to v13\r\n * - Never uses ports with version number higher than current Foundry version\r\n */\r\nexport class PortSelector {\r\n  /**\r\n   * Selects the appropriate port from available ports based on Foundry version.\r\n   * Returns the highest available port version that is <= the Foundry version.\r\n   *\r\n   * @template T - The port type\r\n   * @param availablePorts - Map of version numbers to port implementations\r\n   * @param foundryVersion - Optional Foundry version (will be detected if not provided)\r\n   * @returns Result containing the selected port or an error message\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const ports = new Map([\r\n   *   [13, new FoundryGamePortV13()],\r\n   *   [14, new FoundryGamePortV14()]\r\n   * ]);\r\n   * const selector = new PortSelector();\r\n   * const result = selector.selectPort(ports);\r\n   * // On Foundry v14: selects v14 port\r\n   * // On Foundry v13: selects v13 port\r\n   * ```\r\n   */\r\n  selectPort<T>(availablePorts: Map<number, T>, foundryVersion?: number): Result<T, string> {\r\n    // Detect Foundry version if not provided\r\n    let version: number;\r\n    try {\r\n      version = foundryVersion ?? getFoundryVersion();\r\n    } catch (error) {\r\n      return err(\r\n        `Could not determine Foundry version: ${error instanceof Error ? error.message : String(error)}`\r\n      );\r\n    }\r\n\r\n    // Find the highest available port that is <= Foundry version\r\n    let selectedPort: T | undefined;\r\n    let selectedVersion = -1;\r\n\r\n    for (const [portVersion, port] of availablePorts.entries()) {\r\n      // Ignore ports with version higher than Foundry version\r\n      if (portVersion > version) {\r\n        continue;\r\n      }\r\n\r\n      // Select the highest compatible port\r\n      if (portVersion > selectedVersion) {\r\n        selectedVersion = portVersion;\r\n        selectedPort = port;\r\n      }\r\n    }\r\n\r\n    if (selectedPort === undefined) {\r\n      const availableVersions = Array.from(availablePorts.keys())\r\n        .sort((a, b) => a - b)\r\n        .join(\", \");\r\n      return err(\r\n        `No compatible port found for Foundry version ${version}. Available ports: ${availableVersions || \"none\"}`\r\n      );\r\n    }\r\n\r\n    return ok(selectedPort);\r\n  }\r\n}\r\n","/**\r\n * Registry for managing available port implementations across different Foundry versions.\r\n * Centralizes port registration and discovery.\r\n */\r\n\r\nimport type { Result } from \"@/types/result\";\r\nimport { ok, err } from \"@/utils/result\";\r\n\r\nexport type PortFactory<T> = () => T;\r\n\r\n/**\r\n * Registry that holds exactly one port factory per version.\r\n * @template T - The port interface type\r\n */\r\nexport class PortRegistry<T> {\r\n  // Exactly one factory per version\r\n  private readonly factories = new Map<number, PortFactory<T>>();\r\n\r\n  /**\r\n   * Registers a port factory for a specific Foundry version.\r\n   * @param version - The Foundry version this port supports\r\n   * @param factory - Factory function that creates the port instance\r\n   * @returns Result indicating success or duplicate registration error\r\n   */\r\n  register(version: number, factory: PortFactory<T>): Result<void, string> {\r\n    if (this.factories.has(version)) {\r\n      return err(`PortRegistry: version ${version} already registered`);\r\n    }\r\n    this.factories.set(version, factory);\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Gets all registered port versions.\r\n   * @returns Array of registered version numbers, sorted ascending\r\n   */\r\n  getAvailableVersions(): number[] {\r\n    return Array.from(this.factories.keys()).sort((a, b) => a - b);\r\n  }\r\n\r\n  /**\r\n   * Creates all registered ports. Used for port selection.\r\n   * @returns Map of version numbers to port instances\r\n   */\r\n  createAll(): Map<number, T> {\r\n    const ports = new Map<number, T>();\r\n    for (const [version, factory] of this.factories.entries()) {\r\n      ports.set(version, factory());\r\n    }\r\n    return ports;\r\n  }\r\n\r\n  /**\r\n   * Creates only the port for the specified version or the highest compatible version.\r\n   * More efficient than createAll() when only one port is needed.\r\n   * @param version - The target Foundry version\r\n   * @returns Result containing the port instance or error\r\n   */\r\n  createForVersion(version: number): Result<T, string> {\r\n    // Find highest compatible version (<= target version)\r\n    const compatibleVersions = Array.from(this.factories.keys())\r\n      .filter(v => v <= version)\r\n      .sort((a, b) => b - a);\r\n\r\n    if (compatibleVersions.length === 0) {\r\n      const availableVersions = this.getAvailableVersions().join(\", \");\r\n      return err(\r\n        `No compatible port for Foundry v${version}. Available ports: ${availableVersions || \"none\"}`\r\n      );\r\n    }\r\n\r\n    const selectedVersion = compatibleVersions[0];\r\n    const factory = this.factories.get(selectedVersion)!;\r\n    return ok(factory());\r\n  }\r\n\r\n  /**\r\n   * Checks if a port is registered for a specific version.\r\n   * @param version - The version to check\r\n   * @returns True if a port is registered for this version\r\n   */\r\n  hasVersion(version: number): boolean {\r\n    return this.factories.has(version);\r\n  }\r\n\r\n  /**\r\n   * Gets the highest registered port version.\r\n   * @returns The highest version number or undefined if no ports are registered\r\n   */\r\n  getHighestVersion(): number | undefined {\r\n    const versions = this.getAvailableVersions();\r\n    return versions.length > 0 ? versions[versions.length - 1] : undefined;\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\r\nimport type { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport type { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { err, tryCatch } from \"@/utils/result\";\r\nimport { portSelectorToken, foundryGamePortRegistryToken } from \"@/foundry/foundrytokens\";\r\nimport { getFoundryVersion } from \"@/foundry/versioning/versiondetector\";\r\n\r\n/**\r\n * Service wrapper for FoundryGame that automatically selects the appropriate port\r\n * based on the current Foundry version.\r\n */\r\nexport class FoundryGameService implements FoundryGame {\r\n  static dependencies = [portSelectorToken, foundryGamePortRegistryToken] as const;\r\n\r\n  private port: FoundryGame | null = null;\r\n  private readonly portSelector: PortSelector;\r\n  private readonly portRegistry: PortRegistry<FoundryGame>;\r\n\r\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryGame>) {\r\n    this.portSelector = portSelector;\r\n    this.portRegistry = portRegistry;\r\n  }\r\n\r\n  /**\r\n   * Lazy-loads the appropriate port based on Foundry version.\r\n   * @returns Result containing the port or an error if no compatible port can be selected\r\n   */\r\n  private getPort(): Result<FoundryGame, string> {\r\n    if (this.port === null) {\r\n      const versionResult = tryCatch(\r\n        () => getFoundryVersion(),\r\n        (e) => `Cannot detect Foundry version: ${e instanceof Error ? e.message : String(e)}`\r\n      );\r\n      if (!versionResult.ok) {\r\n        return err(`Failed to detect Foundry version: ${versionResult.error}`);\r\n      }\r\n\r\n      const portResult = this.portRegistry.createForVersion(versionResult.value);\r\n      if (!portResult.ok) {\r\n        return err(`Failed to select FoundryGame port: ${portResult.error}`);\r\n      }\r\n      this.port = portResult.value;\r\n    }\r\n    return { ok: true, value: this.port };\r\n  }\r\n\r\n  getJournalEntries(): Result<FoundryJournalEntry[], string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.getJournalEntries();\r\n  }\r\n\r\n  getJournalEntryById(id: string): Result<FoundryJournalEntry | null, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.getJournalEntryById(id);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryHookCallback } from \"@/foundry/types\";\r\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { portSelectorToken, foundryHooksPortRegistryToken } from \"@/foundry/foundrytokens\";\r\nimport { err, tryCatch } from \"@/utils/result\";\r\nimport { getFoundryVersion } from \"@/foundry/versioning/versiondetector\";\r\n\r\n/**\r\n * Service wrapper for FoundryHooks that automatically selects the appropriate port\r\n * based on the current Foundry version.\r\n */\r\nexport class FoundryHooksService implements FoundryHooks {\r\n  static dependencies = [portSelectorToken, foundryHooksPortRegistryToken] as const;\r\n\r\n  private port: FoundryHooks | null = null;\r\n  private readonly portSelector: PortSelector;\r\n  private readonly portRegistry: PortRegistry<FoundryHooks>;\r\n\r\n  constructor(\r\n    portSelector: PortSelector,\r\n    portRegistry: PortRegistry<FoundryHooks>\r\n  ) {\r\n    this.portSelector = portSelector;\r\n    this.portRegistry = portRegistry;\r\n  }\r\n\r\n  /**\r\n   * Lazy-loads the appropriate port based on Foundry version.\r\n   * @returns Result containing the port or an error if no compatible port can be selected\r\n   */\r\n  private getPort(): Result<FoundryHooks, string> {\r\n    if (this.port === null) {\r\n      const versionResult = tryCatch(\r\n        () => getFoundryVersion(),\r\n        (e) => `Cannot detect Foundry version: ${e instanceof Error ? e.message : String(e)}`\r\n      );\r\n      if (!versionResult.ok) {\r\n        return err(`Failed to detect Foundry version: ${versionResult.error}`);\r\n      }\r\n\r\n      const portResult = this.portRegistry.createForVersion(versionResult.value);\r\n      if (!portResult.ok) {\r\n        return err(`Failed to select FoundryHooks port: ${portResult.error}`);\r\n      }\r\n      this.port = portResult.value;\r\n    }\r\n    return { ok: true, value: this.port };\r\n  }\r\n\r\n  on(hookName: string, callback: FoundryHookCallback): Result<void, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.on(hookName, callback);\r\n  }\r\n\r\n  off(hookName: string, callback: FoundryHookCallback): Result<void, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.off(hookName, callback);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { err, tryCatch } from \"@/utils/result\";\r\nimport { portSelectorToken, foundryDocumentPortRegistryToken } from \"@/foundry/foundrytokens\";\r\nimport { getFoundryVersion } from \"@/foundry/versioning/versiondetector\";\r\n\r\n/**\r\n * Service wrapper for FoundryDocument that automatically selects the appropriate port\r\n * based on the current Foundry version.\r\n */\r\nexport class FoundryDocumentService implements FoundryDocument {\r\n  static dependencies = [portSelectorToken, foundryDocumentPortRegistryToken] as const;\r\n\r\n  private port: FoundryDocument | null = null;\r\n  private readonly portSelector: PortSelector;\r\n  private readonly portRegistry: PortRegistry<FoundryDocument>;\r\n\r\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryDocument>) {\r\n    this.portSelector = portSelector;\r\n    this.portRegistry = portRegistry;\r\n  }\r\n\r\n  /**\r\n   * Lazy-loads the appropriate port based on Foundry version.\r\n   * @returns Result containing the port or an error if no compatible port can be selected\r\n   */\r\n  private getPort(): Result<FoundryDocument, string> {\r\n    if (this.port === null) {\r\n      const versionResult = tryCatch(\r\n        () => getFoundryVersion(),\r\n        (e) => `Cannot detect Foundry version: ${e instanceof Error ? e.message : String(e)}`\r\n      );\r\n      if (!versionResult.ok) {\r\n        return err(`Failed to detect Foundry version: ${versionResult.error}`);\r\n      }\r\n\r\n      const portResult = this.portRegistry.createForVersion(versionResult.value);\r\n      if (!portResult.ok) {\r\n        return err(`Failed to select FoundryDocument port: ${portResult.error}`);\r\n      }\r\n      this.port = portResult.value;\r\n    }\r\n    return { ok: true, value: this.port };\r\n  }\r\n\r\n  getFlag<T = unknown>(\r\n    document: { getFlag: (scope: string, key: string) => unknown },\r\n    scope: string,\r\n    key: string\r\n  ): Result<T | null, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.getFlag<T>(document, scope, key);\r\n  }\r\n\r\n  async setFlag<T = unknown>(\r\n    document: { setFlag: (scope: string, key: string, value: T) => Promise<unknown> },\r\n    scope: string,\r\n    key: string,\r\n    value: T\r\n  ): Promise<Result<void, string>> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return await portResult.value.setFlag(document, scope, key, value);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { err, tryCatch } from \"@/utils/result\";\r\nimport { portSelectorToken, foundryUIPortRegistryToken } from \"@/foundry/foundrytokens\";\r\nimport { getFoundryVersion } from \"@/foundry/versioning/versiondetector\";\r\n\r\n/**\r\n * Service wrapper for FoundryUI that automatically selects the appropriate port\r\n * based on the current Foundry version.\r\n */\r\nexport class FoundryUIService implements FoundryUI {\r\n  static dependencies = [portSelectorToken, foundryUIPortRegistryToken] as const;\r\n\r\n  private port: FoundryUI | null = null;\r\n  private readonly portSelector: PortSelector;\r\n  private readonly portRegistry: PortRegistry<FoundryUI>;\r\n\r\n  constructor(portSelector: PortSelector, portRegistry: PortRegistry<FoundryUI>) {\r\n    this.portSelector = portSelector;\r\n    this.portRegistry = portRegistry;\r\n  }\r\n\r\n  /**\r\n   * Lazy-loads the appropriate port based on Foundry version.\r\n   * @returns Result containing the port or an error if no compatible port can be selected\r\n   */\r\n  private getPort(): Result<FoundryUI, string> {\r\n    if (this.port === null) {\r\n      const versionResult = tryCatch(\r\n        () => getFoundryVersion(),\r\n        (e) => `Cannot detect Foundry version: ${e instanceof Error ? e.message : String(e)}`\r\n      );\r\n      if (!versionResult.ok) {\r\n        return err(`Failed to detect Foundry version: ${versionResult.error}`);\r\n      }\r\n\r\n      const portResult = this.portRegistry.createForVersion(versionResult.value);\r\n      if (!portResult.ok) {\r\n        return err(`Failed to select FoundryUI port: ${portResult.error}`);\r\n      }\r\n      this.port = portResult.value;\r\n    }\r\n    return { ok: true, value: this.port };\r\n  }\r\n\r\n  removeJournalElement(\r\n    journalId: string,\r\n    journalName: string,\r\n    html: HTMLElement\r\n  ): Result<void, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.removeJournalElement(journalId, journalName, html);\r\n  }\r\n\r\n  findElement(container: HTMLElement, selector: string): Result<HTMLElement | null, string> {\r\n    const portResult = this.getPort();\r\n    if (!portResult.ok) return portResult;\r\n    return portResult.value.findElement(container, selector);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryJournalEntry } from \"@/foundry/types\";\r\nimport { tryCatch, err } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryGame interface.\r\n * Encapsulates Foundry v13-specific game API access.\r\n */\r\nexport class FoundryGamePortV13 implements FoundryGame {\r\n  getJournalEntries(): Result<FoundryJournalEntry[], string> {\r\n    if (typeof game === \"undefined\" || !game?.journal) {\r\n      return err(\"Foundry game API not available\");\r\n    }\r\n    return tryCatch(\r\n      () => {\r\n        // game.journal is typed as DocumentCollection<JournalEntry> by fvtt-types\r\n        // DocumentCollection.contents is an array of the stored documents\r\n        const entries = Array.from(game.journal.contents);\r\n        return entries;\r\n      },\r\n      (error) =>\r\n        `Failed to get journal entries: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n\r\n  getJournalEntryById(id: string): Result<FoundryJournalEntry | null, string> {\r\n    if (typeof game === \"undefined\" || !game?.journal) {\r\n      return err(\"Foundry game API not available\");\r\n    }\r\n    return tryCatch(\r\n      () => {\r\n        // game.journal.get() is typed by fvtt-types and returns JournalEntry | undefined\r\n        const entry = game.journal.get(id);\r\n        return entry ?? null;\r\n      },\r\n      (error) =>\r\n        `Failed to get journal entry by ID ${id}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryHookCallback } from \"@/foundry/types\";\r\nimport { err, ok } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryHooks interface.\r\n * Encapsulates Foundry v13-specific hook system access.\r\n */\r\nexport class FoundryHooksPortV13 implements FoundryHooks {\r\n  on(hookName: string, callback: FoundryHookCallback): Result<void, string> {\r\n    if (typeof Hooks === \"undefined\") {\r\n      return err(\"Foundry Hooks API is not available\");\r\n    }\r\n    // Type assertion needed: Our abstraction accepts any hook name (string),\r\n    // but fvtt-types Hooks.on() expects specific hook names (union type).\r\n    // This is intentional to keep our abstraction layer flexible.\r\n    (Hooks.on as (hook: string, fn: (...args: any[]) => any) => number)(hookName, callback);\r\n    return ok(undefined);\r\n  }\r\n\r\n  off(hookName: string, callback: FoundryHookCallback): Result<void, string> {\r\n    if (typeof Hooks === \"undefined\") {\r\n      return err(\"Foundry Hooks API is not available\");\r\n    }\r\n    // Type assertion needed: Our abstraction accepts any hook name (string),\r\n    // but fvtt-types Hooks.off() expects specific hook names (union type).\r\n    // This is intentional to keep our abstraction layer flexible.\r\n    (Hooks.off as (hook: string, fn: number | ((...args: any[]) => any)) => void)(hookName, callback);\r\n    return ok(undefined);\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport { fromPromise, tryCatch } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryDocument interface.\r\n * Encapsulates Foundry v13-specific document operations.\r\n */\r\nexport class FoundryDocumentPortV13 implements FoundryDocument {\r\n  getFlag<T = unknown>(\r\n    document: { getFlag: (scope: string, key: string) => unknown },\r\n    scope: string,\r\n    key: string\r\n  ): Result<T | null, string> {\r\n    return tryCatch(\r\n      () => {\r\n        if (!document?.getFlag) {\r\n          throw new Error(\"Document does not have getFlag method\");\r\n        }\r\n        const value = document.getFlag(scope, key) as T | null | undefined;\r\n        return value ?? null;\r\n      },\r\n      (error) =>\r\n        `Failed to get flag ${scope}.${key}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n\r\n  async setFlag<T = unknown>(\r\n    document: { setFlag: (scope: string, key: string, value: T) => Promise<unknown> },\r\n    scope: string,\r\n    key: string,\r\n    value: T\r\n  ): Promise<Result<void, string>> {\r\n    return fromPromise<void, string>(\r\n      (async () => {\r\n        if (!document?.setFlag) {\r\n          throw new Error(\"Document does not have setFlag method\");\r\n        }\r\n        await document.setFlag(scope, key, value);\r\n      })(),\r\n      (error) =>\r\n        `Failed to set flag ${scope}.${key}: ${error instanceof Error ? error.message : String(error)}`\r\n    );\r\n  }\r\n}\r\n","import type { Result } from \"@/types/result\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\nimport { ok, err } from \"@/utils/result\";\r\n\r\n/**\r\n * v13 implementation of FoundryUI interface.\r\n * Encapsulates Foundry v13-specific UI manipulation.\r\n */\r\nexport class FoundryUIPortV13 implements FoundryUI {\r\n  removeJournalElement(\r\n    journalId: string,\r\n    journalName: string,\r\n    html: HTMLElement\r\n  ): Result<void, string> {\r\n    const element = html.querySelector(\r\n      `li.directory-item[data-entry-id=\"${journalId}\"]`\r\n    ) as HTMLElement | null;\r\n\r\n    if (!element) {\r\n      return err(`Could not find element for journal entry: ${journalName} (${journalId})`);\r\n    }\r\n\r\n    element.remove();\r\n    return ok(undefined);\r\n  }\r\n\r\n  findElement(container: HTMLElement, selector: string): Result<HTMLElement | null, string> {\r\n    const element = container.querySelector(selector) as HTMLElement | null;\r\n    return ok(element);\r\n  }\r\n}\r\n","import { ServiceContainer, registerFallback } from \"@/di_infrastructure/container\";\r\nimport { loggerToken, journalVisibilityServiceToken } from \"@/tokens/tokenindex\";\r\nimport { ConsoleLoggerService } from \"@/services/consolelogger\";\r\nimport { JournalVisibilityService } from \"@/services/JournalVisibilityService\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport { ok, err, isErr } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\nimport {\r\n  foundryGameToken,\r\n  foundryHooksToken,\r\n  foundryDocumentToken,\r\n  foundryUIToken,\r\n  portSelectorToken,\r\n  foundryGamePortRegistryToken,\r\n  foundryHooksPortRegistryToken,\r\n  foundryDocumentPortRegistryToken,\r\n  foundryUIPortRegistryToken,\r\n} from \"@/foundry/foundrytokens\";\r\nimport { PortSelector } from \"@/foundry/versioning/portselector\";\r\nimport { PortRegistry } from \"@/foundry/versioning/portregistry\";\r\nimport { FoundryGameService } from \"@/foundry/services/FoundryGameService\";\r\nimport { FoundryHooksService } from \"@/foundry/services/FoundryHooksService\";\r\nimport { FoundryDocumentService } from \"@/foundry/services/FoundryDocumentService\";\r\nimport { FoundryUIService } from \"@/foundry/services/FoundryUIService\";\r\nimport { FoundryGamePortV13 } from \"@/foundry/ports/v13/FoundryGamePort\";\r\nimport { FoundryHooksPortV13 } from \"@/foundry/ports/v13/FoundryHooksPort\";\r\nimport { FoundryDocumentPortV13 } from \"@/foundry/ports/v13/FoundryDocumentPort\";\r\nimport { FoundryUIPortV13 } from \"@/foundry/ports/v13/FoundryUIPort\";\r\nimport type { FoundryGame } from \"@/foundry/interfaces/FoundryGame\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { FoundryDocument } from \"@/foundry/interfaces/FoundryDocument\";\r\nimport type { FoundryUI } from \"@/foundry/interfaces/FoundryUI\";\r\n\r\n/**\r\n * Configures all dependency injection mappings for the application.\r\n * This is the central place where tokens are connected to their factories.\r\n *\r\n * Also registers fallback factories for critical services that should always be available\r\n * even if container resolution fails.\r\n *\r\n * @param container - The service container to configure\r\n * @returns Result indicating success or configuration errors\r\n *\r\n * @example\r\n * ```typescript\r\n * const container = ServiceContainer.createRoot();\r\n * const result = configureDependencies(container);\r\n * if (isOk(result)) {\r\n *   const logger = container.resolve(loggerToken); // Direct resolution with fallback\r\n * }\r\n * ```\r\n */\r\nexport function configureDependencies(container: ServiceContainer): Result<void, string> {\r\n  // Register fallback factories for services that should always be available\r\n  registerFallback<Logger>(loggerToken, () => new ConsoleLoggerService());\r\n\r\n  // Register logger\r\n  const loggerResult = container.registerClass(\r\n    loggerToken,\r\n    ConsoleLoggerService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(loggerResult)) {\r\n    return err(`Failed to register logger: ${loggerResult.error.message}`);\r\n  }\r\n\r\n  // Register PortSelector as singleton\r\n  const portSelectorResult = container.registerFactory(\r\n    portSelectorToken,\r\n    () => new PortSelector(),\r\n    ServiceLifecycle.SINGLETON,\r\n    []\r\n  );\r\n\r\n  if (isErr(portSelectorResult)) {\r\n    return err(`Failed to register PortSelector: ${portSelectorResult.error.message}`);\r\n  }\r\n\r\n  // Register PortRegistries\r\n  const portRegistrationErrors: string[] = [];\r\n\r\n  const gamePortRegistry = new PortRegistry<FoundryGame>();\r\n  const gamePortRegResult = gamePortRegistry.register(13, () => new FoundryGamePortV13());\r\n  if (isErr(gamePortRegResult)) {\r\n    portRegistrationErrors.push(`FoundryGame v13: ${gamePortRegResult.error}`);\r\n  }\r\n\r\n  const hooksPortRegistry = new PortRegistry<FoundryHooks>();\r\n  const hooksPortRegResult = hooksPortRegistry.register(13, () => new FoundryHooksPortV13());\r\n  if (isErr(hooksPortRegResult)) {\r\n    portRegistrationErrors.push(`FoundryHooks v13: ${hooksPortRegResult.error}`);\r\n  }\r\n\r\n  const documentPortRegistry = new PortRegistry<FoundryDocument>();\r\n  const documentPortRegResult = documentPortRegistry.register(13, () => new FoundryDocumentPortV13());\r\n  if (isErr(documentPortRegResult)) {\r\n    portRegistrationErrors.push(`FoundryDocument v13: ${documentPortRegResult.error}`);\r\n  }\r\n\r\n  const uiPortRegistry = new PortRegistry<FoundryUI>();\r\n  const uiPortRegResult = uiPortRegistry.register(13, () => new FoundryUIPortV13());\r\n  if (isErr(uiPortRegResult)) {\r\n    portRegistrationErrors.push(`FoundryUI v13: ${uiPortRegResult.error}`);\r\n  }\r\n\r\n  // Return early if any port registration failed\r\n  if (portRegistrationErrors.length > 0) {\r\n    return err(`Port registration failed: ${portRegistrationErrors.join(\"; \")}`);\r\n  }\r\n\r\n  const gameRegistryResult = container.registerValue(\r\n    foundryGamePortRegistryToken,\r\n    gamePortRegistry\r\n  );\r\n  if (isErr(gameRegistryResult)) {\r\n    return err(`Failed to register FoundryGame PortRegistry: ${gameRegistryResult.error.message}`);\r\n  }\r\n\r\n  const hooksRegistryResult = container.registerValue(\r\n    foundryHooksPortRegistryToken,\r\n    hooksPortRegistry\r\n  );\r\n  if (isErr(hooksRegistryResult)) {\r\n    return err(\r\n      `Failed to register FoundryHooks PortRegistry: ${hooksRegistryResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const documentRegistryResult = container.registerValue(\r\n    foundryDocumentPortRegistryToken,\r\n    documentPortRegistry\r\n  );\r\n  if (isErr(documentRegistryResult)) {\r\n    return err(\r\n      `Failed to register FoundryDocument PortRegistry: ${documentRegistryResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const uiRegistryResult = container.registerValue(foundryUIPortRegistryToken, uiPortRegistry);\r\n  if (isErr(uiRegistryResult)) {\r\n    return err(`Failed to register FoundryUI PortRegistry: ${uiRegistryResult.error.message}`);\r\n  }\r\n\r\n  // Register Foundry Services using registerClass (with static dependencies)\r\n  const gameServiceResult = container.registerClass(\r\n    foundryGameToken,\r\n    FoundryGameService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(gameServiceResult)) {\r\n    return err(`Failed to register FoundryGame service: ${gameServiceResult.error.message}`);\r\n  }\r\n\r\n  const hooksServiceResult = container.registerClass(\r\n    foundryHooksToken,\r\n    FoundryHooksService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(hooksServiceResult)) {\r\n    return err(`Failed to register FoundryHooks service: ${hooksServiceResult.error.message}`);\r\n  }\r\n\r\n  const documentServiceResult = container.registerClass(\r\n    foundryDocumentToken,\r\n    FoundryDocumentService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(documentServiceResult)) {\r\n    return err(\r\n      `Failed to register FoundryDocument service: ${documentServiceResult.error.message}`\r\n    );\r\n  }\r\n\r\n  const uiServiceResult = container.registerClass(\r\n    foundryUIToken,\r\n    FoundryUIService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(uiServiceResult)) {\r\n    return err(`Failed to register FoundryUI service: ${uiServiceResult.error.message}`);\r\n  }\r\n\r\n  const journalVisibilityResult = container.registerClass(\r\n    journalVisibilityServiceToken,\r\n    JournalVisibilityService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(journalVisibilityResult)) {\r\n    return err(\r\n      `Failed to register JournalVisibility service: ${journalVisibilityResult.error.message}`\r\n    );\r\n  }\r\n\r\n  // Phase 2: Validate\r\n  const validateResult = container.validate();\r\n  if (isErr(validateResult)) {\r\n    const errorMessages = validateResult.error.map((e) => e.message).join(\", \");\r\n    return err(`Validation failed: ${errorMessages}`);\r\n  }\r\n\r\n  return ok(undefined);\r\n}\r\n","import { MODULE_CONSTANTS } from \"@/constants\";\r\nimport type { Result } from \"@/types/result\";\r\nimport { ServiceContainer } from \"@/di_infrastructure/container\";\r\nimport { configureDependencies } from \"@/config/dependencyconfig\";\r\nimport type { InjectionToken } from \"@/di_infrastructure/types/injectiontoken\";\r\nimport type { ModuleApi } from \"@/core/module-api\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\n\r\n/**\r\n * CompositionRoot\r\n *\r\n * Zentraler Bootkernel: erstellt den DI-Container, führt die Basis-Registrierungen\r\n * via configureDependencies aus und stellt die öffentliche Modul-API (nur resolve)\r\n * unter game.modules.get(MODULE_ID).api bereit.\r\n *\r\n * Zweiphasiger Bootstrap:\r\n * - Phase 1 (vor Foundry init): Container erstellen und Grund-Registrierungen.\r\n * - Phase 2 (im Foundry init): Ports selektieren/binden und Hooks registrieren.\r\n */\r\nexport class CompositionRoot {\r\n  private container: ServiceContainer | null = null;\r\n\r\n  /**\r\n   * Erstellt den ServiceContainer und führt Basis-Registrierungen aus.\r\n   * @returns Result mit initialisiertem Container oder Fehlermeldung\r\n   */\r\n  bootstrap(): Result<ServiceContainer, string> {\r\n    const container = ServiceContainer.createRoot();\r\n    const configured = configureDependencies(container);\r\n    if (configured.ok) {\r\n      this.container = container;\r\n      return { ok: true, value: container };\r\n    }\r\n    return { ok: false, error: configured.error };\r\n  }\r\n\r\n  /**\r\n   * Exponiert die öffentliche Modul-API (nur resolve) unter game.modules.get(MODULE_ID).api.\r\n   * Darf erst nach erfolgreichem Bootstrap aufgerufen werden.\r\n   * @throws Fehler, wenn das Foundry-Modul-Objekt nicht verfügbar ist\r\n   */\r\n  exposeToModuleApi(): void {\r\n    const container = this.getContainerOrThrow();\r\n    // game.modules is typed as ModuleCollection (Map<string, Module>) by fvtt-types\r\n    if (typeof game === \"undefined\" || !game?.modules) {\r\n      throw new Error(`${MODULE_CONSTANTS.LOG_PREFIX} Game modules not available`);\r\n    }\r\n    const mod = game.modules.get(MODULE_CONSTANTS.MODULE.ID);\r\n    if (!mod) {\r\n      throw new Error(`${MODULE_CONSTANTS.LOG_PREFIX} Module not available to expose API`);\r\n    }\r\n    const api: ModuleApi = {\r\n      resolve: <TServiceType extends ServiceType>(token: InjectionToken<TServiceType>) =>\r\n        container.resolve<TServiceType>(token),\r\n    };\r\n    // Type-safe assignment thanks to Module augmentation in global.d.ts\r\n    mod.api = api;\r\n  }\r\n\r\n  /**\r\n   * Liefert den initialisierten Container oder wirft einen Fehler, wenn noch nicht verfügbar.\r\n   * @throws Fehler, wenn bootstrap noch nicht erfolgreich war\r\n   */\r\n  getContainerOrThrow(): ServiceContainer {\r\n    if (!this.container) {\r\n      throw new Error(`${MODULE_CONSTANTS.LOG_PREFIX} Container not initialized`);\r\n    }\r\n    return this.container;\r\n  }\r\n}\r\n","import { MODULE_CONSTANTS } from \"@/constants\";\r\nimport { loggerToken, journalVisibilityServiceToken } from \"@/tokens/tokenindex\";\r\nimport { foundryHooksToken } from \"@/foundry/foundrytokens\";\r\nimport type { FoundryHooks } from \"@/foundry/interfaces/FoundryHooks\";\r\nimport type { ServiceContainer } from \"@/di_infrastructure/container\";\r\n\r\n/**\r\n * ModuleHookRegistrar\r\n *\r\n * Bündelt die Registrierung aller Foundry-Hooks für dieses Modul. Muss NACH der\r\n * Port-Selektion im init-Hook aufgerufen werden, damit die finalen Ports aktiv sind.\r\n */\r\nexport class ModuleHookRegistrar {\r\n  /**\r\n   * Registriert alle benötigten Hooks.\r\n   * @param container DI-Container mit final gebundenen Ports und Services\r\n   */\r\n  registerAll(container: ServiceContainer): void {\r\n    const foundryHooks = container.resolve<FoundryHooks>(foundryHooksToken);\r\n    const logger = container.resolve(loggerToken);\r\n    const journalVisibility = container.resolve(journalVisibilityServiceToken);\r\n\r\n    const hookResult = foundryHooks.on(MODULE_CONSTANTS.HOOKS.RENDER_JOURNAL_DIRECTORY, (app, html) => {\r\n      logger.debug(`${MODULE_CONSTANTS.HOOKS.RENDER_JOURNAL_DIRECTORY} fired`);\r\n\r\n      // In Foundry v13+, html is already an HTMLElement (no jQuery)\r\n      const htmlElement = html as HTMLElement;\r\n      if (!htmlElement) {\r\n        logger.error(\"Failed to get HTMLElement from hook\");\r\n        return;\r\n      }\r\n\r\n      journalVisibility.processJournalDirectory(htmlElement);\r\n    });\r\n    \r\n    if (!hookResult.ok) {\r\n      logger.error(`Failed to register ${MODULE_CONSTANTS.HOOKS.RENDER_JOURNAL_DIRECTORY} hook: ${hookResult.error}`);\r\n    }\r\n  }\r\n}\r\n","import { MODULE_CONSTANTS } from \"../constants\";\r\nimport { isOk } from \"@/utils/result\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\nimport { CompositionRoot } from \"@/core/composition-root\";\r\nimport { ModuleHookRegistrar } from \"@/core/module-hook-registrar\";\r\n\r\n/**\r\n * Boot-Orchestrierung für das Modul.\r\n *\r\n * Ablauf:\r\n * - Vor init: DI-Container erstellen (CompositionRoot.bootstrap) und bei Fehler abbrechen\r\n * - In init: API (resolve) exponieren, Ports selektieren/binden (via externem Selector), Hooks registrieren\r\n * - In ready: nur Logging o.ä. – Services sind über api.resolve nutzbar\r\n */\r\n// Hook-spezifische Logik ist in ModuleHookRegistrar ausgelagert\r\n\r\n/**\r\n * Leerer Platzhalter – frühere Initialisierung ist jetzt in den Bootkernel ausgelagert.\r\n */\r\nexport function initializeModule(): void {}\r\n\r\n/**\r\n * Initializes the module when Foundry VTT starts.\r\n * Registers hooks for hiding journal entries based on module flags.\r\n */\r\n\r\n// Eager bootstrap DI before Foundry init\r\nconst root = new CompositionRoot();\r\nconst bootstrapResult = root.bootstrap();\r\nconst bootstrapOk = isOk(bootstrapResult);\r\n\r\nif (!bootstrapOk) {\r\n  console.error(`${MODULE_CONSTANTS.LOG_PREFIX} bootstrap failed`);\r\n  console.error(bootstrapResult.error);\r\n  throw new Error(bootstrapResult.error);\r\n}\r\n\r\nconst logger = root.getContainerOrThrow().resolve(loggerToken);\r\n\r\n// Guard: Ensure Foundry Hooks API is available before registering hooks\r\nif (typeof Hooks === \"undefined\") {\r\n  logger.warn(\"Foundry Hooks API not available - module initialization skipped\");\r\n  // Soft abort: Don't register hooks if Foundry isn't ready\r\n  // This allows tests or non-standard environments to load the module\r\n} else {\r\n  Hooks.on(\"init\", () => {\r\n    logger.info(\"init-phase\");\r\n    // Expose API and register hooks\r\n    root.exposeToModuleApi();\r\n    new ModuleHookRegistrar().registerAll(root.getContainerOrThrow());\r\n    logger.info(\"init-phase completed\");\r\n  });\r\n\r\n  /**\r\n   * Ready hook: Module initialization complete.\r\n   * Executes when Foundry VTT is fully ready.\r\n   */\r\n  Hooks.on(\"ready\", () => {\r\n    logger.info(\"ready-phase\");\r\n    logger.info(\"ready-phase completed\");\r\n  });\r\n}\r\n"],"names":["ServiceLifecycle","game","logger","match"],"mappings":"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"}