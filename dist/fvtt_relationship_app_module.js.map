{"version":3,"file":"fvtt_relationship_app_module.js","sources":["../src/polyfills/cytoscape-assign-fix.ts","../src/constants.ts","../src/utils/result.ts","../src/di_infrastructure/types/servicelifecycle.ts","../src/di_infrastructure/container.ts","../src/di_infrastructure/tokenutilities.ts","../src/tokens/tokenindex.ts","../src/services/consolelogger.ts","../src/config/dependencyconfig.ts","../src/core/init-solid.ts"],"sourcesContent":["/**\r\n * Polyfill für Cytoscape: Object.assign readonly 'equals' fix\r\n *\r\n * ⚠️ WICHTIG: Dieser Polyfill ist ein Legacy-Patch für die Cytoscape-Bibliothek.\r\n * NIEMALS ÄNDERN - könnte das Verhalten der Cytoscape-Integration beeinträchtigen.\r\n */\r\nObject.assign = function (target: any, ...sources: any[]) {\r\n  for (const source of sources) {\r\n    if (source != null) {\r\n      for (const key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key) && key !== \"equals\") {\r\n          try {\r\n            target[key] = source[key];\r\n          } catch {\r\n            // Ignore readonly property errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n};\r\n","/**\r\n * Module-wide constants for the Foundry VTT Relationship App Module.\r\n * Contains metadata and configuration values used throughout the application.\r\n *\r\n * @constant\r\n */\r\nexport const MODULE_CONSTANTS = {\r\n  MODULE: {\r\n    ID: \"fvtt_relationship_app_module\",\r\n    NAME: \"Beziehungsnetzwerke für Foundry\",\r\n    AUTHOR: \"Andreas Rothe\",\r\n    AUTHOR_EMAIL: \"forenadmin.tir@gmail.com\",\r\n    AUTHOR_DISCORD: \"lewellyen\",\r\n  },\r\n  LOG_PREFIX: \"Foundry VTT Relationship App Module |\",\r\n} as const;\r\n","/**\r\n * Utility functions for working with the Result pattern.\r\n * Provides functional error handling with type safety.\r\n *\r\n * This module contains only runtime functions - types are imported from \"../types/result\"\r\n */\r\nimport type { Ok, Err, Result, AsyncResult } from \"../types/result\";\r\n\r\n/**\r\n * Creates a successful Result with a value.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @param value - The successful value to wrap\r\n * @returns A Result indicating success with the provided value\r\n *\r\n * @example\r\n * ```typescript\r\n * const success = ok(42);\r\n * // { ok: true, value: 42 }\r\n * ```\r\n */\r\nexport function ok<SuccessType>(value: SuccessType): Ok<SuccessType> {\r\n  return { ok: true, value };\r\n}\r\n\r\n/**\r\n * Creates an error Result with an error value.\r\n *\r\n * @template ErrorType - The type of the error value\r\n * @param error - The error to wrap\r\n * @returns A Result indicating failure with the provided error\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"Not found\");\r\n * // { ok: false, error: \"Not found\" }\r\n * ```\r\n */\r\nexport function err<ErrorType>(error: ErrorType): Err<ErrorType> {\r\n  return { ok: false, error };\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is successful.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is successful, narrowing the type to Ok<SuccessType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isOk(result)) {\r\n *   console.log(result.value); // Type-safe access to value\r\n * }\r\n * ```\r\n */\r\nexport function isOk<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Ok<SuccessType> {\r\n  return result.ok;\r\n}\r\n\r\n/**\r\n * Type guard to check if a Result is an error.\r\n *\r\n * @template SuccessType - The type of the successful value\r\n * @template ErrorType - The type of the error value\r\n * @param result - The Result to check\r\n * @returns True if the Result is an error, narrowing the type to Err<ErrorType>\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = someOperation();\r\n * if (isErr(result)) {\r\n *   console.error(result.error); // Type-safe access to error\r\n * }\r\n * ```\r\n */\r\nexport function isErr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>\r\n): result is Err<ErrorType> {\r\n  return !result.ok;\r\n}\r\n\r\n/**\r\n * Transforms the value of a successful Result.\r\n * If the Result is an error, it is returned unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the success value\r\n * @returns A new Result with the transformed value, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(5);\r\n * const doubled = map(num, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport function map<SuccessType, NewSuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => NewSuccessType\r\n): Result<NewSuccessType, ErrorType> {\r\n  return result.ok ? ok(transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Transforms the error of a failed Result.\r\n * If the Result is successful, it is returned unchanged.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The current error type\r\n * @template NewErrorType - The new error type after transformation\r\n * @param result - The Result to transform\r\n * @param transform - Function to transform the error value\r\n * @returns A new Result with the transformed error, or the original success\r\n *\r\n * @example\r\n * ```typescript\r\n * const failure = err(\"404\");\r\n * const formatted = mapError(failure, msg => `Error: ${msg}`);\r\n * // { ok: false, error: \"Error: 404\" }\r\n * ```\r\n */\r\nexport function mapError<SuccessType, ErrorType, NewErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  transform: (error: ErrorType) => NewErrorType\r\n): Result<SuccessType, NewErrorType> {\r\n  return result.ok ? result : err(transform(result.error));\r\n}\r\n\r\n/**\r\n * Chains Result operations. If the Result is successful, applies the function to the value.\r\n * Otherwise, returns the error unchanged. This is also known as \"flatMap\" or \"bind\".\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param result - The Result to chain\r\n * @param next - Function that returns a new Result from the success value\r\n * @returns The next Result, or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseNumber = (str: string): Result<number, string> => {\r\n *   const num = parseInt(str);\r\n *   return isNaN(num) ? err(\"Invalid number\") : ok(num);\r\n * };\r\n *\r\n * const doubled = ok(\"5\").pipe(parseNumber).pipe(x => ok(x * 2));\r\n * ```\r\n */\r\nexport function andThen<SuccessType, ErrorType, NextSuccessType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => Result<NextSuccessType, ErrorType>\r\n): Result<NextSuccessType, ErrorType> {\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or returns a fallback value if it's an error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param fallbackValue - The value to return if the Result is an error\r\n * @returns The success value, or the fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * unwrapOr(num, 0); // 42\r\n *\r\n * const err = err(\"Failed\");\r\n * unwrapOr(err, 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOr<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  fallbackValue: SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : fallbackValue;\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or computes a fallback value from the error.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param result - The Result to unwrap\r\n * @param getFallback - Function that computes a fallback from the error\r\n * @returns The success value, or the computed fallback value\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = err(\"Not found\");\r\n * unwrapOrElse(num, error => 0); // 0\r\n * ```\r\n */\r\nexport function unwrapOrElse<SuccessType, ErrorType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  getFallback: (error: ErrorType) => SuccessType\r\n): SuccessType {\r\n  return result.ok ? result.value : getFallback(result.error);\r\n}\r\n\r\n/**\r\n * Unwraps a successful Result or throws an error if it's a failure.\r\n * Use with caution - this defeats the purpose of using Result pattern.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ThrownError - The type of error to throw (must extend Error)\r\n * @param result - The Result to unwrap\r\n * @param toError - Optional function to convert the error to a thrown Error\r\n * @returns The success value\r\n * @throws ThrownError if the Result is an error\r\n *\r\n * @example\r\n * ```typescript\r\n * const num = ok(42);\r\n * getOrThrow(num); // 42\r\n *\r\n * const failure = err(\"Not found\");\r\n * getOrThrow(failure); // throws Error(\"Not found\")\r\n * ```\r\n */\r\nexport function getOrThrow<SuccessType, ErrorType, ThrownError extends Error = Error>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  toError?: (error: ErrorType) => ThrownError\r\n): SuccessType {\r\n  if (result.ok) return result.value;\r\n  const e = toError ? toError(result.error) : (new Error(String(result.error)) as ThrownError);\r\n  throw e;\r\n}\r\n\r\n/**\r\n * Executes a function and wraps the result in a Result, catching any thrown errors.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param fn - The function to execute\r\n * @param mapUnknownError - Function to convert caught errors to the ErrorType\r\n * @returns A Result containing either the return value or the caught error\r\n *\r\n * @example\r\n * ```typescript\r\n * const parsed = tryCatch(\r\n *   () => JSON.parse(\"{ invalid json\"),\r\n *   (e) => `Parse error: ${e}`\r\n * );\r\n * // { ok: false, error: \"Parse error: ...\" }\r\n * ```\r\n */\r\nexport function tryCatch<SuccessType, ErrorType>(\r\n  fn: () => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): Result<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(fn());\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error immediately (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param results - Array of Results to combine\r\n * @returns A Result containing an array of values, or the first error encountered\r\n *\r\n * @example\r\n * ```typescript\r\n * const nums = [ok(1), ok(2), ok(3)];\r\n * all(nums); // { ok: true, value: [1, 2, 3] }\r\n *\r\n * const mixed = [ok(1), err(\"error\"), ok(3)];\r\n * all(mixed); // { ok: false, error: \"error\" }\r\n * ```\r\n */\r\nexport function all<SuccessType, ErrorType>(\r\n  results: Array<Result<SuccessType, ErrorType>>\r\n): Result<SuccessType[], ErrorType> {\r\n  const out: SuccessType[] = [];\r\n  for (const r of results) {\r\n    if (!r.ok) return r;\r\n    out.push(r.value);\r\n  }\r\n  return ok(out);\r\n}\r\n\r\n/**\r\n * Pattern matching for Results. Executes different handlers based on success or failure.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @template ReturnType - The return type of both handlers\r\n * @param result - The Result to match\r\n * @param handlers - Object with onOk and onErr handlers\r\n * @returns The result of the executed handler\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = ok(42);\r\n * match(result, {\r\n *   onOk: value => console.log(`Success: ${value}`),\r\n *   onErr: error => console.error(`Error: ${error}`)\r\n * });\r\n * ```\r\n */\r\nexport function match<SuccessType, ErrorType, ReturnType>(\r\n  result: Result<SuccessType, ErrorType>,\r\n  handlers: { onOk: (value: SuccessType) => ReturnType; onErr: (error: ErrorType) => ReturnType }\r\n): ReturnType {\r\n  return result.ok ? handlers.onOk(result.value) : handlers.onErr(result.error);\r\n}\r\n\r\n/**\r\n * Lifts a regular function to work with Results by wrapping it with error handling.\r\n *\r\n * @template ParamType - The function parameter type\r\n * @template SuccessType - The function return type (success type)\r\n * @template ErrorType - The error type\r\n * @param fn - The function to lift\r\n * @param mapUnknownError - Function to convert thrown errors to the ErrorType\r\n * @returns A function that returns a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const parseJSON = lift(\r\n *   (str: string) => JSON.parse(str),\r\n *   (e) => `Invalid JSON: ${e}`\r\n * );\r\n *\r\n * const result = parseJSON(\"{ invalid }\");\r\n * // { ok: false, error: \"Invalid JSON: ...\" }\r\n * ```\r\n */\r\nexport function lift<ParamType, SuccessType, ErrorType>(\r\n  fn: (param: ParamType) => SuccessType,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): (param: ParamType) => Result<SuccessType, ErrorType> {\r\n  return (param) => tryCatch(() => fn(param), mapUnknownError);\r\n}\r\n\r\n/**\r\n * Transforms the value of an async Result.\r\n * If the Result is an error, returns it unchanged.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template NewSuccessType - The new success type after transformation\r\n * @template ErrorType - The error type\r\n * @param asyncResult - The async Result to transform\r\n * @param transform - Async or sync function to transform the success value\r\n * @returns A promise that resolves to a Result with the transformed value or error\r\n *\r\n * @example\r\n * ```typescript\r\n * const asyncNum = Promise.resolve(ok(5));\r\n * const doubled = await asyncMap(asyncNum, x => x * 2);\r\n * // { ok: true, value: 10 }\r\n * ```\r\n */\r\nexport async function asyncMap<SuccessType, NewSuccessType, ErrorType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  transform: (value: SuccessType) => Promise<NewSuccessType> | NewSuccessType\r\n): AsyncResult<NewSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? ok(await transform(result.value)) : result;\r\n}\r\n\r\n/**\r\n * Chains async Result operations.\r\n * If the Result is successful, applies the async function to the value.\r\n *\r\n * @template SuccessType - The current success type\r\n * @template ErrorType - The error type\r\n * @template NextSuccessType - The next success type after chaining\r\n * @param asyncResult - The async Result to chain\r\n * @param next - Async function that returns a new async Result\r\n * @returns A promise that resolves to the chained Result or the original error\r\n *\r\n * @example\r\n * ```typescript\r\n * const fetchAndProcess = async (url: string) => {\r\n *   const data = await fromPromise(fetch(url).then(r => r.json()), e => String(e));\r\n *   return asyncAndThen(data, processDataAsync);\r\n * };\r\n * ```\r\n */\r\nexport async function asyncAndThen<SuccessType, ErrorType, NextSuccessType>(\r\n  asyncResult: AsyncResult<SuccessType, ErrorType>,\r\n  next: (value: SuccessType) => AsyncResult<NextSuccessType, ErrorType>\r\n): AsyncResult<NextSuccessType, ErrorType> {\r\n  const result = await asyncResult;\r\n  return result.ok ? next(result.value) : result;\r\n}\r\n\r\n/**\r\n * Converts a Promise into an async Result.\r\n * Catches any rejection and converts it to an error Result.\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param promise - The Promise to convert\r\n * @param mapUnknownError - Function to convert unknown errors to the ErrorType\r\n * @returns A promise that resolves to a Result\r\n *\r\n * @example\r\n * ```typescript\r\n * const result = await fromPromise(\r\n *   fetch(\"/api/data\").then(r => r.json()),\r\n *   (e) => `Fetch failed: ${e}`\r\n * );\r\n * ```\r\n */\r\nexport async function fromPromise<SuccessType, ErrorType>(\r\n  promise: Promise<SuccessType>,\r\n  mapUnknownError: (unknownError: unknown) => ErrorType\r\n): AsyncResult<SuccessType, ErrorType> {\r\n  try {\r\n    return ok(await promise);\r\n  } catch (unknownError) {\r\n    return err(mapUnknownError(unknownError));\r\n  }\r\n}\r\n\r\n/**\r\n * Combines multiple async Results into a single Result containing an array of values.\r\n * If any Result is an error, returns that error (short-circuits).\r\n *\r\n * @template SuccessType - The success type\r\n * @template ErrorType - The error type\r\n * @param asyncResults - Array of async Results to combine\r\n * @returns A promise that resolves to a Result containing an array of values or the first error\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = [\r\n *   Promise.resolve(ok(1)),\r\n *   Promise.resolve(ok(2)),\r\n *   Promise.resolve(ok(3))\r\n * ];\r\n * const combined = await asyncAll(results);\r\n * // { ok: true, value: [1, 2, 3] }\r\n * ```\r\n */\r\nexport async function asyncAll<SuccessType, ErrorType>(\r\n  asyncResults: Array<AsyncResult<SuccessType, ErrorType>>\r\n): AsyncResult<SuccessType[], ErrorType> {\r\n  const results: Result<SuccessType, ErrorType>[] = await Promise.all(asyncResults);\r\n  return all(results);\r\n}\r\n","/**\r\n * Enum for service lifecycle strategies in dependency injection.\r\n *\r\n * - SINGLETON: One shared instance across the entire application\r\n * - TRANSIENT: New instance created on each resolution\r\n * - SCOPED: One instance per container scope\r\n *\r\n * @enum {string}\r\n * @property {string} SINGLETON - One instance for all\r\n * @property {string} TRANSIENT - New instance for each resolve()\r\n * @property {string} SCOPED - One instance per scope\r\n */\r\nexport enum ServiceLifecycle {\r\n  SINGLETON = \"singleton\",\r\n  TRANSIENT = \"transient\",\r\n  SCOPED = \"scoped\",\r\n}\r\n","import type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { FactoryFunction } from \"./types/servicefactory\";\r\nimport type { ServiceClass } from \"./types/serviceclass\";\r\nimport type { ServiceDependencies } from \"./types/servicedependencies\";\r\nimport type { ContainerValidationState } from \"./types/containervalidationstate\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\nimport { ok, err, tryCatch, isErr, isOk } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Container } from \"@/di_infrastructure/interfaces/container\";\r\nimport type { ContainerError } from \"@/di_infrastructure/interfaces/containererror\";\r\nimport type { ContainerErrorCode } from \"@/di_infrastructure/types/containererrorcode\";\r\n\r\n/**\r\n * Fallback factory function type for creating service instances when container resolution fails.\r\n */\r\ntype FallbackFactory<T extends ServiceType> = () => T;\r\n\r\n/**\r\n * Global registry of fallback factories for known tokens.\r\n * Used when container resolution fails and a fallback is available.\r\n */\r\nconst fallbackFactories = new Map<symbol, FallbackFactory<ServiceType>>();\r\n\r\n/**\r\n * Register a fallback factory for a specific token.\r\n * This will be used when container.resolve() fails for that token.\r\n *\r\n * @param token - The injection token\r\n * @param factory - Factory function that creates a fallback instance\r\n *\r\n * @example\r\n * ```typescript\r\n * registerFallback(UserServiceToken, () => new DefaultUserService());\r\n * ```\r\n */\r\nexport function registerFallback<T extends ServiceType>(\r\n  token: InjectionToken<T>,\r\n  factory: FallbackFactory<T>\r\n): void {\r\n  fallbackFactories.set(token, factory as FallbackFactory<ServiceType>);\r\n}\r\n\r\n/**\r\n * Dependency injection container that manages service lifecycles.\r\n * Supports Singleton, Transient, and Scoped service patterns with hierarchical container support.\r\n *\r\n * **Scope Chain Behavior:**\r\n * When a parent container is disposed, all child containers are automatically disposed.\r\n * This ensures proper cleanup of resources across the container hierarchy.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const container = new ServiceContainer();\r\n * container.register(LoggerToken, () => new Logger(), ServiceLifecycle.SINGLETON);\r\n * const logger = container.resolve(LoggerToken);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Scope chain with cascading disposal\r\n * const root = new ServiceContainer();\r\n * const child1 = root.createScope(\"child1\");\r\n * const child2 = root.createScope(\"child2\");\r\n * const grandchild = child1.createScope(\"grandchild\");\r\n *\r\n * // Disposing root automatically disposes all children\r\n * root.dispose();\r\n * // All child containers (child1, child2, grandchild) are now disposed\r\n * ```\r\n */\r\nexport class ServiceContainer implements Container {\r\n  /** Service registrations mapping tokens to factories and lifecycles */\r\n  #serviceRegistrations: Map<\r\n    symbol,\r\n    {\r\n      factory: () => any;\r\n      lifecycle: ServiceLifecycle;\r\n      dependencies: ServiceDependencies;\r\n      providerType: \"class\" | \"factory\" | \"value\" | \"alias\";\r\n      aliasTarget?: symbol;\r\n    }\r\n  > = new Map();\r\n\r\n  /** Current validation state of the container */\r\n  #validationState: ContainerValidationState = \"registering\";\r\n\r\n  /** Cached service instances for Singleton and Scoped lifecycles */\r\n  #serviceInstances: Map<symbol, any> = new Map();\r\n\r\n  /** Reference to parent container in the scope hierarchy */\r\n  readonly #parentContainer: ServiceContainer | null = null;\r\n\r\n  /** Flag indicating if this container has been disposed */\r\n  #disposed: boolean = false;\r\n\r\n  /** Hierarchical name for debugging and error messages (e.g., \"root.child1\") */\r\n  readonly #scopeName: string | null = null;\r\n\r\n  /** Set of all child containers for cascading disposal */\r\n  #children: Set<ServiceContainer> = new Set();\r\n\r\n  /**\r\n   * Creates a new service container.\r\n   * If a parent container is provided, creates a scoped child container.\r\n   *\r\n   * **Important:** Child containers are automatically registered with the parent\r\n   * and will be disposed when the parent is disposed (cascading disposal).\r\n   *\r\n   * @param parentContainer - Optional parent container for hierarchical DI\r\n   * @param scopeName - Optional name for the scope (auto-generated if not provided)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Root container\r\n   * const root = new ServiceContainer();\r\n   *\r\n   * // Scoped container (child) with auto-generated name\r\n   * const scope = new ServiceContainer(root);\r\n   *\r\n   * // Scoped container (child) with custom name\r\n   * const namedScope = new ServiceContainer(root, \"myScope\");\r\n   *\r\n   * // All children are tracked by root for cascading disposal\r\n   * root.dispose(); // Automatically disposes scope and namedScope\r\n   * ```\r\n   */\r\n  constructor(parentContainer: ServiceContainer | null = null, scopeName: string | null = null) {\r\n    if (parentContainer !== null) {\r\n      // Child inherits all service registrations from parent\r\n      // This allows child containers to resolve services registered in parent\r\n      this.#serviceRegistrations = new Map(parentContainer.#serviceRegistrations);\r\n\r\n      // Child starts with empty instances - each child has its own scope\r\n      // Singleton instances are still shared via parent lookup in resolve()\r\n      this.#serviceInstances = new Map();\r\n\r\n      this.#parentContainer = parentContainer;\r\n\r\n      // Build hierarchical scope name for debugging\r\n      // Format: \"root.child1.child2\" etc.\r\n      this.#scopeName =\r\n        parentContainer.#scopeName +\r\n        \".\" +\r\n        (scopeName ?? \"scope\" + crypto.randomUUID() + Date.now());\r\n      this.#disposed = false;\r\n\r\n      // Register this child with parent for cascading disposal\r\n      // When parent is disposed, this child will be automatically disposed too\r\n      parentContainer.#children.add(this);\r\n    } else {\r\n      this.#scopeName = \"root\";\r\n      this.#disposed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a child container with its own scope.\r\n   * Inherits service registrations from parent but maintains separate scoped instances.\r\n   *\r\n   * @param name - Optional name for the scope (auto-generated if not provided)\r\n   * @returns Result containing a new scoped container or an error if this container is disposed\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const rootContainer = new ServiceContainer();\r\n   * const scopedContainer = rootContainer.createScope();\r\n   * if (isErr(scopedContainer)) {\r\n   *   console.error(scopedContainer.error.message);\r\n   * }\r\n   * ```\r\n   */\r\n  createScope(name?: string): Result<ServiceContainer, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot create scope from disposed container: ${this.#scopeName}`,\r\n      });\r\n    }\r\n\r\n    if (this.#validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Parent must be validated before creating scopes. Call validate() first.\",\r\n      });\r\n    }\r\n\r\n    const child = new ServiceContainer(this, name ?? null);\r\n    child.#validationState = \"validated\";\r\n\r\n    return ok(child);\r\n  }\r\n\r\n  /**\r\n   * Check if a service is registered.\r\n   * Recursively checks the entire parent container hierarchy from root to this container.\r\n   *\r\n   * @template TServiceType - The type of service\r\n   * @param token - The injection token to check\r\n   * @returns Result indicating if registered in this container or any parent container\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const root = new ServiceContainer();\r\n   * const scope1 = root.createScope();\r\n   * const scope2 = scope1.createScope();\r\n   *\r\n   * root.register(LoggerToken, () => new Logger(), SINGLETON);\r\n   * const result = scope2.isRegistered(LoggerToken);\r\n   * if (isOk(result) && result.value) {\r\n   *   // Service is registered\r\n   * }\r\n   * ```\r\n   */\r\n  isRegistered<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<boolean, never> {\r\n    if (this.#parentContainer !== null) {\r\n      return this.#parentContainer.isRegistered(token);\r\n    }\r\n    return ok(this.#serviceRegistrations.has(token));\r\n  }\r\n\r\n  /**\r\n   * Dispose this container and clean up all scoped instances.\r\n   * Services implementing Disposable will have their dispose() method called automatically.\r\n   *\r\n   * **Cascading Disposal:** All child containers are automatically disposed recursively.\r\n   * Child disposal errors are logged but do not stop parent disposal.\r\n   *\r\n   * Root container clearing requires manual clear() call.\r\n   *\r\n   * @returns Result indicating success or any disposal errors\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const root = new ServiceContainer();\r\n   * const child = root.createScope();\r\n   * const db = child.resolve(DatabaseToken); // Implements Disposable\r\n   *\r\n   * // Disposing root automatically disposes child (and db.dispose() is called)\r\n   * const result = root.dispose();\r\n   * if (isErr(result)) {\r\n   *   console.error(\"Disposal failed:\", result.error);\r\n   * }\r\n   * ```\r\n   */\r\n  dispose(): Result<void, ContainerError> {\r\n    // Check if already disposed\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Container already disposed: ${this.#scopeName}`,\r\n      });\r\n    }\r\n\r\n    // Mark as disposed immediately BEFORE disposing children\r\n    // This prevents new operations on this container while disposal is in progress\r\n    this.#disposed = true;\r\n\r\n    // Recursively dispose all child containers (cascading disposal)\r\n    // Note: Child disposal errors are caught and logged but don't stop the disposal process\r\n    for (const child of this.#children) {\r\n      const childResult = tryCatch(\r\n        () => child.dispose(),\r\n        (error): ContainerError => ({\r\n          code: \"DisposalFailed\",\r\n          message: `Error disposing child container ${child.#scopeName}: ${String(error)}`,\r\n          cause: error,\r\n        })\r\n      );\r\n      if (isErr(childResult)) {\r\n        // Log error but continue with disposal\r\n        console.warn(`Failed to dispose child container ${child.#scopeName}:`, childResult.error);\r\n      }\r\n    }\r\n\r\n    // Dispose all scoped instances that implement Disposable\r\n    for (const [token, instance] of this.#serviceInstances.entries()) {\r\n      if (this.isDisposable(instance)) {\r\n        const result = tryCatch(\r\n          () => instance.dispose(),\r\n          (error): ContainerError => ({\r\n            code: \"DisposalFailed\",\r\n            message: `Error disposing service ${String(token)}: ${String(error)}`,\r\n            tokenDescription: String(token),\r\n            cause: error,\r\n          })\r\n        );\r\n\r\n        if (isErr(result)) {\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clear all instances\r\n    this.#serviceInstances.clear();\r\n\r\n    // Clean up: Remove this container from parent's children set\r\n    // This breaks the reference to prevent memory leaks\r\n    if (this.#parentContainer !== null) {\r\n      this.#parentContainer.#children.delete(this);\r\n    }\r\n\r\n    // Reset validation state\r\n    this.#validationState = \"registering\";\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Check if an instance implements the Disposable interface.\r\n   *\r\n   * @param instance - The service instance to check\r\n   * @returns True if the instance has a dispose() method\r\n   */\r\n  private isDisposable(instance: ServiceType): instance is ServiceType & { dispose: () => void } {\r\n    return (\r\n      \"dispose\" in instance &&\r\n      typeof (instance as ServiceType & { dispose: unknown }).dispose === \"function\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clear all service registrations and instances.\r\n   * Use with caution - this will remove all configured services.\r\n   * Note: dispose() should be used for scoped containers instead.\r\n   *\r\n   * @returns Result indicating success\r\n   */\r\n  clear(): Result<void, never> {\r\n    this.#serviceRegistrations.clear();\r\n    this.#serviceInstances.clear();\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a service class with automatic dependency injection.\r\n   *\r\n   * @template TServiceType - The type of service to register\r\n   * @param token - The injection token that identifies this service\r\n   * @param serviceClass - The service class to instantiate\r\n   * @param lifecycle - Service lifecycle strategy\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerClass<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>,\r\n    serviceClass: ServiceClass<TServiceType>,\r\n    lifecycle: ServiceLifecycle\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    const dependencies = (serviceClass as any).dependencies ?? [];\r\n\r\n    const factory = () => {\r\n      const resolvedDeps = dependencies.map((dep: InjectionToken<ServiceType>) => {\r\n        const result = this.resolveWithError(dep);\r\n        if (isErr(result)) {\r\n          throw new Error(`Dependency ${String(dep)} could not be resolved`);\r\n        }\r\n        return result.value;\r\n      });\r\n      return new serviceClass(...resolvedDeps);\r\n    };\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory,\r\n      lifecycle,\r\n      dependencies,\r\n      providerType: \"class\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a factory function that creates service instances.\r\n   *\r\n   * @template T - The type this factory creates\r\n   * @param token - The injection token that identifies this service\r\n   * @param factory - Factory function that creates the service instance\r\n   * @param lifecycle - Service lifecycle strategy\r\n   * @param dependencies - Array of tokens this factory depends on\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerFactory<T>(\r\n    token: symbol,\r\n    factory: FactoryFunction<T>,\r\n    lifecycle: ServiceLifecycle,\r\n    dependencies: ServiceDependencies\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory,\r\n      lifecycle,\r\n      dependencies,\r\n      providerType: \"factory\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register a constant value (always singleton).\r\n   *\r\n   * @template T - The type of value\r\n   * @param token - The injection token that identifies this value\r\n   * @param value - The value to register\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerValue<T>(token: symbol, value: T): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(token)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(token)} already registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Runtime check: values must not be functions or classes\r\n    if (typeof value === \"function\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message:\r\n          \"registerValue() only accepts plain values, not classes or functions. Use registerClass() or registerFactory() instead.\",\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    this.#serviceRegistrations.set(token, {\r\n      factory: () => value,\r\n      lifecycle: ServiceLifecycle.SINGLETON,\r\n      dependencies: [],\r\n      providerType: \"value\",\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Register an alias that points to another token.\r\n   *\r\n   * @template TServiceType - The type of service\r\n   * @param aliasToken - The alias token\r\n   * @param targetToken - The token to resolve instead\r\n   * @returns Result indicating success or registration error\r\n   */\r\n  registerAlias<TServiceType extends ServiceType>(\r\n    aliasToken: InjectionToken<TServiceType>,\r\n    targetToken: InjectionToken<TServiceType>\r\n  ): Result<void, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot register service on disposed container: ${String(aliasToken)}`,\r\n        tokenDescription: String(aliasToken),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState === \"validated\") {\r\n      return err({\r\n        code: \"InvalidOperation\",\r\n        message: \"Cannot register after validation\",\r\n      });\r\n    }\r\n\r\n    if (this.#serviceRegistrations.has(aliasToken)) {\r\n      return err({\r\n        code: \"DuplicateRegistration\",\r\n        message: `Service ${String(aliasToken)} already registered`,\r\n        tokenDescription: String(aliasToken),\r\n      });\r\n    }\r\n\r\n    const factory = () => {\r\n      const result = this.resolveWithError(targetToken);\r\n      if (isErr(result)) {\r\n        throw new Error(`Alias target ${String(targetToken)} not found`);\r\n      }\r\n      return result.value;\r\n    };\r\n\r\n    this.#serviceRegistrations.set(aliasToken, {\r\n      factory,\r\n      lifecycle: ServiceLifecycle.SINGLETON,\r\n      dependencies: [targetToken],\r\n      providerType: \"alias\",\r\n      aliasTarget: targetToken,\r\n    });\r\n\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Validate all registered services and their dependencies.\r\n   */\r\n  validate(): Result<void, ContainerError[]> {\r\n    if (this.#validationState === \"validated\") {\r\n      return ok(undefined);\r\n    }\r\n\r\n    if (this.#validationState === \"validating\") {\r\n      return err([\r\n        {\r\n          code: \"InvalidOperation\",\r\n          message: \"Validation already in progress\",\r\n        },\r\n      ]);\r\n    }\r\n\r\n    this.#validationState = \"validating\";\r\n\r\n    const errors = this.validateAllDependencies();\r\n\r\n    if (errors.length > 0) {\r\n      this.#validationState = \"registering\";\r\n      return err(errors);\r\n    }\r\n\r\n    this.#validationState = \"validated\";\r\n    return ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Get the current validation state of the container.\r\n   */\r\n  getValidationState(): ContainerValidationState {\r\n    return this.#validationState;\r\n  }\r\n\r\n  /**\r\n   * Resolve a service instance from the container with explicit error handling.\r\n   *\r\n   * @template TServiceType - The type of service to resolve\r\n   * @param token - The injection token identifying the service\r\n   * @returns Result containing the service instance or an error\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const result = container.resolveWithError(LoggerToken);\r\n   * if (isOk(result)) {\r\n   *   const logger = result.value;\r\n   *   logger.info(\"Service resolved successfully\");\r\n   * }\r\n   * ```\r\n   */\r\n  resolveWithError<TServiceType extends ServiceType>(\r\n    token: InjectionToken<TServiceType>\r\n  ): Result<TServiceType, ContainerError> {\r\n    if (this.#disposed) {\r\n      return err({\r\n        code: \"Disposed\",\r\n        message: `Cannot resolve service from disposed container: ${String(token)}`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    if (this.#validationState !== \"validated\") {\r\n      return err({\r\n        code: \"NotValidated\",\r\n        message: \"Container must be validated before resolving. Call validate() first.\",\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    // Check if service is registered\r\n    const checkResult = this.isRegistered(token);\r\n    if (isErr(checkResult) || !checkResult.value) {\r\n      return err({\r\n        code: \"TokenNotRegistered\",\r\n        message: `Service ${String(token)} not registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    const service = this.#serviceRegistrations.get(token);\r\n    if (!service) {\r\n      return err({\r\n        code: \"TokenNotRegistered\",\r\n        message: `Service ${String(token)} not registered`,\r\n        tokenDescription: String(token),\r\n      });\r\n    }\r\n\r\n    return tryCatch(\r\n      () => {\r\n        switch (service.lifecycle) {\r\n          case ServiceLifecycle.SINGLETON:\r\n            // Singleton: Check Parent first (for Child-Container)\r\n            if (this.#parentContainer !== null) {\r\n              const parentResult = this.#parentContainer.resolveWithError(token);\r\n              if (isErr(parentResult)) {\r\n                throw new Error(\"CIRCULAR_DEPENDENCY\");\r\n              }\r\n              return parentResult.value;\r\n            }\r\n            // Singleton: Check current container\r\n            if (!this.#serviceInstances.has(token)) {\r\n              this.#serviceInstances.set(token, service.factory() as TServiceType);\r\n            }\r\n            return this.#serviceInstances.get(token) as TServiceType;\r\n\r\n          case ServiceLifecycle.TRANSIENT:\r\n            // Transient: Always create new instance (no caching)\r\n            return service.factory() as TServiceType;\r\n\r\n          case ServiceLifecycle.SCOPED:\r\n            // Scoped: One instance per child container scope\r\n            // MUST be in child container (not root) to have a parent scope reference\r\n            if (this.#parentContainer === null) {\r\n              throw new Error(\"SCOPED_REQUIRES_CONTAINER\");\r\n            }\r\n            // Create instance on first access, reuse for subsequent resolves in same scope\r\n            if (!this.#serviceInstances.has(token)) {\r\n              this.#serviceInstances.set(token, service.factory() as TServiceType);\r\n            }\r\n            return this.#serviceInstances.get(token) as TServiceType;\r\n\r\n          default:\r\n            throw new Error(\"INVALID_LIFECYCLE\");\r\n        }\r\n      },\r\n      (error): ContainerError => {\r\n        const errorMessage = String(error);\r\n        let code: ContainerErrorCode;\r\n        let message: string;\r\n\r\n        // Classify error based on predefined error message patterns\r\n        // These patterns are thrown in the switch statement above to enable proper categorization\r\n        if (errorMessage.includes(\"CIRCULAR_DEPENDENCY\")) {\r\n          code = \"CircularDependency\";\r\n          message = `Circular dependency detected for service ${String(token)}`;\r\n        } else if (errorMessage.includes(\"SCOPED_REQUIRES_CONTAINER\")) {\r\n          code = \"ScopeRequired\";\r\n          message = `Scoped service ${String(token)} requires a scope container`;\r\n        } else if (errorMessage.includes(\"INVALID_LIFECYCLE\")) {\r\n          code = \"InvalidLifecycle\";\r\n          message = `Invalid service lifecycle: ${String(service.lifecycle)}`;\r\n        } else {\r\n          code = \"FactoryFailed\";\r\n          message = `Error creating service ${String(token)}: ${errorMessage}`;\r\n        }\r\n\r\n        return {\r\n          code,\r\n          message,\r\n          tokenDescription: String(token),\r\n          cause: error,\r\n        };\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Resolve a service instance directly from the container.\r\n   * Uses fallback factory if container resolution fails and a fallback is registered.\r\n   *\r\n   * @template TServiceType - The type of service to resolve\r\n   * @param token - The injection token identifying the service\r\n   * @returns The resolved service instance\r\n   * @throws Error if container resolution fails and no fallback is registered\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Direct resolution with automatic fallback\r\n   * const logger = container.resolve(loggerToken);\r\n   * logger.info(\"This will work even if container resolution fails!\");\r\n   * ```\r\n   */\r\n  resolve<TServiceType extends ServiceType>(token: InjectionToken<TServiceType>): TServiceType {\r\n    const result = this.resolveWithError(token);\r\n\r\n    if (isOk(result)) {\r\n      return result.value;\r\n    }\r\n\r\n    // Try fallback factory if available\r\n    const fallback = fallbackFactories.get(token);\r\n    if (fallback) {\r\n      return fallback() as TServiceType;\r\n    }\r\n\r\n    // No fallback available - throw error with helpful message\r\n    throw new Error(\r\n      `Cannot resolve ${String(token)}: ${result.error.message}. ` +\r\n        `No fallback factory registered for this token.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validate all dependencies and check for circular dependencies.\r\n   */\r\n  private validateAllDependencies(): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n\r\n    // 1. Check that all dependencies are registered\r\n    for (const [token, registration] of this.#serviceRegistrations.entries()) {\r\n      for (const dep of registration.dependencies) {\r\n        if (!this.#serviceRegistrations.has(dep)) {\r\n          errors.push({\r\n            code: \"TokenNotRegistered\",\r\n            message: `${String(token)} depends on ${String(dep)} which is not registered`,\r\n            tokenDescription: String(dep),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 2. Check alias targets\r\n    for (const [token, registration] of this.#serviceRegistrations.entries()) {\r\n      if (registration.providerType === \"alias\" && registration.aliasTarget) {\r\n        if (!this.#serviceRegistrations.has(registration.aliasTarget)) {\r\n          errors.push({\r\n            code: \"AliasTargetNotFound\",\r\n            message: `Alias ${String(token)} points to ${String(registration.aliasTarget)} which is not registered`,\r\n            tokenDescription: String(registration.aliasTarget),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3. Check for circular dependencies\r\n    const circularErrors = this.detectCircularDependencies();\r\n    errors.push(...circularErrors);\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Detect circular dependencies using DFS.\r\n   */\r\n  private detectCircularDependencies(): ContainerError[] {\r\n    const errors: ContainerError[] = [];\r\n    const visited = new Set<symbol>();\r\n\r\n    for (const token of this.#serviceRegistrations.keys()) {\r\n      const visiting = new Set<symbol>();\r\n      const path: symbol[] = [];\r\n\r\n      const error = this.checkCycleForToken(token, visiting, visited, path);\r\n      if (error) {\r\n        errors.push(error);\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Check for cycles starting from a specific token.\r\n   */\r\n  private checkCycleForToken(\r\n    token: symbol,\r\n    visiting: Set<symbol>,\r\n    visited: Set<symbol>,\r\n    path: symbol[]\r\n  ): ContainerError | null {\r\n    if (visiting.has(token)) {\r\n      const cyclePath = [...path, token].map(String).join(\" → \");\r\n      return {\r\n        code: \"CircularDependency\",\r\n        message: `Circular dependency: ${cyclePath}`,\r\n        tokenDescription: String(token),\r\n      };\r\n    }\r\n\r\n    if (visited.has(token)) {\r\n      return null;\r\n    }\r\n\r\n    visiting.add(token);\r\n    path.push(token);\r\n\r\n    const registration = this.#serviceRegistrations.get(token);\r\n    if (registration) {\r\n      for (const dep of registration.dependencies) {\r\n        const error = this.checkCycleForToken(dep, visiting, visited, path);\r\n        if (error) return error;\r\n      }\r\n    }\r\n\r\n    visiting.delete(token);\r\n    path.pop();\r\n    visited.add(token);\r\n\r\n    return null;\r\n  }\r\n}\r\n","/**\r\n * Utility function to create type-safe injection tokens for dependency injection.\r\n */\r\nimport type { InjectionToken } from \"./types/injectiontoken\";\r\nimport type { ServiceType } from \"@/types/servicetypeindex\";\r\n\r\n/**\r\n * Creates a unique, type-safe injection token for dependency injection.\r\n * Each call creates a new Symbol, ensuring uniqueness even with the same description.\r\n *\r\n * @template ServiceType - The type of service this token represents\r\n * @param description - A descriptive name for debugging purposes (appears in DevTools)\r\n * @returns A unique Symbol branded with the service type\r\n *\r\n * @example\r\n * // Create tokens for different services\r\n * const LoggerToken = createInjectionToken<Logger>('Logger');\r\n * const DatabaseToken = createInjectionToken<Database>('Database');\r\n *\r\n * // Tokens can be used with a DI container\r\n * container.register(LoggerToken, new Logger());\r\n */\r\nexport function createInjectionToken<TServiceType extends ServiceType>(\r\n  description: string\r\n): InjectionToken<TServiceType> {\r\n  return Symbol(description) as InjectionToken<TServiceType>;\r\n}\r\n","import { createInjectionToken } from \"@/di_infrastructure/tokenutilities\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\n\r\n/**\r\n * Token for resolving Logger service instances.\r\n * Used to inject logging functionality throughout the application.\r\n */\r\nexport const loggerToken = createInjectionToken<Logger>(\"Logger\");\r\n","import type { Logger } from \"@/interfaces/logger\";\r\nimport { MODULE_CONSTANTS } from \"../constants\";\r\n\r\n/**\r\n * Console-based implementation of the Logger interface.\r\n * Writes log messages to the browser console.\r\n *\r\n * @implements {Logger}\r\n */\r\nexport class ConsoleLoggerService implements Logger {\r\n  static dependencies = [] as const;\r\n\r\n  /**\r\n   * Log a message to console\r\n   * @param message - Message to log\r\n   */\r\n  log(message: string): void {\r\n    console.log(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log an error message\r\n   * @param message - Error message to log\r\n   */\r\n  error(message: string): void {\r\n    console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log a warning message\r\n   * @param message - Warning message to log\r\n   */\r\n  warn(message: string): void {\r\n    console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   * @param message - Info message to log\r\n   */\r\n  info(message: string): void {\r\n    console.info(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Log a debug message\r\n   * @param message - Debug message to log\r\n   */\r\n  debug(message: string): void {\r\n    console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} ${message}`);\r\n  }\r\n}\r\n","import { ServiceContainer, registerFallback } from \"@/di_infrastructure/container\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\nimport { ConsoleLoggerService } from \"@/services/consolelogger\";\r\nimport { ServiceLifecycle } from \"@/di_infrastructure/types/servicelifecycle\";\r\nimport { ok, err, isErr } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport type { Logger } from \"@/interfaces/logger\";\r\n\r\n/**\r\n * Configures all dependency injection mappings for the application.\r\n * This is the central place where tokens are connected to their factories.\r\n *\r\n * Also registers fallback factories for critical services that should always be available\r\n * even if container resolution fails.\r\n *\r\n * @param container - The service container to configure\r\n * @returns Result indicating success or configuration errors\r\n *\r\n * @example\r\n * ```typescript\r\n * const container = new ServiceContainer();\r\n * const result = configureDependencies(container);\r\n * if (isOk(result)) {\r\n *   const logger = container.resolve(loggerToken); // Direct resolution with fallback\r\n * }\r\n * ```\r\n */\r\nexport function configureDependencies(container: ServiceContainer): Result<void, string> {\r\n  // Register fallback factories for services that should always be available\r\n  registerFallback<Logger>(loggerToken, () => new ConsoleLoggerService());\r\n\r\n  const result = container.registerClass(\r\n    loggerToken,\r\n    ConsoleLoggerService,\r\n    ServiceLifecycle.SINGLETON\r\n  );\r\n\r\n  if (isErr(result)) {\r\n    return err(`Failed to register logger: ${result.error.message}`);\r\n  }\r\n\r\n  // Phase 2: Validate\r\n  const validateResult = container.validate();\r\n  if (isErr(validateResult)) {\r\n    const errorMessages = validateResult.error.map((e) => e.message).join(\", \");\r\n    return err(`Validation failed: ${errorMessages}`);\r\n  }\r\n\r\n  return ok(undefined);\r\n}\r\n","import { MODULE_CONSTANTS } from \"../constants\";\r\nimport { ok, err, tryCatch, match } from \"@/utils/result\";\r\nimport type { Result } from \"@/types/result\";\r\nimport { ServiceContainer } from \"@/di_infrastructure/container\";\r\nimport { configureDependencies } from \"@/config/dependencyconfig\";\r\nimport { loggerToken } from \"@/tokens/tokenindex\";\r\n\r\n/**\r\n * Safely gets journal entries that are marked as hidden.\r\n */\r\nfunction getHiddenJournalEntries(): Result<any[], string> {\r\n  return tryCatch(\r\n    () => {\r\n      if (!game?.journal) {\r\n        throw new Error(\"game.journal is not available\");\r\n      }\r\n      return (game as any).journal.filter(\r\n        (j: any) => j.getFlag(MODULE_CONSTANTS.MODULE.ID as any, \"hidden\") === true\r\n      );\r\n    },\r\n    (error) => `Failed to get hidden journal entries: ${error}`\r\n  );\r\n}\r\n\r\n/**\r\n * Safely removes a journal entry from the UI.\r\n */\r\nfunction removeJournalElement(\r\n  journalId: string,\r\n  journalName: string,\r\n  html: HTMLElement\r\n): Result<void, string> {\r\n  const element = html.querySelector(\r\n    `li.directory-item[data-entry-id=\"${journalId}\"]`\r\n  ) as HTMLElement;\r\n\r\n  if (!element) {\r\n    return err(`Could not find element for journal entry: ${journalName} (${journalId})`);\r\n  }\r\n\r\n  element.remove();\r\n  return ok(undefined);\r\n}\r\n\r\n/**\r\n * Initializes the module when Foundry VTT starts.\r\n * Registers hooks for hiding journal entries based on module flags.\r\n */\r\nHooks.on(\"init\", () => {\r\n  console.log(`${MODULE_CONSTANTS.LOG_PREFIX} init`);\r\n\r\n  Hooks.on(\"renderJournalDirectory\", (app, html) => {\r\n    console.debug(`${MODULE_CONSTANTS.LOG_PREFIX} renderJournalDirectory fired`, app);\r\n\r\n    const hiddenResult = getHiddenJournalEntries();\r\n\r\n    match(hiddenResult, {\r\n      onOk: (hidden) => {\r\n        console.debug(\r\n          `${MODULE_CONSTANTS.LOG_PREFIX} Found ${hidden.length} hidden journal entries`\r\n        );\r\n\r\n        for (const journal of hidden) {\r\n          const removeResult = removeJournalElement(journal.id, journal.name, html as HTMLElement);\r\n\r\n          match(removeResult, {\r\n            onOk: () => {\r\n              console.debug(\r\n                `${MODULE_CONSTANTS.LOG_PREFIX} Removing journal entry: ${journal.name}`\r\n              );\r\n            },\r\n            onErr: (error) => {\r\n              console.warn(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n            },\r\n          });\r\n        }\r\n      },\r\n      onErr: (error) => {\r\n        console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n      },\r\n    });\r\n  });\r\n\r\n  const container = new ServiceContainer();\r\n  const configureResult = configureDependencies(container);\r\n  match(configureResult, {\r\n    onOk: () => {\r\n      console.log(`${MODULE_CONSTANTS.LOG_PREFIX} dependencies configured`);\r\n      (globalThis as any).container = container;\r\n    },\r\n    onErr: (error) => {\r\n      console.error(`${MODULE_CONSTANTS.LOG_PREFIX} ${error}`);\r\n      (globalThis as any).container = null;\r\n    },\r\n  });\r\n\r\n  // Direct resolution with automatic fallback - no Result-Check needed\r\n  const logger = container.resolve(loggerToken);\r\n  logger.info(\"Logger resolved\");\r\n  logger.info(\"init completed\");\r\n});\r\n\r\n/**\r\n * Ready hook: Module initialization complete.\r\n * Executes when Foundry VTT is fully ready.\r\n */\r\nHooks.on(\"ready\", () => {\r\n  const container = (globalThis as any).container;\r\n  const logger = container.resolve(loggerToken);\r\n  logger.info(\"Module ready\");\r\n});\r\n"],"names":["ServiceLifecycle"],"mappings":"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"}