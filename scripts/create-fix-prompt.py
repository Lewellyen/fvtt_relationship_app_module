#!/usr/bin/env python3
"""
Erstellt einen Fix-Prompt f√ºr den AI Issue Fix Workflow.
Behandelt sicher alle Sonderzeichen in Issue-Beschreibungen.
"""
import os
import sys

def create_fix_prompt():
    """Erstellt den Fix-Prompt aus Environment-Variablen."""
    issue_num = os.environ.get('ISSUE_NUM', '')
    issue_title = os.environ.get('ISSUE_TITLE', '')
    issue_url = os.environ.get('ISSUE_URL', '')
    issue_body = os.environ.get('ISSUE_BODY', '')
    branch_name = os.environ.get('BRANCH_NAME', '')
    base_branch = os.environ.get('BASE_BRANCH', 'main')

    if not issue_num:
        print("‚ùå Error: ISSUE_NUM environment variable not set", file=sys.stderr)
        sys.exit(1)

    prompt = f"""Du arbeitest in einem GitHub Actions Runner mit vollst√§ndigem Zugriff auf Git und GitHub CLI.

**WICHTIG - Terminal-Befehle:**
Du MUSST Terminal-Befehle direkt ausf√ºhren k√∂nnen. Verwende das `run_terminal_cmd` Tool f√ºr alle Git- und GitHub CLI-Befehle.
Die Terminal-Umgebung ist vollst√§ndig konfiguriert und bereit f√ºr deine Befehle.

# Aufgabe: Issue #{issue_num} beheben

**Issue-Titel:** {issue_title}
**Issue-URL:** {issue_url}

**Issue-Beschreibung:**
{issue_body}

## Deine Aufgabe:

1. **Analysiere das Problem** im Issue
2. **Finde die betroffenen Dateien** (nutze `git`, `gh`, oder lese Dateien direkt)
3. **Implementiere die L√∂sung** direkt im Code
4. **Erstelle Commits** mit `git add` und `git commit`
5. **Pushe die √Ñnderungen** mit `git push` (Branch: {branch_name})
6. **Erstelle einen Pull Request** mit `gh pr create` und verlinke ihn mit dem Issue
7. **Teste deine L√∂sung** (falls Tests vorhanden sind)

## WICHTIG - Du MUSST folgendes tun:

### Git-Operationen:
- **WICHTIG:** Verwende das `run_terminal_cmd` Tool f√ºr ALLE Git-Befehle!
- **Git-Befehle ausf√ºhren:** Nutze `run_terminal_cmd` mit Befehlen wie `git add`, `git commit`, `git push`
- **Erstelle sinnvolle Commits:** Jeder Commit sollte eine logische √Ñnderungseinheit sein
- **Commit-Messages:** Verwende klare, beschreibende Messages (z.B. "fix: resolve issue #{issue_num}")
- **Keine leeren Commits:** Nur committen wenn tats√§chlich √Ñnderungen gemacht wurden
- **Keine Force-Push:** Nutze normale `git push origin {branch_name}`
- **Git ist bereits konfiguriert:** User und Email sind gesetzt, du musst sie nicht nochmal setzen

### Pull Request erstellen:
**NACH dem Push der √Ñnderungen MUSST du einen Pull Request erstellen:**

1. **PR-Titel:** `fix: Resolve issue #{issue_num} - {issue_title}`

2. **PR-Body:** Erstelle eine aussagekr√§ftige Beschreibung:
   ```markdown
   ## ü§ñ AI-Generated Fix for Issue #{issue_num}

   This PR was automatically generated by the AI Issue Fix workflow to resolve issue #{issue_num}.

   **Issue:** {issue_title}
   **Issue URL:** {issue_url}

   ### Changes
   This PR contains the AI-generated fix for the issue. Please review carefully before merging.

   ### Review Checklist
   - [ ] Code changes are correct
   - [ ] Tests pass (if applicable)
   - [ ] No breaking changes introduced
   - [ ] Follows project architecture patterns

   ---
   *This PR was created automatically. Please review and test before merging.*
   ```

3. **PR erstellen mit GitHub CLI:**
   **WICHTIG:** Verwende `run_terminal_cmd` f√ºr alle `gh`-Befehle!

   Zuerst PR-Body in Datei schreiben (verwende `write` Tool):
   - Erstelle `/tmp/pr-body.txt` mit dem PR-Body-Inhalt

   Dann PR erstellen (verwende `run_terminal_cmd`):
   ```
   gh pr create --title "fix: Resolve issue #{issue_num} - {issue_title}" --body-file /tmp/pr-body.txt --base {base_branch} --head {branch_name} --label "ai-generated" --label "automated"
   ```

   **WICHTIG:** Schreibe den PR-Body zuerst in eine Datei (`/tmp/pr-body.txt`), um Sonderzeichen-Probleme zu vermeiden!

4. **Issue verlinken:**
   Nach erfolgreicher PR-Erstellung f√ºge einen Kommentar zum Issue hinzu (verwende `run_terminal_cmd`):
   ```
   gh issue comment {issue_num} --body "ü§ñ AI has created a fix for this issue: PR #<PR_NUMBER>"
   ```

   Ersetze `<PR_NUMBER>` mit der tats√§chlichen PR-Nummer aus dem `gh pr create` Output.

5. **Labels pr√ºfen:**
   Falls die Labels "ai-generated" oder "automated" nicht existieren, erstelle sie nicht - der Workflow k√ºmmert sich darum.

## Git-Konfiguration:

Git ist bereits konfiguriert:
- User: github-actions[bot]
- Email: github-actions[bot]@users.noreply.github.com
- Branch: {branch_name}
- Remote: origin (bereits konfiguriert)

## Projektkontext:

Das Projekt verwendet:
- **Clean Architecture** mit 4 Schichten: Domain ‚Üí Application ‚Üí Infrastructure ‚Üí Framework
- **Result-Pattern** statt Exceptions (siehe ADR-0001)
- **SOLID-Prinzipien** durchg√§ngig
- **Port-Adapter-Pattern** f√ºr Foundry VTT Version-Kompatibilit√§t
- **Dependency Inversion Principle (DIP)**: Abh√§ngigkeiten nur zu Interfaces

## Code-Qualit√§t:

- Halte dich an die bestehenden Architektur-Patterns
- Verwende das Result-Pattern f√ºr Fehlerbehandlung
- Respektiere die Schichttrennung (Clean Architecture)
- F√ºge Tests hinzu, wenn m√∂glich

## Output:

Nachdem du die √Ñnderungen gemacht, committed, gepusht und die PR erstellt hast, gib eine kurze Zusammenfassung aus:
- Welche Dateien wurden ge√§ndert?
- Was wurde behoben?
- PR-Nummer und Link (falls erfolgreich erstellt)
- Gibt es besondere √úberlegungen f√ºr den Reviewer?

## Zusammenfassung der Schritte:

1. ‚úÖ Code-√Ñnderungen implementieren (verwende `search_replace` oder `write` Tool)
2. ‚úÖ Commits erstellen (verwende `run_terminal_cmd` mit `git add` und `git commit`)
3. ‚úÖ √Ñnderungen pushen (verwende `run_terminal_cmd` mit `git push origin {branch_name}`)
4. ‚úÖ PR-Body in `/tmp/pr-body.txt` schreiben (verwende `write` Tool)
5. ‚úÖ PR erstellen (verwende `run_terminal_cmd` mit `gh pr create` - inkl. Labels und Base-Branch: {base_branch})
6. ‚úÖ Issue kommentieren (verwende `run_terminal_cmd` mit `gh issue comment`)

**WICHTIG:** F√ºr ALLE Terminal-Befehle (git, gh) musst du das `run_terminal_cmd` Tool verwenden!

**Beginne jetzt mit der Analyse und Implementierung!**
"""

    output_file = os.environ.get('OUTPUT_FILE', '/tmp/fix-prompt.md')

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(prompt)
        print(f"‚úÖ Prompt created for issue #{issue_num} -> {output_file}", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Error writing prompt file: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    create_fix_prompt()

