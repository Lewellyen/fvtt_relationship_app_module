{
  "summary": {
    "total_issues": 11,
    "by_type": {
      "result_pattern_violation": 2,
      "solid_violation": 2,
      "code_smell": 3,
      "bug": 2,
      "architecture_violation": 2
    },
    "by_severity": {
      "critical": 2,
      "high": 3,
      "medium": 4,
      "low": 2
    }
  },
  "issues": [
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 49,
      "type": "result_pattern_violation",
      "severity": "high",
      "title": "Result-Pattern nicht vollst├ñndig gepr├╝ft",
      "description": "Die Methode pr├╝ft nur 'flagResult.ok', behandelt aber den Fehlerfall nicht. Wenn getFlag() fehlschl├ñgt, wird das Men├╝-Item stillschweigend nicht hinzugef├╝gt, ohne dass der Fehler geloggt wird.",
      "recommendation": "Fehlerfall explizit behandeln und loggen: if (!flagResult.ok) { this.notifications.warn('Failed to check journal hidden flag', flagResult.error); return; }",
      "solid_principle": null,
      "code": "if (flagResult.ok && flagResult.value !== true) {"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 64,
      "type": "result_pattern_violation",
      "severity": "medium",
      "title": "Result-Pattern Fehlerfall nicht behandelt",
      "description": "journalEntryResult wird auf .ok gepr├╝ft, aber der Fehlerfall wird nicht geloggt. Bei einem Fehler wird nur die ID als Fallback verwendet, aber der eigentliche Fehler geht verloren.",
      "recommendation": "Fehler loggen: if (!journalEntryResult.ok) { this.notifications.debug('Failed to get journal name', journalEntryResult.error); }",
      "solid_principle": null,
      "code": "const journalEntryResult = this.journalRepository.getById(journalId);\nconst journalName = journalEntryResult.ok && journalEntryResult.value ? (journalEntryResult.value.name ?? journalId) : journalId;"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 35,
      "type": "code_smell",
      "severity": "medium",
      "title": "Magic String statt Konstante",
      "description": "Der String 'Journal ausblenden' wird hardcoded verwendet (Zeile 35 und 51). Bei ├änderungen m├╝ssen beide Stellen angepasst werden.",
      "recommendation": "Konstante einf├╝hren: private readonly MENU_ITEM_NAME = 'Journal ausblenden'; und in beiden Zeilen verwenden.",
      "solid_principle": "DRY",
      "code": "const existingItem = event.options.find((item) => item.name === \"Journal ausblenden\");"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 26,
      "type": "solid_violation",
      "severity": "high",
      "title": "Single Responsibility Principle Verletzung",
      "description": "Die handle()-Methode hat zu viele Verantwortlichkeiten: ID-Extraktion, Duplikatspr├╝fung, Flag-Pr├╝fung, Men├╝-Item-Erstellung, Flag-Setzen, Name-Abruf, Notification-Handling. Die Methode ist 76 Zeilen lang und schwer zu testen.",
      "recommendation": "In kleinere Methoden aufteilen: shouldAddMenuItem(), createMenuItem(), handleHideJournal(), getJournalDisplayName()",
      "solid_principle": "SRP",
      "code": "handle(event: JournalContextMenuEvent): void { ... }"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 53,
      "type": "bug",
      "severity": "critical",
      "title": "Async Callback ohne Error Handling",
      "description": "Der async Callback (Zeile 53-99) hat kein try-catch. Wenn eine Exception geworfen wird (z.B. bei setFlag), wird diese nicht abgefangen und k├Ânnte die Anwendung zum Absturz bringen.",
      "recommendation": "try-catch Block um den gesamten Callback-Body: try { ... } catch (error) { this.notifications.error('Unexpected error while hiding journal', error); }",
      "solid_principle": null,
      "code": "callback: async (_li: HTMLElement) => { ... }"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 107,
      "type": "code_smell",
      "severity": "low",
      "title": "Primitive Obsession",
      "description": "Die Methode extractJournalId() gibt string | null zur├╝ck. Besser w├ñre ein Result-Pattern f├╝r konsistente Fehlerbehandlung.",
      "recommendation": "R├╝ckgabetyp ├ñndern zu Result<string, Error> und entsprechend behandeln.",
      "solid_principle": null,
      "code": "private extractJournalId(element: HTMLElement): string | null"
    },
    {
      "file": "src/application/handlers/hide-journal-context-menu-handler.ts",
      "line": 22,
      "type": "architecture_violation",
      "severity": "medium",
      "title": "Dependency auf Infrastructure Layer",
      "description": "Die Datei importiert Tokens aus @/infrastructure/shared/tokens (Zeile 6-10). Application Layer sollte nicht direkt auf Infrastructure Layer zugreifen.",
      "recommendation": "Tokens sollten in einem separaten shared/tokens Layer oder im Domain Layer definiert werden.",
      "solid_principle": "DIP",
      "code": "import { journalRepositoryToken, platformUIPortToken, platformNotificationPortToken } from \"@/infrastructure/shared/tokens\";"
    },
    {
      "file": "src/application/handlers/journal-context-menu-handler.interface.ts",
      "line": 33,
      "type": "solid_violation",
      "severity": "medium",
      "title": "Mutable State in Event-Objekt",
      "description": "Das Interface erlaubt direkte Mutation von event.options. Dies verst├Â├ƒt gegen Immutability-Prinzipien und macht den Code schwer nachvollziehbar (Side Effects).",
      "recommendation": "Stattdessen sollte handle() ein Result<ContextMenuOption[], Error> zur├╝ckgeben, das dann vom Caller in die options eingef├╝gt wird.",
      "solid_principle": "OCP",
      "code": "handle(event: JournalContextMenuEvent): void;"
    },
    {
      "file": "src/application/health/ContainerHealthCheck.ts",
      "line": 37,
      "type": "bug",
      "severity": "critical",
      "title": "Side Effect im Constructor",
      "description": "DIContainerHealthCheck ruft registry.register(this) im Constructor auf (Zeile 39). Dies ist problematisch, da 'this' noch nicht vollst├ñndig initialisiert ist und zu Race Conditions f├╝hren kann.",
      "recommendation": "Separate init()-Methode einf├╝hren oder Factory Pattern verwenden: static create(container, registry) { const check = new DIContainerHealthCheck(container, registry); registry.register(check); return check; }",
      "solid_principle": null,
      "code": "constructor(container: Container, registry: HealthCheckRegistry) {\n  super(container);\n  registry.register(this);\n}"
    },
    {
      "file": "src/application/health/ContainerHealthCheck.ts",
      "line": 34,
      "type": "code_smell",
      "severity": "low",
      "title": "Unn├Âtige Vererbung",
      "description": "DIContainerHealthCheck erbt von ContainerHealthCheck nur um registry.register() aufzurufen. Dies ist ein Code Smell (Inheritance for Code Reuse statt Polymorphism).",
      "recommendation": "Composition statt Inheritance: DIContainerHealthCheck sollte ContainerHealthCheck als Dependency halten oder als Factory-Funktion implementiert werden.",
      "solid_principle": "LSP",
      "code": "export class DIContainerHealthCheck extends ContainerHealthCheck"
    },
    {
      "file": "src/application/health/ContainerHealthCheck.ts",
      "line": 1,
      "type": "architecture_violation",
      "severity": "high",
      "title": "Dependency auf Infrastructure Layer",
      "description": "Application Layer importiert Container Interface aus @/infrastructure/di/interfaces (Zeile 1). Dies verletzt Clean Architecture - Application sollte nicht von Infrastructure abh├ñngen.",
      "recommendation": "Container Interface in Domain Layer verschieben oder ├╝ber Port abstrahieren.",
      "solid_principle": "DIP",
      "code": "import type { Container } from \"@/infrastructure/di/interfaces\";"
    }
  ]
}
